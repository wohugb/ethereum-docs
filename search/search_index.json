{
    "docs": [
        {
            "location": "/", 
            "text": "\u6587\u6863\u4ecb\u7ecd\n\n\n\u672c\u6587\u6863\u7ffb\u6574\u7406\u8bd1\u81ea\n\u4ee5\u592a\u574awiki\n\n\n\u53e6\u4e00\u6587\u6863\n\u4ee5\u592a\u574a\u5b85\u57fa\u5730\n\uff0c\n\n\u4e2d\u6587\u6587\u6863\n\u662f\u5df4\u6bd4\u7279\u56fe\u4e66\u7ffb\u8bd1\u7684.\n\n\n\u7531\u4e8e\u7ec4\u4ef6\ntornado\n\u4e0d\u652f\u6301\u7279\u6b8a\u5b57\u7b26\n\u00d0\u039eVTechnologies\n\u5c06\u76ee\u5f55\u540d\u5b57\u6539\u4e3a\nD3VTechnologies", 
            "title": "\u524d\u8a00"
        }, 
        {
            "location": "/#_1", 
            "text": "\u672c\u6587\u6863\u7ffb\u6574\u7406\u8bd1\u81ea \u4ee5\u592a\u574awiki  \u53e6\u4e00\u6587\u6863 \u4ee5\u592a\u574a\u5b85\u57fa\u5730 \uff0c \u4e2d\u6587\u6587\u6863 \u662f\u5df4\u6bd4\u7279\u56fe\u4e66\u7ffb\u8bd1\u7684.  \u7531\u4e8e\u7ec4\u4ef6 tornado \u4e0d\u652f\u6301\u7279\u6b8a\u5b57\u7b26 \u00d0\u039eVTechnologies \u5c06\u76ee\u5f55\u540d\u5b57\u6539\u4e3a D3VTechnologies", 
            "title": "\u6587\u6863\u4ecb\u7ecd"
        }, 
        {
            "location": "/home/", 
            "text": "\u4ee5\u592a\u574a\u6587\u6863\n\n\nThis is the community-maintained wiki covering all sorts of information on the next-generation peer-to-peer technology platform built by the Ethereum Foundation, including \nEthereum\n, \nthe generalized blockchain for smart contract development\n, as well as sister protocols like \nWhisper\n, \nthe private low-level datagram communication platform\n, and Swarm.\n\n\nUsers signed in with GitHub can edit and add pages using the \nbrowser\n or \nlocally\n.\n\n\n\u72b6\u6001\n\n\n\u53d1\u7248 / \u5f00\u53d1\u65f6\u95f4\u7ebf / \u8def\u6807\n  \u67e5\u770b\n\u8fd9\u91cc\n.\n\n\n\u5165\u95e8\n\n\nTo get the basic concepts of Ethereum visit the Ethereum homepage over at \nhttp://ethereum.org\n. For another introduction targeted for end-users but also for (aspiring) developers and others, see \nhere\n. If you want to get a deeper understanding, start by reading the \nwhitepaper\n and the \ndesign rationale\n. For a more formal review, read the \nyellow paper\n. If you are interested in developing smart contracts you can see \nhere\n, as well as under dapp development in the sidebar.\n\n\nFor getting started guides, see here:\n\n\n\n\nhttps://medium.com/@attores/step-by-step-guide-getting-started-with-ethereum-mist-wallet-772a3cc99af4 (using Mist)\n\n\nhttps://www.ethereum.org/greeter (creating a contract)\n\n\nhttps://omarmetwally.wordpress.com/2017/07/25/how-to-create-a-private-ethereum-network/ (setting up a private network)\n\n\n\n\n\u4e0d\u8981\u8ff7\u8def\n\n\nCheck the \nGlossary\n and our \nFAQ\n. There are separate wikis for information relevant to the \nC++\n, \nGo\n and \nRust\n implementations (Python and Javascript coming soon).\n\n\n\u4e0b\u8f7d\n\n\nBleeding edge code can be cloned from the develop branch of their git repositories:\n\n\n\n\ngo-ethereum\n  (Go)\n\n\nparity\n (Rust)\n\n\npyethapp\n (Python)\n\n\ncpp-ethereum\n (C++)\n\n\nethereumj\n (Java)", 
            "title": "\u6982\u8ff0"
        }, 
        {
            "location": "/home/#_1", 
            "text": "This is the community-maintained wiki covering all sorts of information on the next-generation peer-to-peer technology platform built by the Ethereum Foundation, including  Ethereum ,  the generalized blockchain for smart contract development , as well as sister protocols like  Whisper ,  the private low-level datagram communication platform , and Swarm.  Users signed in with GitHub can edit and add pages using the  browser  or  locally .", 
            "title": "\u4ee5\u592a\u574a\u6587\u6863"
        }, 
        {
            "location": "/home/#_2", 
            "text": "\u53d1\u7248 / \u5f00\u53d1\u65f6\u95f4\u7ebf / \u8def\u6807   \u67e5\u770b \u8fd9\u91cc .", 
            "title": "\u72b6\u6001"
        }, 
        {
            "location": "/home/#_3", 
            "text": "To get the basic concepts of Ethereum visit the Ethereum homepage over at  http://ethereum.org . For another introduction targeted for end-users but also for (aspiring) developers and others, see  here . If you want to get a deeper understanding, start by reading the  whitepaper  and the  design rationale . For a more formal review, read the  yellow paper . If you are interested in developing smart contracts you can see  here , as well as under dapp development in the sidebar.  For getting started guides, see here:   https://medium.com/@attores/step-by-step-guide-getting-started-with-ethereum-mist-wallet-772a3cc99af4 (using Mist)  https://www.ethereum.org/greeter (creating a contract)  https://omarmetwally.wordpress.com/2017/07/25/how-to-create-a-private-ethereum-network/ (setting up a private network)", 
            "title": "\u5165\u95e8"
        }, 
        {
            "location": "/home/#_4", 
            "text": "Check the  Glossary  and our  FAQ . There are separate wikis for information relevant to the  C++ ,  Go  and  Rust  implementations (Python and Javascript coming soon).", 
            "title": "\u4e0d\u8981\u8ff7\u8def"
        }, 
        {
            "location": "/home/#_5", 
            "text": "Bleeding edge code can be cloned from the develop branch of their git repositories:   go-ethereum   (Go)  parity  (Rust)  pyethapp  (Python)  cpp-ethereum  (C++)  ethereumj  (Java)", 
            "title": "\u4e0b\u8f7d"
        }, 
        {
            "location": "/Basics/introduction/", 
            "text": "\u4ee5\u592a\u574a\u7b80\u4ecb\n\n\n\n\n\n\nNote that due to the lightning-fast pace of development in the Ethereum space with core development and dapps continually being launched, certain parts of this article may be outdated. You can help by keeping it up to date!\n\n\n\n\n\u5173\u4e8e\n\n\nEthereum\n\u662f\u4e00\u4e2a\n\u65e0\u5fc3\n\u533a\u5757\u94fe\u5e73\u53f0\u7528\u6765\"\u6784\u5efa\u65e0\u963b\u788d\u5e94\u7528\", while Ether is the cryptocurrency used on this platform. Ethereum has been described in several ways, such as (the first and third resources are more general introductions, while the second is a technical introduction, although all are outdated.\nAnother introduction is available \nhere\n, but again, it is outdated. Despite being outdated, Ethereum has maintained backwards compatibility thus far up till January 1 2018, so the info is still relevant.):\n\n\n\n\nNext-Generation Smart Contract and \u65e0\u5fc3\u5e94\u7528\u5e73\u53f0\"\u2014\nEthereum White Paper\n\n\n\"A secure decentralised generalised transaction ledger\" and a generalised \"transactional singleton machine with shared-state\". \u4e5f\u88ab\u63cf\u8ff0\u4e3a \ncrypto-law\u2014Ethereum Yellow Paper\n\n\n\u5f00\u6e90 \"\u53ef\u7f16\u7a0b\u7684\u5757\u94fe\"\u2014 \nEthdocs\n\n\n\n\nLet's briefly breakdown what those terms mean.\n\n\n\u65e0\u5fc3\n technology uses \npeer-to-peer computer networks\n (there's a picture below), and are not subject to the whims of a central authority such as a government or server administrator (like Google or Facebook) which can help to achieve better decision making for public good. \nBlockchain\n means that the currency is built and secured by adding and verifying blocks of transactions to blocks made previously, thus forming a \"chain\". Blocks added to the chain become harder and harder to crack over time, as they are verified by more nodes in the blockchain peer-to-peer network. Blockchain technology has been referred to as the \nWeb 3.0\n. The world wide web (retroactively the Web 1.0) consisted of websites publishing content and users passively reading/viewing it. The Web 2.0 used user interaction, such as forums (with upvoting and commenting), reaction buttons (e.g. the Facebook reactions: likes \ud83d\udc4d, love\u00a0\u2764\ufe0f\u00a0, laughter\u00a0\ud83d\ude06, wow\u00a0\ud83d\ude32, sad\u00a0\ud83d\ude22, angry\u00a0\ud83d\ude20), sharing (republishing), however these interactions have no direct economic effect on the host website; users do not share in the value generated from the website. The Web 3.0 is starting to be defined as the movement away from centralization of computation power in servers which provide services to clients (known as the \nclient-server network model\n) to peer-to-peer networks and blockchains, and \nfrom centralisation of authority and sovereignty from nation-states and corporations to the networked individual\n.\n\n\n\n\n\n\nCryptocurrency\n refers to a a digital currency that secures transactions with cryptographic code, which is solved through hardware computational power (known as mining or proof of work) or other less energy-intensive ways such as proof-of-stake. (There are more details on that below.)\n\n\nZero knowledge proofs like\u00a0\nZK SNARKs\n can also be used to make cryptocurrency transactions more private \ud83d\udd75\ufe0f\u00a0or secret \ud83e\udd10\u00a0(which is different to being secure \ud83d\udd12), thus negating the need to run \u5e94\u7528s on a permissioned private network like the \nEthereum Enterprise Alliance\n. Ethereum uses \nprecompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128\n, for \npairing checks\n, which permit \nzk-SNARKs\n, also see \nhere\n, \nas implemented\n in the \nByzantium hard fork\n. There is also the Zerocoin protocol which is demonstrated by\u00a0\nZcoin\n\u00a0(which plans to integrate Ethereum).\n\n\n\u4f7f\u7528\n\n\nThe platform part of Ethereum makes it much more useful than just a cryptocurrency. With it, you can create any \u65e0\u5fc3 \u5e94\u7528 (known as a dapp, which works over a peer-to- peer network rather than a centralized client-server network \ud83d\udcbb\ud83d\udd78\ufe0f), so the functionality is only limited by what programs could potentially do and not do, and by consequence, what programmers develop,\u00a0\ud83d\udc68\u200d\ud83d\udcbb but it can theoretically be used for any economic or governance activity.\n\n\n\u65e0\u5fc3\u5e94\u7528\u5217\u8868\n\n\n\u70b9\u51fb\n\u8fd9\u91cc\n\uff0c\u67e5\u770b\u65e0\u5fc3\u5e94\u7528\u5217\u8868.\n\n\n\u5e02\u573a\u5206\u6790\n\n\nAs of the 9th of January 2018, \nthe market capitalisation of Ethereum is $118.5 billion USD\n (refer to the link for the latest figure), and \nit has been in circulation possibly\u00a0since 30 July 2015\n, with the \nfirst transaction using Ethereum on 8 August 2015\n. Compare this with the next largest and the current largest cryptocurrency, \nBitcoin, with a market cap of $253.0 billion USD\n, where \nit has been in circulation since January 2009\n. Technically, Ethereum has had a much faster growth rate, while more importantly for long term investment (I do not encourage speculation as that only\u00a0causes volatility as has been seen)\u00a0the fundamentals are much better than Bitcoin. While it is true that Bitcoin has more of a market and currency, e.g. in terms of more entities that will accept it as a form of payment, the creator of this wiki expects that time will change that (indeed the \nmarket cap of Ethereum recently surpassed half that of Bitcoin, around May 2017\n). Also, \nthe number of transactions of Ethereum surpassed that of several cryptocurrencies combined on 22 Nov 2017\n. However, note \nthis retort\n.\n\n\n\u8bae\u9898\n\n\nThere also several issues with Ethereum, such as not being scalable enough, not being full \u65e0\u5fc3, energy consumption with mining and quantum computing attacks. With its \nlarge storage database\n (I have to provide a \nReddit link\n as a source as the \noriginal link\n doesn't have the graph any more, while \nWayback doesn't render it either\n), mining and architecture requiring to run a full node to mine or validate transactions, it is not \u65e0\u5fc3 enough. More (outdated but still applicable) info on that is e.g. \nhere\n, as well as \nhere\n.\n\n\n\u53ef\u6269\u5c55\u6027\n\n\nEthereum will need to scale to process far more transactions per second (to become a \"\nworld computer\n\") than Visa, Mastercard and American Express combined (which process on the order of \ntens of thousands of transactions per second\n [in the link, CTRL+F 24,000]), while Ethereum 1.0, the current version as of December 30 2017, processed \na record of 1103523 transactions on Friday, December 22, 2017, or 12.77 transactions per second\n.\n\n\nNote that \nRipple claims that it's Consensus Ledger can process a thousand transactions per second\n, while it could process more with payment channels. \"Although payment channels achieve practically infinite scalability by decoupling payment from settlement, they do so without incurring the risk typically associated with delayed settlement.\" Further note that Ripple achieves this by trading off on decentralization, through a \ndistributed network of validators or distributed servers\n, while it has been described as a \nfederation protocol\n.\n\n\nThere are even more scalable blockchains that use a delegated proof of stake (DPOS) consensus protocol, such as Bitshares and Steem. \nBitshares can apparently process 100,000 TPS\n.\n\n\nMore generally, in order to have faster payments or higher transaction throughput, you need to reduce the number of validators (miners are a kind of validator that perform energy intensive computational work, finding a random nonce or sequence number in a large set of numbers) in the consensus protocol, or reduce the other (i.e. for faster payments you can reduce transaction throughput or reduce validators, while for higher transaction throughput you can reduce validators or have payments take longer to finalize). This is \na trade-off triangle\n. You could potentially have one blockchain with \nheterogeneous sharding\n, with different shards with a different degree of balance between these properties. Ethereum is working on \nsharding\n, which includes using \nstateless clients\n (while more on that is \nhere\n).\n\n\nIf you increase scalability in an instant via some blockchain or shard, while keeping latency constant (or reducing it) you need to reduce decentralization, which reduces the number of points of attack needed to compromise the whole network, i.e. reducing decentralization reduces security.\n\n\n\u5de5\u4f5c\u91cf\u8bc1\u660e / \u6743\u76ca\u8bc1\u660e / \u5176\u5b83\u8bc1\u660e\u65b9\u6cd5\n\n\nThe mining process to crack cryptographic code (specifically to discover the nonce, a very large number, for each block by trial and error) requires a lot of computation power. Nevertheless, I'm guessing that the computation power should be less when you consider the \nenergy consumption\n of incumbent financial systems. (Think of extracting and processing resources to make coins and notes, minting and printing, energy consumption of banks and tiers of related energy consumption in the life cycle of fiat money.) Still, developers of some cryptocurrencies such as Ethereum are transitioning to (as is the case for Ethereum), or already using, a different way of maintaining and creating blocks, known as proof of stake. For more information, you can see this Proof of Stake Wikipedia article \nhere\n\u00a0(although note the header warning about the article potentially not being verifiable or neutral due to relying heavily on sources too closely associated to the subject). The tricky part is in getting proof methods to work better than proof of work, as outlined \nhere\n\u00a0in the criticism section of the PoS Wiki.\n\n\n\u91cf\u5b50\u8ba1\u7b97\u673a\u653b\u51fb\n\n\nIf quantum computing becomes more performant Ethereum's cryptographic signature scheme, Elliptic Curve Digital Signature Algorithm (ECDSA), would be insecure. However, there are solutions for this that will be implemented soon in the \nConstantinople release\n with \nEIP 86: Abstraction of transaction origin and signature, which has \"\nCustom cryptography\n: users can upgrade to ed25519 signatures, Lamport hash ladder signatures or whatever other scheme they want on their own terms; they do not need to stick with ECDSA.\" Lamport signatures could be used in a quantum resistant algorithm\n. More info on that is e.g. \nhere\n), \nhere\n, and \nhere\n.\n\n\n\u6ca1\u6709\u4efb\u4f55\u79d1\u6280\u4ea7\u54c1\u53ef\u4ee5\u6210\u4e3a\u4e07\u7075\u836f\n\n\nFor the continual improvement of humanity, there needs to be balance in life between things that benefit us materially and things that benefit us on higher levels, particularly spiritually. There is a risk that technology can make some people better off, and others worse off. So there needs to be consideration for how technology can be implemented to maximise \nutility\n.  One consideration of that is \nhere\n.\n\n\n\u7f3a\u9677\n\n\nEthereum has had expensive bugs, such as \nthe DAO vulnerability (CTRL+F vulnerability)\n; and Parity multisig library contract issues \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n. Also see \nreclaiming of ether in common classes of stuck accounts\n, which gives more examples such as sending to an empty address,\ne.g. \n1\n and \n2\n. Info about another bug is \nhere\n.\n\n\n\u5982\u4f55\u4e70\u5356\u4ee5\u592a\u5e01?\n\n\nRefer to \nhere\n.\n\n\n\u5f00\u53d1\n\n\nAre you interested in learning to develop smart contracts with Ethereum, and maybe develop a really useful dapp and become a millionaire?\n\n\nCheck out the \nEthereum website\n! Then, you can \nread the Solidity docs\n.\n\n\nIf you want to help contribute to core development, there is also:\n\n the \nYellow Paper\n (make sure that you read the \nEIPs\n too since as of Dec 8 it is not up-to-date with the last commit on August 8, while the Constantinople EIPs were implemented in October). Instead I recommend ;\n\n Learn Python first, e.g. with \nLearn Python the Hard Way\n (I learnt using this, it's pretty good), \nCodecademy\n, \nPydocs\n, \nCoursera\n, etc. Knowing Python is useful for \npyethereum\n, which is being used as an Ethereum client, to implement Serenity and sharding, as well as \nvyper\n, an experimental, secure smart contract programming language;\n\n \nLLL\n (also see \nhere\n and \nhere\n);\n\n \nJULIA\n, an intermediate language for different Ethereum virtual machines;\n\n clients such as \nGeth\n, \nParity\n which is under \nParity Tech\n a separate organization to the Ethereum Foundation, \nC++ Ethereum\n, \nPyethereum\n;\n\n \nSerenity\n;\n\n \nsharding\n;\n\n \nresearch\n such as stateless clients, sharding, scalability improvements, Casper and more;\n\n \nEWasM\n;\n\n if you're interested in testing, see the documentation \nhere\n, as well as \nthe Github tests repo\n, \na Gist here (it is outdated)\n,  and \nGitter here\n ; and\n* \nmany other repositories\n.\n\n\n\u7ed3\u675f\u8bed\n\n\nEther certainly seems like a good investment, and a good alternative to using fiat currencies, as well as an enabler for otherwise uneconomical business, due to lower transaction costs. It's more \u65e0\u5fc3 nature than central banks has advantages for trade from a local to global scale. With governance \u5e94\u7528s and systems on top Ethereum, it is even possible to do away with the hindering borders surmounted by nation-states. By doing away with these borders, society can be more open, inclusive and equitable.\n\n\nHowever, all technology can only help mankind and the world to a certain extent. What is more important is for each and every person to become increasingly blissful. Each person must go within and enter a stillness of body and mind, which is when that bliss starts to manifest, and practice balanced living. Practicing certain techniques such as those given by Self-Realization Fellowship, such as daily Kriya yoga meditation, developing unconditional love that starts in the heart, keeping the mind at the point between the eyebrows, and moral living, helps each person manifest that bliss within, and from there, express that bliss outwardly at all times.\n\n\n\u5ef6\u4f38\u9605\u8bfb\n\n\n\n\nAnother introduction\n\n\nMyEtherWallet knowledge base (good for issues with wallets)\n\n\nAn introduction (Frontier first release, outdated)\n\n\nHere's another introduction, made in November 2017\n\n\nEthereum community on Gitter\n\n\nEthereum research forum\n\n\nCorrect by construction Casper prototype\n\n\nCasper the Friendly Finality Gadget\n\n\nThe stateless client concept\n\n\nEthereum 2 and alternative PoS implementations\n\n\nEthereum wiki\n\n\nEthereum and the hodlers that love them\n\n\n\n\n\n\nThis article was originally created here in May 2017, and has been regularly updated since then: https://sustergy.wordpress.com/2017/05/18/why-buy-ether-and-how/. Feel free to send a donation to the initial author at jamesray.eth, or make edits to it yourself, or fork it!", 
            "title": "\u4ecb\u7ecd"
        }, 
        {
            "location": "/Basics/introduction/#_1", 
            "text": "Note that due to the lightning-fast pace of development in the Ethereum space with core development and dapps continually being launched, certain parts of this article may be outdated. You can help by keeping it up to date!", 
            "title": "\u4ee5\u592a\u574a\u7b80\u4ecb"
        }, 
        {
            "location": "/Basics/introduction/#_2", 
            "text": "Ethereum \u662f\u4e00\u4e2a \u65e0\u5fc3 \u533a\u5757\u94fe\u5e73\u53f0\u7528\u6765\"\u6784\u5efa\u65e0\u963b\u788d\u5e94\u7528\", while Ether is the cryptocurrency used on this platform. Ethereum has been described in several ways, such as (the first and third resources are more general introductions, while the second is a technical introduction, although all are outdated.\nAnother introduction is available  here , but again, it is outdated. Despite being outdated, Ethereum has maintained backwards compatibility thus far up till January 1 2018, so the info is still relevant.):   Next-Generation Smart Contract and \u65e0\u5fc3\u5e94\u7528\u5e73\u53f0\"\u2014 Ethereum White Paper  \"A secure decentralised generalised transaction ledger\" and a generalised \"transactional singleton machine with shared-state\". \u4e5f\u88ab\u63cf\u8ff0\u4e3a  crypto-law\u2014Ethereum Yellow Paper  \u5f00\u6e90 \"\u53ef\u7f16\u7a0b\u7684\u5757\u94fe\"\u2014  Ethdocs   Let's briefly breakdown what those terms mean.  \u65e0\u5fc3  technology uses  peer-to-peer computer networks  (there's a picture below), and are not subject to the whims of a central authority such as a government or server administrator (like Google or Facebook) which can help to achieve better decision making for public good.  Blockchain  means that the currency is built and secured by adding and verifying blocks of transactions to blocks made previously, thus forming a \"chain\". Blocks added to the chain become harder and harder to crack over time, as they are verified by more nodes in the blockchain peer-to-peer network. Blockchain technology has been referred to as the  Web 3.0 . The world wide web (retroactively the Web 1.0) consisted of websites publishing content and users passively reading/viewing it. The Web 2.0 used user interaction, such as forums (with upvoting and commenting), reaction buttons (e.g. the Facebook reactions: likes \ud83d\udc4d, love\u00a0\u2764\ufe0f\u00a0, laughter\u00a0\ud83d\ude06, wow\u00a0\ud83d\ude32, sad\u00a0\ud83d\ude22, angry\u00a0\ud83d\ude20), sharing (republishing), however these interactions have no direct economic effect on the host website; users do not share in the value generated from the website. The Web 3.0 is starting to be defined as the movement away from centralization of computation power in servers which provide services to clients (known as the  client-server network model ) to peer-to-peer networks and blockchains, and  from centralisation of authority and sovereignty from nation-states and corporations to the networked individual .    Cryptocurrency  refers to a a digital currency that secures transactions with cryptographic code, which is solved through hardware computational power (known as mining or proof of work) or other less energy-intensive ways such as proof-of-stake. (There are more details on that below.)  Zero knowledge proofs like\u00a0 ZK SNARKs  can also be used to make cryptocurrency transactions more private \ud83d\udd75\ufe0f\u00a0or secret \ud83e\udd10\u00a0(which is different to being secure \ud83d\udd12), thus negating the need to run \u5e94\u7528s on a permissioned private network like the  Ethereum Enterprise Alliance . Ethereum uses  precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128 , for  pairing checks , which permit  zk-SNARKs , also see  here ,  as implemented  in the  Byzantium hard fork . There is also the Zerocoin protocol which is demonstrated by\u00a0 Zcoin \u00a0(which plans to integrate Ethereum).", 
            "title": "\u5173\u4e8e"
        }, 
        {
            "location": "/Basics/introduction/#_3", 
            "text": "The platform part of Ethereum makes it much more useful than just a cryptocurrency. With it, you can create any \u65e0\u5fc3 \u5e94\u7528 (known as a dapp, which works over a peer-to- peer network rather than a centralized client-server network \ud83d\udcbb\ud83d\udd78\ufe0f), so the functionality is only limited by what programs could potentially do and not do, and by consequence, what programmers develop,\u00a0\ud83d\udc68\u200d\ud83d\udcbb but it can theoretically be used for any economic or governance activity.", 
            "title": "\u4f7f\u7528"
        }, 
        {
            "location": "/Basics/introduction/#_4", 
            "text": "\u70b9\u51fb \u8fd9\u91cc \uff0c\u67e5\u770b\u65e0\u5fc3\u5e94\u7528\u5217\u8868.", 
            "title": "\u65e0\u5fc3\u5e94\u7528\u5217\u8868"
        }, 
        {
            "location": "/Basics/introduction/#_5", 
            "text": "As of the 9th of January 2018,  the market capitalisation of Ethereum is $118.5 billion USD  (refer to the link for the latest figure), and  it has been in circulation possibly\u00a0since 30 July 2015 , with the  first transaction using Ethereum on 8 August 2015 . Compare this with the next largest and the current largest cryptocurrency,  Bitcoin, with a market cap of $253.0 billion USD , where  it has been in circulation since January 2009 . Technically, Ethereum has had a much faster growth rate, while more importantly for long term investment (I do not encourage speculation as that only\u00a0causes volatility as has been seen)\u00a0the fundamentals are much better than Bitcoin. While it is true that Bitcoin has more of a market and currency, e.g. in terms of more entities that will accept it as a form of payment, the creator of this wiki expects that time will change that (indeed the  market cap of Ethereum recently surpassed half that of Bitcoin, around May 2017 ). Also,  the number of transactions of Ethereum surpassed that of several cryptocurrencies combined on 22 Nov 2017 . However, note  this retort .", 
            "title": "\u5e02\u573a\u5206\u6790"
        }, 
        {
            "location": "/Basics/introduction/#_6", 
            "text": "There also several issues with Ethereum, such as not being scalable enough, not being full \u65e0\u5fc3, energy consumption with mining and quantum computing attacks. With its  large storage database  (I have to provide a  Reddit link  as a source as the  original link  doesn't have the graph any more, while  Wayback doesn't render it either ), mining and architecture requiring to run a full node to mine or validate transactions, it is not \u65e0\u5fc3 enough. More (outdated but still applicable) info on that is e.g.  here , as well as  here .", 
            "title": "\u8bae\u9898"
        }, 
        {
            "location": "/Basics/introduction/#_7", 
            "text": "Ethereum will need to scale to process far more transactions per second (to become a \" world computer \") than Visa, Mastercard and American Express combined (which process on the order of  tens of thousands of transactions per second  [in the link, CTRL+F 24,000]), while Ethereum 1.0, the current version as of December 30 2017, processed  a record of 1103523 transactions on Friday, December 22, 2017, or 12.77 transactions per second .  Note that  Ripple claims that it's Consensus Ledger can process a thousand transactions per second , while it could process more with payment channels. \"Although payment channels achieve practically infinite scalability by decoupling payment from settlement, they do so without incurring the risk typically associated with delayed settlement.\" Further note that Ripple achieves this by trading off on decentralization, through a  distributed network of validators or distributed servers , while it has been described as a  federation protocol .  There are even more scalable blockchains that use a delegated proof of stake (DPOS) consensus protocol, such as Bitshares and Steem.  Bitshares can apparently process 100,000 TPS .  More generally, in order to have faster payments or higher transaction throughput, you need to reduce the number of validators (miners are a kind of validator that perform energy intensive computational work, finding a random nonce or sequence number in a large set of numbers) in the consensus protocol, or reduce the other (i.e. for faster payments you can reduce transaction throughput or reduce validators, while for higher transaction throughput you can reduce validators or have payments take longer to finalize). This is  a trade-off triangle . You could potentially have one blockchain with  heterogeneous sharding , with different shards with a different degree of balance between these properties. Ethereum is working on  sharding , which includes using  stateless clients  (while more on that is  here ).  If you increase scalability in an instant via some blockchain or shard, while keeping latency constant (or reducing it) you need to reduce decentralization, which reduces the number of points of attack needed to compromise the whole network, i.e. reducing decentralization reduces security.", 
            "title": "\u53ef\u6269\u5c55\u6027"
        }, 
        {
            "location": "/Basics/introduction/#_8", 
            "text": "The mining process to crack cryptographic code (specifically to discover the nonce, a very large number, for each block by trial and error) requires a lot of computation power. Nevertheless, I'm guessing that the computation power should be less when you consider the  energy consumption  of incumbent financial systems. (Think of extracting and processing resources to make coins and notes, minting and printing, energy consumption of banks and tiers of related energy consumption in the life cycle of fiat money.) Still, developers of some cryptocurrencies such as Ethereum are transitioning to (as is the case for Ethereum), or already using, a different way of maintaining and creating blocks, known as proof of stake. For more information, you can see this Proof of Stake Wikipedia article  here \u00a0(although note the header warning about the article potentially not being verifiable or neutral due to relying heavily on sources too closely associated to the subject). The tricky part is in getting proof methods to work better than proof of work, as outlined  here \u00a0in the criticism section of the PoS Wiki.", 
            "title": "\u5de5\u4f5c\u91cf\u8bc1\u660e / \u6743\u76ca\u8bc1\u660e / \u5176\u5b83\u8bc1\u660e\u65b9\u6cd5"
        }, 
        {
            "location": "/Basics/introduction/#_9", 
            "text": "If quantum computing becomes more performant Ethereum's cryptographic signature scheme, Elliptic Curve Digital Signature Algorithm (ECDSA), would be insecure. However, there are solutions for this that will be implemented soon in the  Constantinople release  with  EIP 86: Abstraction of transaction origin and signature, which has \" Custom cryptography : users can upgrade to ed25519 signatures, Lamport hash ladder signatures or whatever other scheme they want on their own terms; they do not need to stick with ECDSA.\" Lamport signatures could be used in a quantum resistant algorithm . More info on that is e.g.  here ),  here , and  here .", 
            "title": "\u91cf\u5b50\u8ba1\u7b97\u673a\u653b\u51fb"
        }, 
        {
            "location": "/Basics/introduction/#_10", 
            "text": "For the continual improvement of humanity, there needs to be balance in life between things that benefit us materially and things that benefit us on higher levels, particularly spiritually. There is a risk that technology can make some people better off, and others worse off. So there needs to be consideration for how technology can be implemented to maximise  utility .  One consideration of that is  here .", 
            "title": "\u6ca1\u6709\u4efb\u4f55\u79d1\u6280\u4ea7\u54c1\u53ef\u4ee5\u6210\u4e3a\u4e07\u7075\u836f"
        }, 
        {
            "location": "/Basics/introduction/#_11", 
            "text": "Ethereum has had expensive bugs, such as  the DAO vulnerability (CTRL+F vulnerability) ; and Parity multisig library contract issues  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 . Also see  reclaiming of ether in common classes of stuck accounts , which gives more examples such as sending to an empty address,\ne.g.  1  and  2 . Info about another bug is  here .", 
            "title": "\u7f3a\u9677"
        }, 
        {
            "location": "/Basics/introduction/#_12", 
            "text": "Refer to  here .", 
            "title": "\u5982\u4f55\u4e70\u5356\u4ee5\u592a\u5e01?"
        }, 
        {
            "location": "/Basics/introduction/#_13", 
            "text": "Are you interested in learning to develop smart contracts with Ethereum, and maybe develop a really useful dapp and become a millionaire?  Check out the  Ethereum website ! Then, you can  read the Solidity docs .  If you want to help contribute to core development, there is also:  the  Yellow Paper  (make sure that you read the  EIPs  too since as of Dec 8 it is not up-to-date with the last commit on August 8, while the Constantinople EIPs were implemented in October). Instead I recommend ;  Learn Python first, e.g. with  Learn Python the Hard Way  (I learnt using this, it's pretty good),  Codecademy ,  Pydocs ,  Coursera , etc. Knowing Python is useful for  pyethereum , which is being used as an Ethereum client, to implement Serenity and sharding, as well as  vyper , an experimental, secure smart contract programming language;   LLL  (also see  here  and  here );   JULIA , an intermediate language for different Ethereum virtual machines;  clients such as  Geth ,  Parity  which is under  Parity Tech  a separate organization to the Ethereum Foundation,  C++ Ethereum ,  Pyethereum ;   Serenity ;   sharding ;   research  such as stateless clients, sharding, scalability improvements, Casper and more;   EWasM ;  if you're interested in testing, see the documentation  here , as well as  the Github tests repo ,  a Gist here (it is outdated) ,  and  Gitter here  ; and\n*  many other repositories .", 
            "title": "\u5f00\u53d1"
        }, 
        {
            "location": "/Basics/introduction/#_14", 
            "text": "Ether certainly seems like a good investment, and a good alternative to using fiat currencies, as well as an enabler for otherwise uneconomical business, due to lower transaction costs. It's more \u65e0\u5fc3 nature than central banks has advantages for trade from a local to global scale. With governance \u5e94\u7528s and systems on top Ethereum, it is even possible to do away with the hindering borders surmounted by nation-states. By doing away with these borders, society can be more open, inclusive and equitable.  However, all technology can only help mankind and the world to a certain extent. What is more important is for each and every person to become increasingly blissful. Each person must go within and enter a stillness of body and mind, which is when that bliss starts to manifest, and practice balanced living. Practicing certain techniques such as those given by Self-Realization Fellowship, such as daily Kriya yoga meditation, developing unconditional love that starts in the heart, keeping the mind at the point between the eyebrows, and moral living, helps each person manifest that bliss within, and from there, express that bliss outwardly at all times.", 
            "title": "\u7ed3\u675f\u8bed"
        }, 
        {
            "location": "/Basics/introduction/#_15", 
            "text": "Another introduction  MyEtherWallet knowledge base (good for issues with wallets)  An introduction (Frontier first release, outdated)  Here's another introduction, made in November 2017  Ethereum community on Gitter  Ethereum research forum  Correct by construction Casper prototype  Casper the Friendly Finality Gadget  The stateless client concept  Ethereum 2 and alternative PoS implementations  Ethereum wiki  Ethereum and the hodlers that love them    This article was originally created here in May 2017, and has been regularly updated since then: https://sustergy.wordpress.com/2017/05/18/why-buy-ether-and-how/. Feel free to send a donation to the initial author at jamesray.eth, or make edits to it yourself, or fork it!", 
            "title": "\u5ef6\u4f38\u9605\u8bfb"
        }, 
        {
            "location": "/Basics/Getting-Ether/", 
            "text": "\u83b7\u53d6\u4ee5\u592a\u5e01\n\n\n\n\nnote that you should only buy Ether (or any cryptocurrency except for stable ones like DAI or USDT) with risk capital, i.e. money that you can afford to lose, because of the volatile nature of Ether.\n\n\n\n\n\u4e3a\u4e86\u83b7\u5f97\u919a\uff0c\u4f60\u9700\u8981\uff1a\n\n\n\n\ntrade other currencies for ether using centralised or trustless services\n\n\nuse the user friendly \nMist Ethereum GUI Wallet\n that as of Beta 6 introduced the ability to purchase ether using the http://shapeshift.io/ API.\n\n\nbecome an Ethereum miner (see \nhere\n. Note that \nthis\n Homestead guide is outdated, which is the same as \nthis\n mining wiki). However, this is not recommended as Ethereum is going to transition to proof-of-stake, making mining obsolescent. Becoming a miner would involve investing in a mining rig (several GPUs, plus maybe other hardware if needed, like a compatible computer), which is unlikely to get a return on investment before PoS is implemented.\n\n\n\n\n\u4e0d\u53ef\u9760\u670d\u52a1\n\n\nNote that the Ethereum platform is special in that the smart contracts enable trustless services that obviate the need for trusted third parties in a currency exchange transaction, ie. disintermediate currency exchange businesses.\n\n\nProjects that have launched includes:\n\n\n\n\nEtherDelta\n. I found that the charts on the site weren't very good on January 1, 2017, so I sent a \ntweet giving feedback\n. This is good for trading tokens. Unfortunately I tried to make a deposit with a small amount, so that I could then buy a token but nothing happened.\n\n\nDecentrex\n. This is now closed, but you can still access the site if you get a certificate error by clicking on advanced settings: \"decentrex open source beta project was closed with no further support because of very low volume and very low users attention compared with its \u201cmother\u201d etherdelta (decentrex was a fork of etherdelta like many other etherdelta forks you can find on github) and due to high Ethereum network fees and the fact that Ethereum network is unstable.\"\n\n\n\n\nProjects that have not been released yet (as of Dec 14 2017) includes:\n\n\n\n\nBTCrelay\n\n\nMore information\n (about ETH/BTC 2-way peg without modifying bitcoin code).\n\n\nBTCrelay audit\n\n\n\n\n\n\nEtherEx decentralised exchange\n. (This link no longer works. \nEtherex is not active on Github\n.)\n\n\n\n\nAdditionally there is also \nLocalEthereum\n, which allows exchanging Ether for fiat currencies, like \nLocalbitcoin\n. \"The smart contract allows users to safely exchange ether with one another, and to name a trusted third-party to mediate a trade if a dispute arises. Currently, the trusted mediator is always localethereum.com, but the contract will be adapted in the future to switch over to a reputation-based distributed arbitrator pool.\" The source of this quote is \nhere\n.\n\n\n\u96c6\u4e2d\u4ea4\u6613\u6240\u4e00\u89c8\u00b6\n\n\n\n\n\n\n\n\n\u4ea4\u6613\u6240\n\n\n\u8d27\u5e01\n\n\n\n\n\n\n\n\n\n\nPoloniex\n\n\nBTC\n\n\n\n\n\n\nKraken\n\n\nBTC, USD, EUR, CAD, GBP\n\n\n\n\n\n\nGatecoin\n\n\nBTC, EUR\n\n\n\n\n\n\nBitfinex\n\n\nBTC, USD\n\n\n\n\n\n\nBittrex\n\n\nBTC\n\n\n\n\n\n\nBluetrade\n\n\nBTC, LTC, DOGE\n\n\n\n\n\n\nHitBTC\n\n\nBTC\n\n\n\n\n\n\nLivecoin\n\n\nBTC\n\n\n\n\n\n\nCoinsquare\n\n\nBTC\n\n\n\n\n\n\nBittylicious\n\n\nGBP\n\n\n\n\n\n\nBTER\n\n\nCNY\n\n\n\n\n\n\nYunbi\n\n\nCNY\n\n\n\n\n\n\nMetaexchange\n\n\nBTC\n\n\n\n\n\n\n\n\nYou can also search for \"\ninsert your country\n Ether exchange\".\n\n\nThere's also this: https://myetherwallet.github.io/knowledge-base/faq/buying-selling-exchanging-eth-tokens-fiat.html and see the link at the bottom of the article.\n\n\n\u96c6\u4e2d\u56fa\u5b9a\u5229\u7387\u4ea4\u6362\n\n\n\n\n\n\n\n\n\u4ea4\u6613\u6240\n\n\n\u8d27\u5e01\n\n\n\n\n\n\n\n\n\n\nShapeshift\n\n\nBTC, LTC, DOGE, Other\n\n\n\n\n\n\nBity\n\n\nBTC, USD, EUR, CHF\n\n\n\n\n\n\n\n\n\u4ea4\u6613\u548c\u4ef7\u683c\u5206\u6790\n\n\n\n\nETH markets exhaustive listing by volume on \ncoinmarketcap\n\n\nAggregating realtime stats of major ETH markets:\n\n\nTradeblock\n\n\nEthereumWisdom\n\n\nCryptocompare\n\n\nCoinmarketcap\n\n\n\n\n\n\nEthGasStation\n is useful for checking the gas price to set before making a transaction lists, as well as checking `Gas Guzzlers, or the \nTop 10 ETH Contracts By Transaction Count Over the Last 1,500 Blocks\n\n\n\n\n\u5728\u7ebf\u94b1\u5305\uff0c\u7eb8\u94b1\u5305\u548c\u51b7\u5e93\n\n\n\n\nTodo\n\n\nThis is here just a dumping ground of links and notes\nPlease move this over in a listing form to ecosystem\n\n\nKeep examples here, maybe explain paranoid practices, list dangers\n\n\n\n\n\n\n\u96fe\u919a\u5305\n\n\n\u53d1\u5e03\u4e0b\u8f7d\n\n\n\u96fe\u919a\u5305\u5f00\u53d1\u8005\u9884\u89c8\n - foundation blog post\n\n\n\u5982\u4f55\u8f7b\u677e\u8bbe\u7f6e\u96fe\u919a\u5305\n - Tutorial by Tommy Economics\n\n\n\n\n\n\nKryptokit Jaxx\n\n\nJaxx\u4e3b\u7ad9\n\n\n\u79fb\u52a8\u7248\u672c\n\n\n\n\n\n\n\u919a\u5899\n\n\n\u919a\u5899\u7f51\n\n\n\u919a\u5899\u6e90\n\n\n\n\n\n\n\u6211\u919a\u5305\n\n\n\u6211\u919a\u5305\u7f51\n\n\n\u6211\u919a\u5305\u6e90\n\n\nChrome extension\n\n\n\n\n\n\n\u51b7\u94b1\u5305\n\n\nIcebox\n by \nConsenSys\n - Cold storage based on lightwallet with HD wallet library integrated.\n\n\nReddit \u8ba8\u8bba 1\n\n\n\u5982\u4f55\u8bbe\u7f6e\u51b7\u94b1\u5305\n\n\n\n\n\n\n\u786c\u94b1\u5305\n\n\nreddit\u8ba8\u8bba2\n\n\nreddit\u8ba8\u8bba3\n\n\n\n\n\n\n\u8111\u94b1\u5305\n\n\n\u8111\u888b\u4e0d\u5b89\u5168\uff0c\u4e0d\u8981\u4f7f\u7528\u5b83\u4eec\n\n\nExtreme caution with brain wallets. Read the recent controversy: \nbrainwallets\n vs \nwhy-brain-wallet-is-the-best\n\n\n\n\n\n\nMisc\n\n\nKraken\u94b1\u5305\u6e05\u626b\u5de5\u5177\n - Pre-sale wallet import\n\n\n\u6765\u5b89\u5168\u5730\u5b58\u50a8\u4ee5\u592a\u5e01\u7684\u63a8\u8350\u65b9\u6cd5\n\n\n\u5982\u4f55\u8d2d\u4e70\u548c\u50a8\u5b58\u4e59\u919a\n\n\n\u4e00\u4e2a\u5916\u884c\u4ecb\u7ecd\u66b4\u529b\u5f3a\u8feb\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u4f7f\u7528\u8111\u888b\n\n\nPyethsaletool\n\n\n\u5e10\u6237\u4e0e\u94b1\u5305\n\n\n\n\n\n\n\n\n\u6b32\u4e86\u89e3\u66f4\u591a\u4fe1\u606f(\u5217\u51fa\u66f4\u591a\u4ea4\u6613\u6240), \u67e5\u770b \n\u8fd9\u91cc\n.", 
            "title": "\u83b7\u53d6\u4ee5\u592a\u5e01"
        }, 
        {
            "location": "/Basics/Getting-Ether/#_1", 
            "text": "note that you should only buy Ether (or any cryptocurrency except for stable ones like DAI or USDT) with risk capital, i.e. money that you can afford to lose, because of the volatile nature of Ether.   \u4e3a\u4e86\u83b7\u5f97\u919a\uff0c\u4f60\u9700\u8981\uff1a   trade other currencies for ether using centralised or trustless services  use the user friendly  Mist Ethereum GUI Wallet  that as of Beta 6 introduced the ability to purchase ether using the http://shapeshift.io/ API.  become an Ethereum miner (see  here . Note that  this  Homestead guide is outdated, which is the same as  this  mining wiki). However, this is not recommended as Ethereum is going to transition to proof-of-stake, making mining obsolescent. Becoming a miner would involve investing in a mining rig (several GPUs, plus maybe other hardware if needed, like a compatible computer), which is unlikely to get a return on investment before PoS is implemented.", 
            "title": "\u83b7\u53d6\u4ee5\u592a\u5e01"
        }, 
        {
            "location": "/Basics/Getting-Ether/#_2", 
            "text": "Note that the Ethereum platform is special in that the smart contracts enable trustless services that obviate the need for trusted third parties in a currency exchange transaction, ie. disintermediate currency exchange businesses.  Projects that have launched includes:   EtherDelta . I found that the charts on the site weren't very good on January 1, 2017, so I sent a  tweet giving feedback . This is good for trading tokens. Unfortunately I tried to make a deposit with a small amount, so that I could then buy a token but nothing happened.  Decentrex . This is now closed, but you can still access the site if you get a certificate error by clicking on advanced settings: \"decentrex open source beta project was closed with no further support because of very low volume and very low users attention compared with its \u201cmother\u201d etherdelta (decentrex was a fork of etherdelta like many other etherdelta forks you can find on github) and due to high Ethereum network fees and the fact that Ethereum network is unstable.\"   Projects that have not been released yet (as of Dec 14 2017) includes:   BTCrelay  More information  (about ETH/BTC 2-way peg without modifying bitcoin code).  BTCrelay audit    EtherEx decentralised exchange . (This link no longer works.  Etherex is not active on Github .)   Additionally there is also  LocalEthereum , which allows exchanging Ether for fiat currencies, like  Localbitcoin . \"The smart contract allows users to safely exchange ether with one another, and to name a trusted third-party to mediate a trade if a dispute arises. Currently, the trusted mediator is always localethereum.com, but the contract will be adapted in the future to switch over to a reputation-based distributed arbitrator pool.\" The source of this quote is  here .", 
            "title": "\u4e0d\u53ef\u9760\u670d\u52a1"
        }, 
        {
            "location": "/Basics/Getting-Ether/#_3", 
            "text": "\u4ea4\u6613\u6240  \u8d27\u5e01      Poloniex  BTC    Kraken  BTC, USD, EUR, CAD, GBP    Gatecoin  BTC, EUR    Bitfinex  BTC, USD    Bittrex  BTC    Bluetrade  BTC, LTC, DOGE    HitBTC  BTC    Livecoin  BTC    Coinsquare  BTC    Bittylicious  GBP    BTER  CNY    Yunbi  CNY    Metaexchange  BTC     You can also search for \" insert your country  Ether exchange\".  There's also this: https://myetherwallet.github.io/knowledge-base/faq/buying-selling-exchanging-eth-tokens-fiat.html and see the link at the bottom of the article.", 
            "title": "\u96c6\u4e2d\u4ea4\u6613\u6240\u4e00\u89c8\u00b6"
        }, 
        {
            "location": "/Basics/Getting-Ether/#_4", 
            "text": "\u4ea4\u6613\u6240  \u8d27\u5e01      Shapeshift  BTC, LTC, DOGE, Other    Bity  BTC, USD, EUR, CHF", 
            "title": "\u96c6\u4e2d\u56fa\u5b9a\u5229\u7387\u4ea4\u6362"
        }, 
        {
            "location": "/Basics/Getting-Ether/#_5", 
            "text": "ETH markets exhaustive listing by volume on  coinmarketcap  Aggregating realtime stats of major ETH markets:  Tradeblock  EthereumWisdom  Cryptocompare  Coinmarketcap    EthGasStation  is useful for checking the gas price to set before making a transaction lists, as well as checking `Gas Guzzlers, or the  Top 10 ETH Contracts By Transaction Count Over the Last 1,500 Blocks", 
            "title": "\u4ea4\u6613\u548c\u4ef7\u683c\u5206\u6790"
        }, 
        {
            "location": "/Basics/Getting-Ether/#_6", 
            "text": "Todo  This is here just a dumping ground of links and notes\nPlease move this over in a listing form to ecosystem  Keep examples here, maybe explain paranoid practices, list dangers    \u96fe\u919a\u5305  \u53d1\u5e03\u4e0b\u8f7d  \u96fe\u919a\u5305\u5f00\u53d1\u8005\u9884\u89c8  - foundation blog post  \u5982\u4f55\u8f7b\u677e\u8bbe\u7f6e\u96fe\u919a\u5305  - Tutorial by Tommy Economics    Kryptokit Jaxx  Jaxx\u4e3b\u7ad9  \u79fb\u52a8\u7248\u672c    \u919a\u5899  \u919a\u5899\u7f51  \u919a\u5899\u6e90    \u6211\u919a\u5305  \u6211\u919a\u5305\u7f51  \u6211\u919a\u5305\u6e90  Chrome extension    \u51b7\u94b1\u5305  Icebox  by  ConsenSys  - Cold storage based on lightwallet with HD wallet library integrated.  Reddit \u8ba8\u8bba 1  \u5982\u4f55\u8bbe\u7f6e\u51b7\u94b1\u5305    \u786c\u94b1\u5305  reddit\u8ba8\u8bba2  reddit\u8ba8\u8bba3    \u8111\u94b1\u5305  \u8111\u888b\u4e0d\u5b89\u5168\uff0c\u4e0d\u8981\u4f7f\u7528\u5b83\u4eec  Extreme caution with brain wallets. Read the recent controversy:  brainwallets  vs  why-brain-wallet-is-the-best    Misc  Kraken\u94b1\u5305\u6e05\u626b\u5de5\u5177  - Pre-sale wallet import  \u6765\u5b89\u5168\u5730\u5b58\u50a8\u4ee5\u592a\u5e01\u7684\u63a8\u8350\u65b9\u6cd5  \u5982\u4f55\u8d2d\u4e70\u548c\u50a8\u5b58\u4e59\u919a  \u4e00\u4e2a\u5916\u884c\u4ecb\u7ecd\u66b4\u529b\u5f3a\u8feb\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u4f7f\u7528\u8111\u888b  Pyethsaletool  \u5e10\u6237\u4e0e\u94b1\u5305     \u6b32\u4e86\u89e3\u66f4\u591a\u4fe1\u606f(\u5217\u51fa\u66f4\u591a\u4ea4\u6613\u6240), \u67e5\u770b  \u8fd9\u91cc .", 
            "title": "\u5728\u7ebf\u94b1\u5305\uff0c\u7eb8\u94b1\u5305\u548c\u51b7\u5e93"
        }, 
        {
            "location": "/Basics/dapps/", 
            "text": "\u65e0\u5fc3\u5e94\u7528\n\n\nAny good, service, governance or economic activity can be decentralized and tokenized with and transacted via Ethereum. The token represents the dapp (an abbreviation for decentralized app) while it uses the Ethereum blockchain, but the price of the token is different.\n\n\nActivity that has any economic or governance aspect, conceived or as of yet inconceived, can be done via Ethereum, provided that\u00a0the right code is written and the necessary hardware is used (such as computers running an Ethereum node, and in some special cases, a measurement device to measure a resource flow for additional verification/auditable purposes, like a meter for electricity \u26a1\ud83d\udd0c, water \ud83d\udeb0\u00a0or gas \ud83d\udd25; or a waste \ud83d\uddd1\ufe0f\u00a0volume detector).\n\n\nHere's a challenge: keep an eye out for activity that has not been implemented on Ethereum (or could be implemented in a better way; check this article and research to check whether it's implemented and if so, how well) and then:\n\n\n\n\ndevelop a dapp for the idea yourself (after learning \nSolidity\n, if you don't already know it); or\n\n\nsign an NDA with someone who is interested in developing dapps, share the idea, and form some agreement if they want to proceed with it (which could be proposed in the NDA itself), e.g. a founder's stake in an ICO, a salary, equity in the venture (although a community model more like Ethereum's non-profit foundation is better for a more equitable solution), royalties, a fee for every transaction, etc.\n\n\n\n\nThe platform aspect of Ethereum has been referred to as a 'fat protocol' \nhere\n, as opposed to the 'thin protocols' of Web 1.0 and 2.0 with HTTP, SMTP, etc., with the take home point (in bold) being:\n\n\nthe market cap of the protocol always\n\u00a0\ngrows faster than the combined value of the applications built on top, since the success of the application layer drives further speculation at the protocol layer.\n\n\nOne kind of application that is particularly intriguing is decentralized autononous organisations (\nDAOs\n, this includes entities as large as, or even larger than nation-states\u00a0\ud83c\udde6\ud83c\uddfa\ud83c\uddfa\ud83c\uddf8\ud83c\uddee\ud83c\uddf3\ud83c\uddec\ud83c\udde7\ud83c\udde8\ud83c\uddf3\ud83c\udde7\ud83c\uddf7\ud83c\uddf7\ud83c\uddfa\ud83c\uddef\ud83c\uddf5, social networks, multinational public companies, etc.).\n\n\nNote that having complete autonomy is probably not a good idea, since code may not be able to handle new issues that arise, so human intervention should probably always be an option, but preferably in the hands of a small, non-profit entity or some decentralized solution (perhaps similar to the \nAragon Network\n).\n\n\nBy analogy, you wouldn't want a nuclear power plant to be completely automated with no possible means of human intervention.\n\n\nAs a precaution, you'd want several safeguards including, for example, an off button. \ud83d\ude09\u00a0As explained in this Ethereum Wiki \nhere\n, the first DAO, known as The DAO, resulted in many funds being stolen, and Ethereum hard forking into Ethereum and Ethereum Classic.\n\n\nThe following list is sourced from \nCoin Market Cap tokens (you can sort by market cap)\n and \nState of the Dapps\n, both of which lists many more, as well as elsewhere, e.g. Gitter research room chats. (There are 854 dapps on State of the Dapps as of Dec 1 2017; then [909 on Jan 1 2018] (https://web.archive.org/web/20180101114436/https://www.stateofthedapps.com/). \ud83d\ude2f\n\n\nYou can search by tags.) Other examples are also presented e.g. on day 4 of \nDevcon 3\n, as well as outlined in the Ethereum whitepaper in the\u00a0\nintroduction\n\u00a0and \napplications section\n.\n\n\nNote also that while most of the dapps in the following list run on the Ethereum platform, some examples do not, and where they don't run on Ethereum, it is generally noted as what they do run on.\n\n\nThis is not a big deal, as any dapp could theoretically run on another blockchain, (or indirectly via inter-blockchains like Cosmos or Polkadot) provided that the host blockchain has the required features.\n\n\nAlso note that the below list is not an endorsement, and is not exhaustive or necessarily well-maintained.\n\n\nAt worst, it's included because it was briefly looked into and it seemed like a good idea, while more time may have been spent doing due diligence on some ideas and can therefore have a better idea of its usefulness.\n\n\nDapps that have been implemented, or are under development, or have been publicly conceptualised, includes:\n\n\n\n\na stable coin, e.g. \nDai\n\n\nsmart contracts for the legally enforceable and/or liquid transfer of assets, plus related services e.g. \nMattereum\n and \nSweetbridge\n, e.g. settlement, accounting, risk management, resource sharing, and Optimization \n Liquid Talent. Also, asset-based lending: secure loans with holding of assets e.g cryptocurrenices (locking them up) in exchange for cash (fiat currencies), such as Sweetbridge and \nSALT\n;\n\n\nVeritaseum\n, which \"enables software-driven P2P capital markets without brokerages, banks and traditional exchanges\".\n\n\ninvoice financing with Populous\n\n\ndecentralized exchanges to buy and sell cryptos and fiat, e.g. \nlocalethereum\n; for cryptos only there is\u00a0\nDecentrex\n,\u00a0\nOmega One\n\u00a0and\u00a0\nNVO\n, where the latter two have not been launched as of November 30.\n\n\nnon-decentralized exchanges such as \nCoinbase\n (US), \nBTCmarkets\n (Australia),  while more are below, or ones that only exchange cryptocurrencies like \nPoloniex\n;\n\n\nother exchanges like \nOmiseGo\n. \"OmiseGO is a public Ethereum-based financial technology for use in mainstream digital wallets, that enables real-time, peer-to-peer value exchange and payment services agnostically across jurisdictions and organizational silos, and across both fiat money and decentralized currencies. Designed to enable financial inclusion and disrupt existing institutions, access will be made available to everyone via the OmiseGO network and digital wallet framework.\";\n\n\nexchange platforms like \nBinance\n;\n\n\nasset exchanges like \nWAX\n.\n\n\nthe \nBrave browser\n\u00a0(which the author uses) which uses the \nBasic Attention Token\n, which provides a better solution for users, publishers and advertisers;\n\n\nMaidSafe\n, which has another browser that actually runs on the \nOmni\n layer that runs on Bitcoin, not Ethereum. It is also claiming to be: \"The World's First Autonomous Data Network\". \nCurrently you have to receive an invite which requires roughly an hour of interaction on their Discourse forum/site.\n\n\nZeroNet\n, another decentralized internet network that runs on Bitcoin cryptography and the \nBitTorrent network\n. \nIt on Ubuntu 17.10\n. You can make \nyour own site\n, although \nyou may have issues with following a tutorial\n. Note that this link won't work unless you are running ZeroNet.sh) by clicking the download button on the homepage (then as detailed concisely below the button) extracting it and running (in bash) \n./ZeroNet.sh\n while \ncd\ned to the extracted folder that ZeroNet.sh is located in.\n\n\nstorage, e.g. \nSwarm\n and a distributed hypermedia protocol, IPFS \nwebsite\n, \ndoc\n;\n\n\ncommunication protocols, e.g. \nWhisper\n\u00a0(also see\u00a0\nhere\n\u00a0for code), which allows dapps (you don't need to capitalize this since it is an abbreviation of decentralized applications) to communicate with each other;\n\n\nmulti-chain networks/tools like \nPolkadot\n and \nBTCRelay\n\n\nEthereum Name Service\n (names like \njamesray.eth\n map to an address);\n\n\nmesh networking\n\u00a0e.g. implemented\u00a0\naltheamesh here\n and as voted for\u00a0\nhere\n\u00a0on Twitter (which also has other ideas posted in the comments);\n\n\nsocial networks e.g. \nAkasha\n\u00a0(news \nhere\n),\n\n\nStatus\n: \"A Mobile Ethereum OS: Browse, chat and make payments securely on the decentralized web.\";\n\n\ndecentralized search engines, e.g. \nWeipoint\n\u00a0(a news post is\u00a0\nhere\n);\n\n\nreputation and ratings network e.g. as used by \nEtheal\n, which is described below (CTRL+F);\n\n\nidentity (e.g. as provided by \nuPort\n, as well as \nin-blockchain proposal\n;\n\n\ndecentralized electricity trading and other decentralized energy economic applications,\u00a0which would allow renewable energy to be more economical and accelerate the transition to a clean, renewable energy and safe climate future.\n\n\n\n\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/black-sun-with-rays_2600.png\" alt=\"Sun on Twitter Twemoji 2.3)\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/wind-blowing-face_1f32c.png\" alt=\"Wind Face on Twitter Twemoji 2.3)\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/deciduous-tree_1f333.png\" alt=\"Deciduous Tree on Twitter Twemoji 2.3)\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/water-wave_1f30a.png\" alt=\"Water Wave on Twitter Twemoji 2.3)\n\n\nExamples of \n local electricity trading\n include: \nGrid+\n, \nLO3\n/\nTransactive Grid\n, \nPower Ledger\n, \nNexergy\n, \nLocal Volts\n\u00a0and \nDivvi\n. Grid+ uses Ethereum and \nthey have open source code\n.\n\n\nPower Ledger has closed source code and runs on the Ethereum Enterprise Alliance, rather than the public Ethereum blockchain. \nThey had a token sale in early October\n.\u00a0Both Power Ledger and Grid+ also detail more unique applications in their pipeline, such as renewable energy asset generation (Power Ledger) and Grid+'s in-home computer, an \"intelligent agent\" that pays for a customers electricity in real-time, using stable tokens, stores cryptocurrency like the hardware wallet functions of Ledger and Trezor; providing Casper proof-of-stake signing, and provide an Ethereum API for IoT (\npp. 26 and 34-36, white paper\n).\n\n\nTransactive Grid uses Ethereum\n and it has been rolled out in \nBrooklyn with a microgrid\n, however LO3 hasn't released any code or details for its Transactive Grid application.\n\n\nThe others are still all under development (as of August 2017), and they have been scant on the details of how they would implement their application, at the least not releasing their code.\n\n\nDivvi say on its website that they will use the blockchain.\n\n\nLocal Volts and Nexergy do not.\n\n\n\n\nelectricity tokenization: e.g.\u00a0\nSolarCoin\n, \nEnergyCoin\n, although both are altcoins rather than Ethereum tokens;\n\n\ngovernance of any organisation, e.g. \nDemocracy.Earth\n; and also\u00a0governance of DAOs, e.g. \nAragon\n;\n\n\ndecentralized search engines like \nBitClave\n, \nWeipoint\n and \nEpocum\n;\n\n\nwallets like [Ledger](https://www.myetherwallet.com/\" target=\"_blank\" rel=\"noopener\"\nMyEtherWallet]() or hardware wallets \nTrezor\n or \nzendesk\n;\n\n\nblockchain explorers like \nEtherscan\n;\n\n\na gateway to decentralized services such as \nInfura\n;\n\n\nvisit dapps in your browser with \nMetamask\n;\n\n\ndecentralized media;\n\n\nasset titles (such as land titles). Read more on that \nhere\n: \"Having so far built the software and tested it with a couple dozen land title registrations, Bitfury and the Georgian National Agency of Public Registry have now signed a new memorandum of understanding to expand the service to purchases and sales of land titles, registration of new land titles, demolition of property, mortgages and rentals, as well as notary services\". Nottar.io also provides notary services. A similar, more specific application is for academic certificates with \nSmart Diploma\n;\n\n\nDebit card \ud83d\udcb3\u00a0transactions \ud83e\udd1d\u00a0(done on several exchanges \ud83d\udcb1, e.g. \nCoinjar Swipe\n (but it accepts BTC only), Coinbase, while others which I've mentioned elsewhere in this article have plans to do this e.g. \nOmiseGO\n;\n\n\nco-ownership of real assets e.g. the \nSwarm Fund\n\n\ncrowdsales, e.g. an \nInitial Coin Offering (ICO)\n as compared with an \nIntial Public Offering (IPO)\n, or for tokens with Ethereum: an Initial Token Offering (ITO). Note that this is not so much a business model in itself, per se, rather it is more of a fundraising method (which has also led to scams, e.g. \nhere\n);\n\n\ncrowd development (but not as part of the blockchain, e.g. \nhere\n), e.g. for infrastructure and other public assets;\n\n\nthink of public companies being remodelled into communities with tokens instead of shares, governance using a platform like\u00a0\nDemocracy.Earth\n\u00a0(which can be tailored to have voting anywhere between one vote one person like direct democracy, or conventionally more hierarchical like a board of directors and token-holders instead of or in addition to\u2014and probably eventually superceding\u2014shareholders);\n\n\ndividend payouts and secure email-based transactions with \nDividend\n. For sending ETH via email there is also \nYou've Got ETH\n;\n\n\nprediction \ud83d\udd2e\u00a0\ud83e\udd89\u00a0markets like \nAugur\n \nGNOSIS\n and \nWINGS DAO\n;\n\n\nBuilt-in price discovery and a liquidity mechanism for tokens with Bancor\n;\n\n\nlabour/recruitment/freelance markets like \nChronobank\n and \nEthlance\n;\n\n\npermissioned distributed ledgers like \nHydrachain\n;\n\n\ntrust-based models like the \nTrustlines Network\n\n\nSecure distributed computing, e.g.\u00a0[EWASM](https://golem.network/\" target=\"_blank\" rel=\"noopener\"\nGolem](). Ethereum needs to be faster e.g. with \ndesign\n and parallelizability.\n\n\naccountability, e.g. for \nhere\n and \naid\n\u00a0(also see\u00a0\nhere\n))\n\n\nSelf Learning, Autonomous, Decentralized Artificial Intelligence (this could be used for many things such as self-driving cars, robots, or anything else that is owned by a contract; bots; and art);\n\n\ndecentralised financial services like \nWeTrust\n;\n\n\nfutures-like dapps such as \nTimeBank\n and \nhodlethereum\n;\n\n\nsharing car refueling stations with \nShare\nCharge\n;\n\n\nhealth, e.g. \nEtheal\n, a healthcare service comparison site with a content platform, trust and review / reputation system; an anonymous marketing platform for surveys, ads and communication research where users are paid by pharmaceutical companies; and a platform for building health apps;\n\n\nexamples of contracts are \nhere\n and \nhere\n, e.g. voting, auctions (open or blind), safe remote purchases, micropayment channels, crowdfunding and company stock. Many more can be found on Github, which may be referenced from the whitepaper and the website of a dapp.\n\n\ninsurance\n;\n\n\n\n\nExamples that have been conceptualized, but not implemented (at least as far as the creator of this wiki is aware of) include:\n\n\n\n\nreducing transaction costs for existing business models (\nhere\n is a good read about that). However, to tokenize online centric business models, the network model should change from client-server to peer-to-peer, to avoid a conflict of interest. This is more difficult to achieve since a server is a piece of infrastructure, and transferring to a peer-to-peer model would cause it to be a sunk cost. Additionally, it may be difficult to build a replacement dapp for a successful website, because it is hard to get a network of engaged users to change to using something else (inertia). Centralized web apps  (not just mobile apps but websites, and use the word to contrast with dapps) include:\n\n\nGoogle (although note \nWeipoint\n as mentioned previously),\n\n\nsocial networks like \nFacebook\n, Twitter,  (although note \nAkasha\n above);\n\n\nonline marketplaces e.g. Amazon, eBay and Alibaba (decentralized alternatives include \nSoma for products or services\n, \nCanya for services\n also note this simple implementation and subreddit \nhere\n, as well as more specific or niche marketplaces like \nCryptokitties\n, \nHamster\n). For more info see \nhere\n\n\n\n\n\n\nmaking economically viable other business models that have seen low uptake or aren't economically viable without blockchain tech. So-called sharing economy business models (which are more aptly called tasker or rentier capitalism models) like Airbnb, Uber, AirTasker, Fiverr, Upwork, TaskRabbit, and Menulog are particularly ripe for transformation (the term transformation is preferrable to disruption, since it should be a net positive change, while negative effects are manageable or solvable), since no trusted third party for a transaction is needed, such as banks \ud83c\udfe6, credit card \ud83d\udcb3\u00a0companies or PayPal, just a smart contract; and mortgage brokers;\n\n\nMore examples are [CryptoKitties](https://medium.com/startup-grind/jack-the-giant-joint-stock-pepe-the-history-future-of-the-corporation-f17d30aff411\" target=\"_blank\" rel=\"noopener\"\nhere]()\u2014scroll to the examples\u2014they have bold headings and are about two thirds of the way down, or search for \"Dank meme\u00a0trading\". Note that the Basic Attention Token has already been mentioned, and the creator of this wiki is skeptical that AI will create truly beautiful art, since no AI can have any feeling. \ncryptokitties\n is an example of meme trading and has taken up \na lot of the transactions on the Ethereum network\n.\n\n\ncuration markets, which is part of what \nSteemit\n does (which runs on the STEEM network), and which curators, social networks and wiki authors would all benefit from. More info is \nhere\n;\n\n\nP2P Decentralised Autonomous Transportation Network\n\n\nWaste collection management\n. Other ideas include plus generally thinking of existing business models running on the blockchain, like real estate developers and investment trusts (with which blockchains could be used e.g. for crowdfunding).\n\n\nlegally enforceable wills running on the blockchain, as well as being able to appoint an executor in a legally enforceable way on the blockchain.\n\n\nTron\n, \"a blockchain-based decentralized protocol that aims to construct a worldwide free content entertainment system\"\n\n\nOraclize\n, a blockchain oracle service;\n\n\n\n\n\u66f4\u591a\u7684\u4f8b\u5b50\u53ef\u9605\u8bfb\n\u8fd9\u91cc\u7684\u535a\u5ba2\u6587\u7ae0\n\u4ee5\u53ca\n\u7ef4\u57fa\u5185\u5bb9", 
            "title": "\u65e0\u5fc3\u5e94\u7528"
        }, 
        {
            "location": "/Basics/dapps/#_1", 
            "text": "Any good, service, governance or economic activity can be decentralized and tokenized with and transacted via Ethereum. The token represents the dapp (an abbreviation for decentralized app) while it uses the Ethereum blockchain, but the price of the token is different.  Activity that has any economic or governance aspect, conceived or as of yet inconceived, can be done via Ethereum, provided that\u00a0the right code is written and the necessary hardware is used (such as computers running an Ethereum node, and in some special cases, a measurement device to measure a resource flow for additional verification/auditable purposes, like a meter for electricity \u26a1\ud83d\udd0c, water \ud83d\udeb0\u00a0or gas \ud83d\udd25; or a waste \ud83d\uddd1\ufe0f\u00a0volume detector).  Here's a challenge: keep an eye out for activity that has not been implemented on Ethereum (or could be implemented in a better way; check this article and research to check whether it's implemented and if so, how well) and then:   develop a dapp for the idea yourself (after learning  Solidity , if you don't already know it); or  sign an NDA with someone who is interested in developing dapps, share the idea, and form some agreement if they want to proceed with it (which could be proposed in the NDA itself), e.g. a founder's stake in an ICO, a salary, equity in the venture (although a community model more like Ethereum's non-profit foundation is better for a more equitable solution), royalties, a fee for every transaction, etc.   The platform aspect of Ethereum has been referred to as a 'fat protocol'  here , as opposed to the 'thin protocols' of Web 1.0 and 2.0 with HTTP, SMTP, etc., with the take home point (in bold) being:  the market cap of the protocol always \u00a0 grows faster than the combined value of the applications built on top, since the success of the application layer drives further speculation at the protocol layer.  One kind of application that is particularly intriguing is decentralized autononous organisations ( DAOs , this includes entities as large as, or even larger than nation-states\u00a0\ud83c\udde6\ud83c\uddfa\ud83c\uddfa\ud83c\uddf8\ud83c\uddee\ud83c\uddf3\ud83c\uddec\ud83c\udde7\ud83c\udde8\ud83c\uddf3\ud83c\udde7\ud83c\uddf7\ud83c\uddf7\ud83c\uddfa\ud83c\uddef\ud83c\uddf5, social networks, multinational public companies, etc.).  Note that having complete autonomy is probably not a good idea, since code may not be able to handle new issues that arise, so human intervention should probably always be an option, but preferably in the hands of a small, non-profit entity or some decentralized solution (perhaps similar to the  Aragon Network ).  By analogy, you wouldn't want a nuclear power plant to be completely automated with no possible means of human intervention.  As a precaution, you'd want several safeguards including, for example, an off button. \ud83d\ude09\u00a0As explained in this Ethereum Wiki  here , the first DAO, known as The DAO, resulted in many funds being stolen, and Ethereum hard forking into Ethereum and Ethereum Classic.  The following list is sourced from  Coin Market Cap tokens (you can sort by market cap)  and  State of the Dapps , both of which lists many more, as well as elsewhere, e.g. Gitter research room chats. (There are 854 dapps on State of the Dapps as of Dec 1 2017; then [909 on Jan 1 2018] (https://web.archive.org/web/20180101114436/https://www.stateofthedapps.com/). \ud83d\ude2f  You can search by tags.) Other examples are also presented e.g. on day 4 of  Devcon 3 , as well as outlined in the Ethereum whitepaper in the\u00a0 introduction \u00a0and  applications section .  Note also that while most of the dapps in the following list run on the Ethereum platform, some examples do not, and where they don't run on Ethereum, it is generally noted as what they do run on.  This is not a big deal, as any dapp could theoretically run on another blockchain, (or indirectly via inter-blockchains like Cosmos or Polkadot) provided that the host blockchain has the required features.  Also note that the below list is not an endorsement, and is not exhaustive or necessarily well-maintained.  At worst, it's included because it was briefly looked into and it seemed like a good idea, while more time may have been spent doing due diligence on some ideas and can therefore have a better idea of its usefulness.  Dapps that have been implemented, or are under development, or have been publicly conceptualised, includes:   a stable coin, e.g.  Dai  smart contracts for the legally enforceable and/or liquid transfer of assets, plus related services e.g.  Mattereum  and  Sweetbridge , e.g. settlement, accounting, risk management, resource sharing, and Optimization   Liquid Talent. Also, asset-based lending: secure loans with holding of assets e.g cryptocurrenices (locking them up) in exchange for cash (fiat currencies), such as Sweetbridge and  SALT ;  Veritaseum , which \"enables software-driven P2P capital markets without brokerages, banks and traditional exchanges\".  invoice financing with Populous  decentralized exchanges to buy and sell cryptos and fiat, e.g.  localethereum ; for cryptos only there is\u00a0 Decentrex ,\u00a0 Omega One \u00a0and\u00a0 NVO , where the latter two have not been launched as of November 30.  non-decentralized exchanges such as  Coinbase  (US),  BTCmarkets  (Australia),  while more are below, or ones that only exchange cryptocurrencies like  Poloniex ;  other exchanges like  OmiseGo . \"OmiseGO is a public Ethereum-based financial technology for use in mainstream digital wallets, that enables real-time, peer-to-peer value exchange and payment services agnostically across jurisdictions and organizational silos, and across both fiat money and decentralized currencies. Designed to enable financial inclusion and disrupt existing institutions, access will be made available to everyone via the OmiseGO network and digital wallet framework.\";  exchange platforms like  Binance ;  asset exchanges like  WAX .  the  Brave browser \u00a0(which the author uses) which uses the  Basic Attention Token , which provides a better solution for users, publishers and advertisers;  MaidSafe , which has another browser that actually runs on the  Omni  layer that runs on Bitcoin, not Ethereum. It is also claiming to be: \"The World's First Autonomous Data Network\".  Currently you have to receive an invite which requires roughly an hour of interaction on their Discourse forum/site.  ZeroNet , another decentralized internet network that runs on Bitcoin cryptography and the  BitTorrent network .  It on Ubuntu 17.10 . You can make  your own site , although  you may have issues with following a tutorial . Note that this link won't work unless you are running ZeroNet.sh) by clicking the download button on the homepage (then as detailed concisely below the button) extracting it and running (in bash)  ./ZeroNet.sh  while  cd ed to the extracted folder that ZeroNet.sh is located in.  storage, e.g.  Swarm  and a distributed hypermedia protocol, IPFS  website ,  doc ;  communication protocols, e.g.  Whisper \u00a0(also see\u00a0 here \u00a0for code), which allows dapps (you don't need to capitalize this since it is an abbreviation of decentralized applications) to communicate with each other;  multi-chain networks/tools like  Polkadot  and  BTCRelay  Ethereum Name Service  (names like  jamesray.eth  map to an address);  mesh networking \u00a0e.g. implemented\u00a0 altheamesh here  and as voted for\u00a0 here \u00a0on Twitter (which also has other ideas posted in the comments);  social networks e.g.  Akasha \u00a0(news  here ),  Status : \"A Mobile Ethereum OS: Browse, chat and make payments securely on the decentralized web.\";  decentralized search engines, e.g.  Weipoint \u00a0(a news post is\u00a0 here );  reputation and ratings network e.g. as used by  Etheal , which is described below (CTRL+F);  identity (e.g. as provided by  uPort , as well as  in-blockchain proposal ;  decentralized electricity trading and other decentralized energy economic applications,\u00a0which would allow renewable energy to be more economical and accelerate the transition to a clean, renewable energy and safe climate future.   ![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/black-sun-with-rays_2600.png\" alt=\"Sun on Twitter Twemoji 2.3)\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/wind-blowing-face_1f32c.png\" alt=\"Wind Face on Twitter Twemoji 2.3)\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/deciduous-tree_1f333.png\" alt=\"Deciduous Tree on Twitter Twemoji 2.3)\n![](https://emojipedia-us.s3.amazonaws.com/thumbs/120/twitter/103/water-wave_1f30a.png\" alt=\"Water Wave on Twitter Twemoji 2.3)  Examples of   local electricity trading  include:  Grid+ ,  LO3 / Transactive Grid ,  Power Ledger ,  Nexergy ,  Local Volts \u00a0and  Divvi . Grid+ uses Ethereum and  they have open source code .  Power Ledger has closed source code and runs on the Ethereum Enterprise Alliance, rather than the public Ethereum blockchain.  They had a token sale in early October .\u00a0Both Power Ledger and Grid+ also detail more unique applications in their pipeline, such as renewable energy asset generation (Power Ledger) and Grid+'s in-home computer, an \"intelligent agent\" that pays for a customers electricity in real-time, using stable tokens, stores cryptocurrency like the hardware wallet functions of Ledger and Trezor; providing Casper proof-of-stake signing, and provide an Ethereum API for IoT ( pp. 26 and 34-36, white paper ).  Transactive Grid uses Ethereum  and it has been rolled out in  Brooklyn with a microgrid , however LO3 hasn't released any code or details for its Transactive Grid application.  The others are still all under development (as of August 2017), and they have been scant on the details of how they would implement their application, at the least not releasing their code.  Divvi say on its website that they will use the blockchain.  Local Volts and Nexergy do not.   electricity tokenization: e.g.\u00a0 SolarCoin ,  EnergyCoin , although both are altcoins rather than Ethereum tokens;  governance of any organisation, e.g.  Democracy.Earth ; and also\u00a0governance of DAOs, e.g.  Aragon ;  decentralized search engines like  BitClave ,  Weipoint  and  Epocum ;  wallets like [Ledger](https://www.myetherwallet.com/\" target=\"_blank\" rel=\"noopener\" MyEtherWallet]() or hardware wallets  Trezor  or  zendesk ;  blockchain explorers like  Etherscan ;  a gateway to decentralized services such as  Infura ;  visit dapps in your browser with  Metamask ;  decentralized media;  asset titles (such as land titles). Read more on that  here : \"Having so far built the software and tested it with a couple dozen land title registrations, Bitfury and the Georgian National Agency of Public Registry have now signed a new memorandum of understanding to expand the service to purchases and sales of land titles, registration of new land titles, demolition of property, mortgages and rentals, as well as notary services\". Nottar.io also provides notary services. A similar, more specific application is for academic certificates with  Smart Diploma ;  Debit card \ud83d\udcb3\u00a0transactions \ud83e\udd1d\u00a0(done on several exchanges \ud83d\udcb1, e.g.  Coinjar Swipe  (but it accepts BTC only), Coinbase, while others which I've mentioned elsewhere in this article have plans to do this e.g.  OmiseGO ;  co-ownership of real assets e.g. the  Swarm Fund  crowdsales, e.g. an  Initial Coin Offering (ICO)  as compared with an  Intial Public Offering (IPO) , or for tokens with Ethereum: an Initial Token Offering (ITO). Note that this is not so much a business model in itself, per se, rather it is more of a fundraising method (which has also led to scams, e.g.  here );  crowd development (but not as part of the blockchain, e.g.  here ), e.g. for infrastructure and other public assets;  think of public companies being remodelled into communities with tokens instead of shares, governance using a platform like\u00a0 Democracy.Earth \u00a0(which can be tailored to have voting anywhere between one vote one person like direct democracy, or conventionally more hierarchical like a board of directors and token-holders instead of or in addition to\u2014and probably eventually superceding\u2014shareholders);  dividend payouts and secure email-based transactions with  Dividend . For sending ETH via email there is also  You've Got ETH ;  prediction \ud83d\udd2e\u00a0\ud83e\udd89\u00a0markets like  Augur   GNOSIS  and  WINGS DAO ;  Built-in price discovery and a liquidity mechanism for tokens with Bancor ;  labour/recruitment/freelance markets like  Chronobank  and  Ethlance ;  permissioned distributed ledgers like  Hydrachain ;  trust-based models like the  Trustlines Network  Secure distributed computing, e.g.\u00a0[EWASM](https://golem.network/\" target=\"_blank\" rel=\"noopener\" Golem](). Ethereum needs to be faster e.g. with  design  and parallelizability.  accountability, e.g. for  here  and  aid \u00a0(also see\u00a0 here ))  Self Learning, Autonomous, Decentralized Artificial Intelligence (this could be used for many things such as self-driving cars, robots, or anything else that is owned by a contract; bots; and art);  decentralised financial services like  WeTrust ;  futures-like dapps such as  TimeBank  and  hodlethereum ;  sharing car refueling stations with  Share Charge ;  health, e.g.  Etheal , a healthcare service comparison site with a content platform, trust and review / reputation system; an anonymous marketing platform for surveys, ads and communication research where users are paid by pharmaceutical companies; and a platform for building health apps;  examples of contracts are  here  and  here , e.g. voting, auctions (open or blind), safe remote purchases, micropayment channels, crowdfunding and company stock. Many more can be found on Github, which may be referenced from the whitepaper and the website of a dapp.  insurance ;   Examples that have been conceptualized, but not implemented (at least as far as the creator of this wiki is aware of) include:   reducing transaction costs for existing business models ( here  is a good read about that). However, to tokenize online centric business models, the network model should change from client-server to peer-to-peer, to avoid a conflict of interest. This is more difficult to achieve since a server is a piece of infrastructure, and transferring to a peer-to-peer model would cause it to be a sunk cost. Additionally, it may be difficult to build a replacement dapp for a successful website, because it is hard to get a network of engaged users to change to using something else (inertia). Centralized web apps  (not just mobile apps but websites, and use the word to contrast with dapps) include:  Google (although note  Weipoint  as mentioned previously),  social networks like  Facebook , Twitter,  (although note  Akasha  above);  online marketplaces e.g. Amazon, eBay and Alibaba (decentralized alternatives include  Soma for products or services ,  Canya for services  also note this simple implementation and subreddit  here , as well as more specific or niche marketplaces like  Cryptokitties ,  Hamster ). For more info see  here    making economically viable other business models that have seen low uptake or aren't economically viable without blockchain tech. So-called sharing economy business models (which are more aptly called tasker or rentier capitalism models) like Airbnb, Uber, AirTasker, Fiverr, Upwork, TaskRabbit, and Menulog are particularly ripe for transformation (the term transformation is preferrable to disruption, since it should be a net positive change, while negative effects are manageable or solvable), since no trusted third party for a transaction is needed, such as banks \ud83c\udfe6, credit card \ud83d\udcb3\u00a0companies or PayPal, just a smart contract; and mortgage brokers;  More examples are [CryptoKitties](https://medium.com/startup-grind/jack-the-giant-joint-stock-pepe-the-history-future-of-the-corporation-f17d30aff411\" target=\"_blank\" rel=\"noopener\" here]()\u2014scroll to the examples\u2014they have bold headings and are about two thirds of the way down, or search for \"Dank meme\u00a0trading\". Note that the Basic Attention Token has already been mentioned, and the creator of this wiki is skeptical that AI will create truly beautiful art, since no AI can have any feeling.  cryptokitties  is an example of meme trading and has taken up  a lot of the transactions on the Ethereum network .  curation markets, which is part of what  Steemit  does (which runs on the STEEM network), and which curators, social networks and wiki authors would all benefit from. More info is  here ;  P2P Decentralised Autonomous Transportation Network  Waste collection management . Other ideas include plus generally thinking of existing business models running on the blockchain, like real estate developers and investment trusts (with which blockchains could be used e.g. for crowdfunding).  legally enforceable wills running on the blockchain, as well as being able to appoint an executor in a legally enforceable way on the blockchain.  Tron , \"a blockchain-based decentralized protocol that aims to construct a worldwide free content entertainment system\"  Oraclize , a blockchain oracle service;   \u66f4\u591a\u7684\u4f8b\u5b50\u53ef\u9605\u8bfb \u8fd9\u91cc\u7684\u535a\u5ba2\u6587\u7ae0 \u4ee5\u53ca \u7ef4\u57fa\u5185\u5bb9", 
            "title": "\u65e0\u5fc3\u5e94\u7528"
        }, 
        {
            "location": "/Basics/White-Paper/", 
            "text": "\u767d\u76ae\u4e66\n\n\n\u4e0b\u4e00\u4ee3\u667a\u80fd\u5408\u7ea6\u4e0e\u5206\u6563\u5f0f\u5e94\u7528\u5e73\u53f0\n\n\nSatoshi Nakamoto's development of Bitcoin in 2009 has often been hailed as a radical development in money and currency, being the first example of a digital asset which simultaneously has no backing or \"\nintrinsic value\n\" and no centralized issuer or controller.\n\n\nHowever, another - arguably more important - part of the Bitcoin experiment is the underlying blockchain technology as a tool of distributed consensus, and attention is rapidly starting to shift to this other aspect of Bitcoin.\n\n\nCommonly cited alternative applications of blockchain technology include using on-blockchain digital assets to represent custom currencies and financial instruments (\n\"colored coins\"\n), the ownership of an underlying physical device (\n\"smart property\"\n), non-fungible assets such as domain names (\n\"Namecoin\"\n), as well as more complex applications involving having digital assets being directly controlled by a piece of code implementing arbitrary rules (\n\"smart contracts\"\n) or even blockchain-based \"\ndecentralized autonomous organizations\n\" (DAOs).\n\n\nWhat Ethereum intends to provide is a blockchain with a built-in fully fledged Turing-complete programming language that can be used to create \"contracts\" that can be used to encode arbitrary state transition functions, allowing users to create any of the systems described above, as well as many others that we have not yet imagined, simply by writing up the logic in a few lines of code.\n\n\n\u6bd4\u7279\u5e01\u4ecb\u7ecd\u548c\u73b0\u6709\u7684\u6982\u5ff5\n\n\n\u5386\u53f2\n\n\nThe concept of decentralized digital currency, as well as alternative applications like property registries, has been around for decades.\n\n\n80\u5e74\u4ee3-90\u5e74\u4ee3,\u533f\u540d\u7535\u5b50\u73b0\u91d1\u534f\u8bae, mostly reliant on a cryptographic primitive known as Chaumian blinding, provided a currency with a high degree of privacy, but the protocols largely failed to gain traction because of their reliance on a centralized intermediary.\n\n\n1998\u5e74, Wei Dai's \nb-money\n became the first proposal to introduce the idea of creating money through solving computational puzzles as well as decentralized consensus, but the proposal was scant on details as to how decentralized consensus could actually be implemented.\n\n\n2005\u5e74, Hal Finney introduced a concept of \"\nreusable proofs of work\n\", a system which uses ideas from b-money together with Adam Back's computationally difficult Hashcash puzzles to create a concept for a cryptocurrency, but once again fell short of the ideal by relying on trusted computing as a backend.\n\n\n2009\u5e74, a decentralized currency was for the first time implemented in practice by Satoshi Nakamoto, combining established primitives for managing ownership through public key cryptography with a consensus algorithm for keeping track of who owns coins, known as \"proof of work\".\n\n\nThe mechanism behind proof of work was a breakthrough in the space because it simultaneously solved two problems.\n\n\n\u9996\u5148, it provided a simple and moderately effective consensus algorithm, allowing nodes in the network to collectively agree on a set of canonical updates to the state of the Bitcoin ledger.\n\n\n\u5176\u6b21, it provided a mechanism for allowing free entry into the consensus process, solving the political problem of deciding who gets to influence the consensus, while simultaneously preventing sybil attacks.\n\n\nIt does this by substituting a formal barrier to participation, such as the requirement to be registered as a unique entity on a particular list, with an economic barrier - the weight of a single node in the consensus voting process is directly proportional to the computing power that the node brings.\n\n\nSince then, an alternative approach has been proposed called \nproof of stake\n, calculating the weight of a node as being proportional to its currency holdings and not computational resources; the discussion of the relative merits of the two approaches is beyond the scope of this paper but it should be noted that both approaches can be used to serve as the backbone of a cryptocurrency.\n\n\n\u72b6\u6001\u4f20\u9012\u7cfb\u7edf\u7684\u6bd4\u7279\u5e01\n\n\n\n\nFrom a technical standpoint, the ledger of a cryptocurrency such as Bitcoin can be thought of as a state transition system, where there is a \"state\" consisting of the ownership status of all existing bitcoins and a \"state transition function\" that takes a state and a transaction and outputs a new state which is the result. In a standard banking system, for example, the state is a balance sheet, a transaction is a request to move $X from A to B, and the state transition function reduces the value in A's account by $X and increases the value in B's account by $X. If A's account has less than $X in the first place, the state transition function returns an error. Hence, one can formally define:\n\n\nAPPLY(S,TX) -\n S\n or ERROR\n\n\n\n\n\nIn the banking system defined above:\n\n\nAPPLY({ Alice: $50, Bob: $50 },\nsend $20 from Alice to Bob\n) = { Alice: $30, Bob: $70 }\n\n\n\n\n\nBut:\n\n\nAPPLY({ Alice: $50, Bob: $50 },\nsend $70 from Alice to Bob\n) = ERROR\n\n\n\n\n\nThe \"state\" in Bitcoin is the collection of all coins (technically, \"unspent transaction outputs\" or UTXO) that have been minted and not yet spent, with each UTXO having a denomination and an owner (defined by a 20-byte address which is essentially a cryptographic public key\n[1]\n). A transaction contains one or more inputs, with each input containing a reference to an existing UTXO and a cryptographic signature produced by the private key associated with the owner's address, and one or more outputs, with each output containing a new UTXO to be added to the state.\n\n\nThe state transition function \nAPPLY(S,TX) -\n S'\n can be defined roughly as follows:\n\n\n\n\nFor each input in \nTX\n:\n\n\nIf the referenced UTXO is not in \nS\n, return an error.\n\n\nIf the provided signature does not match the owner of the UTXO, return an error.\n\n\n\n\n\n\nIf the sum of the denominations of all input UTXO is less than the sum of the denominations of all output UTXO, return an error.\n\n\nReturn \nS\n with all input UTXO removed and all output UTXO added.\n\n\n\n\nThe first half of the first step prevents transaction senders from spending coins that do not exist, the second half of the first step prevents transaction senders from spending other people's coins, and the second step enforces conservation of value. In order to use this for payment, the protocol is as follows. Suppose Alice wants to send 11.7 BTC to Bob. First, Alice will look for a set of available UTXO that she owns that totals up to at least 11.7 BTC. Realistically, Alice will not be able to get exactly 11.7 BTC; say that the smallest she can get is 6+4+2=12. She then creates a transaction with those three inputs and two outputs. The first output will be 11.7 BTC with Bob's address as its owner, and the second output will be the remaining 0.3 BTC \"change\", with the owner being Alice herself.\n\n\n\u6316\u77ff\n\n\n\n\nIf we had access to a trustworthy centralized service, this system would be trivial to implement; it could simply be coded exactly as described, using a centralized server's hard drive to keep track of the state. However, with Bitcoin we are trying to build a decentralized currency system, so we will need to combine the state transaction system with a consensus system in order to ensure that everyone agrees on the order of transactions. Bitcoin's decentralized consensus process requires nodes in the network to continuously attempt to produce packages of transactions called \"blocks\". The network is intended to produce roughly one block every ten minutes, with each block containing a timestamp, a nonce, a reference to (ie. hash of) the previous block and a list of all of the transactions that have taken place since the previous block. Over time, this creates a persistent, ever-growing, \"blockchain\" that constantly updates to represent the latest state of the Bitcoin ledger.\n\n\nThe algorithm for checking if a block is valid, expressed in this paradigm, is as follows:\n\n\n\n\nCheck if the previous block referenced by the block exists and is valid.\n\n\nCheck that the timestamp of the block is greater than that of the previous block\n[2]\n and less than 2 hours into the future\n\n\nCheck that the proof of work on the block is valid.\n\n\nLet \nS[0]\n be the state at the end of the previous block.\n\n\nSuppose \nTX\n is the block's transaction list with \nn\n transactions. For all \ni\n in \n0...n-1\n, set \nS[i+1] = APPLY(S[i],TX[i])\n If any application returns an error, exit and return false.\n\n\nReturn true, and register \nS[n]\n as the state at the end of this block.\n\n\n\n\nEssentially, each transaction in the block must provide a valid state transition from what was the canonical state before the transaction was executed to some new state. Note that the state is not encoded in the block in any way; it is purely an abstraction to be remembered by the validating node and can only be (securely) computed for any block by starting from the genesis state and sequentially applying every transaction in every block. Additionally, note that the order in which the miner includes transactions into the block matters; if there are two transactions A and B in a block such that B spends a UTXO created by A, then the block will be valid if A comes before B but not otherwise.\n\n\nThe one validity condition present in the above list that is not found in other systems is the requirement for \"proof of work\". The precise condition is that the double-SHA256 hash of every block, treated as a 256-bit number, must be less than a dynamically adjusted target, which as of the time of this writing is approximately 2\n187\n. The purpose of this is to make block creation computationally \"hard\", thereby preventing sybil attackers from remaking the entire blockchain in their favor. Because SHA256 is designed to be a completely unpredictable pseudorandom function, the only way to create a valid block is simply trial and error, repeatedly incrementing the nonce and seeing if the new hash matches.\n\n\nAt the current target of ~2\n187\n, the network must make an average of ~2\n69\n tries before a valid block is found; in general, the target is recalibrated by the network every 2016 blocks so that on average a new block is produced by some node in the network every ten minutes. In order to compensate miners for this computational work, the miner of every block is entitled to include a transaction giving themselves 25 BTC out of nowhere. Additionally, if any transaction has a higher total denomination in its inputs than in its outputs, the difference also goes to the miner as a \"transaction fee\". Incidentally, this is also the only mechanism by which BTC are issued; the genesis state contained no coins at all.\n\n\nIn order to better understand the purpose of mining, let us examine what happens in the event of a malicious attacker. Since Bitcoin's underlying cryptography is known to be secure, the attacker will target the one part of the Bitcoin system that is not protected by cryptography directly: the order of transactions. The attacker's strategy is simple:\n\n\n\n\nSend 100 BTC to a merchant in exchange for some product (preferably a rapid-delivery digital good)\n\n\nWait for the delivery of the product\n\n\nProduce another transaction sending the same 100 BTC to himself\n\n\nTry to convince the network that his transaction to himself was the one that came first.\n\n\n\n\nOnce step (1) has taken place, after a few minutes some miner will include the transaction in a block, say block number 270000. After about one hour, five more blocks will have been added to the chain after that block, with each of those blocks indirectly pointing to the transaction and thus \"confirming\" it. At this point, the merchant will accept the payment as finalized and deliver the product; since we are assuming this is a digital good, delivery is instant. Now, the attacker creates another transaction sending the 100 BTC to himself. If the attacker simply releases it into the wild, the transaction will not be processed; miners will attempt to run \nAPPLY(S,TX)\n and notice that \nTX\n consumes a UTXO which is no longer in the state. So instead, the attacker creates a \"fork\" of the blockchain, starting by mining another version of block 270000 pointing to the same block 269999 as a parent but with the new transaction in place of the old one. Because the block data is different, this requires redoing the proof of work. Furthermore, the attacker's new version of block 270000 has a different hash, so the original blocks 270001 to 270005 do not \"point\" to it; thus, the original chain and the attacker's new chain are completely separate. The rule is that in a fork the longest blockchain is taken to be the truth, and so legitimate miners will work on the 270005 chain while the attacker alone is working on the 270000 chain. In order for the attacker to make his blockchain the longest, he would need to have more computational power than the rest of the network combined in order to catch up (hence, \"51% attack\").\n\n\n\u9ed8\u514b\u5c14\u6811\n\n\n\n\nLeft: it suffices to present only a small number of nodes in a Merkle tree to give a proof of the validity of a branch.\n\n\nRight: any attempt to change any part of the Merkle tree will eventually lead to an inconsistency somewhere up the chain.\n\n\nAn important scalability feature of Bitcoin is that the block is stored in a multi-level data structure. The \"hash\" of a block is actually only the hash of the block header, a roughly 200-byte piece of data that contains the timestamp, nonce, previous block hash and the root hash of a data structure called the Merkle tree storing all transactions in the block. A Merkle tree is a type of binary tree, composed of a set of nodes with a large number of leaf nodes at the bottom of the tree containing the underlying data, a set of intermediate nodes where each node is the hash of its two children, and finally a single root node, also formed from the hash of its two children, representing the \"top\" of the tree. The purpose of the Merkle tree is to allow the data in a block to be delivered piecemeal: a node can download only the header of a block from one source, the small part of the tree relevant to them from another source, and still be assured that all of the data is correct. The reason why this works is that hashes propagate upward: if a malicious user attempts to swap in a fake transaction into the bottom of a Merkle tree, this change will cause a change in the node above, and then a change in the node above that, finally changing the root of the tree and therefore the hash of the block, causing the protocol to register it as a completely different block (almost certainly with an invalid proof of work).\n\n\nThe Merkle tree protocol is arguably essential to long-term sustainability. A \"full node\" in the Bitcoin network, one that stores and processes the entirety of every block, takes up about 15 GB of disk space in the Bitcoin network as of April 2014, and is growing by over a gigabyte per month. Currently, this is viable for some desktop computers and not phones, and later on in the future only businesses and hobbyists will be able to participate. A protocol known as \"simplified payment verification\" (SPV) allows for another class of nodes to exist, called \"light nodes\", which download the block headers, verify the proof of work on the block headers, and then download only the \"branches\" associated with transactions that are relevant to them. This allows light nodes to determine with a strong guarantee of security what the status of any Bitcoin transaction, and their current balance, is while downloading only a very small portion of the entire blockchain.\n\n\n\u66ff\u4ee3\u533a\u5757\u94fe\u5e94\u7528\u7a0b\u5e8f\n\n\nThe idea of taking the underlying blockchain idea and applying it to other concepts also has a long history. In 2005, Nick Szabo came out with the concept of \"\nsecure property titles with owner authority\n\", a document describing how \"new advances in replicated database technology\" will allow for a blockchain-based system for storing a registry of who owns what land, creating an elaborate framework including concepts such as homesteading, adverse possession and Georgian land tax. However, there was unfortunately no effective replicated database system available at the time, and so the protocol was never implemented in practice. After 2009, however, once Bitcoin's decentralized consensus was developed a number of alternative applications rapidly began to emerge.\n\n\n\n\nNamecoin\n - created in 2010, \nNamecoin\n is best described as a decentralized name registration database. In decentralized protocols like Tor, Bitcoin and BitMessage, there needs to be some way of identifying accounts so that other people can interact with them, but in all existing solutions the only kind of identifier available is a pseudorandom hash like \n1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy\n. Ideally, one would like to be able to have an account with a name like \"george\". However, the problem is that if one person can create an account named \"george\" then someone else can use the same process to register \"george\" for themselves as well and impersonate them. The only solution is a first-to-file paradigm, where the first registerer succeeds and the second fails - a problem perfectly suited for the Bitcoin consensus protocol. Namecoin is the oldest, and most successful, implementation of a name registration system using such an idea.\n\n\nColored coins\n - the purpose of \ncolored coins\n is to serve as a protocol to allow people to create their own digital currencies - or, in the important trivial case of a currency with one unit, digital tokens, on the Bitcoin blockchain. In the colored coins protocol, one \"issues\" a new currency by publicly assigning a color to a specific Bitcoin UTXO, and the protocol recursively defines the color of other UTXO to be the same as the color of the inputs that the transaction creating them spent (some special rules apply in the case of mixed-color inputs). This allows users to maintain wallets containing only UTXO of a specific color and send them around much like regular bitcoins, backtracking through the blockchain to determine the color of any UTXO that they receive.\n\n\nMetacoins\n - the idea behind a metacoin is to have a protocol that lives on top of Bitcoin, using Bitcoin transactions to store metacoin transactions but having a different state transition function, \nAPPLY'\n. Because the metacoin protocol cannot prevent invalid metacoin transactions from appearing in the Bitcoin blockchain, a rule is added that if \nAPPLY'(S,TX)\n returns an error, the protocol defaults to \nAPPLY'(S,TX) = S\n. This provides an easy mechanism for creating an arbitrary cryptocurrency protocol, potentially with advanced features that cannot be implemented inside of Bitcoin itself, but with a very low development cost since the complexities of mining and networking are already handled by the Bitcoin protocol. Metacoins have been used to implement some classes of financial contracts, name registration and decentralized exchange.\n\n\n\n\nThus, in general, there are two approaches toward building a consensus protocol: building an independent network, and building a protocol on top of Bitcoin. The former approach, while reasonably successful in the case of applications like Namecoin, is difficult to implement; each individual implementation needs to bootstrap an independent blockchain, as well as building and testing all of the necessary state transition and networking code. Additionally, we predict that the set of applications for decentralized consensus technology will follow a power law distribution where the vast majority of applications would be too small to warrant their own blockchain, and we note that there exist large classes of decentralized applications, particularly decentralized autonomous organizations, that need to interact with each other.\n\n\nThe Bitcoin-based approach, on the other hand, has the flaw that it does not inherit the simplified payment verification features of Bitcoin. SPV works for Bitcoin because it can use blockchain depth as a proxy for validity; at some point, once the ancestors of a transaction go far enough back, it is safe to say that they were legitimately part of the state. Blockchain-based meta-protocols, on the other hand, cannot force the blockchain not to include transactions that are not valid within the context of their own protocols. Hence, a fully secure SPV meta-protocol implementation would need to backward scan all the way to the beginning of the Bitcoin blockchain to determine whether or not certain transactions are valid. Currently, all \"light\" implementations of Bitcoin-based meta-protocols rely on a trusted server to provide the data, arguably a highly suboptimal result especially when one of the primary purposes of a cryptocurrency is to eliminate the need for trust.\n\n\n\u811a\u672c\n\n\nEven without any extensions, the Bitcoin protocol actually does facilitate a weak version of a concept of \"smart contracts\". UTXO in Bitcoin can be owned not just by a public key, but also by a more complicated script expressed in a simple stack-based programming language. In this paradigm, a transaction spending that UTXO must provide data that satisfies the script. Indeed, even the basic public key ownership mechanism is implemented via a script: the script takes an elliptic curve signature as input, verifies it against the transaction and the address that owns the UTXO, and returns 1 if the verification is successful and 0 otherwise. Other, more complicated, scripts exist for various additional use cases. For example, one can construct a script that requires signatures from two out of a given three private keys to validate (\"multisig\"), a setup useful for corporate accounts, secure savings accounts and some merchant escrow situations. Scripts can also be used to pay bounties for solutions to computational problems, and one can even construct a script that says something like \"this Bitcoin UTXO is yours if you can provide an SPV proof that you sent a Dogecoin transaction of this denomination to me\", essentially allowing decentralized cross-cryptocurrency exchange.\n\n\nHowever, the scripting language as implemented in Bitcoin has several important limitations:\n\n\n\n\nLack of Turing-completeness\n - that is to say, while there is a large subset of computation that the Bitcoin scripting language supports, it does not nearly support everything. The main category that is missing is loops. This is done to avoid infinite loops during transaction verification; theoretically it is a surmountable obstacle for script programmers, since any loop can be simulated by simply repeating the underlying code many times with an if statement, but it does lead to scripts that are very space-inefficient. For example, implementing an alternative elliptic curve signature algorithm would likely require 256 repeated multiplication rounds all individually included in the code.\n\n\nValue-blindness\n - there is no way for a UTXO script to provide fine-grained control over the amount that can be withdrawn. For example, one powerful use case of an oracle contract would be a hedging contract, where A and B put in $1000 worth of BTC and after 30 days the script sends $1000 worth of BTC to A and the rest to B. This would require an oracle to determine the value of 1 BTC in USD, but even then it is a massive improvement in terms of trust and infrastructure requirement over the fully centralized solutions that are available now. However, because UTXO are all-or-nothing, the only way to achieve this is through the very inefficient hack of having many UTXO of varying denominations (eg. one UTXO of 2\nk\n for every k up to 30) and having O pick which UTXO to send to A and which to B.\n\n\nLack of state\n - UTXO can either be spent or unspent; there is no opportunity for multi-stage contracts or scripts which keep any other internal state beyond that. This makes it hard to make multi-stage options contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary for secure computational bounties). It also means that UTXO can only be used to build simple, one-off contracts and not more complex \"stateful\" contracts such as decentralized organizations, and makes meta-protocols difficult to implement. Binary state combined with value-blindness also mean that another important application, withdrawal limits, is impossible.\n\n\nBlockchain-blindness\n - UTXO are blind to blockchain data such as the nonce, the timestamp and previous block hash. This severely limits applications in gambling, and several other categories, by depriving the scripting language of a potentially valuable source of randomness.\n\n\n\n\nThus, we see three approaches to building advanced applications on top of cryptocurrency: building a new blockchain, using scripting on top of Bitcoin, and building a meta-protocol on top of Bitcoin. Building a new blockchain allows for unlimited freedom in building a feature set, but at the cost of development time, bootstrapping effort and security. Using scripting is easy to implement and standardize, but is very limited in its capabilities, and meta-protocols, while easy, suffer from faults in scalability. With Ethereum, we intend to build an alternative framework that provides even larger gains in ease of development as well as even stronger light client properties, while at the same time allowing applications to share an economic environment and blockchain security.\n\n\n\u4ee5\u592a\u574a\n\n\nThe intent of Ethereum is to create an alternative protocol for building decentralized applications, providing a different set of tradeoffs that we believe will be very useful for a large class of decentralized applications, with particular emphasis on situations where rapid development time, security for small and rarely used applications, and the ability of different applications to very efficiently interact, are important. Ethereum does this by building what is essentially the ultimate abstract foundational layer: a blockchain with a built-in Turing-complete programming language, allowing anyone to write smart contracts and decentralized applications where they can create their own arbitrary rules for ownership, transaction formats and state transition functions. A bare-bones version of Namecoin can be written in two lines of code, and other protocols like currencies and reputation systems can be built in under twenty. Smart contracts, cryptographic \"boxes\" that contain value and only unlock it if certain conditions are met, can also be built on top of the platform, with vastly more power than that offered by Bitcoin scripting because of the added powers of Turing-completeness, value-awareness, blockchain-awareness and state.\n\n\n\u8d26\u53f7\n\n\nIn Ethereum, the state is made up of objects called \"accounts\", with each account having a 20-byte address and state transitions being direct transfers of value and information between accounts. An Ethereum account contains four fields:\n\n\n\n\nThe \nnonce\n, a counter used to make sure each transaction can only be processed once\n\n\nThe account's current \nether balance\n\n\nThe account's \ncontract code\n, if present\n\n\nThe account's \nstorage\n (empty by default)\n\n\n\n\n\"Ether\" is the main internal crypto-fuel of Ethereum, and is used to pay transaction fees. In general, there are two types of accounts: \nexternally owned accounts\n, controlled by private keys, and \ncontract accounts\n, controlled by their contract code. An externally owned account has no code, and one can send messages from an externally owned account by creating and signing a transaction; in a contract account, every time the contract account receives a message its code activates, allowing it to read and write to internal storage and send other messages or create contracts in turn.\n\n\nNote that \"contracts\" in Ethereum should not be seen as something that should be \"fulfilled\" or \"complied with\"; rather, they are more like \"autonomous agents\" that live inside of the Ethereum execution environment, always executing a specific piece of code when \"poked\" by a message or transaction, and having direct control over their own ether balance and their own key/value store to keep track of persistent variables.\n\n\n\u6d88\u606f\u548c\u4ea4\u6613\n\n\nThe term \"transaction\" is used in Ethereum to refer to the signed data package that stores a message to be sent from an externally owned account. Transactions contain:\n\n\n\n\nThe recipient of the message\n\n\nA signature identifying the sender\n\n\nThe amount of ether to transfer from the sender to the recipient\n\n\nAn optional data field\n\n\nA \nSTARTGAS\n value, representing the maximum number of computational steps the transaction execution is allowed to take\n\n\nA \nGASPRICE\n value, representing the fee the sender pays per computational step\n\n\n\n\nThe first three are standard fields expected in any cryptocurrency. The data field has no function by default, but the virtual machine has an opcode using which a contract can access the data; as an example use case, if a contract is functioning as an on-blockchain domain registration service, then it may wish to interpret the data being passed to it as containing two \"fields\", the first field being a domain to register and the second field being the IP address to register it to. The contract would read these values from the message data and appropriately place them in storage.\n\n\nThe \nSTARTGAS\n and \nGASPRICE\n fields are crucial for Ethereum's anti-denial of service model. In order to prevent accidental or hostile infinite loops or other computational wastage in code, each transaction is required to set a limit to how many computational steps of code execution it can use. The fundamental unit of computation is \"gas\"; usually, a computational step costs 1 gas, but some operations cost higher amounts of gas because they are more computationally expensive, or increase the amount of data that must be stored as part of the state. There is also a fee of 5 gas for every byte in the transaction data. The intent of the fee system is to require an attacker to pay proportionately for every resource that they consume, including computation, bandwidth and storage; hence, any transaction that leads to the network consuming a greater amount of any of these resources must have a gas fee roughly proportional to the increment.\n\n\n\u6d88\u606f\n\n\nContracts have the ability to send \"messages\" to other contracts. Messages are virtual objects that are never serialized and exist only in the Ethereum execution environment. A message contains:\n\n\n\n\nThe sender of the message (implicit)\n\n\nThe recipient of the message\n\n\nThe amount of ether to transfer alongside the message\n\n\nAn optional data field\n\n\nA \nSTARTGAS\n value\n\n\n\n\nEssentially, a message is like a transaction, except it is produced by a contract and not an external actor. A message is produced when a contract currently executing code executes the \nCALL\n opcode, which produces and executes a message. Like a transaction, a message leads to the recipient account running its code. Thus, contracts can have relationships with other contracts in exactly the same way that external actors can.\n\n\nNote that the gas allowance assigned by a transaction or contract applies to the total gas consumed by that transaction and all sub-executions. For example, if an external actor A sends a transaction to B with 1000 gas, and B consumes 600 gas before sending a message to C, and the internal execution of C consumes 300 gas before returning, then B can spend another 100 gas before running out of gas.\n\n\n\u72b6\u6001\u8f6c\u79fb\u51fd\u6570\n\n\n\n\nThe Ethereum state transition function, \nAPPLY(S,TX) -\n S'\n can be defined as follows:\n\n\n\n\nCheck if the transaction is well-formed (ie. has the right number of values), the signature is valid, and the nonce matches the nonce in the sender's account. If not, return an error.\n\n\nCalculate the transaction fee as \nSTARTGAS * GASPRICE\n, and determine the sending address from the signature. Subtract the fee from the sender's account balance and increment the sender's nonce. If there is not enough balance to spend, return an error.\n\n\nInitialize \nGAS = STARTGAS\n, and take off a certain quantity of gas per byte to pay for the bytes in the transaction.\n\n\nTransfer the transaction value from the sender's account to the receiving account. If the receiving account does not yet exist, create it. If the receiving account is a contract, run the contract's code either to completion or until the execution runs out of gas.\n\n\nIf the value transfer failed because the sender did not have enough money, or the code execution ran out of gas, revert all state changes except the payment of the fees, and add the fees to the miner's account.\n\n\nOtherwise, refund the fees for all remaining gas to the sender, and send the fees paid for gas consumed to the miner.\n\n\n\n\nFor example, suppose that the contract's code is:\n\n\nif !self.storage[calldataload(0)]:\n    self.storage[calldataload(0)] = calldataload(32)\n\n\n\n\n\nNote that in reality the contract code is written in the low-level EVM code; this example is written in Serpent, one of our high-level languages, for clarity, and can be compiled down to EVM code. Suppose that the contract's storage starts off empty, and a transaction is sent with 10 ether value, 2000 gas, 0.001 ether gasprice, and 64 bytes of data, with bytes 0-31 representing the number \n2\n and bytes 32-63 representing the string \nCHARLIE\n. The process for the state transition function in this case is as follows:\n\n\n\n\nCheck that the transaction is valid and well formed.\n\n\nCheck that the transaction sender has at least 2000 * 0.001 = 2 ether. If it is, then subtract 2 ether from the sender's account.\n\n\nInitialize gas = 2000; assuming the transaction is 170 bytes long and the byte-fee is 5, subtract 850 so that there is 1150 gas left.\n\n\nSubtract 10 more ether from the sender's account, and add it to the contract's account.\n\n\nRun the code. In this case, this is simple: it checks if the contract's storage at index \n2\n is used, notices that it is not, and so it sets the storage at index \n2\n to the value \nCHARLIE\n. Suppose this takes 187 gas, so the remaining amount of gas is 1150 - 187 = 963\n\n\nAdd 963 * 0.001 = 0.963 ether back to the sender's account, and return the resulting state.\n\n\n\n\nIf there was no contract at the receiving end of the transaction, then the total transaction fee would simply be equal to the provided \nGASPRICE\n multiplied by the length of the transaction in bytes, and the data sent alongside the transaction would be irrelevant.\n\n\nNote that messages work equivalently to transactions in terms of reverts: if a message execution runs out of gas, then that message's execution, and all other executions triggered by that execution, revert, but parent executions do not need to revert. This means that it is \"safe\" for a contract to call another contract, as if A calls B with G gas then A's execution is guaranteed to lose at most G gas. Finally, note that there is an opcode, \nCREATE\n, that creates a contract; its execution mechanics are generally similar to \nCALL\n, with the exception that the output of the execution determines the code of a newly created contract.\n\n\n\u4ee3\u7801\u6267\u884c\n\n\nThe code in Ethereum contracts is written in a low-level, stack-based bytecode language, referred to as \"Ethereum virtual machine code\" or \"EVM code\". The code consists of a series of bytes, where each byte represents an operation. In general, code execution is an infinite loop that consists of repeatedly carrying out the operation at the current program counter (which begins at zero) and then incrementing the program counter by one, until the end of the code is reached or an error or \nSTOP\n or \nRETURN\n instruction is detected. The operations have access to three types of space in which to store data:\n\n\n\n\nThe \nstack\n, a last-in-first-out container to which values can be pushed and popped\n\n\nMemory\n, an infinitely expandable byte array\n\n\nThe contract's long-term \nstorage\n, a key/value store. Unlike stack and memory, which reset after computation ends, storage persists for the long term.\n\n\n\n\nThe code can also access the value, sender and data of the incoming message, as well as block header data, and the code can also return a byte array of data as an output.\n\n\nThe formal execution model of EVM code is surprisingly simple. While the Ethereum virtual machine is running, its full computational state can be defined by the tuple \n(block_state, transaction, message, code, memory, stack, pc, gas)\n, where \nblock_state\n is the global state containing all accounts and includes balances and storage. At the start of every round of execution, the current instruction is found by taking the \npc\nth byte of \ncode\n (or 0 if \npc \n= len(code)\n), and each instruction has its own definition in terms of how it affects the tuple. For example, \nADD\n pops two items off the stack and pushes their sum, reduces \ngas\n by 1 and increments \npc\n by 1, and \nSSTORE\n pops the top two items off the stack and inserts the second item into the contract's storage at the index specified by the first item. Although there are many ways to optimize Ethereum virtual machine execution via just-in-time compilation, a basic implementation of Ethereum can be done in a few hundred lines of code.\n\n\n\u533a\u5757\u94fe\u548c\u6316\u77ff\n\n\n\n\nThe Ethereum blockchain is in many ways similar to the Bitcoin blockchain, although it does have some differences. The main difference between Ethereum and Bitcoin with regard to the blockchain architecture is that, unlike Bitcoin, Ethereum blocks contain a copy of both the transaction list and the most recent state. Aside from that, two other values, the block number and the difficulty, are also stored in the block. The basic block validation algorithm in Ethereum is as follows:\n\n\n\n\nCheck if the previous block referenced exists and is valid.\n\n\nCheck that the timestamp of the block is greater than that of the referenced previous block and less than 15 minutes into the future\n\n\nCheck that the block number, difficulty, transaction root, uncle root and gas limit (various low-level Ethereum-specific concepts) are valid.\n\n\nCheck that the proof of work on the block is valid.\n\n\nLet \nS[0]\n be the state at the end of the previous block.\n\n\nLet \nTX\n be the block's transaction list, with \nn\n transactions. For all \ni\n in \n0...n-1\n, set \nS[i+1] = APPLY(S[i],TX[i])\n. If any applications returns an error, or if the total gas consumed in the block up until this point exceeds the \nGASLIMIT\n, return an error.\n\n\nLet \nS_FINAL\n be \nS[n]\n, but adding the block reward paid to the miner.\n\n\nCheck if the Merkle tree root of the state \nS_FINAL\n is equal to the final state root provided in the block header. If it is, the block is valid; otherwise, it is not valid.\n\n\n\n\nThe approach may seem highly inefficient at first glance, because it needs to store the entire state with each block, but in reality efficiency should be comparable to that of Bitcoin. The reason is that the state is stored in the tree structure, and after every block only a small part of the tree needs to be changed. Thus, in general, between two adjacent blocks the vast majority of the tree should be the same, and therefore the data can be stored once and referenced twice using pointers (ie. hashes of subtrees). A special kind of tree known as a \"Patricia tree\" is used to accomplish this, including a modification to the Merkle tree concept that allows for nodes to be inserted and deleted, and not just changed, efficiently.  Additionally, because all of the state information is part of the last block, there is no need to store the entire blockchain history - a strategy which, if it could be applied to Bitcoin, can be calculated to provide 5-20x savings in space.\n\n\nA commonly asked question is \"where\" contract code is executed, in terms of physical hardware. This has a simple answer: the process of executing contract code is part of the definition of the state transition function, which is part of the block validation algorithm, so if a transaction is added into block \nB\n the code execution spawned by that transaction will be executed by all nodes, now and in the future, that download and validate block \nB\n.\n\n\n\u5e94\u7528\n\n\nIn general, there are three types of applications on top of Ethereum. The first category is financial applications, providing users with more powerful ways of managing and entering into contracts using their money. This includes sub-currencies, financial derivatives, hedging contracts, savings wallets, wills, and ultimately even some classes of full-scale employment contracts. The second category is semi-financial applications, where money is involved but there is also a heavy non-monetary side to what is being done; a perfect example is self-enforcing bounties for solutions to computational problems. Finally, there are applications such as online voting and decentralized governance that are not financial at all.\n\n\n\u4ee4\u724c\u7cfb\u7edf\n\n\nOn-blockchain token systems have many applications ranging from sub-currencies representing assets such as USD or gold to company stocks, individual tokens representing smart property, secure unforgeable coupons, and even token systems with no ties to conventional value at all, used as point systems for incentivization. Token systems are surprisingly easy to implement in Ethereum. The key point to understand is that all a currency, or token system, fundamentally is a database with one operation: subtract X units from A and give X units to B, with the proviso that (i) A had at least X units before the transaction and (2) the transaction is approved by A. All that it takes to implement a token system is to implement this logic into a contract.\n\n\nThe basic code for implementing a token system in Serpent looks as follows:\n\n\ndef send(to, value):\n    if self.storage[msg.sender] \n= value:\n        self.storage[msg.sender] = self.storage[msg.sender] - value\n        self.storage[to] = self.storage[to] + value\n\n\n\n\n\nThis is essentially a literal implementation of the \"banking system\" state transition function described further above in this document. A few extra lines of code need to be added to provide for the initial step of distributing the currency units in the first place and a few other edge cases, and ideally a function would be added to let other contracts query for the balance of an address. But that's all there is to it. Theoretically, Ethereum-based token systems acting as sub-currencies can potentially include another important feature that on-chain Bitcoin-based meta-currencies lack: the ability to pay transaction fees directly in that currency. The way this would be implemented is that the contract would maintain an ether balance with which it would refund ether used to pay fees to the sender, and it would refill this balance by collecting the internal currency units that it takes in fees and reselling them in a constant running auction. Users would thus need to \"activate\" their accounts with ether, but once the ether is there it would be reusable because the contract would refund it each time.\n\n\n\u91d1\u878d\u884d\u751f\u54c1\u548c\u7a33\u5b9a\u4ef7\u503c\u8d27\u5e01\n\n\nFinancial derivatives are the most common application of a \"smart contract\", and one of the simplest to implement in code. The main challenge in implementing financial contracts is that the majority of them require reference to an external price ticker; for example, a very desirable application is a smart contract that hedges against the volatility of ether (or another cryptocurrency) with respect to the US dollar, but doing this requires the contract to know what the value of ETH/USD is. The simplest way to do this is through a \"data feed\" contract maintained by a specific party (eg. NASDAQ) designed so that that party has the ability to update the contract as needed, and providing an interface that allows other contracts to send a message to that contract and get back a response that provides the price.\n\n\nGiven that critical ingredient, the hedging contract would look as follows:\n\n\n\n\nWait for party A to input 1000 ether.\n\n\nWait for party B to input 1000 ether.\n\n\nRecord the USD value of 1000 ether, calculated by querying the data feed contract, in storage, say this is $x.\n\n\nAfter 30 days, allow A or B to \"reactivate\" the contract in order to send $x worth of ether (calculated by querying the data feed contract again to get the new price) to A and the rest to B.\n\n\n\n\nSuch a contract would have significant potential in crypto-commerce. One of the main problems cited about cryptocurrency is the fact that it's volatile; although many users and merchants may want the security and convenience of dealing with cryptographic assets, they may not wish to face that prospect of losing 23% of the value of their funds in a single day. Up until now, the most commonly proposed solution has been issuer-backed assets; the idea is that an issuer creates a sub-currency in which they have the right to issue and revoke units, and provide one unit of the currency to anyone who provides them (offline) with one unit of a specified underlying asset (eg. gold, USD). The issuer then promises to provide one unit of the underlying asset to anyone who sends back one unit of the crypto-asset. This mechanism allows any non-cryptographic asset to be \"uplifted\" into a cryptographic asset, provided that the issuer can be trusted.\n\n\nIn practice, however, issuers are not always trustworthy, and in some cases the banking infrastructure is too weak, or too hostile, for such services to exist. Financial derivatives provide an alternative. Here, instead of a single issuer providing the funds to back up an asset, a decentralized market of speculators, betting that the price of a cryptographic reference asset (eg. ETH) will go up, plays that role. Unlike issuers, speculators have no option to default on their side of the bargain because the hedging contract holds their funds in escrow. Note that this approach is not fully decentralized, because a trusted source is still needed to provide the price ticker, although arguably even still this is a massive improvement in terms of reducing infrastructure requirements (unlike being an issuer, issuing a price feed requires no licenses and can likely be categorized as free speech) and reducing the potential for fraud.\n\n\n\u8eab\u4efd\u548c\u58f0\u8a89\u7cfb\u7edf\n\n\nThe earliest alternative cryptocurrency of all, \nNamecoin\n, attempted to use a Bitcoin-like blockchain to provide a name registration system, where users can register their names in a public database alongside other data. The major cited use case is for a \nDNS\n system, mapping domain names like \"bitcoin.org\" (or, in Namecoin's case, \"bitcoin.bit\") to an IP address. Other use cases include email authentication and potentially more advanced reputation systems. Here is the basic contract to provide a Namecoin-like name registration system on Ethereum:\n\n\ndef register(name, value):\n    if !self.storage[name]:\n        self.storage[name] = value\n\n\n\n\n\nThe contract is very simple; all it is is a database inside the Ethereum network that can be added to, but not modified or removed from. Anyone can register a name with some value, and that registration then sticks forever. A more sophisticated name registration contract will also have a \"function clause\" allowing other contracts to query it, as well as a mechanism for the \"owner\" (ie. the first registerer) of a name to change the data or transfer ownership. One can even add reputation and web-of-trust functionality on top.\n\n\n\u65e0\u5fc3\u6587\u4ef6\u5b58\u50a8\n\n\nOver the past few years, there have emerged a number of popular online file storage startups, the most prominent being Dropbox, seeking to allow users to upload a backup of their hard drive and have the service store the backup and allow the user to access it in exchange for a monthly fee. However, at this point the file storage market is at times relatively inefficient; a cursory look at various \nexisting solutions\n shows that, particularly at the \"uncanny valley\" 20-200 GB level at which neither free quotas nor enterprise-level discounts kick in, monthly prices for mainstream file storage costs are such that you are paying for more than the cost of the entire hard drive in a single month. Ethereum contracts can allow for the development of a decentralized file storage ecosystem, where individual users can earn small quantities of money by renting out their own hard drives and unused space can be used to further drive down the costs of file storage.\n\n\nThe key underpinning piece of such a device would be what we have termed the \"decentralized Dropbox contract\". This contract works as follows. First, one splits the desired data up into blocks, encrypting each block for privacy, and builds a Merkle tree out of it. One then makes a contract with the rule that, every N blocks, the contract would pick a random index in the Merkle tree (using the previous block hash, accessible from contract code, as a source of randomness), and give X ether to the first entity to supply a transaction with a simplified payment verification-like proof of ownership of the block at that particular index in the tree. When a user wants to re-download their file, they can use a micropayment channel protocol (eg. pay 1 szabo per 32 kilobytes) to recover the file; the most fee-efficient approach is for the payer not to publish the transaction until the end, instead replacing the transaction with a slightly more lucrative one with the same nonce after every 32 kilobytes.\n\n\nAn important feature of the protocol is that, although it may seem like one is trusting many random nodes not to decide to forget the file, one can reduce that risk down to near-zero by splitting the file into many pieces via secret sharing, and watching the contracts to see each piece is still in some node's possession. If a contract is still paying out money, that provides a cryptographic proof that someone out there is still storing the file.\n\n\n\u65e0\u5fc3\u81ea\u7ec4\u7ec7\n\n\nThe general concept of a \"decentralized autonomous organization\" is that of a virtual entity that has a certain set of members or shareholders which, perhaps with a 67% majority, have the right to spend the entity's funds and modify its code. The members would collectively decide on how the organization should allocate its funds. Methods for allocating a DAO's funds could range from bounties, salaries to even more exotic mechanisms such as an internal currency to reward work. This essentially replicates the legal trappings of a traditional company or nonprofit but using only cryptographic blockchain technology for enforcement. So far much of the talk around DAOs has been around the \"capitalist\" model of a \"decentralized autonomous corporation\" (DAC) with dividend-receiving shareholders and tradable shares; an alternative, perhaps described as a \"decentralized autonomous community\", would have all members have an equal share in the decision making and require 67% of existing members to agree to add or remove a member. The requirement that one person can only have one membership would then need to be enforced collectively by the group.\n\n\nA general outline for how to code a DAO is as follows. The simplest design is simply a piece of self-modifying code that changes if two thirds of members agree on a change. Although code is theoretically immutable, one can easily get around this and have de-facto mutability by having chunks of the code in separate contracts, and having the address of which contracts to call stored in the modifiable storage. In a simple implementation of such a DAO contract, there would be three transaction types, distinquished by the data provided in the transaction:\n\n\n\n\n[0,i,K,V]\n to register a proposal with index \ni\n to change the address at storage index \nK\n to value \nV\n\n\n[0,i]\n to register a vote in favor of proposal \ni\n\n\n[2,i]\n to finalize proposal \ni\n if enough votes have been made\n\n\n\n\nThe contract would then have clauses for each of these. It would maintain a record of all open storage changes, along with a list of who voted for them. It would also have a list of all members. When any storage change gets to two thirds of members voting for it, a finalizing transaction could execute the change. A more sophisticated skeleton would also have built-in voting ability for features like sending a transaction, adding members and removing members, and may even provide for \nLiquid Democracy\n-style vote delegation (ie. anyone can assign someone to vote for them, and assignment is transitive so if A assigns B and B assigns C then C determines A's vote). This design would allow the DAO to grow organically as a decentralized community, allowing people to eventually delegate the task of filtering out who is a member to specialists, although unlike in the \"current system\" specialists can easily pop in and out of existence over time as individual community members change their alignments.\n\n\nAn alternative model is for a decentralized corporation, where any account can have zero or more shares, and two thirds of the shares are required to make a decision. A complete skeleton would involve asset management functionality, the ability to make an offer to buy or sell shares, and the ability to accept offers (preferably with an order-matching mechanism inside the contract). Delegation would also exist Liquid Democracy-style, generalizing the concept of a \"board of directors\".\n\n\n\u5176\u5b83\u5e94\u7528\n\n\n1. Savings wallets\n. Suppose that Alice wants to keep her funds safe, but is worried that she will lose or someone will hack her private key. She puts ether into a contract with Bob, a bank, as follows:\n\n\n\n\nAlice alone can withdraw a maximum of 1% of the funds per day.\n\n\nBob alone can withdraw a maximum of 1% of the funds per day, but Alice has the ability to make a transaction with her key shutting off this ability.\n\n\nAlice and Bob together can withdraw anything.\n\n\n\n\nNormally, 1% per day is enough for Alice, and if Alice wants to withdraw more she can contact Bob for help. If Alice's key gets hacked, she runs to Bob to move the funds to a new contract. If she loses her key, Bob will get the funds out eventually. If Bob turns out to be malicious, then she can turn off his ability to withdraw.\n\n\n2. Crop insurance\n. One can easily make a financial derivatives contract but using a data feed of the weather instead of any price index. If a farmer in Iowa purchases a derivative that pays out inversely based on the precipitation in Iowa, then if there is a drought, the farmer will automatically receive money and if there is enough rain the farmer will be happy because their crops would do well. This can be expanded to natural disaster insurance generally.\n\n\n3. A decentralized data feed\n. For financial contracts for difference, it may actually be possible to decentralize the data feed via a protocol called \"\nSchellingCoin\n\". SchellingCoin basically works as follows: N parties all put into the system the value of a given datum (eg. the ETH/USD price), the values are sorted, and everyone between the 25th and 75th percentile gets one token as a reward. Everyone has the incentive to provide the answer that everyone else will provide, and the only value that a large number of players can realistically agree on is the obvious default: the truth. This creates a decentralized protocol that can theoretically provide any number of values, including the ETH/USD price, the temperature in Berlin or even the result of a particular hard computation.\n\n\n4. Smart multisignature escrow\n. Bitcoin allows multisignature transaction contracts where, for example, three out of a given five keys can spend the funds. Ethereum allows for more granularity; for example, four out of five can spend everything, three out of five can spend up to 10% per day, and two out of five can spend up to 0.5% per day. Additionally, Ethereum multisig is asynchronous - two parties can register their signatures on the blockchain at different times and the last signature will automatically send the transaction.\n\n\n5. Cloud computing\n. The EVM technology can also be used to create a verifiable computing environment, allowing users to ask others to carry out computations and then optionally ask for proofs that computations at certain randomly selected checkpoints were done correctly. This allows for the creation of a cloud computing market where any user can participate with their desktop, laptop or specialized server, and spot-checking together with security deposits can be used to ensure that the system is trustworthy (ie. nodes cannot profitably cheat). Although such a system may not be suitable for all tasks; tasks that require a high level of inter-process communication, for example, cannot easily be done on a large cloud of nodes. Other tasks, however, are much easier to parallelize; projects like SETI@home, folding@home and genetic algorithms can easily be implemented on top of such a platform.\n\n\n6. Peer-to-peer gambling\n. Any number of peer-to-peer gambling protocols, such as Frank Stajano and Richard Clayton's \nCyberdice\n, can be implemented on the Ethereum blockchain. The simplest gambling protocol is actually simply a contract for difference on the next block hash, and more advanced protocols can be built up from there, creating gambling services with near-zero fees that have no ability to cheat.\n\n\n7. Prediction markets\n. Provided an oracle or SchellingCoin, prediction markets are also easy to implement, and prediction markets together with SchellingCoin may prove to be the first mainstream application of \nfutarchy\n as a governance protocol for decentralized organizations.\n\n\n8. On-chain decentralized marketplaces\n, using the identity and reputation system as a base.\n\n\n\u6742\u8bb0\u548c\u5173\u6ce8\n\n\n\u4fee\u6539\u7684GHOST\u5b9e\u73b0\n\n\nThe \"Greedy Heaviest Observed Subtree\" (GHOST) protocol is an innovation first introduced by Yonatan Sompolinsky and Aviv Zohar in \nDecember 2013\n. The motivation behind GHOST is that blockchains with fast confirmation times currently suffer from reduced security due to a high stale rate - because blocks take a certain time to propagate through the network, if miner A mines a block and then miner B happens to mine another block before miner A's block propagates to B, miner B's block will end up wasted and will not contribute to network security. Furthermore, there is a centralization issue: if miner A is a mining pool with 30% hashpower and B has 10% hashpower, A will have a risk of producing a stale block 70% of the time (since the other 30% of the time A produced the last block and so will get mining data immediately) whereas B will have a risk of producing a stale block 90% of the time. Thus, if the block interval is short enough for the stale rate to be high, A will be substantially more efficient simply by virtue of its size. With these two effects combined, blockchains which produce blocks quickly are very likely to lead to one mining pool having a large enough percentage of the network hashpower to have de facto control over the mining process.\n\n\nAs described by Sompolinsky and Zohar, GHOST solves the first issue of network security loss by including stale blocks in the calculation of which chain is the \"longest\"; that is to say, not just the parent and further ancestors of a block, but also the stale descendants of the block's ancestor (in Ethereum jargon, \"uncles\") are added to the calculation of which block has the largest total proof of work backing it. To solve the second issue of centralization bias, we go beyond the protocol described by Sompolinsky and Zohar, and also provide block rewards to stales: a stale block receives 87.5% of its base reward, and the nephew that includes the stale block receives the remaining 12.5%. Transaction fees, however, are not awarded to uncles.\n\n\nEthereum implements a simplified version of GHOST which only goes down seven levels. Specifically, it is defined as follows:\n\n\n\n\nA block must specify a parent, and it must specify 0 or more uncles\n\n\nAn uncle included in block B must have the following properties:\n\n\nIt must be a direct child of the kth generation ancestor of B, where 2 \n= k \n= 7.\n\n\nIt cannot be an ancestor of B\n\n\nAn uncle must be a valid block header, but does not need to be a previously verified or even valid block\n\n\nAn uncle must be different from all uncles included in previous blocks and all other uncles included in the same block (non-double-inclusion)\n\n\nFor every uncle U in block B, the miner of B gets an additional 3.125% added to its coinbase reward and the miner of U gets 93.75% of a standard coinbase reward.\n\n\n\n\nThis limited version of GHOST, with uncles includable only up to 7 generations, was used for two reasons. First, unlimited GHOST would include too many complications into the calculation of which uncles for a given block are valid. Second, unlimited GHOST with compensation as used in Ethereum removes the incentive for a miner to mine on the main chain and not the chain of a public attacker.\n\n\n\u8d39\u7528\n\n\nBecause every transaction published into the blockchain imposes on the network the cost of needing to download and verify it, there is a need for some regulatory mechanism, typically involving transaction fees, to prevent abuse. The default approach, used in Bitcoin, is to have purely voluntary fees, relying on miners to act as the gatekeepers and set dynamic minimums. This approach has been received very favorably in the Bitcoin community particularly because it is \"market-based\", allowing supply and demand between miners and transaction senders determine the price. The problem with this line of reasoning is, however, that transaction processing is not a market; although it is intuitively attractive to construe transaction processing as a service that the miner is offering to the sender, in reality every transaction that a miner includes will need to be processed by every node in the network, so the vast majority of the cost of transaction processing is borne by third parties and not the miner that is making the decision of whether or not to include it. Hence, tragedy-of-the-commons problems are very likely to occur.\n\n\nHowever, as it turns out this flaw in the market-based mechanism, when given a particular inaccurate simplifying assumption, magically cancels itself out. The argument is as follows. Suppose that:\n\n\n\n\nA transaction leads to \nk\n operations, offering the reward \nkR\n to any miner that includes it where \nR\n is set by the sender and \nk\n and \nR\n are (roughly) visible to the miner beforehand.\n\n\nAn operation has a processing cost of \nC\n to any node (ie. all nodes have equal efficiency)\n\n\nThere are \nN\n mining nodes, each with exactly equal processing power (ie. \n1/N\n of total)\n\n\nNo non-mining full nodes exist.\n\n\n\n\nA miner would be willing to process a transaction if the expected reward is greater than the cost. Thus, the expected reward is \nkR/N\n since the miner has a \n1/N\n chance of processing the next block, and the processing cost for the miner is simply \nkC\n. Hence, miners will include transactions where \nkR/N \n kC\n, or \nR \n NC\n. Note that \nR\n is the per-operation fee provided by the sender, and is thus a lower bound on the benefit that the sender derives from the transaction, and \nNC\n is the cost to the entire network together of processing an operation. Hence, miners have the incentive to include only those transactions for which the total utilitarian benefit exceeds the cost.\n\n\nHowever, there are several important deviations from those assumptions in reality:\n\n\n\n\nThe miner does pay a higher cost to process the transaction than the other verifying nodes, since the extra verification time delays block propagation and thus increases the chance the block will become a stale.\n\n\nThere do exist nonmining full nodes.\n\n\nThe mining power distribution may end up radically inegalitarian in practice.\n\n\nSpeculators, political enemies and crazies whose utility function includes causing harm to the network do exist, and they can cleverly set up contracts where their cost is much lower than the cost paid by other verifying nodes.\n\n\n\n\n(1) provides a tendency for the miner to include fewer transactions, and (2) increases \nNC\n; hence, these two effects at least partially cancel each other out. (3) and (4) are the major issue; to solve them we simply institute a floating cap: no block can have more operations than \nBLK_LIMIT_FACTOR\n times the long-term exponential moving average. Specifically:\n\n\nblk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) / EMA_FACTOR)\n\n\n\n\n\nBLK_LIMIT_FACTOR\n and \nEMA_FACTOR\n are constants that will be set to 65536 and 1.5 for the time being, but will likely be changed after further analysis.\n\n\nThere is another factor disincentivizing large block sizes in Bitcoin: blocks that are large will take longer to propagate, and thus have a higher probability of becoming stales. In Ethereum, highly gas-consuming blocks can also take longer to propagate both because they are physically larger and because they take longer to process the transaction state transitions to validate. This delay disincentive is a significant consideration in Bitcoin, but less so in Ethereum because of the GHOST protocol; hence, relying on regulated block limits provides a more stable baseline.\n\n\n\u8ba1\u7b97\u548c\u56fe\u7075\u5b8c\u6574\u6027\n\n\nAn important note is that the Ethereum virtual machine is Turing-complete; this means that EVM code can encode any computation that can be conceivably carried out, including infinite loops. EVM code allows looping in two ways. First, there is a \nJUMP\n instruction that allows the program to jump back to a previous spot in the code, and a \nJUMPI\n instruction to do conditional jumping, allowing for statements like \nwhile x \n 27: x = x * 2\n. Second, contracts can call other contracts, potentially allowing for looping through recursion. This naturally leads to a problem: can malicious users essentially shut miners and full nodes down by forcing them to enter into an infinite loop? The issue arises because of a problem in computer science known as the halting problem: there is no way to tell, in the general case, whether or not a given program will ever halt.\n\n\nAs described in the state transition section, our solution works by requiring a transaction to set a maximum number of computational steps that it is allowed to take, and if execution takes longer computation is reverted but fees are still paid. Messages work in the same way. To show the motivation behind our solution, consider the following examples:\n\n\n\n\nAn attacker creates a contract which runs an infinite loop, and then sends a transaction activating that loop to the miner. The miner will process the transaction, running the infinite loop, and wait for it to run out of gas. Even though the execution runs out of gas and stops halfway through, the transaction is still valid and the miner still claims the fee from the attacker for each computational step.\n\n\nAn attacker creates a very long infinite loop with the intent of forcing the miner to keep computing for such a long time that by the time computation finishes a few more blocks will have come out and it will not be possible for the miner to include the transaction to claim the fee. However, the attacker will be required to submit a value for \nSTARTGAS\n limiting the number of computational steps that execution can take, so the miner will know ahead of time that the computation will take an excessively large number of steps.\n\n\nAn attacker sees a contract with code of some form like \nsend(A,contract.storage[A]); contract.storage[A] = 0\n, and sends a transaction with just enough gas to run the first step but not the second (ie. making a withdrawal but not letting the balance go down). The contract author does not need to worry about protecting against such attacks, because if execution stops halfway through the changes get reverted.\n\n\nA financial contract works by taking the median of nine proprietary data feeds in order to minimize risk. An attacker takes over one of the data feeds, which is designed to be modifiable via the variable-address-call mechanism described in the section on DAOs, and converts it to run an infinite loop, thereby attempting to force any attempts to claim funds from the financial contract to run out of gas. However, the financial contract can set a gas limit on the message to prevent this problem.\n\n\n\n\nThe alternative to Turing-completeness is Turing-incompleteness, where \nJUMP\n and \nJUMPI\n do not exist and only one copy of each contract is allowed to exist in the call stack at any given time. With this system, the fee system described and the uncertainties around the effectiveness of our solution might not be necessary, as the cost of executing a contract would be bounded above by its size. Additionally, Turing-incompleteness is not even that big a limitation; out of all the contract examples we have conceived internally, so far only one required a loop, and even that loop could be removed by making 26 repetitions of a one-line piece of code. Given the serious implications of Turing-completeness, and the limited benefit, why not simply have a Turing-incomplete language? In reality, however, Turing-incompleteness is far from a neat solution to the problem. To see why, consider the following contracts:\n\n\nC0\n:\n \ncall\n(\nC1\n);\n \ncall\n(\nC1\n);\n\n\nC1\n:\n \ncall\n(\nC2\n);\n \ncall\n(\nC2\n);\n\n\nC2\n:\n \ncall\n(\nC3\n);\n \ncall\n(\nC3\n);\n\n\n...\n\n\nC49\n:\n \ncall\n(\nC50\n);\n \ncall\n(\nC50\n);\n\n\nC50\n:\n \n(\nrun\n \none\n \nstep\n \nof\n \na\n \nprogram\n \nand\n \nrecord\n \nthe\n \nchange\n \nin\n \nstorage\n)\n\n\n\n\n\n\nNow, send a transaction to A. Thus, in 51 transactions, we have a contract that takes up 2\n50\n computational steps. Miners could try to detect such logic bombs ahead of time by maintaining a value alongside each contract specifying the maximum number of computational steps that it can take, and calculating this for contracts calling other contracts recursively, but that would require miners to forbid contracts that create other contracts (since the creation and execution of all 26 contracts above could easily be rolled into a single contract). Another problematic point is that the address field of a message is a variable, so in general it may not even be possible to tell which other contracts a given contract will call ahead of time. Hence, all in all, we have a surprising conclusion: Turing-completeness is surprisingly easy to manage, and the lack of Turing-completeness is equally surprisingly difficult to manage unless the exact same controls are in place - but in that case why not just let the protocol be Turing-complete?\n\n\n\u8d27\u5e01\u548c\u53d1\u884c\n\n\nThe Ethereum network includes its own built-in currency, ether, which serves the dual purpose of providing a primary liquidity layer to allow for efficient exchange between various types of digital assets and, more importantly, of providing a mechanism for paying transaction fees. For convenience and to avoid future argument (see the current mBTC/uBTC/satoshi debate in Bitcoin), the denominations will be pre-labelled:\n\n\n\n\n1: wei\n\n\n10\n12\n: szabo\n\n\n10\n15\n: finney\n\n\n10\n18\n: ether\n\n\n\n\nThis should be taken as an expanded version of the concept of \"dollars\" and \"cents\" or \"BTC\" and \"satoshi\". In the near future, we expect \"ether\" to be used for ordinary transactions, \"finney\" for microtransactions and \"szabo\" and \"wei\" for technical discussions around fees and protocol implementation; the remaining denominations may become useful later and should not be included in clients at this point.\n\n\nThe issuance model will be as follows:\n\n\n\n\nEther will be released in a currency sale at the price of 1000-2000 ether per BTC, a mechanism intended to fund the Ethereum organization and pay for development that has been used with success by other platforms such as Mastercoin and NXT. Earlier buyers will benefit from larger discounts. The BTC received from the sale will be used entirely to pay salaries and bounties to developers and invested into various for-profit and non-profit projects in the Ethereum and cryptocurrency ecosystem.\n\n\n0.099x the total amount sold (60102216 ETH) will be allocated to the organization to compensate early contributors and pay ETH-denominated expenses before the genesis block.\n\n\n0.099x the total amount sold will be maintained as a long-term reserve.\n\n\n0.26x the total amount sold will be allocated to miners per year forever after that point.\n\n\n\n\n\n\n\n\n\n\nGroup\n\n\nAt launch\n\n\nAfter 1 year\n\n\nAfter 5 years\n\n\n\n\n\n\n\n\n\n\nCurrency units\n\n\n1.198X\n\n\n1.458X\n\n\n2.498X\n\n\n\n\n\n\nPurchasers\n\n\n83.5%\n\n\n68.6%\n\n\n40.0%\n\n\n\n\n\n\nReserve spent pre-sale\n\n\n8.26%\n\n\n6.79%\n\n\n3.96%\n\n\n\n\n\n\nReserve used post-sale\n\n\n8.26%\n\n\n6.79%\n\n\n3.96%\n\n\n\n\n\n\nMiners\n\n\n0%\n\n\n17.8%\n\n\n52.0%\n\n\n\n\n\n\n\n\nLong-Term Supply Growth Rate (percent)\n\n\n\n\nDespite the linear currency issuance, just like with Bitcoin over time the supply growth rate nevertheless tends to zero\n\n\nThe two main choices in the above model are (1) the existence and size of an endowment pool, and (2) the existence of a permanently growing linear supply, as opposed to a capped supply as in Bitcoin. The justification of the endowment pool is as follows. If the endowment pool did not exist, and the linear issuance reduced to 0.217x to provide the same inflation rate, then the total quantity of ether would be 16.5% less and so each unit would be 19.8% more valuable. Hence, in the equilibrium 19.8% more ether would be purchased in the sale, so each unit would once again be exactly as valuable as before. The organization would also then have 1.198x as much BTC, which can be considered to be split into two slices: the original BTC, and the additional 0.198x. Hence, this situation is \nexactly equivalent\n to the endowment, but with one important difference: the organization holds purely BTC, and so is not incentivized to support the value of the ether unit.\n\n\nThe permanent linear supply growth model reduces the risk of what some see as excessive wealth concentration in Bitcoin, and gives individuals living in present and future eras a fair chance to acquire currency units, while at the same time retaining a strong incentive to obtain and hold ether because the \"supply growth rate\" as a percentage still tends to zero over time. We also theorize that because coins are always lost over time due to carelessness, death, etc, and coin loss can be modeled as a percentage of the total supply per year, that the total currency supply in circulation will in fact eventually stabilize at a value equal to the annual issuance divided by the loss rate (eg. at a loss rate of 1%, once the supply reaches 26X then 0.26X will be mined and 0.26X lost every year, creating an equilibrium).\n\n\nNote that in the future, it is likely that Ethereum will switch to a proof-of-stake model for security, reducing the issuance requirement to somewhere between zero and 0.05X per year. In the event that the Ethereum organization loses funding or for any other reason disappears, we leave open a \"social contract\": anyone has the right to create a future candidate version of Ethereum, with the only condition being that the quantity of ether must be at most equal to \n60102216 * (1.198 + 0.26 * n)\n where \nn\n is the number of years after the genesis block. Creators are free to crowd-sell or otherwise assign some or all of the difference between the PoS-driven supply expansion and the maximum allowable supply expansion to pay for development. Candidate upgrades that do not comply with the social contract may justifiably be forked into compliant versions.\n\n\n\u91c7\u77ff\u4e2d\u5fc3\n\n\nThe Bitcoin mining algorithm works by having miners compute SHA256 on slightly modified versions of the block header millions of times over and over again, until eventually one node comes up with a version whose hash is less than the target (currently around 2\n192\n). However, this mining algorithm is vulnerable to two forms of centralization. First, the mining ecosystem has come to be dominated by ASICs (application-specific integrated circuits), computer chips designed for, and therefore thousands of times more efficient at, the specific task of Bitcoin mining. This means that Bitcoin mining is no longer a highly decentralized and egalitarian pursuit, requiring millions of dollars of capital to effectively participate in. Second, most Bitcoin miners do not actually perform block validation locally; instead, they rely on a centralized mining pool to provide the block headers. This problem is arguably worse: as of the time of this writing, the top three mining pools indirectly control roughly 50% of processing power in the Bitcoin network, although this is mitigated by the fact that miners can switch to other mining pools if a pool or coalition attempts a 51% attack.\n\n\nThe current intent at Ethereum is to use a mining algorithm where miners are required to fetch random data from the state, compute some randomly selected transactions from the last N blocks in the blockchain, and return the hash of the result. This has two important benefits. First, Ethereum contracts can include any kind of computation, so an Ethereum ASIC would essentially be an ASIC for general computation - ie. a better CPU. Second, mining requires access to the entire blockchain, forcing miners to store the entire blockchain and at least be capable of verifying every transaction. This removes the need for centralized mining pools; although mining pools can still serve the legitimate role of evening out the randomness of reward distribution, this function can be served equally well by peer-to-peer pools with no central control.\n\n\nThis model is untested, and there may be difficulties along the way in avoiding certain clever optimizations when using contract execution as a mining algorithm. However, one notably interesting feature of this algorithm is that it allows anyone to \"poison the well\", by introducing a large number of contracts into the blockchain specifically designed to stymie certain ASICs. The economic incentives exist for ASIC manufacturers to use such a trick to attack each other. Thus, the solution that we are developing is ultimately an adaptive economic human solution rather than purely a technical one.\n\n\n\u53ef\u6269\u5c55\u6027\n\n\nOne common concern about Ethereum is the issue of scalability. Like Bitcoin, Ethereum suffers from the flaw that every transaction needs to be processed by every node in the network. With Bitcoin, the size of the current blockchain rests at about 15 GB, growing by about 1 MB per hour. If the Bitcoin network were to process Visa's 2000 transactions per second, it would grow by 1 MB per three seconds (1 GB per hour, 8 TB per year). Ethereum is likely to suffer a similar growth pattern, worsened by the fact that there will be many applications on top of the Ethereum blockchain instead of just a currency as is the case with Bitcoin, but ameliorated by the fact that Ethereum full nodes need to store just the state instead of the entire blockchain history.\n\n\nThe problem with such a large blockchain size is centralization risk. If the blockchain size increases to, say, 100 TB, then the likely scenario would be that only a very small number of large businesses would run full nodes, with all regular users using light SPV nodes. In such a situation, there arises the potential concern that the full nodes could band together and all agree to cheat in some profitable fashion (eg. change the block reward, give themselves BTC). Light nodes would have no way of detecting this immediately. Of course, at least one honest full node would likely exist, and after a few hours information about the fraud would trickle out through channels like Reddit, but at that point it would be too late: it would be up to the ordinary users to organize an effort to blacklist the given blocks, a massive and likely infeasible coordination problem on a similar scale as that of pulling off a successful 51% attack. In the case of Bitcoin, this is currently a problem, but there exists a blockchain modification \nsuggested by Peter Todd\n which will alleviate this issue.\n\n\nIn the near term, Ethereum will use two additional strategies to cope with this problem. First, because of the blockchain-based mining algorithms, at least every miner will be forced to be a full node, creating a lower bound on the number of full nodes. Second and more importantly, however, we will include an intermediate state tree root in the blockchain after processing each transaction. Even if block validation is centralized, as long as one honest verifying node exists, the centralization problem can be circumvented via a verification protocol. If a miner publishes an invalid block, that block must either be badly formatted, or the state \nS[n]\n is incorrect. Since \nS[0]\n is known to be correct, there must be some first state \nS[i]\n that is incorrect where \nS[i-1]\n is correct. The verifying node would provide the index \ni\n, along with a \"proof of invalidity\" consisting of the subset of Patricia tree nodes needing to process \nAPPLY(S[i-1],TX[i]) -\n S[i]\n. Nodes would be able to use those nodes to run that part of the computation, and see that the \nS[i]\n generated does not match the \nS[i]\n provided.\n\n\nAnother, more sophisticated, attack would involve the malicious miners publishing incomplete blocks, so the full information does not even exist to determine whether or not blocks are valid. The solution to this is a challenge-response protocol: verification nodes issue \"challenges\" in the form of target transaction indices, and upon receiving a node a light node treats the block as untrusted until another node, whether the miner or another verifier, provides a subset of Patricia nodes as a proof of validity.\n\n\n\u7ed3\u8bba\n\n\nThe Ethereum protocol was originally conceived as an upgraded version of a cryptocurrency, providing advanced features such as on-blockchain escrow, withdrawal limits, financial contracts, gambling markets and the like via a highly generalized programming language. The Ethereum protocol would not \"support\" any of the applications directly, but the existence of a Turing-complete programming language means that arbitrary contracts can theoretically be created for any transaction type or application. What is more interesting about Ethereum, however, is that the Ethereum protocol moves far beyond just currency. Protocols around decentralized file storage, decentralized computation and decentralized prediction markets, among dozens of other such concepts, have the potential to substantially increase the efficiency of the computational industry, and provide a massive boost to other peer-to-peer protocols by adding for the first time an economic layer. Finally, there is also a substantial array of applications that have nothing to do with money at all.\n\n\nThe concept of an arbitrary state transition function as implemented by the Ethereum protocol provides for a platform with unique potential; rather than being a closed-ended, single-purpose protocol intended for a specific array of applications in data storage, gambling or finance, Ethereum is open-ended by design, and we believe that it is extremely well-suited to serving as a foundational layer for a very large number of both financial and non-financial protocols in the years to come.\n\n\n\u7b14\u8bb0\u548c\u8fdb\u4e00\u6b65\u9605\u8bfb\n\n\n\u7b14\u8bb0\n\n\n\n\nA sophisticated reader may notice that in fact a Bitcoin address is the hash of the elliptic curve public key, and not the public key itself. However, it is in fact perfectly legitimate cryptographic terminology to refer to the pubkey hash as a public key itself. This is because Bitcoin's cryptography can be considered to be a custom digital signature algorithm, where the public key consists of the hash of the ECC pubkey, the signature consists of the ECC pubkey concatenated with the ECC signature, and the verification algorithm involves checking the ECC pubkey in the signature against the ECC pubkey hash provided as a public key and then verifying the ECC signature against the ECC pubkey.\n\n\nTechnically, the median of the 11 previous blocks.\n\n\nInternally, 2 and \"CHARLIE\" are both numbers, with the latter being in big-endian base 256 representation. Numbers can be at least 0 and at most 2\n256\n-1.\n\n\n\n\n\u8fdb\u4e00\u6b65\u9605\u8bfb\n\n\n\n\n\u5185\u5728\u89c4\u5b9a\n\n\n\u667a\u80fd\u8d22\u4ea7\n\n\n\u667a\u80fd\u5408\u7ea6\n\n\nB-money\n\n\n\u53ef\u91cd\u7528\u7684\u5de5\u4f5c\u8bc1\u660e\n\n\n\u62e5\u6709\u8457\u4f5c\u6743\u5b89\u5168\u5c5e\u6027\u6807\u9898\n\n\n\u6bd4\u7279\u5e01\u767d\u76ae\u4e66\n\n\n\u540d\u5e01\n\n\nZooko's triangle\n\n\n\u5f69\u5e01\u767d\u76ae\u4e66\n\n\n\u4e3b\u5e01\u767d\u76ae\u4e66\n\n\n\u65e0\u5fc3\u81ea\u6cbb\u516c\u53f8\uff0c\u6bd4\u7279\u5e01\u6742\u5fd7\n\n\n\u7b80\u5316\u4ed8\u6b3e\u786e\u8ba4\n\n\n\u6885\u514b\u5c14\u6811\n\n\n\u5e15\u7279\u4e3d\u590f\u6811\n\n\n\u9b3c\n\n\nStorJ\u548c\u81ea\u6cbb\u4ee3\u7406, Jeff Garzik\n\n\nMike Hearn\u5728\u56fe\u7075\u8282\u4e0a\u7684\u667a\u80fd\u8d22\u4ea7\n\n\n\u4ee5\u592a\u574a RLP\n\n\n\u4ee5\u592a\u574a\u6885\u514b\u52d2\u5e15\u7279\u91cc\u590f\u6811\n\n\n\u9ed8\u514b\u5c14\u5408\u96c6\u6811\u4e0a\u7684\u5f7c\u5f97\u00b7\u6258\u5fb7", 
            "title": "\u767d\u76ae\u4e66"
        }, 
        {
            "location": "/Basics/White-Paper/#_1", 
            "text": "\u4e0b\u4e00\u4ee3\u667a\u80fd\u5408\u7ea6\u4e0e\u5206\u6563\u5f0f\u5e94\u7528\u5e73\u53f0  Satoshi Nakamoto's development of Bitcoin in 2009 has often been hailed as a radical development in money and currency, being the first example of a digital asset which simultaneously has no backing or \" intrinsic value \" and no centralized issuer or controller.  However, another - arguably more important - part of the Bitcoin experiment is the underlying blockchain technology as a tool of distributed consensus, and attention is rapidly starting to shift to this other aspect of Bitcoin.  Commonly cited alternative applications of blockchain technology include using on-blockchain digital assets to represent custom currencies and financial instruments ( \"colored coins\" ), the ownership of an underlying physical device ( \"smart property\" ), non-fungible assets such as domain names ( \"Namecoin\" ), as well as more complex applications involving having digital assets being directly controlled by a piece of code implementing arbitrary rules ( \"smart contracts\" ) or even blockchain-based \" decentralized autonomous organizations \" (DAOs).  What Ethereum intends to provide is a blockchain with a built-in fully fledged Turing-complete programming language that can be used to create \"contracts\" that can be used to encode arbitrary state transition functions, allowing users to create any of the systems described above, as well as many others that we have not yet imagined, simply by writing up the logic in a few lines of code.  \u6bd4\u7279\u5e01\u4ecb\u7ecd\u548c\u73b0\u6709\u7684\u6982\u5ff5", 
            "title": "\u767d\u76ae\u4e66"
        }, 
        {
            "location": "/Basics/White-Paper/#_2", 
            "text": "The concept of decentralized digital currency, as well as alternative applications like property registries, has been around for decades.  80\u5e74\u4ee3-90\u5e74\u4ee3,\u533f\u540d\u7535\u5b50\u73b0\u91d1\u534f\u8bae, mostly reliant on a cryptographic primitive known as Chaumian blinding, provided a currency with a high degree of privacy, but the protocols largely failed to gain traction because of their reliance on a centralized intermediary.  1998\u5e74, Wei Dai's  b-money  became the first proposal to introduce the idea of creating money through solving computational puzzles as well as decentralized consensus, but the proposal was scant on details as to how decentralized consensus could actually be implemented.  2005\u5e74, Hal Finney introduced a concept of \" reusable proofs of work \", a system which uses ideas from b-money together with Adam Back's computationally difficult Hashcash puzzles to create a concept for a cryptocurrency, but once again fell short of the ideal by relying on trusted computing as a backend.  2009\u5e74, a decentralized currency was for the first time implemented in practice by Satoshi Nakamoto, combining established primitives for managing ownership through public key cryptography with a consensus algorithm for keeping track of who owns coins, known as \"proof of work\".  The mechanism behind proof of work was a breakthrough in the space because it simultaneously solved two problems.  \u9996\u5148, it provided a simple and moderately effective consensus algorithm, allowing nodes in the network to collectively agree on a set of canonical updates to the state of the Bitcoin ledger.  \u5176\u6b21, it provided a mechanism for allowing free entry into the consensus process, solving the political problem of deciding who gets to influence the consensus, while simultaneously preventing sybil attacks.  It does this by substituting a formal barrier to participation, such as the requirement to be registered as a unique entity on a particular list, with an economic barrier - the weight of a single node in the consensus voting process is directly proportional to the computing power that the node brings.  Since then, an alternative approach has been proposed called  proof of stake , calculating the weight of a node as being proportional to its currency holdings and not computational resources; the discussion of the relative merits of the two approaches is beyond the scope of this paper but it should be noted that both approaches can be used to serve as the backbone of a cryptocurrency.", 
            "title": "\u5386\u53f2"
        }, 
        {
            "location": "/Basics/White-Paper/#_3", 
            "text": "From a technical standpoint, the ledger of a cryptocurrency such as Bitcoin can be thought of as a state transition system, where there is a \"state\" consisting of the ownership status of all existing bitcoins and a \"state transition function\" that takes a state and a transaction and outputs a new state which is the result. In a standard banking system, for example, the state is a balance sheet, a transaction is a request to move $X from A to B, and the state transition function reduces the value in A's account by $X and increases the value in B's account by $X. If A's account has less than $X in the first place, the state transition function returns an error. Hence, one can formally define:  APPLY(S,TX) -  S  or ERROR  In the banking system defined above:  APPLY({ Alice: $50, Bob: $50 }, send $20 from Alice to Bob ) = { Alice: $30, Bob: $70 }  But:  APPLY({ Alice: $50, Bob: $50 }, send $70 from Alice to Bob ) = ERROR  The \"state\" in Bitcoin is the collection of all coins (technically, \"unspent transaction outputs\" or UTXO) that have been minted and not yet spent, with each UTXO having a denomination and an owner (defined by a 20-byte address which is essentially a cryptographic public key [1] ). A transaction contains one or more inputs, with each input containing a reference to an existing UTXO and a cryptographic signature produced by the private key associated with the owner's address, and one or more outputs, with each output containing a new UTXO to be added to the state.  The state transition function  APPLY(S,TX) -  S'  can be defined roughly as follows:   For each input in  TX :  If the referenced UTXO is not in  S , return an error.  If the provided signature does not match the owner of the UTXO, return an error.    If the sum of the denominations of all input UTXO is less than the sum of the denominations of all output UTXO, return an error.  Return  S  with all input UTXO removed and all output UTXO added.   The first half of the first step prevents transaction senders from spending coins that do not exist, the second half of the first step prevents transaction senders from spending other people's coins, and the second step enforces conservation of value. In order to use this for payment, the protocol is as follows. Suppose Alice wants to send 11.7 BTC to Bob. First, Alice will look for a set of available UTXO that she owns that totals up to at least 11.7 BTC. Realistically, Alice will not be able to get exactly 11.7 BTC; say that the smallest she can get is 6+4+2=12. She then creates a transaction with those three inputs and two outputs. The first output will be 11.7 BTC with Bob's address as its owner, and the second output will be the remaining 0.3 BTC \"change\", with the owner being Alice herself.", 
            "title": "\u72b6\u6001\u4f20\u9012\u7cfb\u7edf\u7684\u6bd4\u7279\u5e01"
        }, 
        {
            "location": "/Basics/White-Paper/#_4", 
            "text": "If we had access to a trustworthy centralized service, this system would be trivial to implement; it could simply be coded exactly as described, using a centralized server's hard drive to keep track of the state. However, with Bitcoin we are trying to build a decentralized currency system, so we will need to combine the state transaction system with a consensus system in order to ensure that everyone agrees on the order of transactions. Bitcoin's decentralized consensus process requires nodes in the network to continuously attempt to produce packages of transactions called \"blocks\". The network is intended to produce roughly one block every ten minutes, with each block containing a timestamp, a nonce, a reference to (ie. hash of) the previous block and a list of all of the transactions that have taken place since the previous block. Over time, this creates a persistent, ever-growing, \"blockchain\" that constantly updates to represent the latest state of the Bitcoin ledger.  The algorithm for checking if a block is valid, expressed in this paradigm, is as follows:   Check if the previous block referenced by the block exists and is valid.  Check that the timestamp of the block is greater than that of the previous block [2]  and less than 2 hours into the future  Check that the proof of work on the block is valid.  Let  S[0]  be the state at the end of the previous block.  Suppose  TX  is the block's transaction list with  n  transactions. For all  i  in  0...n-1 , set  S[i+1] = APPLY(S[i],TX[i])  If any application returns an error, exit and return false.  Return true, and register  S[n]  as the state at the end of this block.   Essentially, each transaction in the block must provide a valid state transition from what was the canonical state before the transaction was executed to some new state. Note that the state is not encoded in the block in any way; it is purely an abstraction to be remembered by the validating node and can only be (securely) computed for any block by starting from the genesis state and sequentially applying every transaction in every block. Additionally, note that the order in which the miner includes transactions into the block matters; if there are two transactions A and B in a block such that B spends a UTXO created by A, then the block will be valid if A comes before B but not otherwise.  The one validity condition present in the above list that is not found in other systems is the requirement for \"proof of work\". The precise condition is that the double-SHA256 hash of every block, treated as a 256-bit number, must be less than a dynamically adjusted target, which as of the time of this writing is approximately 2 187 . The purpose of this is to make block creation computationally \"hard\", thereby preventing sybil attackers from remaking the entire blockchain in their favor. Because SHA256 is designed to be a completely unpredictable pseudorandom function, the only way to create a valid block is simply trial and error, repeatedly incrementing the nonce and seeing if the new hash matches.  At the current target of ~2 187 , the network must make an average of ~2 69  tries before a valid block is found; in general, the target is recalibrated by the network every 2016 blocks so that on average a new block is produced by some node in the network every ten minutes. In order to compensate miners for this computational work, the miner of every block is entitled to include a transaction giving themselves 25 BTC out of nowhere. Additionally, if any transaction has a higher total denomination in its inputs than in its outputs, the difference also goes to the miner as a \"transaction fee\". Incidentally, this is also the only mechanism by which BTC are issued; the genesis state contained no coins at all.  In order to better understand the purpose of mining, let us examine what happens in the event of a malicious attacker. Since Bitcoin's underlying cryptography is known to be secure, the attacker will target the one part of the Bitcoin system that is not protected by cryptography directly: the order of transactions. The attacker's strategy is simple:   Send 100 BTC to a merchant in exchange for some product (preferably a rapid-delivery digital good)  Wait for the delivery of the product  Produce another transaction sending the same 100 BTC to himself  Try to convince the network that his transaction to himself was the one that came first.   Once step (1) has taken place, after a few minutes some miner will include the transaction in a block, say block number 270000. After about one hour, five more blocks will have been added to the chain after that block, with each of those blocks indirectly pointing to the transaction and thus \"confirming\" it. At this point, the merchant will accept the payment as finalized and deliver the product; since we are assuming this is a digital good, delivery is instant. Now, the attacker creates another transaction sending the 100 BTC to himself. If the attacker simply releases it into the wild, the transaction will not be processed; miners will attempt to run  APPLY(S,TX)  and notice that  TX  consumes a UTXO which is no longer in the state. So instead, the attacker creates a \"fork\" of the blockchain, starting by mining another version of block 270000 pointing to the same block 269999 as a parent but with the new transaction in place of the old one. Because the block data is different, this requires redoing the proof of work. Furthermore, the attacker's new version of block 270000 has a different hash, so the original blocks 270001 to 270005 do not \"point\" to it; thus, the original chain and the attacker's new chain are completely separate. The rule is that in a fork the longest blockchain is taken to be the truth, and so legitimate miners will work on the 270005 chain while the attacker alone is working on the 270000 chain. In order for the attacker to make his blockchain the longest, he would need to have more computational power than the rest of the network combined in order to catch up (hence, \"51% attack\").", 
            "title": "\u6316\u77ff"
        }, 
        {
            "location": "/Basics/White-Paper/#_5", 
            "text": "Left: it suffices to present only a small number of nodes in a Merkle tree to give a proof of the validity of a branch.  Right: any attempt to change any part of the Merkle tree will eventually lead to an inconsistency somewhere up the chain.  An important scalability feature of Bitcoin is that the block is stored in a multi-level data structure. The \"hash\" of a block is actually only the hash of the block header, a roughly 200-byte piece of data that contains the timestamp, nonce, previous block hash and the root hash of a data structure called the Merkle tree storing all transactions in the block. A Merkle tree is a type of binary tree, composed of a set of nodes with a large number of leaf nodes at the bottom of the tree containing the underlying data, a set of intermediate nodes where each node is the hash of its two children, and finally a single root node, also formed from the hash of its two children, representing the \"top\" of the tree. The purpose of the Merkle tree is to allow the data in a block to be delivered piecemeal: a node can download only the header of a block from one source, the small part of the tree relevant to them from another source, and still be assured that all of the data is correct. The reason why this works is that hashes propagate upward: if a malicious user attempts to swap in a fake transaction into the bottom of a Merkle tree, this change will cause a change in the node above, and then a change in the node above that, finally changing the root of the tree and therefore the hash of the block, causing the protocol to register it as a completely different block (almost certainly with an invalid proof of work).  The Merkle tree protocol is arguably essential to long-term sustainability. A \"full node\" in the Bitcoin network, one that stores and processes the entirety of every block, takes up about 15 GB of disk space in the Bitcoin network as of April 2014, and is growing by over a gigabyte per month. Currently, this is viable for some desktop computers and not phones, and later on in the future only businesses and hobbyists will be able to participate. A protocol known as \"simplified payment verification\" (SPV) allows for another class of nodes to exist, called \"light nodes\", which download the block headers, verify the proof of work on the block headers, and then download only the \"branches\" associated with transactions that are relevant to them. This allows light nodes to determine with a strong guarantee of security what the status of any Bitcoin transaction, and their current balance, is while downloading only a very small portion of the entire blockchain.", 
            "title": "\u9ed8\u514b\u5c14\u6811"
        }, 
        {
            "location": "/Basics/White-Paper/#_6", 
            "text": "The idea of taking the underlying blockchain idea and applying it to other concepts also has a long history. In 2005, Nick Szabo came out with the concept of \" secure property titles with owner authority \", a document describing how \"new advances in replicated database technology\" will allow for a blockchain-based system for storing a registry of who owns what land, creating an elaborate framework including concepts such as homesteading, adverse possession and Georgian land tax. However, there was unfortunately no effective replicated database system available at the time, and so the protocol was never implemented in practice. After 2009, however, once Bitcoin's decentralized consensus was developed a number of alternative applications rapidly began to emerge.   Namecoin  - created in 2010,  Namecoin  is best described as a decentralized name registration database. In decentralized protocols like Tor, Bitcoin and BitMessage, there needs to be some way of identifying accounts so that other people can interact with them, but in all existing solutions the only kind of identifier available is a pseudorandom hash like  1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy . Ideally, one would like to be able to have an account with a name like \"george\". However, the problem is that if one person can create an account named \"george\" then someone else can use the same process to register \"george\" for themselves as well and impersonate them. The only solution is a first-to-file paradigm, where the first registerer succeeds and the second fails - a problem perfectly suited for the Bitcoin consensus protocol. Namecoin is the oldest, and most successful, implementation of a name registration system using such an idea.  Colored coins  - the purpose of  colored coins  is to serve as a protocol to allow people to create their own digital currencies - or, in the important trivial case of a currency with one unit, digital tokens, on the Bitcoin blockchain. In the colored coins protocol, one \"issues\" a new currency by publicly assigning a color to a specific Bitcoin UTXO, and the protocol recursively defines the color of other UTXO to be the same as the color of the inputs that the transaction creating them spent (some special rules apply in the case of mixed-color inputs). This allows users to maintain wallets containing only UTXO of a specific color and send them around much like regular bitcoins, backtracking through the blockchain to determine the color of any UTXO that they receive.  Metacoins  - the idea behind a metacoin is to have a protocol that lives on top of Bitcoin, using Bitcoin transactions to store metacoin transactions but having a different state transition function,  APPLY' . Because the metacoin protocol cannot prevent invalid metacoin transactions from appearing in the Bitcoin blockchain, a rule is added that if  APPLY'(S,TX)  returns an error, the protocol defaults to  APPLY'(S,TX) = S . This provides an easy mechanism for creating an arbitrary cryptocurrency protocol, potentially with advanced features that cannot be implemented inside of Bitcoin itself, but with a very low development cost since the complexities of mining and networking are already handled by the Bitcoin protocol. Metacoins have been used to implement some classes of financial contracts, name registration and decentralized exchange.   Thus, in general, there are two approaches toward building a consensus protocol: building an independent network, and building a protocol on top of Bitcoin. The former approach, while reasonably successful in the case of applications like Namecoin, is difficult to implement; each individual implementation needs to bootstrap an independent blockchain, as well as building and testing all of the necessary state transition and networking code. Additionally, we predict that the set of applications for decentralized consensus technology will follow a power law distribution where the vast majority of applications would be too small to warrant their own blockchain, and we note that there exist large classes of decentralized applications, particularly decentralized autonomous organizations, that need to interact with each other.  The Bitcoin-based approach, on the other hand, has the flaw that it does not inherit the simplified payment verification features of Bitcoin. SPV works for Bitcoin because it can use blockchain depth as a proxy for validity; at some point, once the ancestors of a transaction go far enough back, it is safe to say that they were legitimately part of the state. Blockchain-based meta-protocols, on the other hand, cannot force the blockchain not to include transactions that are not valid within the context of their own protocols. Hence, a fully secure SPV meta-protocol implementation would need to backward scan all the way to the beginning of the Bitcoin blockchain to determine whether or not certain transactions are valid. Currently, all \"light\" implementations of Bitcoin-based meta-protocols rely on a trusted server to provide the data, arguably a highly suboptimal result especially when one of the primary purposes of a cryptocurrency is to eliminate the need for trust.", 
            "title": "\u66ff\u4ee3\u533a\u5757\u94fe\u5e94\u7528\u7a0b\u5e8f"
        }, 
        {
            "location": "/Basics/White-Paper/#_7", 
            "text": "Even without any extensions, the Bitcoin protocol actually does facilitate a weak version of a concept of \"smart contracts\". UTXO in Bitcoin can be owned not just by a public key, but also by a more complicated script expressed in a simple stack-based programming language. In this paradigm, a transaction spending that UTXO must provide data that satisfies the script. Indeed, even the basic public key ownership mechanism is implemented via a script: the script takes an elliptic curve signature as input, verifies it against the transaction and the address that owns the UTXO, and returns 1 if the verification is successful and 0 otherwise. Other, more complicated, scripts exist for various additional use cases. For example, one can construct a script that requires signatures from two out of a given three private keys to validate (\"multisig\"), a setup useful for corporate accounts, secure savings accounts and some merchant escrow situations. Scripts can also be used to pay bounties for solutions to computational problems, and one can even construct a script that says something like \"this Bitcoin UTXO is yours if you can provide an SPV proof that you sent a Dogecoin transaction of this denomination to me\", essentially allowing decentralized cross-cryptocurrency exchange.  However, the scripting language as implemented in Bitcoin has several important limitations:   Lack of Turing-completeness  - that is to say, while there is a large subset of computation that the Bitcoin scripting language supports, it does not nearly support everything. The main category that is missing is loops. This is done to avoid infinite loops during transaction verification; theoretically it is a surmountable obstacle for script programmers, since any loop can be simulated by simply repeating the underlying code many times with an if statement, but it does lead to scripts that are very space-inefficient. For example, implementing an alternative elliptic curve signature algorithm would likely require 256 repeated multiplication rounds all individually included in the code.  Value-blindness  - there is no way for a UTXO script to provide fine-grained control over the amount that can be withdrawn. For example, one powerful use case of an oracle contract would be a hedging contract, where A and B put in $1000 worth of BTC and after 30 days the script sends $1000 worth of BTC to A and the rest to B. This would require an oracle to determine the value of 1 BTC in USD, but even then it is a massive improvement in terms of trust and infrastructure requirement over the fully centralized solutions that are available now. However, because UTXO are all-or-nothing, the only way to achieve this is through the very inefficient hack of having many UTXO of varying denominations (eg. one UTXO of 2 k  for every k up to 30) and having O pick which UTXO to send to A and which to B.  Lack of state  - UTXO can either be spent or unspent; there is no opportunity for multi-stage contracts or scripts which keep any other internal state beyond that. This makes it hard to make multi-stage options contracts, decentralized exchange offers or two-stage cryptographic commitment protocols (necessary for secure computational bounties). It also means that UTXO can only be used to build simple, one-off contracts and not more complex \"stateful\" contracts such as decentralized organizations, and makes meta-protocols difficult to implement. Binary state combined with value-blindness also mean that another important application, withdrawal limits, is impossible.  Blockchain-blindness  - UTXO are blind to blockchain data such as the nonce, the timestamp and previous block hash. This severely limits applications in gambling, and several other categories, by depriving the scripting language of a potentially valuable source of randomness.   Thus, we see three approaches to building advanced applications on top of cryptocurrency: building a new blockchain, using scripting on top of Bitcoin, and building a meta-protocol on top of Bitcoin. Building a new blockchain allows for unlimited freedom in building a feature set, but at the cost of development time, bootstrapping effort and security. Using scripting is easy to implement and standardize, but is very limited in its capabilities, and meta-protocols, while easy, suffer from faults in scalability. With Ethereum, we intend to build an alternative framework that provides even larger gains in ease of development as well as even stronger light client properties, while at the same time allowing applications to share an economic environment and blockchain security.", 
            "title": "\u811a\u672c"
        }, 
        {
            "location": "/Basics/White-Paper/#_8", 
            "text": "The intent of Ethereum is to create an alternative protocol for building decentralized applications, providing a different set of tradeoffs that we believe will be very useful for a large class of decentralized applications, with particular emphasis on situations where rapid development time, security for small and rarely used applications, and the ability of different applications to very efficiently interact, are important. Ethereum does this by building what is essentially the ultimate abstract foundational layer: a blockchain with a built-in Turing-complete programming language, allowing anyone to write smart contracts and decentralized applications where they can create their own arbitrary rules for ownership, transaction formats and state transition functions. A bare-bones version of Namecoin can be written in two lines of code, and other protocols like currencies and reputation systems can be built in under twenty. Smart contracts, cryptographic \"boxes\" that contain value and only unlock it if certain conditions are met, can also be built on top of the platform, with vastly more power than that offered by Bitcoin scripting because of the added powers of Turing-completeness, value-awareness, blockchain-awareness and state.", 
            "title": "\u4ee5\u592a\u574a"
        }, 
        {
            "location": "/Basics/White-Paper/#_9", 
            "text": "In Ethereum, the state is made up of objects called \"accounts\", with each account having a 20-byte address and state transitions being direct transfers of value and information between accounts. An Ethereum account contains four fields:   The  nonce , a counter used to make sure each transaction can only be processed once  The account's current  ether balance  The account's  contract code , if present  The account's  storage  (empty by default)   \"Ether\" is the main internal crypto-fuel of Ethereum, and is used to pay transaction fees. In general, there are two types of accounts:  externally owned accounts , controlled by private keys, and  contract accounts , controlled by their contract code. An externally owned account has no code, and one can send messages from an externally owned account by creating and signing a transaction; in a contract account, every time the contract account receives a message its code activates, allowing it to read and write to internal storage and send other messages or create contracts in turn.  Note that \"contracts\" in Ethereum should not be seen as something that should be \"fulfilled\" or \"complied with\"; rather, they are more like \"autonomous agents\" that live inside of the Ethereum execution environment, always executing a specific piece of code when \"poked\" by a message or transaction, and having direct control over their own ether balance and their own key/value store to keep track of persistent variables.", 
            "title": "\u8d26\u53f7"
        }, 
        {
            "location": "/Basics/White-Paper/#_10", 
            "text": "The term \"transaction\" is used in Ethereum to refer to the signed data package that stores a message to be sent from an externally owned account. Transactions contain:   The recipient of the message  A signature identifying the sender  The amount of ether to transfer from the sender to the recipient  An optional data field  A  STARTGAS  value, representing the maximum number of computational steps the transaction execution is allowed to take  A  GASPRICE  value, representing the fee the sender pays per computational step   The first three are standard fields expected in any cryptocurrency. The data field has no function by default, but the virtual machine has an opcode using which a contract can access the data; as an example use case, if a contract is functioning as an on-blockchain domain registration service, then it may wish to interpret the data being passed to it as containing two \"fields\", the first field being a domain to register and the second field being the IP address to register it to. The contract would read these values from the message data and appropriately place them in storage.  The  STARTGAS  and  GASPRICE  fields are crucial for Ethereum's anti-denial of service model. In order to prevent accidental or hostile infinite loops or other computational wastage in code, each transaction is required to set a limit to how many computational steps of code execution it can use. The fundamental unit of computation is \"gas\"; usually, a computational step costs 1 gas, but some operations cost higher amounts of gas because they are more computationally expensive, or increase the amount of data that must be stored as part of the state. There is also a fee of 5 gas for every byte in the transaction data. The intent of the fee system is to require an attacker to pay proportionately for every resource that they consume, including computation, bandwidth and storage; hence, any transaction that leads to the network consuming a greater amount of any of these resources must have a gas fee roughly proportional to the increment.", 
            "title": "\u6d88\u606f\u548c\u4ea4\u6613"
        }, 
        {
            "location": "/Basics/White-Paper/#_11", 
            "text": "Contracts have the ability to send \"messages\" to other contracts. Messages are virtual objects that are never serialized and exist only in the Ethereum execution environment. A message contains:   The sender of the message (implicit)  The recipient of the message  The amount of ether to transfer alongside the message  An optional data field  A  STARTGAS  value   Essentially, a message is like a transaction, except it is produced by a contract and not an external actor. A message is produced when a contract currently executing code executes the  CALL  opcode, which produces and executes a message. Like a transaction, a message leads to the recipient account running its code. Thus, contracts can have relationships with other contracts in exactly the same way that external actors can.  Note that the gas allowance assigned by a transaction or contract applies to the total gas consumed by that transaction and all sub-executions. For example, if an external actor A sends a transaction to B with 1000 gas, and B consumes 600 gas before sending a message to C, and the internal execution of C consumes 300 gas before returning, then B can spend another 100 gas before running out of gas.", 
            "title": "\u6d88\u606f"
        }, 
        {
            "location": "/Basics/White-Paper/#_12", 
            "text": "The Ethereum state transition function,  APPLY(S,TX) -  S'  can be defined as follows:   Check if the transaction is well-formed (ie. has the right number of values), the signature is valid, and the nonce matches the nonce in the sender's account. If not, return an error.  Calculate the transaction fee as  STARTGAS * GASPRICE , and determine the sending address from the signature. Subtract the fee from the sender's account balance and increment the sender's nonce. If there is not enough balance to spend, return an error.  Initialize  GAS = STARTGAS , and take off a certain quantity of gas per byte to pay for the bytes in the transaction.  Transfer the transaction value from the sender's account to the receiving account. If the receiving account does not yet exist, create it. If the receiving account is a contract, run the contract's code either to completion or until the execution runs out of gas.  If the value transfer failed because the sender did not have enough money, or the code execution ran out of gas, revert all state changes except the payment of the fees, and add the fees to the miner's account.  Otherwise, refund the fees for all remaining gas to the sender, and send the fees paid for gas consumed to the miner.   For example, suppose that the contract's code is:  if !self.storage[calldataload(0)]:\n    self.storage[calldataload(0)] = calldataload(32)  Note that in reality the contract code is written in the low-level EVM code; this example is written in Serpent, one of our high-level languages, for clarity, and can be compiled down to EVM code. Suppose that the contract's storage starts off empty, and a transaction is sent with 10 ether value, 2000 gas, 0.001 ether gasprice, and 64 bytes of data, with bytes 0-31 representing the number  2  and bytes 32-63 representing the string  CHARLIE . The process for the state transition function in this case is as follows:   Check that the transaction is valid and well formed.  Check that the transaction sender has at least 2000 * 0.001 = 2 ether. If it is, then subtract 2 ether from the sender's account.  Initialize gas = 2000; assuming the transaction is 170 bytes long and the byte-fee is 5, subtract 850 so that there is 1150 gas left.  Subtract 10 more ether from the sender's account, and add it to the contract's account.  Run the code. In this case, this is simple: it checks if the contract's storage at index  2  is used, notices that it is not, and so it sets the storage at index  2  to the value  CHARLIE . Suppose this takes 187 gas, so the remaining amount of gas is 1150 - 187 = 963  Add 963 * 0.001 = 0.963 ether back to the sender's account, and return the resulting state.   If there was no contract at the receiving end of the transaction, then the total transaction fee would simply be equal to the provided  GASPRICE  multiplied by the length of the transaction in bytes, and the data sent alongside the transaction would be irrelevant.  Note that messages work equivalently to transactions in terms of reverts: if a message execution runs out of gas, then that message's execution, and all other executions triggered by that execution, revert, but parent executions do not need to revert. This means that it is \"safe\" for a contract to call another contract, as if A calls B with G gas then A's execution is guaranteed to lose at most G gas. Finally, note that there is an opcode,  CREATE , that creates a contract; its execution mechanics are generally similar to  CALL , with the exception that the output of the execution determines the code of a newly created contract.", 
            "title": "\u72b6\u6001\u8f6c\u79fb\u51fd\u6570"
        }, 
        {
            "location": "/Basics/White-Paper/#_13", 
            "text": "The code in Ethereum contracts is written in a low-level, stack-based bytecode language, referred to as \"Ethereum virtual machine code\" or \"EVM code\". The code consists of a series of bytes, where each byte represents an operation. In general, code execution is an infinite loop that consists of repeatedly carrying out the operation at the current program counter (which begins at zero) and then incrementing the program counter by one, until the end of the code is reached or an error or  STOP  or  RETURN  instruction is detected. The operations have access to three types of space in which to store data:   The  stack , a last-in-first-out container to which values can be pushed and popped  Memory , an infinitely expandable byte array  The contract's long-term  storage , a key/value store. Unlike stack and memory, which reset after computation ends, storage persists for the long term.   The code can also access the value, sender and data of the incoming message, as well as block header data, and the code can also return a byte array of data as an output.  The formal execution model of EVM code is surprisingly simple. While the Ethereum virtual machine is running, its full computational state can be defined by the tuple  (block_state, transaction, message, code, memory, stack, pc, gas) , where  block_state  is the global state containing all accounts and includes balances and storage. At the start of every round of execution, the current instruction is found by taking the  pc th byte of  code  (or 0 if  pc  = len(code) ), and each instruction has its own definition in terms of how it affects the tuple. For example,  ADD  pops two items off the stack and pushes their sum, reduces  gas  by 1 and increments  pc  by 1, and  SSTORE  pops the top two items off the stack and inserts the second item into the contract's storage at the index specified by the first item. Although there are many ways to optimize Ethereum virtual machine execution via just-in-time compilation, a basic implementation of Ethereum can be done in a few hundred lines of code.", 
            "title": "\u4ee3\u7801\u6267\u884c"
        }, 
        {
            "location": "/Basics/White-Paper/#_14", 
            "text": "The Ethereum blockchain is in many ways similar to the Bitcoin blockchain, although it does have some differences. The main difference between Ethereum and Bitcoin with regard to the blockchain architecture is that, unlike Bitcoin, Ethereum blocks contain a copy of both the transaction list and the most recent state. Aside from that, two other values, the block number and the difficulty, are also stored in the block. The basic block validation algorithm in Ethereum is as follows:   Check if the previous block referenced exists and is valid.  Check that the timestamp of the block is greater than that of the referenced previous block and less than 15 minutes into the future  Check that the block number, difficulty, transaction root, uncle root and gas limit (various low-level Ethereum-specific concepts) are valid.  Check that the proof of work on the block is valid.  Let  S[0]  be the state at the end of the previous block.  Let  TX  be the block's transaction list, with  n  transactions. For all  i  in  0...n-1 , set  S[i+1] = APPLY(S[i],TX[i]) . If any applications returns an error, or if the total gas consumed in the block up until this point exceeds the  GASLIMIT , return an error.  Let  S_FINAL  be  S[n] , but adding the block reward paid to the miner.  Check if the Merkle tree root of the state  S_FINAL  is equal to the final state root provided in the block header. If it is, the block is valid; otherwise, it is not valid.   The approach may seem highly inefficient at first glance, because it needs to store the entire state with each block, but in reality efficiency should be comparable to that of Bitcoin. The reason is that the state is stored in the tree structure, and after every block only a small part of the tree needs to be changed. Thus, in general, between two adjacent blocks the vast majority of the tree should be the same, and therefore the data can be stored once and referenced twice using pointers (ie. hashes of subtrees). A special kind of tree known as a \"Patricia tree\" is used to accomplish this, including a modification to the Merkle tree concept that allows for nodes to be inserted and deleted, and not just changed, efficiently.  Additionally, because all of the state information is part of the last block, there is no need to store the entire blockchain history - a strategy which, if it could be applied to Bitcoin, can be calculated to provide 5-20x savings in space.  A commonly asked question is \"where\" contract code is executed, in terms of physical hardware. This has a simple answer: the process of executing contract code is part of the definition of the state transition function, which is part of the block validation algorithm, so if a transaction is added into block  B  the code execution spawned by that transaction will be executed by all nodes, now and in the future, that download and validate block  B .", 
            "title": "\u533a\u5757\u94fe\u548c\u6316\u77ff"
        }, 
        {
            "location": "/Basics/White-Paper/#_15", 
            "text": "In general, there are three types of applications on top of Ethereum. The first category is financial applications, providing users with more powerful ways of managing and entering into contracts using their money. This includes sub-currencies, financial derivatives, hedging contracts, savings wallets, wills, and ultimately even some classes of full-scale employment contracts. The second category is semi-financial applications, where money is involved but there is also a heavy non-monetary side to what is being done; a perfect example is self-enforcing bounties for solutions to computational problems. Finally, there are applications such as online voting and decentralized governance that are not financial at all.", 
            "title": "\u5e94\u7528"
        }, 
        {
            "location": "/Basics/White-Paper/#_16", 
            "text": "On-blockchain token systems have many applications ranging from sub-currencies representing assets such as USD or gold to company stocks, individual tokens representing smart property, secure unforgeable coupons, and even token systems with no ties to conventional value at all, used as point systems for incentivization. Token systems are surprisingly easy to implement in Ethereum. The key point to understand is that all a currency, or token system, fundamentally is a database with one operation: subtract X units from A and give X units to B, with the proviso that (i) A had at least X units before the transaction and (2) the transaction is approved by A. All that it takes to implement a token system is to implement this logic into a contract.  The basic code for implementing a token system in Serpent looks as follows:  def send(to, value):\n    if self.storage[msg.sender]  = value:\n        self.storage[msg.sender] = self.storage[msg.sender] - value\n        self.storage[to] = self.storage[to] + value  This is essentially a literal implementation of the \"banking system\" state transition function described further above in this document. A few extra lines of code need to be added to provide for the initial step of distributing the currency units in the first place and a few other edge cases, and ideally a function would be added to let other contracts query for the balance of an address. But that's all there is to it. Theoretically, Ethereum-based token systems acting as sub-currencies can potentially include another important feature that on-chain Bitcoin-based meta-currencies lack: the ability to pay transaction fees directly in that currency. The way this would be implemented is that the contract would maintain an ether balance with which it would refund ether used to pay fees to the sender, and it would refill this balance by collecting the internal currency units that it takes in fees and reselling them in a constant running auction. Users would thus need to \"activate\" their accounts with ether, but once the ether is there it would be reusable because the contract would refund it each time.", 
            "title": "\u4ee4\u724c\u7cfb\u7edf"
        }, 
        {
            "location": "/Basics/White-Paper/#_17", 
            "text": "Financial derivatives are the most common application of a \"smart contract\", and one of the simplest to implement in code. The main challenge in implementing financial contracts is that the majority of them require reference to an external price ticker; for example, a very desirable application is a smart contract that hedges against the volatility of ether (or another cryptocurrency) with respect to the US dollar, but doing this requires the contract to know what the value of ETH/USD is. The simplest way to do this is through a \"data feed\" contract maintained by a specific party (eg. NASDAQ) designed so that that party has the ability to update the contract as needed, and providing an interface that allows other contracts to send a message to that contract and get back a response that provides the price.  Given that critical ingredient, the hedging contract would look as follows:   Wait for party A to input 1000 ether.  Wait for party B to input 1000 ether.  Record the USD value of 1000 ether, calculated by querying the data feed contract, in storage, say this is $x.  After 30 days, allow A or B to \"reactivate\" the contract in order to send $x worth of ether (calculated by querying the data feed contract again to get the new price) to A and the rest to B.   Such a contract would have significant potential in crypto-commerce. One of the main problems cited about cryptocurrency is the fact that it's volatile; although many users and merchants may want the security and convenience of dealing with cryptographic assets, they may not wish to face that prospect of losing 23% of the value of their funds in a single day. Up until now, the most commonly proposed solution has been issuer-backed assets; the idea is that an issuer creates a sub-currency in which they have the right to issue and revoke units, and provide one unit of the currency to anyone who provides them (offline) with one unit of a specified underlying asset (eg. gold, USD). The issuer then promises to provide one unit of the underlying asset to anyone who sends back one unit of the crypto-asset. This mechanism allows any non-cryptographic asset to be \"uplifted\" into a cryptographic asset, provided that the issuer can be trusted.  In practice, however, issuers are not always trustworthy, and in some cases the banking infrastructure is too weak, or too hostile, for such services to exist. Financial derivatives provide an alternative. Here, instead of a single issuer providing the funds to back up an asset, a decentralized market of speculators, betting that the price of a cryptographic reference asset (eg. ETH) will go up, plays that role. Unlike issuers, speculators have no option to default on their side of the bargain because the hedging contract holds their funds in escrow. Note that this approach is not fully decentralized, because a trusted source is still needed to provide the price ticker, although arguably even still this is a massive improvement in terms of reducing infrastructure requirements (unlike being an issuer, issuing a price feed requires no licenses and can likely be categorized as free speech) and reducing the potential for fraud.", 
            "title": "\u91d1\u878d\u884d\u751f\u54c1\u548c\u7a33\u5b9a\u4ef7\u503c\u8d27\u5e01"
        }, 
        {
            "location": "/Basics/White-Paper/#_18", 
            "text": "The earliest alternative cryptocurrency of all,  Namecoin , attempted to use a Bitcoin-like blockchain to provide a name registration system, where users can register their names in a public database alongside other data. The major cited use case is for a  DNS  system, mapping domain names like \"bitcoin.org\" (or, in Namecoin's case, \"bitcoin.bit\") to an IP address. Other use cases include email authentication and potentially more advanced reputation systems. Here is the basic contract to provide a Namecoin-like name registration system on Ethereum:  def register(name, value):\n    if !self.storage[name]:\n        self.storage[name] = value  The contract is very simple; all it is is a database inside the Ethereum network that can be added to, but not modified or removed from. Anyone can register a name with some value, and that registration then sticks forever. A more sophisticated name registration contract will also have a \"function clause\" allowing other contracts to query it, as well as a mechanism for the \"owner\" (ie. the first registerer) of a name to change the data or transfer ownership. One can even add reputation and web-of-trust functionality on top.", 
            "title": "\u8eab\u4efd\u548c\u58f0\u8a89\u7cfb\u7edf"
        }, 
        {
            "location": "/Basics/White-Paper/#_19", 
            "text": "Over the past few years, there have emerged a number of popular online file storage startups, the most prominent being Dropbox, seeking to allow users to upload a backup of their hard drive and have the service store the backup and allow the user to access it in exchange for a monthly fee. However, at this point the file storage market is at times relatively inefficient; a cursory look at various  existing solutions  shows that, particularly at the \"uncanny valley\" 20-200 GB level at which neither free quotas nor enterprise-level discounts kick in, monthly prices for mainstream file storage costs are such that you are paying for more than the cost of the entire hard drive in a single month. Ethereum contracts can allow for the development of a decentralized file storage ecosystem, where individual users can earn small quantities of money by renting out their own hard drives and unused space can be used to further drive down the costs of file storage.  The key underpinning piece of such a device would be what we have termed the \"decentralized Dropbox contract\". This contract works as follows. First, one splits the desired data up into blocks, encrypting each block for privacy, and builds a Merkle tree out of it. One then makes a contract with the rule that, every N blocks, the contract would pick a random index in the Merkle tree (using the previous block hash, accessible from contract code, as a source of randomness), and give X ether to the first entity to supply a transaction with a simplified payment verification-like proof of ownership of the block at that particular index in the tree. When a user wants to re-download their file, they can use a micropayment channel protocol (eg. pay 1 szabo per 32 kilobytes) to recover the file; the most fee-efficient approach is for the payer not to publish the transaction until the end, instead replacing the transaction with a slightly more lucrative one with the same nonce after every 32 kilobytes.  An important feature of the protocol is that, although it may seem like one is trusting many random nodes not to decide to forget the file, one can reduce that risk down to near-zero by splitting the file into many pieces via secret sharing, and watching the contracts to see each piece is still in some node's possession. If a contract is still paying out money, that provides a cryptographic proof that someone out there is still storing the file.", 
            "title": "\u65e0\u5fc3\u6587\u4ef6\u5b58\u50a8"
        }, 
        {
            "location": "/Basics/White-Paper/#_20", 
            "text": "The general concept of a \"decentralized autonomous organization\" is that of a virtual entity that has a certain set of members or shareholders which, perhaps with a 67% majority, have the right to spend the entity's funds and modify its code. The members would collectively decide on how the organization should allocate its funds. Methods for allocating a DAO's funds could range from bounties, salaries to even more exotic mechanisms such as an internal currency to reward work. This essentially replicates the legal trappings of a traditional company or nonprofit but using only cryptographic blockchain technology for enforcement. So far much of the talk around DAOs has been around the \"capitalist\" model of a \"decentralized autonomous corporation\" (DAC) with dividend-receiving shareholders and tradable shares; an alternative, perhaps described as a \"decentralized autonomous community\", would have all members have an equal share in the decision making and require 67% of existing members to agree to add or remove a member. The requirement that one person can only have one membership would then need to be enforced collectively by the group.  A general outline for how to code a DAO is as follows. The simplest design is simply a piece of self-modifying code that changes if two thirds of members agree on a change. Although code is theoretically immutable, one can easily get around this and have de-facto mutability by having chunks of the code in separate contracts, and having the address of which contracts to call stored in the modifiable storage. In a simple implementation of such a DAO contract, there would be three transaction types, distinquished by the data provided in the transaction:   [0,i,K,V]  to register a proposal with index  i  to change the address at storage index  K  to value  V  [0,i]  to register a vote in favor of proposal  i  [2,i]  to finalize proposal  i  if enough votes have been made   The contract would then have clauses for each of these. It would maintain a record of all open storage changes, along with a list of who voted for them. It would also have a list of all members. When any storage change gets to two thirds of members voting for it, a finalizing transaction could execute the change. A more sophisticated skeleton would also have built-in voting ability for features like sending a transaction, adding members and removing members, and may even provide for  Liquid Democracy -style vote delegation (ie. anyone can assign someone to vote for them, and assignment is transitive so if A assigns B and B assigns C then C determines A's vote). This design would allow the DAO to grow organically as a decentralized community, allowing people to eventually delegate the task of filtering out who is a member to specialists, although unlike in the \"current system\" specialists can easily pop in and out of existence over time as individual community members change their alignments.  An alternative model is for a decentralized corporation, where any account can have zero or more shares, and two thirds of the shares are required to make a decision. A complete skeleton would involve asset management functionality, the ability to make an offer to buy or sell shares, and the ability to accept offers (preferably with an order-matching mechanism inside the contract). Delegation would also exist Liquid Democracy-style, generalizing the concept of a \"board of directors\".", 
            "title": "\u65e0\u5fc3\u81ea\u7ec4\u7ec7"
        }, 
        {
            "location": "/Basics/White-Paper/#_21", 
            "text": "1. Savings wallets . Suppose that Alice wants to keep her funds safe, but is worried that she will lose or someone will hack her private key. She puts ether into a contract with Bob, a bank, as follows:   Alice alone can withdraw a maximum of 1% of the funds per day.  Bob alone can withdraw a maximum of 1% of the funds per day, but Alice has the ability to make a transaction with her key shutting off this ability.  Alice and Bob together can withdraw anything.   Normally, 1% per day is enough for Alice, and if Alice wants to withdraw more she can contact Bob for help. If Alice's key gets hacked, she runs to Bob to move the funds to a new contract. If she loses her key, Bob will get the funds out eventually. If Bob turns out to be malicious, then she can turn off his ability to withdraw.  2. Crop insurance . One can easily make a financial derivatives contract but using a data feed of the weather instead of any price index. If a farmer in Iowa purchases a derivative that pays out inversely based on the precipitation in Iowa, then if there is a drought, the farmer will automatically receive money and if there is enough rain the farmer will be happy because their crops would do well. This can be expanded to natural disaster insurance generally.  3. A decentralized data feed . For financial contracts for difference, it may actually be possible to decentralize the data feed via a protocol called \" SchellingCoin \". SchellingCoin basically works as follows: N parties all put into the system the value of a given datum (eg. the ETH/USD price), the values are sorted, and everyone between the 25th and 75th percentile gets one token as a reward. Everyone has the incentive to provide the answer that everyone else will provide, and the only value that a large number of players can realistically agree on is the obvious default: the truth. This creates a decentralized protocol that can theoretically provide any number of values, including the ETH/USD price, the temperature in Berlin or even the result of a particular hard computation.  4. Smart multisignature escrow . Bitcoin allows multisignature transaction contracts where, for example, three out of a given five keys can spend the funds. Ethereum allows for more granularity; for example, four out of five can spend everything, three out of five can spend up to 10% per day, and two out of five can spend up to 0.5% per day. Additionally, Ethereum multisig is asynchronous - two parties can register their signatures on the blockchain at different times and the last signature will automatically send the transaction.  5. Cloud computing . The EVM technology can also be used to create a verifiable computing environment, allowing users to ask others to carry out computations and then optionally ask for proofs that computations at certain randomly selected checkpoints were done correctly. This allows for the creation of a cloud computing market where any user can participate with their desktop, laptop or specialized server, and spot-checking together with security deposits can be used to ensure that the system is trustworthy (ie. nodes cannot profitably cheat). Although such a system may not be suitable for all tasks; tasks that require a high level of inter-process communication, for example, cannot easily be done on a large cloud of nodes. Other tasks, however, are much easier to parallelize; projects like SETI@home, folding@home and genetic algorithms can easily be implemented on top of such a platform.  6. Peer-to-peer gambling . Any number of peer-to-peer gambling protocols, such as Frank Stajano and Richard Clayton's  Cyberdice , can be implemented on the Ethereum blockchain. The simplest gambling protocol is actually simply a contract for difference on the next block hash, and more advanced protocols can be built up from there, creating gambling services with near-zero fees that have no ability to cheat.  7. Prediction markets . Provided an oracle or SchellingCoin, prediction markets are also easy to implement, and prediction markets together with SchellingCoin may prove to be the first mainstream application of  futarchy  as a governance protocol for decentralized organizations.  8. On-chain decentralized marketplaces , using the identity and reputation system as a base.", 
            "title": "\u5176\u5b83\u5e94\u7528"
        }, 
        {
            "location": "/Basics/White-Paper/#_22", 
            "text": "", 
            "title": "\u6742\u8bb0\u548c\u5173\u6ce8"
        }, 
        {
            "location": "/Basics/White-Paper/#ghost", 
            "text": "The \"Greedy Heaviest Observed Subtree\" (GHOST) protocol is an innovation first introduced by Yonatan Sompolinsky and Aviv Zohar in  December 2013 . The motivation behind GHOST is that blockchains with fast confirmation times currently suffer from reduced security due to a high stale rate - because blocks take a certain time to propagate through the network, if miner A mines a block and then miner B happens to mine another block before miner A's block propagates to B, miner B's block will end up wasted and will not contribute to network security. Furthermore, there is a centralization issue: if miner A is a mining pool with 30% hashpower and B has 10% hashpower, A will have a risk of producing a stale block 70% of the time (since the other 30% of the time A produced the last block and so will get mining data immediately) whereas B will have a risk of producing a stale block 90% of the time. Thus, if the block interval is short enough for the stale rate to be high, A will be substantially more efficient simply by virtue of its size. With these two effects combined, blockchains which produce blocks quickly are very likely to lead to one mining pool having a large enough percentage of the network hashpower to have de facto control over the mining process.  As described by Sompolinsky and Zohar, GHOST solves the first issue of network security loss by including stale blocks in the calculation of which chain is the \"longest\"; that is to say, not just the parent and further ancestors of a block, but also the stale descendants of the block's ancestor (in Ethereum jargon, \"uncles\") are added to the calculation of which block has the largest total proof of work backing it. To solve the second issue of centralization bias, we go beyond the protocol described by Sompolinsky and Zohar, and also provide block rewards to stales: a stale block receives 87.5% of its base reward, and the nephew that includes the stale block receives the remaining 12.5%. Transaction fees, however, are not awarded to uncles.  Ethereum implements a simplified version of GHOST which only goes down seven levels. Specifically, it is defined as follows:   A block must specify a parent, and it must specify 0 or more uncles  An uncle included in block B must have the following properties:  It must be a direct child of the kth generation ancestor of B, where 2  = k  = 7.  It cannot be an ancestor of B  An uncle must be a valid block header, but does not need to be a previously verified or even valid block  An uncle must be different from all uncles included in previous blocks and all other uncles included in the same block (non-double-inclusion)  For every uncle U in block B, the miner of B gets an additional 3.125% added to its coinbase reward and the miner of U gets 93.75% of a standard coinbase reward.   This limited version of GHOST, with uncles includable only up to 7 generations, was used for two reasons. First, unlimited GHOST would include too many complications into the calculation of which uncles for a given block are valid. Second, unlimited GHOST with compensation as used in Ethereum removes the incentive for a miner to mine on the main chain and not the chain of a public attacker.", 
            "title": "\u4fee\u6539\u7684GHOST\u5b9e\u73b0"
        }, 
        {
            "location": "/Basics/White-Paper/#_23", 
            "text": "Because every transaction published into the blockchain imposes on the network the cost of needing to download and verify it, there is a need for some regulatory mechanism, typically involving transaction fees, to prevent abuse. The default approach, used in Bitcoin, is to have purely voluntary fees, relying on miners to act as the gatekeepers and set dynamic minimums. This approach has been received very favorably in the Bitcoin community particularly because it is \"market-based\", allowing supply and demand between miners and transaction senders determine the price. The problem with this line of reasoning is, however, that transaction processing is not a market; although it is intuitively attractive to construe transaction processing as a service that the miner is offering to the sender, in reality every transaction that a miner includes will need to be processed by every node in the network, so the vast majority of the cost of transaction processing is borne by third parties and not the miner that is making the decision of whether or not to include it. Hence, tragedy-of-the-commons problems are very likely to occur.  However, as it turns out this flaw in the market-based mechanism, when given a particular inaccurate simplifying assumption, magically cancels itself out. The argument is as follows. Suppose that:   A transaction leads to  k  operations, offering the reward  kR  to any miner that includes it where  R  is set by the sender and  k  and  R  are (roughly) visible to the miner beforehand.  An operation has a processing cost of  C  to any node (ie. all nodes have equal efficiency)  There are  N  mining nodes, each with exactly equal processing power (ie.  1/N  of total)  No non-mining full nodes exist.   A miner would be willing to process a transaction if the expected reward is greater than the cost. Thus, the expected reward is  kR/N  since the miner has a  1/N  chance of processing the next block, and the processing cost for the miner is simply  kC . Hence, miners will include transactions where  kR/N   kC , or  R   NC . Note that  R  is the per-operation fee provided by the sender, and is thus a lower bound on the benefit that the sender derives from the transaction, and  NC  is the cost to the entire network together of processing an operation. Hence, miners have the incentive to include only those transactions for which the total utilitarian benefit exceeds the cost.  However, there are several important deviations from those assumptions in reality:   The miner does pay a higher cost to process the transaction than the other verifying nodes, since the extra verification time delays block propagation and thus increases the chance the block will become a stale.  There do exist nonmining full nodes.  The mining power distribution may end up radically inegalitarian in practice.  Speculators, political enemies and crazies whose utility function includes causing harm to the network do exist, and they can cleverly set up contracts where their cost is much lower than the cost paid by other verifying nodes.   (1) provides a tendency for the miner to include fewer transactions, and (2) increases  NC ; hence, these two effects at least partially cancel each other out. (3) and (4) are the major issue; to solve them we simply institute a floating cap: no block can have more operations than  BLK_LIMIT_FACTOR  times the long-term exponential moving average. Specifically:  blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) / EMA_FACTOR)  BLK_LIMIT_FACTOR  and  EMA_FACTOR  are constants that will be set to 65536 and 1.5 for the time being, but will likely be changed after further analysis.  There is another factor disincentivizing large block sizes in Bitcoin: blocks that are large will take longer to propagate, and thus have a higher probability of becoming stales. In Ethereum, highly gas-consuming blocks can also take longer to propagate both because they are physically larger and because they take longer to process the transaction state transitions to validate. This delay disincentive is a significant consideration in Bitcoin, but less so in Ethereum because of the GHOST protocol; hence, relying on regulated block limits provides a more stable baseline.", 
            "title": "\u8d39\u7528"
        }, 
        {
            "location": "/Basics/White-Paper/#_24", 
            "text": "An important note is that the Ethereum virtual machine is Turing-complete; this means that EVM code can encode any computation that can be conceivably carried out, including infinite loops. EVM code allows looping in two ways. First, there is a  JUMP  instruction that allows the program to jump back to a previous spot in the code, and a  JUMPI  instruction to do conditional jumping, allowing for statements like  while x   27: x = x * 2 . Second, contracts can call other contracts, potentially allowing for looping through recursion. This naturally leads to a problem: can malicious users essentially shut miners and full nodes down by forcing them to enter into an infinite loop? The issue arises because of a problem in computer science known as the halting problem: there is no way to tell, in the general case, whether or not a given program will ever halt.  As described in the state transition section, our solution works by requiring a transaction to set a maximum number of computational steps that it is allowed to take, and if execution takes longer computation is reverted but fees are still paid. Messages work in the same way. To show the motivation behind our solution, consider the following examples:   An attacker creates a contract which runs an infinite loop, and then sends a transaction activating that loop to the miner. The miner will process the transaction, running the infinite loop, and wait for it to run out of gas. Even though the execution runs out of gas and stops halfway through, the transaction is still valid and the miner still claims the fee from the attacker for each computational step.  An attacker creates a very long infinite loop with the intent of forcing the miner to keep computing for such a long time that by the time computation finishes a few more blocks will have come out and it will not be possible for the miner to include the transaction to claim the fee. However, the attacker will be required to submit a value for  STARTGAS  limiting the number of computational steps that execution can take, so the miner will know ahead of time that the computation will take an excessively large number of steps.  An attacker sees a contract with code of some form like  send(A,contract.storage[A]); contract.storage[A] = 0 , and sends a transaction with just enough gas to run the first step but not the second (ie. making a withdrawal but not letting the balance go down). The contract author does not need to worry about protecting against such attacks, because if execution stops halfway through the changes get reverted.  A financial contract works by taking the median of nine proprietary data feeds in order to minimize risk. An attacker takes over one of the data feeds, which is designed to be modifiable via the variable-address-call mechanism described in the section on DAOs, and converts it to run an infinite loop, thereby attempting to force any attempts to claim funds from the financial contract to run out of gas. However, the financial contract can set a gas limit on the message to prevent this problem.   The alternative to Turing-completeness is Turing-incompleteness, where  JUMP  and  JUMPI  do not exist and only one copy of each contract is allowed to exist in the call stack at any given time. With this system, the fee system described and the uncertainties around the effectiveness of our solution might not be necessary, as the cost of executing a contract would be bounded above by its size. Additionally, Turing-incompleteness is not even that big a limitation; out of all the contract examples we have conceived internally, so far only one required a loop, and even that loop could be removed by making 26 repetitions of a one-line piece of code. Given the serious implications of Turing-completeness, and the limited benefit, why not simply have a Turing-incomplete language? In reality, however, Turing-incompleteness is far from a neat solution to the problem. To see why, consider the following contracts:  C0 :   call ( C1 );   call ( C1 );  C1 :   call ( C2 );   call ( C2 );  C2 :   call ( C3 );   call ( C3 );  ...  C49 :   call ( C50 );   call ( C50 );  C50 :   ( run   one   step   of   a   program   and   record   the   change   in   storage )   Now, send a transaction to A. Thus, in 51 transactions, we have a contract that takes up 2 50  computational steps. Miners could try to detect such logic bombs ahead of time by maintaining a value alongside each contract specifying the maximum number of computational steps that it can take, and calculating this for contracts calling other contracts recursively, but that would require miners to forbid contracts that create other contracts (since the creation and execution of all 26 contracts above could easily be rolled into a single contract). Another problematic point is that the address field of a message is a variable, so in general it may not even be possible to tell which other contracts a given contract will call ahead of time. Hence, all in all, we have a surprising conclusion: Turing-completeness is surprisingly easy to manage, and the lack of Turing-completeness is equally surprisingly difficult to manage unless the exact same controls are in place - but in that case why not just let the protocol be Turing-complete?", 
            "title": "\u8ba1\u7b97\u548c\u56fe\u7075\u5b8c\u6574\u6027"
        }, 
        {
            "location": "/Basics/White-Paper/#_25", 
            "text": "The Ethereum network includes its own built-in currency, ether, which serves the dual purpose of providing a primary liquidity layer to allow for efficient exchange between various types of digital assets and, more importantly, of providing a mechanism for paying transaction fees. For convenience and to avoid future argument (see the current mBTC/uBTC/satoshi debate in Bitcoin), the denominations will be pre-labelled:   1: wei  10 12 : szabo  10 15 : finney  10 18 : ether   This should be taken as an expanded version of the concept of \"dollars\" and \"cents\" or \"BTC\" and \"satoshi\". In the near future, we expect \"ether\" to be used for ordinary transactions, \"finney\" for microtransactions and \"szabo\" and \"wei\" for technical discussions around fees and protocol implementation; the remaining denominations may become useful later and should not be included in clients at this point.  The issuance model will be as follows:   Ether will be released in a currency sale at the price of 1000-2000 ether per BTC, a mechanism intended to fund the Ethereum organization and pay for development that has been used with success by other platforms such as Mastercoin and NXT. Earlier buyers will benefit from larger discounts. The BTC received from the sale will be used entirely to pay salaries and bounties to developers and invested into various for-profit and non-profit projects in the Ethereum and cryptocurrency ecosystem.  0.099x the total amount sold (60102216 ETH) will be allocated to the organization to compensate early contributors and pay ETH-denominated expenses before the genesis block.  0.099x the total amount sold will be maintained as a long-term reserve.  0.26x the total amount sold will be allocated to miners per year forever after that point.      Group  At launch  After 1 year  After 5 years      Currency units  1.198X  1.458X  2.498X    Purchasers  83.5%  68.6%  40.0%    Reserve spent pre-sale  8.26%  6.79%  3.96%    Reserve used post-sale  8.26%  6.79%  3.96%    Miners  0%  17.8%  52.0%     Long-Term Supply Growth Rate (percent)   Despite the linear currency issuance, just like with Bitcoin over time the supply growth rate nevertheless tends to zero  The two main choices in the above model are (1) the existence and size of an endowment pool, and (2) the existence of a permanently growing linear supply, as opposed to a capped supply as in Bitcoin. The justification of the endowment pool is as follows. If the endowment pool did not exist, and the linear issuance reduced to 0.217x to provide the same inflation rate, then the total quantity of ether would be 16.5% less and so each unit would be 19.8% more valuable. Hence, in the equilibrium 19.8% more ether would be purchased in the sale, so each unit would once again be exactly as valuable as before. The organization would also then have 1.198x as much BTC, which can be considered to be split into two slices: the original BTC, and the additional 0.198x. Hence, this situation is  exactly equivalent  to the endowment, but with one important difference: the organization holds purely BTC, and so is not incentivized to support the value of the ether unit.  The permanent linear supply growth model reduces the risk of what some see as excessive wealth concentration in Bitcoin, and gives individuals living in present and future eras a fair chance to acquire currency units, while at the same time retaining a strong incentive to obtain and hold ether because the \"supply growth rate\" as a percentage still tends to zero over time. We also theorize that because coins are always lost over time due to carelessness, death, etc, and coin loss can be modeled as a percentage of the total supply per year, that the total currency supply in circulation will in fact eventually stabilize at a value equal to the annual issuance divided by the loss rate (eg. at a loss rate of 1%, once the supply reaches 26X then 0.26X will be mined and 0.26X lost every year, creating an equilibrium).  Note that in the future, it is likely that Ethereum will switch to a proof-of-stake model for security, reducing the issuance requirement to somewhere between zero and 0.05X per year. In the event that the Ethereum organization loses funding or for any other reason disappears, we leave open a \"social contract\": anyone has the right to create a future candidate version of Ethereum, with the only condition being that the quantity of ether must be at most equal to  60102216 * (1.198 + 0.26 * n)  where  n  is the number of years after the genesis block. Creators are free to crowd-sell or otherwise assign some or all of the difference between the PoS-driven supply expansion and the maximum allowable supply expansion to pay for development. Candidate upgrades that do not comply with the social contract may justifiably be forked into compliant versions.", 
            "title": "\u8d27\u5e01\u548c\u53d1\u884c"
        }, 
        {
            "location": "/Basics/White-Paper/#_26", 
            "text": "The Bitcoin mining algorithm works by having miners compute SHA256 on slightly modified versions of the block header millions of times over and over again, until eventually one node comes up with a version whose hash is less than the target (currently around 2 192 ). However, this mining algorithm is vulnerable to two forms of centralization. First, the mining ecosystem has come to be dominated by ASICs (application-specific integrated circuits), computer chips designed for, and therefore thousands of times more efficient at, the specific task of Bitcoin mining. This means that Bitcoin mining is no longer a highly decentralized and egalitarian pursuit, requiring millions of dollars of capital to effectively participate in. Second, most Bitcoin miners do not actually perform block validation locally; instead, they rely on a centralized mining pool to provide the block headers. This problem is arguably worse: as of the time of this writing, the top three mining pools indirectly control roughly 50% of processing power in the Bitcoin network, although this is mitigated by the fact that miners can switch to other mining pools if a pool or coalition attempts a 51% attack.  The current intent at Ethereum is to use a mining algorithm where miners are required to fetch random data from the state, compute some randomly selected transactions from the last N blocks in the blockchain, and return the hash of the result. This has two important benefits. First, Ethereum contracts can include any kind of computation, so an Ethereum ASIC would essentially be an ASIC for general computation - ie. a better CPU. Second, mining requires access to the entire blockchain, forcing miners to store the entire blockchain and at least be capable of verifying every transaction. This removes the need for centralized mining pools; although mining pools can still serve the legitimate role of evening out the randomness of reward distribution, this function can be served equally well by peer-to-peer pools with no central control.  This model is untested, and there may be difficulties along the way in avoiding certain clever optimizations when using contract execution as a mining algorithm. However, one notably interesting feature of this algorithm is that it allows anyone to \"poison the well\", by introducing a large number of contracts into the blockchain specifically designed to stymie certain ASICs. The economic incentives exist for ASIC manufacturers to use such a trick to attack each other. Thus, the solution that we are developing is ultimately an adaptive economic human solution rather than purely a technical one.", 
            "title": "\u91c7\u77ff\u4e2d\u5fc3"
        }, 
        {
            "location": "/Basics/White-Paper/#_27", 
            "text": "One common concern about Ethereum is the issue of scalability. Like Bitcoin, Ethereum suffers from the flaw that every transaction needs to be processed by every node in the network. With Bitcoin, the size of the current blockchain rests at about 15 GB, growing by about 1 MB per hour. If the Bitcoin network were to process Visa's 2000 transactions per second, it would grow by 1 MB per three seconds (1 GB per hour, 8 TB per year). Ethereum is likely to suffer a similar growth pattern, worsened by the fact that there will be many applications on top of the Ethereum blockchain instead of just a currency as is the case with Bitcoin, but ameliorated by the fact that Ethereum full nodes need to store just the state instead of the entire blockchain history.  The problem with such a large blockchain size is centralization risk. If the blockchain size increases to, say, 100 TB, then the likely scenario would be that only a very small number of large businesses would run full nodes, with all regular users using light SPV nodes. In such a situation, there arises the potential concern that the full nodes could band together and all agree to cheat in some profitable fashion (eg. change the block reward, give themselves BTC). Light nodes would have no way of detecting this immediately. Of course, at least one honest full node would likely exist, and after a few hours information about the fraud would trickle out through channels like Reddit, but at that point it would be too late: it would be up to the ordinary users to organize an effort to blacklist the given blocks, a massive and likely infeasible coordination problem on a similar scale as that of pulling off a successful 51% attack. In the case of Bitcoin, this is currently a problem, but there exists a blockchain modification  suggested by Peter Todd  which will alleviate this issue.  In the near term, Ethereum will use two additional strategies to cope with this problem. First, because of the blockchain-based mining algorithms, at least every miner will be forced to be a full node, creating a lower bound on the number of full nodes. Second and more importantly, however, we will include an intermediate state tree root in the blockchain after processing each transaction. Even if block validation is centralized, as long as one honest verifying node exists, the centralization problem can be circumvented via a verification protocol. If a miner publishes an invalid block, that block must either be badly formatted, or the state  S[n]  is incorrect. Since  S[0]  is known to be correct, there must be some first state  S[i]  that is incorrect where  S[i-1]  is correct. The verifying node would provide the index  i , along with a \"proof of invalidity\" consisting of the subset of Patricia tree nodes needing to process  APPLY(S[i-1],TX[i]) -  S[i] . Nodes would be able to use those nodes to run that part of the computation, and see that the  S[i]  generated does not match the  S[i]  provided.  Another, more sophisticated, attack would involve the malicious miners publishing incomplete blocks, so the full information does not even exist to determine whether or not blocks are valid. The solution to this is a challenge-response protocol: verification nodes issue \"challenges\" in the form of target transaction indices, and upon receiving a node a light node treats the block as untrusted until another node, whether the miner or another verifier, provides a subset of Patricia nodes as a proof of validity.", 
            "title": "\u53ef\u6269\u5c55\u6027"
        }, 
        {
            "location": "/Basics/White-Paper/#_28", 
            "text": "The Ethereum protocol was originally conceived as an upgraded version of a cryptocurrency, providing advanced features such as on-blockchain escrow, withdrawal limits, financial contracts, gambling markets and the like via a highly generalized programming language. The Ethereum protocol would not \"support\" any of the applications directly, but the existence of a Turing-complete programming language means that arbitrary contracts can theoretically be created for any transaction type or application. What is more interesting about Ethereum, however, is that the Ethereum protocol moves far beyond just currency. Protocols around decentralized file storage, decentralized computation and decentralized prediction markets, among dozens of other such concepts, have the potential to substantially increase the efficiency of the computational industry, and provide a massive boost to other peer-to-peer protocols by adding for the first time an economic layer. Finally, there is also a substantial array of applications that have nothing to do with money at all.  The concept of an arbitrary state transition function as implemented by the Ethereum protocol provides for a platform with unique potential; rather than being a closed-ended, single-purpose protocol intended for a specific array of applications in data storage, gambling or finance, Ethereum is open-ended by design, and we believe that it is extremely well-suited to serving as a foundational layer for a very large number of both financial and non-financial protocols in the years to come.", 
            "title": "\u7ed3\u8bba"
        }, 
        {
            "location": "/Basics/White-Paper/#_29", 
            "text": "", 
            "title": "\u7b14\u8bb0\u548c\u8fdb\u4e00\u6b65\u9605\u8bfb"
        }, 
        {
            "location": "/Basics/White-Paper/#_30", 
            "text": "A sophisticated reader may notice that in fact a Bitcoin address is the hash of the elliptic curve public key, and not the public key itself. However, it is in fact perfectly legitimate cryptographic terminology to refer to the pubkey hash as a public key itself. This is because Bitcoin's cryptography can be considered to be a custom digital signature algorithm, where the public key consists of the hash of the ECC pubkey, the signature consists of the ECC pubkey concatenated with the ECC signature, and the verification algorithm involves checking the ECC pubkey in the signature against the ECC pubkey hash provided as a public key and then verifying the ECC signature against the ECC pubkey.  Technically, the median of the 11 previous blocks.  Internally, 2 and \"CHARLIE\" are both numbers, with the latter being in big-endian base 256 representation. Numbers can be at least 0 and at most 2 256 -1.", 
            "title": "\u7b14\u8bb0"
        }, 
        {
            "location": "/Basics/White-Paper/#_31", 
            "text": "\u5185\u5728\u89c4\u5b9a  \u667a\u80fd\u8d22\u4ea7  \u667a\u80fd\u5408\u7ea6  B-money  \u53ef\u91cd\u7528\u7684\u5de5\u4f5c\u8bc1\u660e  \u62e5\u6709\u8457\u4f5c\u6743\u5b89\u5168\u5c5e\u6027\u6807\u9898  \u6bd4\u7279\u5e01\u767d\u76ae\u4e66  \u540d\u5e01  Zooko's triangle  \u5f69\u5e01\u767d\u76ae\u4e66  \u4e3b\u5e01\u767d\u76ae\u4e66  \u65e0\u5fc3\u81ea\u6cbb\u516c\u53f8\uff0c\u6bd4\u7279\u5e01\u6742\u5fd7  \u7b80\u5316\u4ed8\u6b3e\u786e\u8ba4  \u6885\u514b\u5c14\u6811  \u5e15\u7279\u4e3d\u590f\u6811  \u9b3c  StorJ\u548c\u81ea\u6cbb\u4ee3\u7406, Jeff Garzik  Mike Hearn\u5728\u56fe\u7075\u8282\u4e0a\u7684\u667a\u80fd\u8d22\u4ea7  \u4ee5\u592a\u574a RLP  \u4ee5\u592a\u574a\u6885\u514b\u52d2\u5e15\u7279\u91cc\u590f\u6811  \u9ed8\u514b\u5c14\u5408\u96c6\u6811\u4e0a\u7684\u5f7c\u5f97\u00b7\u6258\u5fb7", 
            "title": "\u8fdb\u4e00\u6b65\u9605\u8bfb"
        }, 
        {
            "location": "/Basics/Design-Rationale/", 
            "text": "\u8bbe\u8ba1\u539f\u7406\n\n\nAlthough Ethereum borrows many ideas that have already been tried and tested for half a decade in older cryptocurrencies like Bitcoin, there are a number of places in which Ethereum diverges from the most common way of handling certain protocol features, and there are also many situations in which Ethereum has been forced to develop completely new economic approaches because it offers functionality that is not offered by other existing systems. The purpose of this document will be to detail all of the finer potentially nonobvious or in some cases controversial decisions that were made in the process of building the Ethereum protocol, as well as showing the risks involved in both our approach and possible alternatives.\n\n\n\u539f\u5219\n\n\nThe Ethereum protocol design process follows a number of principles:\n\n\n\n\nSandwich complexity model\n: we believe that the bottom level architecture of Ethereum should be as simple as possible, and the interfaces to Ethereum (including high level programming languages for developers and the user interface for users) should be as easy to understand as possible. Where complexity is inevitable, it should be pushed into the \"middle layers\" of the protocol, that are not part of the core consensus but are also not seen by end users - high-level-language compilers, argument serialization and deserialization scripts, storage data structure models, the leveldb storage interface and the wire protocol, etc. However, this preference is not absolute.\n\n\nFreedom\n: users should not be restricted in what they use the Ethereum protocol for, and we should not attempt to preferentially favor or disfavor certain kinds of Ethereum contracts or transactions based on the nature of their purpose. This is similar to the guiding principle behind the concept of \"net neutrality\". One example of this principle \nnot\n being followed is the situation in the Bitcoin transaction protocol where use of the blockchain for \"off-label\" purposes (eg. data storage, meta-protocols) is discouraged, and in some cases explicit quasi-protocol changes (eg. OP_RETURN restriction to 40 bytes) are made to attempt to attack applications using the blockchain in \"unauthorized\" ways. In Ethereum, we instead strongly favor the approach of setting up transaction fees in such a way as to be roughly incentive-compatible, such that users that use the blockchain in bloat-producing ways internalize the cost of their activities (ie. Pigovian taxation).\n\n\nGeneralization\n: protocol features and opcodes in Ethereum should embody maximally low-level concepts, so that they can be combined in arbitrary ways including ways that may not seem useful today but which may become useful later, and so that a bundle of low-level concepts can be made more efficient by stripping out some of its functionality when it is not necessary. An example of this principle being followed is our choice of a LOG opcode as a way of feeding information to (particularly light client) dapps, as opposed to simply logging all transactions and messages as was internally suggested earlier - the concept of \"message\" is really the agglomeration of multiple concepts, including \"function call\" and \"event interesting to outside watchers\", and it is worth separating the two.\n\n\nWe Have No Features\n: as a corollary to generalization, we often refuse to build in even very common high-level use cases as intrinsic parts of the protocol, with the understanding that if people really want to do it they can always create a sub-protocol (eg. ether-backed subcurrency, bitcoin/litecoin/dogecoin sidechain, etc) inside of a contract. An example of this is the lack of a Bitcoin-like \"locktime\" feature in Ethereum, as such a feature can be simulated via a protocol where users send \"signed data packets\" and those data packets can be fed into a specialized contract that processes them and performs some corresponding function if the data packet is in some contract-specific sense valid.\n\n\nNon-risk-aversion\n: we are okay with higher degrees of risk if a risk-increasing change provides very substantial benefits (eg. generalized state transitions, 50x faster block times, consensus efficiency, etc)\n\n\n\n\nThese principles are all involved in guiding Ethereum development, but they are not absolute; in some cases, desire to reduce development time or not to try too many radical things at once has led us to delay certain changes, even some that are obviously beneficial, to a future release (eg. Ethereum 1.1).\n\n\n\u533a\u5757\u94fe\u534f\u8bae\n\n\nThis section provides a description of some of the blockchain-level protocol changes made in Ethereum, including how blocks and transactions work, how data is serialized and stored, and the mechanisms behind accounts.\n\n\n\u5e10\u6237\uff0c\u800c\u4e0d\u662fUTXO\n\n\nBitcoin, along with many of its derivatives, stores data about users' balances in a structure based on \nunspent transaction outputs\n (UTXOs): the entire state of the system consists of a set of \"unspent outputs\" (think, \"coins\"), such that each coin has an owner and a value, and a transaction spends one or more coins and creates one or more new coins, subject to the validity constraints:\n\n\n\n\nEvery referenced input must be valid and not yet spent\n\n\nThe transaction must have a signature matching the owner of the input for every input\n\n\nThe total value of the inputs must equal or exceed the total value of the outputs\n\n\n\n\nA user's \"balance\" in the system is thus the total value of the set of coins for which the user has a private key capable of producing a valid signature.\n\n\n\n(Image from https://bitcoin.org/en/developer-guide)\n\n\nEthereum jettisons this scheme in favor of a simpler approach: the state stores a list of accounts where each account has a balance, as well as Ethereum-specific data (code and internal storage), and a transaction is valid if the sending account has enough balance to pay for it, in which case the sending account is debited and the receiving account is credited with the value. If the receiving account has code, the code runs, and internal storage may also be changed, or the code may even create additional messages to other accounts which lead to further debits and credits.\n\n\nThe benefits of UTXOs are:\n\n\n\n\nHigher degree of privacy\n: if a user uses a new address for each transaction that they receive then it will often be difficult to link accounts to each other. This applies greatly to currency, but less to arbitrary dapps, as arbitrary dapps often necessarily involve keeping track of complex bundled state of users and there may not exist such an easy user state partitioning scheme as in currency.\n\n\nPotential scalability paradigms\n: UTXOs are more theoretically compatible with certain kinds of scalability paradigms, as we can rely on only the owner of some coins maintaining a Merkle proof of ownership, and even if everyone including the owner decides to forget that data then only the owner is harmed. In an account paradigm, everyone losing the portion of a Merkle tree corresponding to an account would make it impossible to process messages that affect that account at all in any way, including sending to it. However, non-UTXO-dependent scalability paradigms do exist.\n\n\n\n\nThe benefits of accounts are:\n\n\n\n\nLarge space savings\n: for example, if an account has 5 UTXO, then switching from a UTXO model to an account model would reduce the space requirements from (20 + 32 + 8) * 5 = 300 bytes (20 for the address, 32 for the txid and 8 for the value) to 20 + 8 + 2 = 30 bytes (20 for the address, 8 for the value, 2 for a nonce(see below)). In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. Additionally, transactions can be smaller (eg. 100 bytes in Ethereum vs. 200-250 bytes in Bitcoin) because every transaction need only make one reference and one signature and produces one output.\n\n\nGreater fungibility\n: because there is no blockchain-level concept of the source of a specific set of coins, it becomes less practical, both technically and legally, to institute a redlist/blacklisting scheme and to draw a distinction between coins depending on where they come from.\n\n\nSimplicity\n: easier to code and understand, especially once more complex scripts become involved. Although it is possible to shoehorn arbitrary decentralized applications into a UTXO paradigm, essentially by giving scripts the ability to restrict what kinds of UTXO a given UTXO can be spent to, and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate, such a paradigm is much more complicated and ugly than just using accounts.\n\n\nConstant light client reference\n: light clients can at any point access all data related to an account by scanning down the state tree in a specific direction. In a UTXO paradigm, the references change with each transaction, a particularly burdensome problem for long-running dapps that try to use the above mentioned state-root-in-UTXO propagation mechanism.\n\n\n\n\nWe have decided that, particularly because we are dealing with dapps containing arbitrary state and code, the benefits of accounts massively outweigh the alternatives. Additionally, in the spirit of the We Have No Features principle, we note that if people really do care about privacy then mixers and coinjoin can be built via signed-data-packet protocols inside of contracts.\n\n\nOne weakness of the account paradigm is that in order to prevent replay attacks, every transaction must have a \"nonce\", such that the account keeps track of the nonces used and only accepts a transaction if its nonce is 1 after the last nonce used. This means that even no-longer-used accounts can never be pruned from the account state. A simple solution to this problem is to require transactions to contain a block number, making them un-replayable after some period of time, and reset nonces once every period. Miners or other users will need to \"ping\" unused accounts in order to delete them from the state, as it would be too expensive to do a full sweep as part of the blockchain protocol itself. We did not go with this mechanism only to speed up development for 1.0; 1.1 and beyond will likely use such a system.\n\n\nMerkle\u5e15\u7279\u91cc\u590f\u6811\n\n\nThe Merkle Patricia tree/trie, previously envisioned by Alan Reiner and implemented in the Ripple protocol, is the primary data structure of Ethereum, and is used to store all account state, as well as transactions and receipts in each block. The MPT is a combination of a \nMerkle tree\n and \nPatricia tree\n, taking the elements of both to create a structure that has both of the following properties:\n\n\n\n\nEvery unique set of key/value pairs maps uniquely to a root hash, and it is not possible to spoof membership of a key/value pair in a trie (unless an attacker has ~2^128 computing power)\n\n\nIt is possible to change, add or delete key/value pairs in logarithmic time\n\n\n\n\nThis gives us a way of providing an efficient, easily updateable, \"fingerprint\" of our entire state tree. The Ethereum MPT is formally described here: https://github.com/ethereum/wiki/wiki/Patricia-Tree\n\n\nSpecific design decisions in the MPT include:\n\n\n\n\nHaving two classes of nodes\n, kv nodes and diverge nodes (see MPT spec for more details). The presence of kv nodes increases efficiency because if a tree is sparse in a particular area the kv node will serve as a \"shortcut\" removing the need to have a tree of depth 64.\n\n\nMaking diverge nodes hexary and not binary\n: this was done to improve lookup efficiency. We now recognize that this choice was suboptimal, as the lookup efficiency of a hexary tree can be simulated in a binary paradigm by storing nodes batched. However, because the trie construction is so easy to implement incorrectly and end up with at the very least state root mismatches, we have decided to table such a reorganization until 1.1.\n\n\nNo distinction between empty value and non-membership\n: this was done for simplicity, and because it works well with Ethereum's default that values that are unset (eg. balances) generally mean zero and the empty string is used to represent zero. However, we do note that it sacrifices some generality and is thus slightly suboptimal.\n\n\nDistinction between terminating and non-terminating nodes\n: technically, the \"is this node terminating\" flag is unnecessary, as all tries in Ethereum are used to store static key lengths, but we added it anyway to increase generality, hoping that the Ethereum MPT implementations will be used as-is by other cryptographic protocols.\n\n\nUsing sha3(k) as the key in the \"secure tree\"\n (used in the state and account storage tries): this makes it much more difficult to DoS the trie by setting up maximally unfavorable chains of diverge nodes 64 levels deep and repeatedly calling SLOAD and SSTORE on them. Note that this makes it more difficult to enumerate the tree; if you want to have enumeration capability in your client, the simplest approach is to maintain a database mapping \nsha3(k) -\n k\n.\n\n\n\n\nRLP\n\n\nRLP (\"recursive length prefix\") encoding is the main serialization format used in Ethereum, and is used everywhere - for blocks, transactions, account state data and wire protocol messages. RLP is formally described here: https://github.com/ethereum/wiki/wiki/RLP\n\n\nRLP is intended to be a highly minimalistic serialization format; its sole purpose is to store nested arrays of bytes. Unlike \nprotobuf\n, \nBSON\n and other existing solutions, RLP does not attempt to define any specific data types such as booleans, floats, doubles or even integers; instead, it simply exists to store structure, in the form of nested arrays, and leaves it up to the protocol to determine the meaning of the arrays. Key/value maps are also not explicitly supported; the semi-official suggestion for supporting key/value maps is to represent such maps as \n[[k1, v1], [k2, v2], ...]\n where \nk1, k2...\n are sorted using the standard ordering for strings.\n\n\nThe alternative to RLP would have been using an existing algorithm such as protobuf or BSON; however, we prefer RLP because of (1) simplicity of implementation, and (2) guaranteed absolute byte-perfect consistency. Key/value maps in many languages don't have an explicit ordering, and floating point formats have many special cases, potentially leading to the same data leading to different encodings and thus different hashes. By developing a protocol in-house we can be assured that it is designed with these goals in mind (this is a general principle that applies also to other parts of the code, eg. the VM). Note that bencode, used by BitTorrent, may have provided a passable alternative for RLP, although its use of decimal encoding for lengths makes it slightly suboptimal compared to the binary RLP.\n\n\n\u538b\u7f29\u7b97\u6cd5\n\n\nThe wire protocol and the database both use a custom compression algorithm to store data. The algorithm can best be described as run-length-encoding zeroes and leaving other values as they are, with the exception of a few special cases for common values like \nsha3('')\n. For example:\n\n\n compress(\nhorse\n)\n\nhorse\n\n\n compress(\ndonkey dragon 1231231243\n)\n\ndonkey dragon 1231231243\n\n\n compress(\n\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97\n)\n\n\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97\n\n\n compress(\n\\xc5\\xd2F\\x01\\x86\\xf7#\n\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82\n;{\\xfa\\xd8\\x04]\\x85\\xa4p\n)\n\n\\xfe\\x01\n\n\n\n\n\n\nBefore the compression algorithm existed, many parts of the Ethereum protocol had a number of special cases; for example, \nsha3\n was often overridden so that \nsha3('') = ''\n, as that would save 64 bytes from not needing to store code or storage in accounts. However, a change was made recently where all of these special cases were removed, making Ethereum data structures much bulkier by default, instead adding the data saving functionality to a layer outside the blockchain protocol by putting it on the wire protocol and seamlessly inserting it into users' database implementations. This adds modularity, simplifying the consensus layer, and also allows continued upgrades to the compression algorithm to be deployed relatively easily (eg. via network protocol versions).\n\n\nTrie\u7684\u7528\u6cd5\n\n\nWarning: this section assumes knowledge of how bloom filters work. For an introduction, see http://en.wikipedia.org/wiki/Bloom_filter\n\n\nEvery block header in the Ethereum blockchain contains pointers to three tries: the \nstate trie\n, representing the entire state after accessing the block, the \ntransaction trie\n, representing all transactions in the block keyed by index (ie. key 0: the first transaction to execute, key 1: the second transaction, etc), and the \nreceipt tree\n, representing the \"receipts\" corresponding to each transaction. A receipt for a transaction is an RLP-encoded data structure:\n\n\n[ medstate, gas_used, logbloom, logs ]\n\n\n\n\n\nWhere:\n\n\n\n\nmedstate\n is the state trie root after processing the transaction\n\n\ngas_used\n is the amount of gas used after processing the transaction\n\n\nlogs\n is a list of items of the form \n[address, [topic1, topic2...], data]\n that are produced by the \nLOG0\n ... \nLOG4\n opcodes during the execution of the transaction (including by the main call and sub-calls). \naddress\n is the address of the contract that produced the log, the topics are up to 4 32-byte values, and the data is an arbitrarily sized byte array.\n\n\nlogbloom\n is a bloom filter made up of the addresses and topics of all logs in the transaction.\n\n\n\n\nThere is also a bloom in the block header, which is the OR of all of the blooms for the transactions in the block. The purpose of this construction is to make the Ethereum protocol light-client friendly in as many ways as possible. For more details on Ethereum light clients and their use cases, see the \nlight client page (principles section)\n.\n\n\n\u53d4\u53d4\u6fc0\u52b1\n\n\nThe \"Greedy Heaviest Observed Subtree\" (GHOST) protocol is an innovation \nfirst introduced\n by Yonatan Sompolinsky and Aviv Zohar in December 2013, and is the first serious attempt at solving the issues preventing much faster block times. The motivation behind GHOST is that blockchains with fast confirmation times currently suffer from reduced security due to a high stale rate - because blocks take a certain time to propagate through the network, if miner A mines a block and then miner B happens to mine another block before miner A's block propagates to B, miner B's block will end up wasted (\"stale\") and will not contribute to network security. Furthermore, there is a centralization issue: if miner A is a mining pool with 30% hashpower and B has 10% hashpower, A will have a risk of producing a stale block 70% of the time (since the other 30% of the time A produced the last block and so will get mining data immediately) whereas B will have a risk of producing a stale block 90% of the time. Thus, if the block interval is short enough for the stale rate to be high, A will be substantially more efficient simply by virtue of its size. With these two effects combined, blockchains which produce blocks quickly are very likely to lead to one mining pool having a large enough percentage of the network hashpower to have de facto control over the mining process.\n\n\nAs described by Sompolinsky and Zohar, GHOST solves the first issue of network security loss by including stale blocks in the calculation of which chain is the \"longest\"; that is to say, not just the parent and further ancestors of a block, but also the stale descendants of the block's ancestor (in Ethereum jargon, \"uncles\") are added to the calculation of which block has the largest total proof of work backing it.\n\n\nTo solve the second issue of centralization bias, we adopt a different strategy: we provide block rewards to stales: a stale block receives 7/8 (87.5%) of its base reward, and the nephew that includes the stale block receives 1/32 (3.125%) of the base reward as an inclusion bounty. Transaction fees, however, are not awarded to uncles or nephews.\n\n\nIn Ethereum, stale block can only be included as an uncle by up to the seventh-generation descendant of one of its direct siblings, and not any block with a more distant relation. This was done for several reasons. First, unlimited GHOST would include too many complications into the calculation of which uncles for a given block are valid. Second, unlimited uncle incentivization as used in Ethereum removes the incentive for a miner to mine on the main chain and not the chain of a public attacker. Finally, calculations show that restricting to seven levels provides most of the desired effect without many of the negative consequences.\n\n\n\n\nA simulator that measures centralization risks is available at https://github.com/ethereum/economic-modeling/blob/master/ghost.py\n\n\nA high-level discussion can be found at https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\n\n\n\n\nDesign decisions in our block time algorithm include:\n\n\n\n\n12 second block time\n: 12 seconds was chosen as a time that is as fast as possible, but is at the same time substantially longer than network latency. A \n2013 paper\n by Decker and Wattenhofer in Zurich measures Bitcoin network latency, and determines that 12.6 seconds is the time it takes for a new block to propagate to 95% of nodes; however, the paper also points out that the bulk of the propagation time is proportional to block size, and thus in a faster currency we can expect the propagation time to be drastically reduced. The constant portion of the propagation interval is about 2 seconds; however, for safety we assume that blocks take 12 seconds to propagate in our analysis.\n\n\n7 block ancestor limit\n: this is part of a design goal of wanting to make block history very quickly \"forgettable\" after a small number of blocks, and 7 blocks has been proven to provide most of the desired effect\n\n\n1 block descendant limit\n (eg. \nc(c(p(p(p(head)))))\n, where c = child and p = parent, is invalid): this is part of a design goal of simplicity, and the simulator above shows that it does not pose large centralization risks.\n\n\nUncle validity requirements\n: uncles have to be valid headers, not valid blocks. This is done for simplicity, and to maintain the model of a blockchain as being a linear data structure (and not a block-DAG, as in Sompolinsky and Zohar's newer models). Requiring uncles to be valid blocks is also a valid approach.\n\n\nReward distribution\n: 7/8 of the base mining reward to the uncle, 1/32 to the nephew, 0% of transaction fees to either. This will make uncle incentivization ineffective from a centralization perspective if fees dominate; however, this is one of the reasons why Ethereum is meant to continue issuing ether for as long as we continue using PoW.\n\n\n\n\nDifficulty Update Algorithm\n\n\nThe difficulty in Ethereum is currently updated according to the following rule:\n\n\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n    1 if block.timestamp - block.parent.timestamp \n 9 else\n    -1 if block.timestamp - block.parent.timestamp \n= 9\n\n\n\n\n\nThe design goals behind the difficulty update rule are:\n\n\n\n\nFast updating\n: the time between blocks should readjust quickly given increasing or decreasing hashpower\n\n\nLow volatility\n: the difficulty should not bounce excessively if the hashpower is constant\n\n\nSimplicity\n: the algorithm should be relatively simple to implement\n\n\nLow memory\n: the algorithm should not rely on more than a few blocks of history, and should include as few \"memory variables\" as possible. Assume that the last ten blocks, plus all memory variables placed in the block headers of the last ten blocks, are all that is available for the algorithm to work with\n\n\nNon-exploitability\n: the algorithm should not excessively encourage miners to fiddle with timestamps, or mining pools to repeatedly add and remove hashpower, in an attempt to maximize their revenue\n\n\n\n\nWe have already determined that our current algorithm is highly suboptimal on low volatility and non-exploitability, and at the very least we plan to switch the timestamps compares to be the parent and grandparent, so that miners only have the incentive to modify timestamps if they are mining two blocks in a row. Another more powerful formula with simulations is located at https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py (the simulator uses Bitcoin mining power, but uses the per-day average for the entire day; it at one point simulates a 95% crash in a single day).\n\n\n\u5929\u7136\u6c14\u548c\u8d39\u7528\n\n\nWhereas all transactions in Bitcoin are roughly the same, and thus their cost to the network can be modeled to a single unit, transactions in Ethereum are more complex, and so a transaction fee system needs to take into account many ingredients, including cost of bandwidth, cost of storage and cost of computation. Of particular importance is the fact that the Ethereum programming language is Turing-complete, and so transactions may use bandwidth, storage and computation in arbitrary quantities, and the latter may end up being used in quantities that due to the halting problem cannot even be reliably predicted ahead of time. Preventing denial-of-service attacks via infinite loops is a key objective.\n\n\nThe basic mechanism behind transaction fees is as follows:\n\n\n\n\nEvery transaction must specify a quantity of \"gas\" that it is willing to consume (called \nstartgas\n), and the fee that it is willing to pay per unit gas (\ngasprice\n). At the start of execution, \nstartgas * gasprice\n ether are removed from the transaction sender's account.\n\n\nAll operations during transaction execution, including database reads and writes, messages, and every computational step taken by the virtual machine consumes a certain quantity of gas.\n\n\nIf a transaction execution processes fully, consuming less gas than its specified limit, say with \ngas_rem\n gas remaining, then the transaction executes normally, and at the end of the execution the transaction sender receives a refund of \ngas_rem * gasprice\n and the miner of the block receives a reward of \n(startgas - gas_rem) * gasprice\n.\n\n\nIf a transaction \"runs out of gas\" mid-execution, then all execution reverts, but the transaction is nevertheless valid, and the only effect of the transaction is to transfer the entire sum \nstartgas * gasprice\n to the miner.\n\n\nWhen a contract sends a message to the other contract, it also has the option to set a gas limit specifically on the sub-execution arising out of that message. If the sub-execution runs out of gas, then the sub-execution is reverted, but the gas is nevertheless consumed.\n\n\n\n\nEach of the above components is necessary. For example:\n\n\n\n\nIf transactions did not need to specify a gas limit, then a malicious user could send a transaction that makes a multi-billion round loop, and no one would be able to process it since processing such a transaction would take longer than a block interval, but miners would not be able to tell beforehand, leading to a denial-of-service vulnerability.\n\n\nThe alternative to strict gas-counting, time-limiting, does not work because it is too highly subjective (some machines are faster than others, and even among identical machines close-calls will always exist)\n\n\nThe entire value \nstartgas * gasprice\n has to be taken out at the start as a deposit so that there arise no situations where an account \"bankrupts\" itself mid-execution and becomes unable to pay for its gas costs. Note that balance checking is not sufficient, because an account can send its balance somewhere else.\n\n\nIf execution did not revert in the event of an insufficient gas error, then contracts would need to take strong and difficult security measures to prevent themselves from being exploited by transactions or messages that provide only enough gas halfway through, thereby leading to some of the changes in a contract execution being executed but not others.\n\n\nIf sub-limits did not exist, then hostile accounts could enact a denial-of-service attack against other contracts by entering into agreements with them, and then inserting an infinite loop at the beginning of computation so that any attempts by the victim contract to compensate the attack contract or send a message to it would starve the entire transaction execution.\n\n\nRequiring transaction senders to pay for gas instead of contracts substantially increases developer usability. Very early versions of Ethereum had contracts pay for gas, but this led to the rather ugly problem that every contract had to implement \"guard\" code that would make sure that every incoming message compensated the contract with enough ether to pay for the gas that it consumed.\n\n\n\n\nNote the following particular features in gas costs:\n\n\n\n\n21000 gas is charged for any transaction as a \"base fee\". This covers the cost of an elliptic curve operation to recover the sender address from the signature as well as the disk and bandwidth space of storing the transaction.\n\n\nA transaction can include an unlimited amount of \"data\", and there exist opcodes in the virtual machine which allow the contract receiving a transaction to access this data. The \"intrinsic gas\" fee for data is 4 gas per zero byte and 68 gas per nonzero byte. This formula arose because we saw that most transaction data in contracts written by users was organized into a series of 32-byte arguments, most of which had many leading zero bytes, and given that such constructions seem inefficient but are actually efficient due to compression algorithms, we wanted to encourage their use in place of more complicated mechanisms which would try to tightly pack arguments according to the expected number of bytes, leading to very substantial complexity increase at compiler level. This is an exception to the sandwich complexity model, but a justified one due to the ratio of cost to benefit.\n\n\nThe cost of the SSTORE opcode, which sets values in account storage, is either: (i) 20000 gas when changing a zero value to a nonzero value, (ii) 5000 gas when changing a zero value to a zero value or a nonzero value to a nonzero value, or (iii) 5000 gas when changing a nonzero value to a zero value, plus a 20000 gas refund to be given at the end of successful transaction execution (ie. NOT an execution leading to an out-of-gas exception). Refunds are capped at 50% of the total gas spent by a transaction. This provides a small incentive to clear storage, as we noticed that lacking such an incentive many contracts would leave storage unused, leading to quickly increasing bloat, providing most of the benefits of \"charging rent\" for storage without the cost of losing the assurance that a contract once placed will continue to exist forever. The delayed refund mechanism is necessary to prevent denial-of-service attacks where the attacker sends a transaction with a low amount of gas that repeatedly clears a large number of storage slots as part of a long-running loop, and then runs out of gas, consuming a large amount of verifiers' computing power without actually clearing storage or spending a lot of gas. The 50% cap is needed to ensure that a miner given a transaction with some quantity of gas can still determine an upper bound on the computational time to execute the transaction.\n\n\nThere is no gas cost to data in messages provided by contracts. This is because there is no need to actually \"copy\" any data during a message call, as the call data can simply be viewed as a pointer to the parent contract's memory which will not change while the child execution is in progress.\n\n\nMemory is an infinitely expandable array. However, there is a gas cost of 1 per 32 bytes of memory expansion, rounding up.\n\n\nSome opcodes, whose computation time is highly argument-dependent, have variable gas costs. For example, the gas cost of EXP is 10 + 10 per byte in the exponent (ie. x^0 = 1 gas, x^1 ... x^255 = 2 gas, x^256 ... x^65535 = 3 gas, etc), and the gas cost of the copy opcodes (CALLDATACOPY, CODECOPY, EXTCODECOPY) is 1 + 1 per 32 bytes copies, rounding up (LOG also has a similar rule). The memory expansion gas cost is not sufficient to cover this, as it opens up a quadratic attack (50000 rounds of CALLDATACOPY of 50000 gas ~= 50000^2 computing effort, but only ~50000 gas before the variable gas cost was introduced)\n\n\nThe CALL opcode (and CALLCODE for symmetry) costs an additional 9000 gas if the value is nonzero. This is because any value transfer causes significant bloat to history storage for an archival node. Note that the actual fee \ncharged\n is 6700; on top of this we add a mandatory 2300 gas minimum that is automatically given to the recipient. This is in order to ensure that wallets that receive transactions to at least have enough gas to make a log of the transaction.\n\n\n\n\nThe other important part of the gas mechanism is the economics of the gas price itself. The default approach, used in Bitcoin, is to have purely voluntary fees, relying on miners to act as the gatekeepers and set dynamic minimums; the equivalent in Ethereum would be allowing transaction senders to set arbitrary gas costs. This approach has been received very favorably in the Bitcoin community particularly because it is \"market-based\", allowing supply and demand between miners and transaction senders to determine the price. The problem with this line of reasoning is, however, that transaction processing is not a market; although it is intuitively attractive to construe transaction processing as a service that the miner is offering to the sender, in reality every transaction that a miner includes will need to be processed by every node in the network, so the vast majority of the cost of transaction processing is borne by third parties and not the miner that is making the decision of whether or not to include it. Hence, tragedy-of-the-commons problems are very likely to occur.\n\n\nCurrently, due to a lack of clear information about how miners will behave in reality, we are going with a fairly simple approach: a voting system. Miners have the right to set the gas limit for the current block to be within ~0.0975% (1/1024) of the gas limit of the last block, and so the resulting gas limit should be the median of miners' preferences. The hope is that in the future we will be able to soft-fork this into a more precise algorithm.\n\n\n\u865a\u62df\u673a\n\n\nThe Ethereum virtual machine is the engine in which transaction code gets executed, and is the core differentiating feature between Ethereum and other systems. Note that the \nvirtual machine\n should be considered separately from the \ncontract and message model\n - for example, the SIGNEXTEND opcode is a feature of the VM, but the fact that contracts can call other contracts and specify gas limits to sub-calls is part of the contract and message model. Design goals in the EVM include:\n\n\n\n\nSimplicity\n: as few and as low-level opcodes as possible, as few data types as possible and as few virtual-machine-level constructs as possible\n\n\nTotal determinism\n: there should be absolutely no room for ambiguity in any part of the VM specification, and the results should be completely deterministic. Additionally, there should be a precise concept of computational step which can be measured so as to compute gas consumption.\n\n\nSpace savings\n: EVM assembly should be as compact as possible (eg. the 4000 byte base size of default C programs is NOT acceptable)\n\n\nSpecialization to expected applications\n: the ability to handle 20-byte addresses and custom cryptography with 32-byte values, modular arithmetic used in custom cryptography, read block and transaction data, interact with state, etc\n\n\nSimple security\n: it should be easy to come up with a gas cost model for operations that makes the VM non-exploitable\n\n\nOptimization-friendliness\n: it should be easy to apply optimizations so that JIT-compiled and otherwise sped-up versions of the VM can be built.\n\n\n\n\nSome particular design decisions that were made:\n\n\n\n\nTemporary/permanent storage distinction\n - a distinction exists between temporary storage, which exists within each instance of the VM and disappears when VM execution finishes, and permanent storage, which exists on the blockchain state level on a per-account basis. For example, suppose the following tree of execution takes place (using S for permanent storage and M for temporary): (i) A calls B, (ii) B sets \nB.S[0] = 5\n, \nB.M[0] = 9\n, (iii) B calls C, (iv) C calls B. At this point, if B tries to read \nB.S[0]\n, it will receive the value stored in B earlier, 5, but is B tries to read \nB.M[0]\n it will receive 0 because it is a new instance of the virtual machine with fresh temporary storage. If B now sets \nB.M[0] = 13\n and \nB.S[0] = 17\n in this inner call, and then both this inner call and C's call terminate, bringing the execution back to B's outer call, then B reading M will see \nB.M[0] = 9\n (since the last time this value was set was in the same VM execution instance) and \nB.S[0] = 17\n. If B's outer call ends and A calls B again, then B will see \nB.M[0] = 0\n and \nB.S[0] = 17\n. The purpose of this distinction is to (1) provide each execution instance with its own memory that is not subject to corruption by recursive calls, making secure programming easier, and (2) to provide a form of memory which can be manipulated very quickly, as storage updates are necessarily slow due to the need to modify the trie.\n\n\nStack/memory model\n - the decision was made early on to have three types of computational state (aside from the program counter which points to the next instruction): stack (a standard LIFO stack of 32-byte values), memory (an infinitely expandable temporary byte array) and storage (permanent storage). On the temporary storage side, the alternative to stack and memory is a memory-only paradigm, or some hybrid of registers and memory (not very different, as registers basically are a kind of memory). In such a case, every instruction would have three arguments, eg. \nADD R1 R2 R3: M[R1] = M[R2] + M[R3]\n. The stack paradigm was chosen for the obvious reason that it makes the code four times smaller.\n\n\n32 byte word size\n - the alternative is 4 or 8 byte words, as in most other architectures, or unlimited, as in Bitcoin. 4 or 8 byte words are too restrictive to store addresses and big values for crypto computations, and unlimited values are too hard to make a secure gas model around. 32 bytes is ideal because it is just large enough to store 32 byte values common in many crypto implementations, as well as addresses (and provides the ability to pack address and value into a single storage index as an optimization), but not so large as to be extremely inefficient.\n\n\nHaving our own VM at all\n - the alternative is reusing Java, or some Lisp dialect, or Lua. We decided that having a specialized VM was appropriate because (i) our VM spec is much simpler than many other virtual machines, because other virtual machines have to pay a much lower cost for complexity, whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures, (ii) it allows us to specialize the VM much more, eg. by having a 32 byte word size, (iii) it allows us not to have a very complex external dependency which may lead to installation difficulties, and (iv) a full security review of Ethereum specific to our particular security needs would necessitate a security review of the external VM anyway, so the effort savings are not that large.\n\n\nUsing a variable extendable memory size\n - we deemed a fixed memory size unnecessarily restrictive if the size is small and unnecessarily expensive if the size is large, and noted that if statements for memory access are necessary in any case to check for out-of-bounds access, so fixed size would not even make execution more efficient.\n\n\nNot having a stack size limit\n - no particular justification either way; note that limits are not strictly necessary in many cases as the combination of gas costs and a block-level gas limit will always act as a ceiling on the consumption of every resource.\n\n\nHaving a 1024 call depth limit\n - many programing languages break at high stack depths much more quickly than they break at high levels of memory usage or computational load, so the implied limit from the block gas limit may not be sufficient.\n\n\nNo types\n - done for simplicity. Instead, signed and unsigned opcodes for DIV, SDIV, MOD, SMOD are used instead (it turns out that for ADD and MUL the behavior of signed and unsigned opcodes is equivalent), and the transformations for fixed point arithmetic (high-depth fixed-point arithmetic is another benefit of 32-byte words) are in all cases simple, eg. at 32 bits of depth, \na * b -\n (a * b) / 2^32\n, \na / b -\n a * 2^32 / b\n, and +, - and * are unchanged from integer cases.\n\n\n\n\nThe function and purpose of some opcodes in the VM is obvious, however other opcodes are less so. Some particular justifications are given below:\n\n\n\n\nADDMOD\n, \nMULMOD\n: in most cases, \naddmod(a, b, c) = a * b % c\n. However, in the specific case of many classes of elliptic curve cryptography, 32-byte modular arithmetic is used, and doing \na * b % c\n directly is therefore actually doing \n((a * b) % 2^256) % c\n, which gives a completely different result. A formula that calculates \na * b % c\n with 32-byte values in 32 bytes of space is rather nontrivial and bulky.\n\n\nSIGNEXTEND\n: the purpose of SIGNEXTEND is to facilitate typecasting from a larger signed integer to a smaller signed integer. Small signed integers are useful because JIT-compiled virtual machines may in the future be able to detect long-running chunks of code that deals primarily with 32-byte integers and speed it up considerably.\n\n\nSHA3\n: SHA3 is very highly applicable in Ethereum code as secure infinite-sized hash maps that use storage will likely need to use a secure hash function so as to prevent malicious collisions, as well as for verifying Merkle trees and even verifying Ethereum-like data structures. A key point is that its companions \nSHA256\n, \nECRECOVER\n and \nRIPEMD160\n are included not as opcodes but as pseudo-contracts. The purpose of this is to place them into a separate category so that, if/when we come up with a proper \"native extensions\" system later, more such contracts can be added without filling up the opcode space.\n\n\nORIGIN\n: the primary use of the ORIGIN opcode, which provides the sender of a transaction, is to allow contracts to make refund payments for gas.\n\n\nCOINBASE\n: the primary uses of the COINBASE opcode are to (i) allow sub-currencies to contribute to network security if they so choose, and (ii) open up the use of miners as a decentralized economic set for sub-consensus-based applications like Schellingcoin.\n\n\nPREVHASH\n: used as a semi-secure source of randomness, and to allow contracts to evaluate Merkle tree proofs of state in the previous block without requiring a highly complex recursive \"Ethereum light client in Ethereum\" construction.\n\n\nEXTCODESIZE\n, \nEXTCODECOPY\n: the primary uses here are to allow contracts to check the code of other contracts against a template, or even simulating them, before interacting with them. See http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/ for applications.\n\n\nJUMPDEST\n: JIT-compiled virtual machines become much easier to implement when jump destinations are restricted to a few indices (specifically, the computational complexity of a variable-destination jump is roughly O(log(number of valid jump destinations)), although static jumps are always constant-time). Hence, we need (i) a restriction on valid variable jump destinations, and (ii) an incentive to use static over dynamic jumps. To meet both goals, we have the rules that (i) jumps that are immediately preceded by a push can jump anywhere but another jump, and (ii) other jumps can only jump to a JUMPDEST. The restriction against jumping on jumps is needed so that the question of whether a jump is dynamic or static can be determined by simply looking at the previous operation in the code. The lack of a need for JUMPDEST operations for static jumps is the incentive to use them. The prohibition against jumping into push data also speeds up JIT VM compilation and execution.\n\n\nLOG\n: LOG is meant to log events, see trie usage section above.\n\n\nCALLCODE\n: the purpose of this is to allow contracts to call \"functions\" in the form of code stored in other contracts, with a separate stack and memory, but using the contract's own storage. This makes it much easier to scalably implement \"standard libraries\" of code on the blockchain.\n\n\nSELFDESTRUCT\n: an opcode which allows a contract to quickly delete itself if it is no longer needed. The fact that SELFDESTRUCTs are processed at the end of transaction execution, and not immediately, is motivated by the fact that having the ability to revert SELFDESTRUCTs that were already executed would substantially increase the complexity of the cache that would be required in an efficient VM implementation.\n\n\nPC\n: although theoretically not necessary, as all instances of the PC opcode can be replaced by simply putting in the actual program counter at that index as a push, using PC in code allows for the creation of position-independent code (ie. compiled functions which can be copy/pasted into other contracts, and do not break if they end up at different indices).", 
            "title": "\u8bbe\u8ba1\u539f\u7406"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_1", 
            "text": "Although Ethereum borrows many ideas that have already been tried and tested for half a decade in older cryptocurrencies like Bitcoin, there are a number of places in which Ethereum diverges from the most common way of handling certain protocol features, and there are also many situations in which Ethereum has been forced to develop completely new economic approaches because it offers functionality that is not offered by other existing systems. The purpose of this document will be to detail all of the finer potentially nonobvious or in some cases controversial decisions that were made in the process of building the Ethereum protocol, as well as showing the risks involved in both our approach and possible alternatives.", 
            "title": "\u8bbe\u8ba1\u539f\u7406"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_2", 
            "text": "The Ethereum protocol design process follows a number of principles:   Sandwich complexity model : we believe that the bottom level architecture of Ethereum should be as simple as possible, and the interfaces to Ethereum (including high level programming languages for developers and the user interface for users) should be as easy to understand as possible. Where complexity is inevitable, it should be pushed into the \"middle layers\" of the protocol, that are not part of the core consensus but are also not seen by end users - high-level-language compilers, argument serialization and deserialization scripts, storage data structure models, the leveldb storage interface and the wire protocol, etc. However, this preference is not absolute.  Freedom : users should not be restricted in what they use the Ethereum protocol for, and we should not attempt to preferentially favor or disfavor certain kinds of Ethereum contracts or transactions based on the nature of their purpose. This is similar to the guiding principle behind the concept of \"net neutrality\". One example of this principle  not  being followed is the situation in the Bitcoin transaction protocol where use of the blockchain for \"off-label\" purposes (eg. data storage, meta-protocols) is discouraged, and in some cases explicit quasi-protocol changes (eg. OP_RETURN restriction to 40 bytes) are made to attempt to attack applications using the blockchain in \"unauthorized\" ways. In Ethereum, we instead strongly favor the approach of setting up transaction fees in such a way as to be roughly incentive-compatible, such that users that use the blockchain in bloat-producing ways internalize the cost of their activities (ie. Pigovian taxation).  Generalization : protocol features and opcodes in Ethereum should embody maximally low-level concepts, so that they can be combined in arbitrary ways including ways that may not seem useful today but which may become useful later, and so that a bundle of low-level concepts can be made more efficient by stripping out some of its functionality when it is not necessary. An example of this principle being followed is our choice of a LOG opcode as a way of feeding information to (particularly light client) dapps, as opposed to simply logging all transactions and messages as was internally suggested earlier - the concept of \"message\" is really the agglomeration of multiple concepts, including \"function call\" and \"event interesting to outside watchers\", and it is worth separating the two.  We Have No Features : as a corollary to generalization, we often refuse to build in even very common high-level use cases as intrinsic parts of the protocol, with the understanding that if people really want to do it they can always create a sub-protocol (eg. ether-backed subcurrency, bitcoin/litecoin/dogecoin sidechain, etc) inside of a contract. An example of this is the lack of a Bitcoin-like \"locktime\" feature in Ethereum, as such a feature can be simulated via a protocol where users send \"signed data packets\" and those data packets can be fed into a specialized contract that processes them and performs some corresponding function if the data packet is in some contract-specific sense valid.  Non-risk-aversion : we are okay with higher degrees of risk if a risk-increasing change provides very substantial benefits (eg. generalized state transitions, 50x faster block times, consensus efficiency, etc)   These principles are all involved in guiding Ethereum development, but they are not absolute; in some cases, desire to reduce development time or not to try too many radical things at once has led us to delay certain changes, even some that are obviously beneficial, to a future release (eg. Ethereum 1.1).", 
            "title": "\u539f\u5219"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_3", 
            "text": "This section provides a description of some of the blockchain-level protocol changes made in Ethereum, including how blocks and transactions work, how data is serialized and stored, and the mechanisms behind accounts.", 
            "title": "\u533a\u5757\u94fe\u534f\u8bae"
        }, 
        {
            "location": "/Basics/Design-Rationale/#utxo", 
            "text": "Bitcoin, along with many of its derivatives, stores data about users' balances in a structure based on  unspent transaction outputs  (UTXOs): the entire state of the system consists of a set of \"unspent outputs\" (think, \"coins\"), such that each coin has an owner and a value, and a transaction spends one or more coins and creates one or more new coins, subject to the validity constraints:   Every referenced input must be valid and not yet spent  The transaction must have a signature matching the owner of the input for every input  The total value of the inputs must equal or exceed the total value of the outputs   A user's \"balance\" in the system is thus the total value of the set of coins for which the user has a private key capable of producing a valid signature.  \n(Image from https://bitcoin.org/en/developer-guide)  Ethereum jettisons this scheme in favor of a simpler approach: the state stores a list of accounts where each account has a balance, as well as Ethereum-specific data (code and internal storage), and a transaction is valid if the sending account has enough balance to pay for it, in which case the sending account is debited and the receiving account is credited with the value. If the receiving account has code, the code runs, and internal storage may also be changed, or the code may even create additional messages to other accounts which lead to further debits and credits.  The benefits of UTXOs are:   Higher degree of privacy : if a user uses a new address for each transaction that they receive then it will often be difficult to link accounts to each other. This applies greatly to currency, but less to arbitrary dapps, as arbitrary dapps often necessarily involve keeping track of complex bundled state of users and there may not exist such an easy user state partitioning scheme as in currency.  Potential scalability paradigms : UTXOs are more theoretically compatible with certain kinds of scalability paradigms, as we can rely on only the owner of some coins maintaining a Merkle proof of ownership, and even if everyone including the owner decides to forget that data then only the owner is harmed. In an account paradigm, everyone losing the portion of a Merkle tree corresponding to an account would make it impossible to process messages that affect that account at all in any way, including sending to it. However, non-UTXO-dependent scalability paradigms do exist.   The benefits of accounts are:   Large space savings : for example, if an account has 5 UTXO, then switching from a UTXO model to an account model would reduce the space requirements from (20 + 32 + 8) * 5 = 300 bytes (20 for the address, 32 for the txid and 8 for the value) to 20 + 8 + 2 = 30 bytes (20 for the address, 8 for the value, 2 for a nonce(see below)). In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. Additionally, transactions can be smaller (eg. 100 bytes in Ethereum vs. 200-250 bytes in Bitcoin) because every transaction need only make one reference and one signature and produces one output.  Greater fungibility : because there is no blockchain-level concept of the source of a specific set of coins, it becomes less practical, both technically and legally, to institute a redlist/blacklisting scheme and to draw a distinction between coins depending on where they come from.  Simplicity : easier to code and understand, especially once more complex scripts become involved. Although it is possible to shoehorn arbitrary decentralized applications into a UTXO paradigm, essentially by giving scripts the ability to restrict what kinds of UTXO a given UTXO can be spent to, and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate, such a paradigm is much more complicated and ugly than just using accounts.  Constant light client reference : light clients can at any point access all data related to an account by scanning down the state tree in a specific direction. In a UTXO paradigm, the references change with each transaction, a particularly burdensome problem for long-running dapps that try to use the above mentioned state-root-in-UTXO propagation mechanism.   We have decided that, particularly because we are dealing with dapps containing arbitrary state and code, the benefits of accounts massively outweigh the alternatives. Additionally, in the spirit of the We Have No Features principle, we note that if people really do care about privacy then mixers and coinjoin can be built via signed-data-packet protocols inside of contracts.  One weakness of the account paradigm is that in order to prevent replay attacks, every transaction must have a \"nonce\", such that the account keeps track of the nonces used and only accepts a transaction if its nonce is 1 after the last nonce used. This means that even no-longer-used accounts can never be pruned from the account state. A simple solution to this problem is to require transactions to contain a block number, making them un-replayable after some period of time, and reset nonces once every period. Miners or other users will need to \"ping\" unused accounts in order to delete them from the state, as it would be too expensive to do a full sweep as part of the blockchain protocol itself. We did not go with this mechanism only to speed up development for 1.0; 1.1 and beyond will likely use such a system.", 
            "title": "\u5e10\u6237\uff0c\u800c\u4e0d\u662fUTXO"
        }, 
        {
            "location": "/Basics/Design-Rationale/#merkle", 
            "text": "The Merkle Patricia tree/trie, previously envisioned by Alan Reiner and implemented in the Ripple protocol, is the primary data structure of Ethereum, and is used to store all account state, as well as transactions and receipts in each block. The MPT is a combination of a  Merkle tree  and  Patricia tree , taking the elements of both to create a structure that has both of the following properties:   Every unique set of key/value pairs maps uniquely to a root hash, and it is not possible to spoof membership of a key/value pair in a trie (unless an attacker has ~2^128 computing power)  It is possible to change, add or delete key/value pairs in logarithmic time   This gives us a way of providing an efficient, easily updateable, \"fingerprint\" of our entire state tree. The Ethereum MPT is formally described here: https://github.com/ethereum/wiki/wiki/Patricia-Tree  Specific design decisions in the MPT include:   Having two classes of nodes , kv nodes and diverge nodes (see MPT spec for more details). The presence of kv nodes increases efficiency because if a tree is sparse in a particular area the kv node will serve as a \"shortcut\" removing the need to have a tree of depth 64.  Making diverge nodes hexary and not binary : this was done to improve lookup efficiency. We now recognize that this choice was suboptimal, as the lookup efficiency of a hexary tree can be simulated in a binary paradigm by storing nodes batched. However, because the trie construction is so easy to implement incorrectly and end up with at the very least state root mismatches, we have decided to table such a reorganization until 1.1.  No distinction between empty value and non-membership : this was done for simplicity, and because it works well with Ethereum's default that values that are unset (eg. balances) generally mean zero and the empty string is used to represent zero. However, we do note that it sacrifices some generality and is thus slightly suboptimal.  Distinction between terminating and non-terminating nodes : technically, the \"is this node terminating\" flag is unnecessary, as all tries in Ethereum are used to store static key lengths, but we added it anyway to increase generality, hoping that the Ethereum MPT implementations will be used as-is by other cryptographic protocols.  Using sha3(k) as the key in the \"secure tree\"  (used in the state and account storage tries): this makes it much more difficult to DoS the trie by setting up maximally unfavorable chains of diverge nodes 64 levels deep and repeatedly calling SLOAD and SSTORE on them. Note that this makes it more difficult to enumerate the tree; if you want to have enumeration capability in your client, the simplest approach is to maintain a database mapping  sha3(k) -  k .", 
            "title": "Merkle\u5e15\u7279\u91cc\u590f\u6811"
        }, 
        {
            "location": "/Basics/Design-Rationale/#rlp", 
            "text": "RLP (\"recursive length prefix\") encoding is the main serialization format used in Ethereum, and is used everywhere - for blocks, transactions, account state data and wire protocol messages. RLP is formally described here: https://github.com/ethereum/wiki/wiki/RLP  RLP is intended to be a highly minimalistic serialization format; its sole purpose is to store nested arrays of bytes. Unlike  protobuf ,  BSON  and other existing solutions, RLP does not attempt to define any specific data types such as booleans, floats, doubles or even integers; instead, it simply exists to store structure, in the form of nested arrays, and leaves it up to the protocol to determine the meaning of the arrays. Key/value maps are also not explicitly supported; the semi-official suggestion for supporting key/value maps is to represent such maps as  [[k1, v1], [k2, v2], ...]  where  k1, k2...  are sorted using the standard ordering for strings.  The alternative to RLP would have been using an existing algorithm such as protobuf or BSON; however, we prefer RLP because of (1) simplicity of implementation, and (2) guaranteed absolute byte-perfect consistency. Key/value maps in many languages don't have an explicit ordering, and floating point formats have many special cases, potentially leading to the same data leading to different encodings and thus different hashes. By developing a protocol in-house we can be assured that it is designed with these goals in mind (this is a general principle that applies also to other parts of the code, eg. the VM). Note that bencode, used by BitTorrent, may have provided a passable alternative for RLP, although its use of decimal encoding for lengths makes it slightly suboptimal compared to the binary RLP.", 
            "title": "RLP"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_4", 
            "text": "The wire protocol and the database both use a custom compression algorithm to store data. The algorithm can best be described as run-length-encoding zeroes and leaving other values as they are, with the exception of a few special cases for common values like  sha3('') . For example:   compress( horse ) horse   compress( donkey dragon 1231231243 ) donkey dragon 1231231243   compress( \\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97 ) \\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97   compress( \\xc5\\xd2F\\x01\\x86\\xf7# \\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82 ;{\\xfa\\xd8\\x04]\\x85\\xa4p ) \\xfe\\x01   Before the compression algorithm existed, many parts of the Ethereum protocol had a number of special cases; for example,  sha3  was often overridden so that  sha3('') = '' , as that would save 64 bytes from not needing to store code or storage in accounts. However, a change was made recently where all of these special cases were removed, making Ethereum data structures much bulkier by default, instead adding the data saving functionality to a layer outside the blockchain protocol by putting it on the wire protocol and seamlessly inserting it into users' database implementations. This adds modularity, simplifying the consensus layer, and also allows continued upgrades to the compression algorithm to be deployed relatively easily (eg. via network protocol versions).", 
            "title": "\u538b\u7f29\u7b97\u6cd5"
        }, 
        {
            "location": "/Basics/Design-Rationale/#trie", 
            "text": "Warning: this section assumes knowledge of how bloom filters work. For an introduction, see http://en.wikipedia.org/wiki/Bloom_filter  Every block header in the Ethereum blockchain contains pointers to three tries: the  state trie , representing the entire state after accessing the block, the  transaction trie , representing all transactions in the block keyed by index (ie. key 0: the first transaction to execute, key 1: the second transaction, etc), and the  receipt tree , representing the \"receipts\" corresponding to each transaction. A receipt for a transaction is an RLP-encoded data structure:  [ medstate, gas_used, logbloom, logs ]  Where:   medstate  is the state trie root after processing the transaction  gas_used  is the amount of gas used after processing the transaction  logs  is a list of items of the form  [address, [topic1, topic2...], data]  that are produced by the  LOG0  ...  LOG4  opcodes during the execution of the transaction (including by the main call and sub-calls).  address  is the address of the contract that produced the log, the topics are up to 4 32-byte values, and the data is an arbitrarily sized byte array.  logbloom  is a bloom filter made up of the addresses and topics of all logs in the transaction.   There is also a bloom in the block header, which is the OR of all of the blooms for the transactions in the block. The purpose of this construction is to make the Ethereum protocol light-client friendly in as many ways as possible. For more details on Ethereum light clients and their use cases, see the  light client page (principles section) .", 
            "title": "Trie\u7684\u7528\u6cd5"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_5", 
            "text": "The \"Greedy Heaviest Observed Subtree\" (GHOST) protocol is an innovation  first introduced  by Yonatan Sompolinsky and Aviv Zohar in December 2013, and is the first serious attempt at solving the issues preventing much faster block times. The motivation behind GHOST is that blockchains with fast confirmation times currently suffer from reduced security due to a high stale rate - because blocks take a certain time to propagate through the network, if miner A mines a block and then miner B happens to mine another block before miner A's block propagates to B, miner B's block will end up wasted (\"stale\") and will not contribute to network security. Furthermore, there is a centralization issue: if miner A is a mining pool with 30% hashpower and B has 10% hashpower, A will have a risk of producing a stale block 70% of the time (since the other 30% of the time A produced the last block and so will get mining data immediately) whereas B will have a risk of producing a stale block 90% of the time. Thus, if the block interval is short enough for the stale rate to be high, A will be substantially more efficient simply by virtue of its size. With these two effects combined, blockchains which produce blocks quickly are very likely to lead to one mining pool having a large enough percentage of the network hashpower to have de facto control over the mining process.  As described by Sompolinsky and Zohar, GHOST solves the first issue of network security loss by including stale blocks in the calculation of which chain is the \"longest\"; that is to say, not just the parent and further ancestors of a block, but also the stale descendants of the block's ancestor (in Ethereum jargon, \"uncles\") are added to the calculation of which block has the largest total proof of work backing it.  To solve the second issue of centralization bias, we adopt a different strategy: we provide block rewards to stales: a stale block receives 7/8 (87.5%) of its base reward, and the nephew that includes the stale block receives 1/32 (3.125%) of the base reward as an inclusion bounty. Transaction fees, however, are not awarded to uncles or nephews.  In Ethereum, stale block can only be included as an uncle by up to the seventh-generation descendant of one of its direct siblings, and not any block with a more distant relation. This was done for several reasons. First, unlimited GHOST would include too many complications into the calculation of which uncles for a given block are valid. Second, unlimited uncle incentivization as used in Ethereum removes the incentive for a miner to mine on the main chain and not the chain of a public attacker. Finally, calculations show that restricting to seven levels provides most of the desired effect without many of the negative consequences.   A simulator that measures centralization risks is available at https://github.com/ethereum/economic-modeling/blob/master/ghost.py  A high-level discussion can be found at https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/   Design decisions in our block time algorithm include:   12 second block time : 12 seconds was chosen as a time that is as fast as possible, but is at the same time substantially longer than network latency. A  2013 paper  by Decker and Wattenhofer in Zurich measures Bitcoin network latency, and determines that 12.6 seconds is the time it takes for a new block to propagate to 95% of nodes; however, the paper also points out that the bulk of the propagation time is proportional to block size, and thus in a faster currency we can expect the propagation time to be drastically reduced. The constant portion of the propagation interval is about 2 seconds; however, for safety we assume that blocks take 12 seconds to propagate in our analysis.  7 block ancestor limit : this is part of a design goal of wanting to make block history very quickly \"forgettable\" after a small number of blocks, and 7 blocks has been proven to provide most of the desired effect  1 block descendant limit  (eg.  c(c(p(p(p(head))))) , where c = child and p = parent, is invalid): this is part of a design goal of simplicity, and the simulator above shows that it does not pose large centralization risks.  Uncle validity requirements : uncles have to be valid headers, not valid blocks. This is done for simplicity, and to maintain the model of a blockchain as being a linear data structure (and not a block-DAG, as in Sompolinsky and Zohar's newer models). Requiring uncles to be valid blocks is also a valid approach.  Reward distribution : 7/8 of the base mining reward to the uncle, 1/32 to the nephew, 0% of transaction fees to either. This will make uncle incentivization ineffective from a centralization perspective if fees dominate; however, this is one of the reasons why Ethereum is meant to continue issuing ether for as long as we continue using PoW.", 
            "title": "\u53d4\u53d4\u6fc0\u52b1"
        }, 
        {
            "location": "/Basics/Design-Rationale/#difficulty-update-algorithm", 
            "text": "The difficulty in Ethereum is currently updated according to the following rule:  diff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n    1 if block.timestamp - block.parent.timestamp   9 else\n    -1 if block.timestamp - block.parent.timestamp  = 9  The design goals behind the difficulty update rule are:   Fast updating : the time between blocks should readjust quickly given increasing or decreasing hashpower  Low volatility : the difficulty should not bounce excessively if the hashpower is constant  Simplicity : the algorithm should be relatively simple to implement  Low memory : the algorithm should not rely on more than a few blocks of history, and should include as few \"memory variables\" as possible. Assume that the last ten blocks, plus all memory variables placed in the block headers of the last ten blocks, are all that is available for the algorithm to work with  Non-exploitability : the algorithm should not excessively encourage miners to fiddle with timestamps, or mining pools to repeatedly add and remove hashpower, in an attempt to maximize their revenue   We have already determined that our current algorithm is highly suboptimal on low volatility and non-exploitability, and at the very least we plan to switch the timestamps compares to be the parent and grandparent, so that miners only have the incentive to modify timestamps if they are mining two blocks in a row. Another more powerful formula with simulations is located at https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py (the simulator uses Bitcoin mining power, but uses the per-day average for the entire day; it at one point simulates a 95% crash in a single day).", 
            "title": "Difficulty Update Algorithm"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_6", 
            "text": "Whereas all transactions in Bitcoin are roughly the same, and thus their cost to the network can be modeled to a single unit, transactions in Ethereum are more complex, and so a transaction fee system needs to take into account many ingredients, including cost of bandwidth, cost of storage and cost of computation. Of particular importance is the fact that the Ethereum programming language is Turing-complete, and so transactions may use bandwidth, storage and computation in arbitrary quantities, and the latter may end up being used in quantities that due to the halting problem cannot even be reliably predicted ahead of time. Preventing denial-of-service attacks via infinite loops is a key objective.  The basic mechanism behind transaction fees is as follows:   Every transaction must specify a quantity of \"gas\" that it is willing to consume (called  startgas ), and the fee that it is willing to pay per unit gas ( gasprice ). At the start of execution,  startgas * gasprice  ether are removed from the transaction sender's account.  All operations during transaction execution, including database reads and writes, messages, and every computational step taken by the virtual machine consumes a certain quantity of gas.  If a transaction execution processes fully, consuming less gas than its specified limit, say with  gas_rem  gas remaining, then the transaction executes normally, and at the end of the execution the transaction sender receives a refund of  gas_rem * gasprice  and the miner of the block receives a reward of  (startgas - gas_rem) * gasprice .  If a transaction \"runs out of gas\" mid-execution, then all execution reverts, but the transaction is nevertheless valid, and the only effect of the transaction is to transfer the entire sum  startgas * gasprice  to the miner.  When a contract sends a message to the other contract, it also has the option to set a gas limit specifically on the sub-execution arising out of that message. If the sub-execution runs out of gas, then the sub-execution is reverted, but the gas is nevertheless consumed.   Each of the above components is necessary. For example:   If transactions did not need to specify a gas limit, then a malicious user could send a transaction that makes a multi-billion round loop, and no one would be able to process it since processing such a transaction would take longer than a block interval, but miners would not be able to tell beforehand, leading to a denial-of-service vulnerability.  The alternative to strict gas-counting, time-limiting, does not work because it is too highly subjective (some machines are faster than others, and even among identical machines close-calls will always exist)  The entire value  startgas * gasprice  has to be taken out at the start as a deposit so that there arise no situations where an account \"bankrupts\" itself mid-execution and becomes unable to pay for its gas costs. Note that balance checking is not sufficient, because an account can send its balance somewhere else.  If execution did not revert in the event of an insufficient gas error, then contracts would need to take strong and difficult security measures to prevent themselves from being exploited by transactions or messages that provide only enough gas halfway through, thereby leading to some of the changes in a contract execution being executed but not others.  If sub-limits did not exist, then hostile accounts could enact a denial-of-service attack against other contracts by entering into agreements with them, and then inserting an infinite loop at the beginning of computation so that any attempts by the victim contract to compensate the attack contract or send a message to it would starve the entire transaction execution.  Requiring transaction senders to pay for gas instead of contracts substantially increases developer usability. Very early versions of Ethereum had contracts pay for gas, but this led to the rather ugly problem that every contract had to implement \"guard\" code that would make sure that every incoming message compensated the contract with enough ether to pay for the gas that it consumed.   Note the following particular features in gas costs:   21000 gas is charged for any transaction as a \"base fee\". This covers the cost of an elliptic curve operation to recover the sender address from the signature as well as the disk and bandwidth space of storing the transaction.  A transaction can include an unlimited amount of \"data\", and there exist opcodes in the virtual machine which allow the contract receiving a transaction to access this data. The \"intrinsic gas\" fee for data is 4 gas per zero byte and 68 gas per nonzero byte. This formula arose because we saw that most transaction data in contracts written by users was organized into a series of 32-byte arguments, most of which had many leading zero bytes, and given that such constructions seem inefficient but are actually efficient due to compression algorithms, we wanted to encourage their use in place of more complicated mechanisms which would try to tightly pack arguments according to the expected number of bytes, leading to very substantial complexity increase at compiler level. This is an exception to the sandwich complexity model, but a justified one due to the ratio of cost to benefit.  The cost of the SSTORE opcode, which sets values in account storage, is either: (i) 20000 gas when changing a zero value to a nonzero value, (ii) 5000 gas when changing a zero value to a zero value or a nonzero value to a nonzero value, or (iii) 5000 gas when changing a nonzero value to a zero value, plus a 20000 gas refund to be given at the end of successful transaction execution (ie. NOT an execution leading to an out-of-gas exception). Refunds are capped at 50% of the total gas spent by a transaction. This provides a small incentive to clear storage, as we noticed that lacking such an incentive many contracts would leave storage unused, leading to quickly increasing bloat, providing most of the benefits of \"charging rent\" for storage without the cost of losing the assurance that a contract once placed will continue to exist forever. The delayed refund mechanism is necessary to prevent denial-of-service attacks where the attacker sends a transaction with a low amount of gas that repeatedly clears a large number of storage slots as part of a long-running loop, and then runs out of gas, consuming a large amount of verifiers' computing power without actually clearing storage or spending a lot of gas. The 50% cap is needed to ensure that a miner given a transaction with some quantity of gas can still determine an upper bound on the computational time to execute the transaction.  There is no gas cost to data in messages provided by contracts. This is because there is no need to actually \"copy\" any data during a message call, as the call data can simply be viewed as a pointer to the parent contract's memory which will not change while the child execution is in progress.  Memory is an infinitely expandable array. However, there is a gas cost of 1 per 32 bytes of memory expansion, rounding up.  Some opcodes, whose computation time is highly argument-dependent, have variable gas costs. For example, the gas cost of EXP is 10 + 10 per byte in the exponent (ie. x^0 = 1 gas, x^1 ... x^255 = 2 gas, x^256 ... x^65535 = 3 gas, etc), and the gas cost of the copy opcodes (CALLDATACOPY, CODECOPY, EXTCODECOPY) is 1 + 1 per 32 bytes copies, rounding up (LOG also has a similar rule). The memory expansion gas cost is not sufficient to cover this, as it opens up a quadratic attack (50000 rounds of CALLDATACOPY of 50000 gas ~= 50000^2 computing effort, but only ~50000 gas before the variable gas cost was introduced)  The CALL opcode (and CALLCODE for symmetry) costs an additional 9000 gas if the value is nonzero. This is because any value transfer causes significant bloat to history storage for an archival node. Note that the actual fee  charged  is 6700; on top of this we add a mandatory 2300 gas minimum that is automatically given to the recipient. This is in order to ensure that wallets that receive transactions to at least have enough gas to make a log of the transaction.   The other important part of the gas mechanism is the economics of the gas price itself. The default approach, used in Bitcoin, is to have purely voluntary fees, relying on miners to act as the gatekeepers and set dynamic minimums; the equivalent in Ethereum would be allowing transaction senders to set arbitrary gas costs. This approach has been received very favorably in the Bitcoin community particularly because it is \"market-based\", allowing supply and demand between miners and transaction senders to determine the price. The problem with this line of reasoning is, however, that transaction processing is not a market; although it is intuitively attractive to construe transaction processing as a service that the miner is offering to the sender, in reality every transaction that a miner includes will need to be processed by every node in the network, so the vast majority of the cost of transaction processing is borne by third parties and not the miner that is making the decision of whether or not to include it. Hence, tragedy-of-the-commons problems are very likely to occur.  Currently, due to a lack of clear information about how miners will behave in reality, we are going with a fairly simple approach: a voting system. Miners have the right to set the gas limit for the current block to be within ~0.0975% (1/1024) of the gas limit of the last block, and so the resulting gas limit should be the median of miners' preferences. The hope is that in the future we will be able to soft-fork this into a more precise algorithm.", 
            "title": "\u5929\u7136\u6c14\u548c\u8d39\u7528"
        }, 
        {
            "location": "/Basics/Design-Rationale/#_7", 
            "text": "The Ethereum virtual machine is the engine in which transaction code gets executed, and is the core differentiating feature between Ethereum and other systems. Note that the  virtual machine  should be considered separately from the  contract and message model  - for example, the SIGNEXTEND opcode is a feature of the VM, but the fact that contracts can call other contracts and specify gas limits to sub-calls is part of the contract and message model. Design goals in the EVM include:   Simplicity : as few and as low-level opcodes as possible, as few data types as possible and as few virtual-machine-level constructs as possible  Total determinism : there should be absolutely no room for ambiguity in any part of the VM specification, and the results should be completely deterministic. Additionally, there should be a precise concept of computational step which can be measured so as to compute gas consumption.  Space savings : EVM assembly should be as compact as possible (eg. the 4000 byte base size of default C programs is NOT acceptable)  Specialization to expected applications : the ability to handle 20-byte addresses and custom cryptography with 32-byte values, modular arithmetic used in custom cryptography, read block and transaction data, interact with state, etc  Simple security : it should be easy to come up with a gas cost model for operations that makes the VM non-exploitable  Optimization-friendliness : it should be easy to apply optimizations so that JIT-compiled and otherwise sped-up versions of the VM can be built.   Some particular design decisions that were made:   Temporary/permanent storage distinction  - a distinction exists between temporary storage, which exists within each instance of the VM and disappears when VM execution finishes, and permanent storage, which exists on the blockchain state level on a per-account basis. For example, suppose the following tree of execution takes place (using S for permanent storage and M for temporary): (i) A calls B, (ii) B sets  B.S[0] = 5 ,  B.M[0] = 9 , (iii) B calls C, (iv) C calls B. At this point, if B tries to read  B.S[0] , it will receive the value stored in B earlier, 5, but is B tries to read  B.M[0]  it will receive 0 because it is a new instance of the virtual machine with fresh temporary storage. If B now sets  B.M[0] = 13  and  B.S[0] = 17  in this inner call, and then both this inner call and C's call terminate, bringing the execution back to B's outer call, then B reading M will see  B.M[0] = 9  (since the last time this value was set was in the same VM execution instance) and  B.S[0] = 17 . If B's outer call ends and A calls B again, then B will see  B.M[0] = 0  and  B.S[0] = 17 . The purpose of this distinction is to (1) provide each execution instance with its own memory that is not subject to corruption by recursive calls, making secure programming easier, and (2) to provide a form of memory which can be manipulated very quickly, as storage updates are necessarily slow due to the need to modify the trie.  Stack/memory model  - the decision was made early on to have three types of computational state (aside from the program counter which points to the next instruction): stack (a standard LIFO stack of 32-byte values), memory (an infinitely expandable temporary byte array) and storage (permanent storage). On the temporary storage side, the alternative to stack and memory is a memory-only paradigm, or some hybrid of registers and memory (not very different, as registers basically are a kind of memory). In such a case, every instruction would have three arguments, eg.  ADD R1 R2 R3: M[R1] = M[R2] + M[R3] . The stack paradigm was chosen for the obvious reason that it makes the code four times smaller.  32 byte word size  - the alternative is 4 or 8 byte words, as in most other architectures, or unlimited, as in Bitcoin. 4 or 8 byte words are too restrictive to store addresses and big values for crypto computations, and unlimited values are too hard to make a secure gas model around. 32 bytes is ideal because it is just large enough to store 32 byte values common in many crypto implementations, as well as addresses (and provides the ability to pack address and value into a single storage index as an optimization), but not so large as to be extremely inefficient.  Having our own VM at all  - the alternative is reusing Java, or some Lisp dialect, or Lua. We decided that having a specialized VM was appropriate because (i) our VM spec is much simpler than many other virtual machines, because other virtual machines have to pay a much lower cost for complexity, whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures, (ii) it allows us to specialize the VM much more, eg. by having a 32 byte word size, (iii) it allows us not to have a very complex external dependency which may lead to installation difficulties, and (iv) a full security review of Ethereum specific to our particular security needs would necessitate a security review of the external VM anyway, so the effort savings are not that large.  Using a variable extendable memory size  - we deemed a fixed memory size unnecessarily restrictive if the size is small and unnecessarily expensive if the size is large, and noted that if statements for memory access are necessary in any case to check for out-of-bounds access, so fixed size would not even make execution more efficient.  Not having a stack size limit  - no particular justification either way; note that limits are not strictly necessary in many cases as the combination of gas costs and a block-level gas limit will always act as a ceiling on the consumption of every resource.  Having a 1024 call depth limit  - many programing languages break at high stack depths much more quickly than they break at high levels of memory usage or computational load, so the implied limit from the block gas limit may not be sufficient.  No types  - done for simplicity. Instead, signed and unsigned opcodes for DIV, SDIV, MOD, SMOD are used instead (it turns out that for ADD and MUL the behavior of signed and unsigned opcodes is equivalent), and the transformations for fixed point arithmetic (high-depth fixed-point arithmetic is another benefit of 32-byte words) are in all cases simple, eg. at 32 bits of depth,  a * b -  (a * b) / 2^32 ,  a / b -  a * 2^32 / b , and +, - and * are unchanged from integer cases.   The function and purpose of some opcodes in the VM is obvious, however other opcodes are less so. Some particular justifications are given below:   ADDMOD ,  MULMOD : in most cases,  addmod(a, b, c) = a * b % c . However, in the specific case of many classes of elliptic curve cryptography, 32-byte modular arithmetic is used, and doing  a * b % c  directly is therefore actually doing  ((a * b) % 2^256) % c , which gives a completely different result. A formula that calculates  a * b % c  with 32-byte values in 32 bytes of space is rather nontrivial and bulky.  SIGNEXTEND : the purpose of SIGNEXTEND is to facilitate typecasting from a larger signed integer to a smaller signed integer. Small signed integers are useful because JIT-compiled virtual machines may in the future be able to detect long-running chunks of code that deals primarily with 32-byte integers and speed it up considerably.  SHA3 : SHA3 is very highly applicable in Ethereum code as secure infinite-sized hash maps that use storage will likely need to use a secure hash function so as to prevent malicious collisions, as well as for verifying Merkle trees and even verifying Ethereum-like data structures. A key point is that its companions  SHA256 ,  ECRECOVER  and  RIPEMD160  are included not as opcodes but as pseudo-contracts. The purpose of this is to place them into a separate category so that, if/when we come up with a proper \"native extensions\" system later, more such contracts can be added without filling up the opcode space.  ORIGIN : the primary use of the ORIGIN opcode, which provides the sender of a transaction, is to allow contracts to make refund payments for gas.  COINBASE : the primary uses of the COINBASE opcode are to (i) allow sub-currencies to contribute to network security if they so choose, and (ii) open up the use of miners as a decentralized economic set for sub-consensus-based applications like Schellingcoin.  PREVHASH : used as a semi-secure source of randomness, and to allow contracts to evaluate Merkle tree proofs of state in the previous block without requiring a highly complex recursive \"Ethereum light client in Ethereum\" construction.  EXTCODESIZE ,  EXTCODECOPY : the primary uses here are to allow contracts to check the code of other contracts against a template, or even simulating them, before interacting with them. See http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/ for applications.  JUMPDEST : JIT-compiled virtual machines become much easier to implement when jump destinations are restricted to a few indices (specifically, the computational complexity of a variable-destination jump is roughly O(log(number of valid jump destinations)), although static jumps are always constant-time). Hence, we need (i) a restriction on valid variable jump destinations, and (ii) an incentive to use static over dynamic jumps. To meet both goals, we have the rules that (i) jumps that are immediately preceded by a push can jump anywhere but another jump, and (ii) other jumps can only jump to a JUMPDEST. The restriction against jumping on jumps is needed so that the question of whether a jump is dynamic or static can be determined by simply looking at the previous operation in the code. The lack of a need for JUMPDEST operations for static jumps is the incentive to use them. The prohibition against jumping into push data also speeds up JIT VM compilation and execution.  LOG : LOG is meant to log events, see trie usage section above.  CALLCODE : the purpose of this is to allow contracts to call \"functions\" in the form of code stored in other contracts, with a separate stack and memory, but using the contract's own storage. This makes it much easier to scalably implement \"standard libraries\" of code on the blockchain.  SELFDESTRUCT : an opcode which allows a contract to quickly delete itself if it is no longer needed. The fact that SELFDESTRUCTs are processed at the end of transaction execution, and not immediately, is motivated by the fact that having the ability to revert SELFDESTRUCTs that were already executed would substantially increase the complexity of the cache that would be required in an efficient VM implementation.  PC : although theoretically not necessary, as all instances of the PC opcode can be replaced by simply putting in the actual program counter at that index as a push, using PC in code allows for the creation of position-independent code (ie. compiled functions which can be copy/pasted into other contracts, and do not break if they end up at different indices).", 
            "title": "\u865a\u62df\u673a"
        }, 
        {
            "location": "/Basics/Yellow-Paper/", 
            "text": "\u9ec4\u76ae\u4e66\n\n\nPDF", 
            "title": "\u9ec4\u76ae\u4e66"
        }, 
        {
            "location": "/Basics/Yellow-Paper/#_1", 
            "text": "PDF", 
            "title": "\u9ec4\u76ae\u4e66"
        }, 
        {
            "location": "/Basics/FAQ/", 
            "text": "\u5e38\u89c1\u95ee\u9898\n\n\n\u4ee5\u592a\u574a\n\n\n\u4ec0\u4e48\u662f\u4ee5\u592a\u574a\uff1f\n\u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\uff0c\u5728\u4e13\u95e8\u7684\u7ef4\u57fa\u9875\u9762\n\u4ec0\u4e48\u662f\u4ee5\u592a\u574a\uff1f\n\u4e0a\u4ecb\u7ecd.\n\u5982\u679c\u60a8\u559c\u6b22\u901a\u8fc7\u89c2\u770b\u89c6\u9891\u8fdb\u884c\u5b66\u4e60\uff0c\u8bf7\u53c2\u9605:\n\u4ecb\u7ecd\u4ee5\u592a\u574a\n (Video, 10mi)\nVitalik Buterin reveals Ethereum at Bitcoin Miami 2014\n (Video, 28min)\nSingularity 1 on 1: Ethereum is a Decentralized Consensus Platform\n (Video, 69min)\nOur second Reddit \"Ask Me Anything\" for community selected questions\n (not actually a video)\n\u6211\u5982\u4f55\u8d2d\u4e70Ether\u6216ETH\uff1f\n\u9605\u8bfb\n\u8fd9\u91cc\n.\n\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u4e86\u89e3\u66f4\u591a\u6709\u5173\u4ee5\u592a\u574a\u7684\u4fe1\u606f\uff1f\n\u4e3b\u7ad9\n\u8bba\u575b\nGithub\n\u535a\u5ba2\n\u7ef4\u57fa\n [\u5df2\u7ecf\u4e0d\u5de5\u4f5c\u4e86]\n\u805a\u4f1a\n\u767d\u76ae\u4e66\n\u9ec4\u76ae\u4e66\nFacebook\nYoutube\nGoogle+\nIRC Freenode\n(#ethereum) for weblink)\n\u5806\u6362\n\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u4e3b\u8981\u7684\u9879\u76ee\u77e5\u8bc6\u5e93\uff1f\ngo-ethereum\n (\n@obscuren\n, \n@maran\n)\nParity\ncpp-ethereum\n (\n@gavofyork\n, \n@programmerTim\n, \n@caktux\n)\npyethereum\n (\n@vbuterin\n, \n@heikoheiko\n, \n@chenhouwu\n)\nethereumj\n (\n@romanman\n, \n@nicksavers\n)\nethereumjs-lib\n (\n@ethers\n, \n@wanderer\n)\nmore repositories are in the \nEthereum organisation on Github\n\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u4e86\u89e3\u4ee5\u592a\u5e01\u7684\u9500\u552e\u548c\u6316\u77ff\uff1f\n\u6bd4\u7279\u5e01\u552e\u5356\u5e38\u89c1\u95ee\u9898\n\u6316\u77ff\u5e38\u89c1\u95ee\u9898\n\u94b1\u5305\n\n\nIf you have an issue with your wallet, an exchange or other matters relating to using the Ether cryptocurrency or making transactions, see this \nMyEtherWallet knowledge base\n. It answers many FAQs such as:\n\n\n\n\ntransaction is not showing up or is pending forever\n\n\nETH or Tokens sent to or from exchange haven't shown up / Transaction says complete, but funds haven't shown up yet\n\n\nPhish, Hacks, Thefts \n stolen funds due to phishing messages on Slack / Reddit / Google Ads\n\n\n\n\n\u5ba2\u6237\u7aef\n\n\n\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u5b98\u65b9\u7248\u672c?\n\u5ba2\u6237\u7aef:\nReleases for Geth\n (Go)\nReleases for Parity\n (Rust)\nReleases for eth\n (C++)\nReleases for Pyethereum\n (Python)\nReleases for Ethereumj\n (Java)\nReleases for EthereumJS\n (Javascript)\n\u5176\u5b83:\nReleases for Mist\n (wallet and browser for dapps)\nReleases for Pyethapp\n (Python)\nReleases for Py-EVM\n (Python)\n\u5982\u4f55\u5b89\u88c5\u5f00\u53d1\u7248\u672c?\nHomebrew\nHomebrew Ethereum\n (\n@caktux\n)\n\u6307\u5357\neth/AlethZero super easy install guide for OSX\n (\n@stephantual\n)\nGo-Ethereum simple build guide for OSX\n (\n@stephantual\n)\nBuilding on Ubuntu\nBuilds\nEthdev Buildbot\n\u5982\u4f55\u4ece\u6e90\u4ee3\u7801\u5b89\u88c5\u5ba2\u6237\u7aef\uff1f\nBuilding eth/AlethZero (C++)\nBuilding Mist (Go)\nInstalling Pyethereum (Python)\nInstalling EthereumJ (Java)\nInstalling Ethereumjs-lib (JavaScript for Browser and Node)\n\u91c7\u77ff\n\n\n\u6211\u600e\u6837\u624d\u80fd\u6316\u6398\u4ee5\u592a\u5e01?\n\u4f7f\u7528 eth/AlethZero\nTo process transactions\nDisable \"Debug\" \n \"Force Mining\"\nClick \"Mine\"\nTo force mine (Use sparingly, unless stress testing)\nEnable \"Debug\" \n \"Force Mining\"\nClick \"Mine\"\n\u4f7f\u7528 eth \u5ba2\u6237\u7aef\n# Only force mine to acquire ether or stress test\n$ eth --force-mining --mining on [YOUR OPTIONS...]\n\n\n\n\u5951\u7ea6\n\n\n\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u4e86\u89e3\u5408\u7ea6\u5f00\u53d1\uff1f\n\u6587\u7ae0\nEthereum Development Tutorial\n\u89c6\u9891\nEthereum\nEtherCasts\n\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u5b66\u4e60\u7c7bPython\u8bed\u8a00Serpent\uff1f\n\u8bf4\u660e\nThe Serpent Language\n\u793a\u4f8b\nVitalik's Serpent examples\n\u624b\u518c\nPyethereum and Serpent Programming Guide\n\u89c6\u9891\nLearn Ethereum with Vitalik\n\u6211\u54ea\u91cc\u53ef\u4ee5\u5b66\u6821\u7c7bLisp\u8bed\u8a00 LLL?\n\u8bf4\u660e\u4e66\nThe LLL Language\n\u793a\u4f8b\nLLL examples for PoC 5\n\u89c6\u9891\nProgramming Society with Asm\n\u6211\u54ea\u91cc\u53ef\u4ee5\u5b66\u7c7bJavaScript\u8bed\u8a00Solidity?\n\u6587\u6863\nSolidity Documentation\n\u624b\u518c\nContract Writing in Solidity\n\u5982\u4f55\u6d4b\u8bd5\u5408\u7ea6?\nEVM Contract Simulator\n (\n@EtherCasts\n)\nPyethereum Tester\n (\n@ethereum\n)\n\u5728\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u793a\u4f8b\u5408\u7ea6\uff1f\nSerpent\nBy Vitalik Buterin\n (\n@vbuterin\n)\nBy EtherCasts\n (\n@EtherCasts\n)\nBy Rob Myers\n (\n@robmyers\n)\nBy Tyler Florez\n (\n@qualiabyte\n)\nLLL\nBy Gavin Wood\n (\n@gavofyork\n)\nBy Dennis Mckinnon\n (\n@dennismckinnon\n)\nBy Doug A.\n (\n@dlle9\n)\n\u00d0Apps\n\n\n\u6211\u54ea\u91cc\u53ef\u4ee5\u5b66\u4e60\u4ee5\u592a\u574a\u63a5\u53e3?\nThe PoC 6 API for C++\nThe PoC 5 API for Go\nThe PoC 6 API for QML\nThe PoC 7 API for JavaScript\n\u6211\u54ea\u91cc\u53ef\u4ee5\u5b66 \u00d0App \u5f00\u53d1?\nWriting Your Own Currency\n (\n@maran\n)\n\u6211\u54ea\u91cc\u53ef\u4ee5\u627e\u5230 \u00d0App \u5f00\u53d1\u5de5\u5177?\n\u5b98\u65b9\neth/AlethZero GUI client (C++)\nEth command-line client (C++)\nLLLC Compiler (C++)\nEthereum command-line client (Go)\nMist Browser (Go)\nPyeth command-line client (Python)\nSerpent Compiler (Python)\n\u793e\u533a\nEmacs LLL Mode\n (\n@robmyers\n)\nEmacs Serpent Mode\n (\n@robmyers\n)\nEVM-Sim\n (\n@EtherCasts\n)\nMintChalk\n (\n@mintchalk\n)\n\u6211\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u00d0Apps\u793a\u4f8b?\ndapp-bin\n (\n@ethereum\n)\nGavCoin\n (\n@gavofyork\n)\nJeffCoin\n (\n@obscuren\n)\nMake It Rain\n (\n@EtherCasts\n)\nChronos\n (\n@mquandalle\n)\nArtworld-Ethereum\n (\n@robmyers\n)\nCryptoCoinWatch\n (\n@EtherCasts\n)\nOccam's Run\n (\n@d11e9\n)\nTrustDavis\n (\n@EtherCasts\n)\nIRC\n\n\n\u6211\u5982\u4f55\u52a0\u5165\u4ee5\u592a\u574aIRC\u9891\u9053?\n\u5728IRC\u4e0a\u7684\u4ee5\u592a\u574a\u5f00\u53d1\u793e\u533a\u804a\u5929!\n\u66f4\u591a\u95ee\u7b54\n\n\n\n\n@fivedogit\u5199\u7684\u5e38\u89c1\u95ee\u9898", 
            "title": "FAQ"
        }, 
        {
            "location": "/Basics/FAQ/#_1", 
            "text": "", 
            "title": "\u5e38\u89c1\u95ee\u9898"
        }, 
        {
            "location": "/Basics/FAQ/#_2", 
            "text": "\u4ec0\u4e48\u662f\u4ee5\u592a\u574a\uff1f \u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\uff0c\u5728\u4e13\u95e8\u7684\u7ef4\u57fa\u9875\u9762 \u4ec0\u4e48\u662f\u4ee5\u592a\u574a\uff1f \u4e0a\u4ecb\u7ecd. \u5982\u679c\u60a8\u559c\u6b22\u901a\u8fc7\u89c2\u770b\u89c6\u9891\u8fdb\u884c\u5b66\u4e60\uff0c\u8bf7\u53c2\u9605: \u4ecb\u7ecd\u4ee5\u592a\u574a  (Video, 10mi) Vitalik Buterin reveals Ethereum at Bitcoin Miami 2014  (Video, 28min) Singularity 1 on 1: Ethereum is a Decentralized Consensus Platform  (Video, 69min) Our second Reddit \"Ask Me Anything\" for community selected questions  (not actually a video) \u6211\u5982\u4f55\u8d2d\u4e70Ether\u6216ETH\uff1f \u9605\u8bfb \u8fd9\u91cc . \u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u4e86\u89e3\u66f4\u591a\u6709\u5173\u4ee5\u592a\u574a\u7684\u4fe1\u606f\uff1f \u4e3b\u7ad9 \u8bba\u575b Github \u535a\u5ba2 \u7ef4\u57fa  [\u5df2\u7ecf\u4e0d\u5de5\u4f5c\u4e86] \u805a\u4f1a \u767d\u76ae\u4e66 \u9ec4\u76ae\u4e66 Facebook Youtube Google+ IRC Freenode (#ethereum) for weblink) \u5806\u6362 \u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u4e3b\u8981\u7684\u9879\u76ee\u77e5\u8bc6\u5e93\uff1f go-ethereum  ( @obscuren ,  @maran ) Parity cpp-ethereum  ( @gavofyork ,  @programmerTim ,  @caktux ) pyethereum  ( @vbuterin ,  @heikoheiko ,  @chenhouwu ) ethereumj  ( @romanman ,  @nicksavers ) ethereumjs-lib  ( @ethers ,  @wanderer ) more repositories are in the  Ethereum organisation on Github \u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u4e86\u89e3\u4ee5\u592a\u5e01\u7684\u9500\u552e\u548c\u6316\u77ff\uff1f \u6bd4\u7279\u5e01\u552e\u5356\u5e38\u89c1\u95ee\u9898 \u6316\u77ff\u5e38\u89c1\u95ee\u9898", 
            "title": "\u4ee5\u592a\u574a"
        }, 
        {
            "location": "/Basics/FAQ/#_3", 
            "text": "If you have an issue with your wallet, an exchange or other matters relating to using the Ether cryptocurrency or making transactions, see this  MyEtherWallet knowledge base . It answers many FAQs such as:   transaction is not showing up or is pending forever  ETH or Tokens sent to or from exchange haven't shown up / Transaction says complete, but funds haven't shown up yet  Phish, Hacks, Thefts   stolen funds due to phishing messages on Slack / Reddit / Google Ads", 
            "title": "\u94b1\u5305"
        }, 
        {
            "location": "/Basics/FAQ/#_4", 
            "text": "\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u5b98\u65b9\u7248\u672c? \u5ba2\u6237\u7aef: Releases for Geth  (Go) Releases for Parity  (Rust) Releases for eth  (C++) Releases for Pyethereum  (Python) Releases for Ethereumj  (Java) Releases for EthereumJS  (Javascript) \u5176\u5b83: Releases for Mist  (wallet and browser for dapps) Releases for Pyethapp  (Python) Releases for Py-EVM  (Python) \u5982\u4f55\u5b89\u88c5\u5f00\u53d1\u7248\u672c? Homebrew Homebrew Ethereum  ( @caktux ) \u6307\u5357 eth/AlethZero super easy install guide for OSX  ( @stephantual ) Go-Ethereum simple build guide for OSX  ( @stephantual ) Building on Ubuntu Builds Ethdev Buildbot \u5982\u4f55\u4ece\u6e90\u4ee3\u7801\u5b89\u88c5\u5ba2\u6237\u7aef\uff1f Building eth/AlethZero (C++) Building Mist (Go) Installing Pyethereum (Python) Installing EthereumJ (Java) Installing Ethereumjs-lib (JavaScript for Browser and Node)", 
            "title": "\u5ba2\u6237\u7aef"
        }, 
        {
            "location": "/Basics/FAQ/#_5", 
            "text": "\u6211\u600e\u6837\u624d\u80fd\u6316\u6398\u4ee5\u592a\u5e01? \u4f7f\u7528 eth/AlethZero To process transactions Disable \"Debug\"   \"Force Mining\" Click \"Mine\" To force mine (Use sparingly, unless stress testing) Enable \"Debug\"   \"Force Mining\" Click \"Mine\" \u4f7f\u7528 eth \u5ba2\u6237\u7aef # Only force mine to acquire ether or stress test\n$ eth --force-mining --mining on [YOUR OPTIONS...]", 
            "title": "\u91c7\u77ff"
        }, 
        {
            "location": "/Basics/FAQ/#_6", 
            "text": "\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u4e86\u89e3\u5408\u7ea6\u5f00\u53d1\uff1f \u6587\u7ae0 Ethereum Development Tutorial \u89c6\u9891 Ethereum EtherCasts \u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u5b66\u4e60\u7c7bPython\u8bed\u8a00Serpent\uff1f \u8bf4\u660e The Serpent Language \u793a\u4f8b Vitalik's Serpent examples \u624b\u518c Pyethereum and Serpent Programming Guide \u89c6\u9891 Learn Ethereum with Vitalik \u6211\u54ea\u91cc\u53ef\u4ee5\u5b66\u6821\u7c7bLisp\u8bed\u8a00 LLL? \u8bf4\u660e\u4e66 The LLL Language \u793a\u4f8b LLL examples for PoC 5 \u89c6\u9891 Programming Society with Asm \u6211\u54ea\u91cc\u53ef\u4ee5\u5b66\u7c7bJavaScript\u8bed\u8a00Solidity? \u6587\u6863 Solidity Documentation \u624b\u518c Contract Writing in Solidity \u5982\u4f55\u6d4b\u8bd5\u5408\u7ea6? EVM Contract Simulator  ( @EtherCasts ) Pyethereum Tester  ( @ethereum ) \u5728\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u793a\u4f8b\u5408\u7ea6\uff1f Serpent By Vitalik Buterin  ( @vbuterin ) By EtherCasts  ( @EtherCasts ) By Rob Myers  ( @robmyers ) By Tyler Florez  ( @qualiabyte ) LLL By Gavin Wood  ( @gavofyork ) By Dennis Mckinnon  ( @dennismckinnon ) By Doug A.  ( @dlle9 )", 
            "title": "\u5951\u7ea6"
        }, 
        {
            "location": "/Basics/FAQ/#apps", 
            "text": "\u6211\u54ea\u91cc\u53ef\u4ee5\u5b66\u4e60\u4ee5\u592a\u574a\u63a5\u53e3? The PoC 6 API for C++ The PoC 5 API for Go The PoC 6 API for QML The PoC 7 API for JavaScript \u6211\u54ea\u91cc\u53ef\u4ee5\u5b66 \u00d0App \u5f00\u53d1? Writing Your Own Currency  ( @maran ) \u6211\u54ea\u91cc\u53ef\u4ee5\u627e\u5230 \u00d0App \u5f00\u53d1\u5de5\u5177? \u5b98\u65b9 eth/AlethZero GUI client (C++) Eth command-line client (C++) LLLC Compiler (C++) Ethereum command-line client (Go) Mist Browser (Go) Pyeth command-line client (Python) Serpent Compiler (Python) \u793e\u533a Emacs LLL Mode  ( @robmyers ) Emacs Serpent Mode  ( @robmyers ) EVM-Sim  ( @EtherCasts ) MintChalk  ( @mintchalk ) \u6211\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u00d0Apps\u793a\u4f8b? dapp-bin  ( @ethereum ) GavCoin  ( @gavofyork ) JeffCoin  ( @obscuren ) Make It Rain  ( @EtherCasts ) Chronos  ( @mquandalle ) Artworld-Ethereum  ( @robmyers ) CryptoCoinWatch  ( @EtherCasts ) Occam's Run  ( @d11e9 ) TrustDavis  ( @EtherCasts )", 
            "title": "\u00d0Apps"
        }, 
        {
            "location": "/Basics/FAQ/#irc", 
            "text": "\u6211\u5982\u4f55\u52a0\u5165\u4ee5\u592a\u574aIRC\u9891\u9053? \u5728IRC\u4e0a\u7684\u4ee5\u592a\u574a\u5f00\u53d1\u793e\u533a\u804a\u5929!", 
            "title": "IRC"
        }, 
        {
            "location": "/Basics/FAQ/#_7", 
            "text": "@fivedogit\u5199\u7684\u5e38\u89c1\u95ee\u9898", 
            "title": "\u66f4\u591a\u95ee\u7b54"
        }, 
        {
            "location": "/Basics/Releases/", 
            "text": "\u7248\u672c\u53d1\u5e03\n\n\nWhile still valid, the substance behind Ethereum has changed, and will continue to, but will avoid making any disruptions to the operation of the network, while maintaining backwards compatibility. The \noriginal development roadmap\n that was laid out before Ethereum went live specified some of the following milestones:\n\n\n\n\nPrerelease step 0: Olympic testnet\n - launched May 2015 as announced \nhere\n.  The \nOlympic testnet\n phase saw a lot of major improvements, followed by Frontier which was launched immediately after.\n\n\nRelease step One: Frontier\n, launched 30 July 2015, starting from \nblock 1\n. \nHere\n is an Ethereum blog post just before the launch, \nhere\n and \nhere\n is a wiki. More details are \nhere\n.\n\n\nRelease step 2.0: Homestead\n, launched 14 March 2016 (Pi Day) at block number 1,150,000 as announced \nhere\n. For changes in the Homestead release, see \nthis EIP\n. Homestead marked the exit from a beta product to a stable release.\n\n\nRelease step 2.1: Spurious Dragon\n, was released in Nov 2016. Spurious Dragon is aiming for \nDapp developers\n as well as end users for limited categories of applications, and had a number of security enhancements.\n\n\nRelease Step 3.0: Metropolis phase 1: Byzantium\n, October 16 2017 as announced \nhere\n. Byzantium aims to introduce various privacy and functionality improvements. Details are \nhere\n. For the Byzantium Hard Fork, refer to \nhere\n, which is an archive link showing the Byzantium EIPs. Also, refer to \nhere\n for a quick summary of Byzantium EIPs.\n\n\nRelease Step 3.1: Metropolis phase 2: Constantinople\n, TBA, expected in 2018. Details on Metropolis are \nhere\n. \nThis archive link lists the deferred Constantinople EIPs\n. This is an archive link in case the EIPs list is changed in a way that does not breakdown EIPs into different releases, as is the case up until now.\n\n\nRelease Step Four: Serenity\n, TBA. Serenity is meant to move from consensus through \nProof-of-Work\n to \nProof-of-Stake\n. Details are \nhere\n and \nhere\n, although the second post seems outdated as abstraction has moved forward to Constantinople.\n\n\nFor other changes, refer to the \nthe finalized list of EIPs\n.\n\n\nFurther releases will focus on massive scalability increases through sharding as well as virtual machine improvements and other features, as detailed \nhere\n.", 
            "title": "\u53d1\u5e03"
        }, 
        {
            "location": "/Basics/Releases/#_1", 
            "text": "While still valid, the substance behind Ethereum has changed, and will continue to, but will avoid making any disruptions to the operation of the network, while maintaining backwards compatibility. The  original development roadmap  that was laid out before Ethereum went live specified some of the following milestones:   Prerelease step 0: Olympic testnet  - launched May 2015 as announced  here .  The  Olympic testnet  phase saw a lot of major improvements, followed by Frontier which was launched immediately after.  Release step One: Frontier , launched 30 July 2015, starting from  block 1 .  Here  is an Ethereum blog post just before the launch,  here  and  here  is a wiki. More details are  here .  Release step 2.0: Homestead , launched 14 March 2016 (Pi Day) at block number 1,150,000 as announced  here . For changes in the Homestead release, see  this EIP . Homestead marked the exit from a beta product to a stable release.  Release step 2.1: Spurious Dragon , was released in Nov 2016. Spurious Dragon is aiming for  Dapp developers  as well as end users for limited categories of applications, and had a number of security enhancements.  Release Step 3.0: Metropolis phase 1: Byzantium , October 16 2017 as announced  here . Byzantium aims to introduce various privacy and functionality improvements. Details are  here . For the Byzantium Hard Fork, refer to  here , which is an archive link showing the Byzantium EIPs. Also, refer to  here  for a quick summary of Byzantium EIPs.  Release Step 3.1: Metropolis phase 2: Constantinople , TBA, expected in 2018. Details on Metropolis are  here .  This archive link lists the deferred Constantinople EIPs . This is an archive link in case the EIPs list is changed in a way that does not breakdown EIPs into different releases, as is the case up until now.  Release Step Four: Serenity , TBA. Serenity is meant to move from consensus through  Proof-of-Work  to  Proof-of-Stake . Details are  here  and  here , although the second post seems outdated as abstraction has moved forward to Constantinople.  For other changes, refer to the  the finalized list of EIPs .  Further releases will focus on massive scalability increases through sharding as well as virtual machine improvements and other features, as detailed  here .", 
            "title": "\u7248\u672c\u53d1\u5e03"
        }, 
        {
            "location": "/Client/cpp-ethereum/", 
            "text": "", 
            "title": "cpp-ethereum (C++)"
        }, 
        {
            "location": "/Client/ethereumj/", 
            "text": "", 
            "title": "ethereumj (Java)"
        }, 
        {
            "location": "/Client/go-ethereum/", 
            "text": "", 
            "title": "Geth (Go)"
        }, 
        {
            "location": "/Client/parity/", 
            "text": "", 
            "title": "Parity (Rust)"
        }, 
        {
            "location": "/Client/pyethapp/", 
            "text": "", 
            "title": "pyethapp (Python)"
        }, 
        {
            "location": "/Dapps/Safety/", 
            "text": "\u4ee5\u592a\u574a\u5408\u540c\u5b89\u5168\u6280\u672f\u548c\u6280\u5de7\n\n\nThe community is encouraged to keep this wiki updated: it becomes more complete as more contributions are added.\n\n\nCurrently this wiki is out-of-date and see its source \n\"Smart Contract Best Practices\"\n for more recent updates and corrections.\n\n\nAdditional Requested Content\n\n\nWe especially welcome content in the following areas:\n\n\n\n\nTesting Solidity code (structure, frameworks, common test idioms)\n\n\nSoftware engineering practices for smart contracts and/or blockchain-based programming\n\n\n\n\nGeneral Philosophy\n\n\nEthereum and complex blockchain programs are new and highly experimental. Therefore, you should expect constant changes in the security landscape, as new bugs and security risks are discovered, and new best practices are developed. Following the security practices in this document is therefore only the beginning of the security work you will need to do as a smart contract developer.\n\n\nSmart contract programming requires a different engineering mindset than you may be used to. The cost of failure can be high, and change can be difficult, making it in some ways more similar to hardware programming or financial services programming than web or mobile development. It is therefore not enough to defend against known vulnerabilities. Instead, you will need to learn a new philosophy of development:\n\n\n\n\nPrepare for failure\n. Any non-trivial contract will have errors in it. Your code must therefore be able to respond to bugs and vulnerabilities gracefully.\n\n\nPause the contract when things are going wrong ('circuit breaker')\n\n\nManage the amount of money at risk (rate limiting, maximum usage)\n\n\n\n\nHave an effective upgrade path for bugfixes and improvements\n\n\n\n\n\n\nRoll out carefully\n. It is always better to catch bugs before a full production release.\n\n\n\n\nTest contracts thoroughly, and add tests whenever new attack vectors are discovered\n\n\nProvide bug bounties starting from alpha testnet releases\n\n\n\n\nRollout in phases, with increasing usage and testing in each phase\n\n\n\n\n\n\nKeep contracts simple\n. Complexity increases the likelihood of errors.\n\n\n\n\nEnsure the contract logic is simple\n\n\nModularize code to keep contracts and functions small\n\n\nUse already-written tools or code where possible (eg. don't roll your own random number generator)\n\n\nPrefer clarity to performance whenever possible\n\n\n\n\nOnly use the blockchain for the parts of your system that require decentralization\n\n\n\n\n\n\nStay up to date\n. Use the resources listed in the next section to keep track of new security developments.\n\n\n\n\nCheck your contracts for any new bug that's discovered\n\n\nUpgrade to the latest version of any tool or library as soon as possible\n\n\n\n\nAdopt new security techniques that appear useful\n\n\n\n\n\n\nBe aware of blockchain properties\n. While much of your programming experience will be relevant to Ethereum programming, there are some pitfalls to be aware of.\n\n\n\n\nBe extremely careful about external contract calls, which may execute malicious code and change control flow.\n\n\nUnderstand that your public functions are public, and may be called maliciously. Your private data is also viewable by anyone.\n\n\nKeep gas costs and the block gas limit in mind.\n\n\n\n\nSecurity Notifications\n\n\nThis is a list of resources that will often highlight discovered exploits in Ethereum or Solidity. The official source of security notifications is the Ethereum Blog, but in many cases vulnerabilities will be disclosed and discussed earlier in other locations.\n\n\n\n\nEthereum Blog\n: The official Ethereum blog\n\n\nEthereum Blog - Security only\n: All blog posts that are tagged \nSecurity\n\n\nEthereum Gitter\n chat rooms\n\n\nSolidity\n\n\nGo-Ethereum\n\n\nCPP-Ethereum\n\n\nResearch\n\n\nReddit\n\n\nNetwork Stats\n\n\n\n\nIt's highly recommended that you \nregularly\n read all these sources, as exploits they note may impact your contracts.\n\n\nAdditionally, here is a list of Ethereum core developers who may write about security, and see the \nbibliography\n for more from the community.\n\n\n\n\nVitalik Buterin\n: \nTwitter\n, \nGithub\n, \nReddit\n, \nEthereum Blog\n\n\nDr. Christian Reitwiessner\n: \nTwitter\n, \nGithub\n, \nEthereum Blog\n\n\nDr. Gavin Wood\n: \nTwitter\n, \nBlog\n, \nGithub\n\n\nVlad Zamfir\n: \nTwitter\n, \nGithub\n, \nEthereum Blog\n\n\n\n\nBeyond following core developers, it is critical to participate in the wider blockchain-related security community - as security disclosures or observations will come through a variety of parties.\n\n\nRecommendations for Smart Contract Security in Solidity\n\n\nExternal Calls\n\n\nAvoid external calls when possible\n\n\nCalls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract \nor\n any other contract that it depends upon. As such, every external call should be treated as a potential security risk, and removed if possible. When it is not possible to remove external calls, use the recommendations in the rest of this section to minimize the danger.\n\n\nUse \nsend()\n, avoid \ncall.value()\n\n\nWhen sending Ether, use \nsomeAddress.send()\n and avoid \nsomeAddress.call.value()()\n.\n\n\nExternal calls such as \nsomeAddress.call.value()()\n can trigger malicious code. While \nsend()\n also triggers code, it is safe because it only has access to gas stipend of 2,300 gas. Currently, this is only enough to log an event, not enough to launch an attack.\n\n\n// bad\nif(!someAddress.call.value(100)()) {\n    // Some failure code\n}\n\n// good\nif(!someAddress.send(100)) {\n    // Some failure code\n}\n\n\n\n\nHandle errors in external calls\n\n\nSolidity offers low-level call methods that work on raw addresses: \naddress.call()\n, \naddress.callcode()\n, \naddress.delegatecall()\n, and \naddress.send\n. These low-level methods never throw an exception, but will return \nfalse\n if the call encounters an exception. On the other hand, \ncontract calls\n (e.g., \nExternalContract.doSomething()\n) will automatically propagate a throw (for example, \nExternalContract.doSomething()\n will also \nthrow\n if \ndoSomething()\n throws).\n\n\nIf you choose to use the low-level call methods, make sure to handle the possibility that the call will fail, by checking the return value.\n\n\n// bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn\nt check for result\nsomeAddress.call.value(100)(bytes4(sha3(\ndeposit()\n))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\nif(!someAddress.send(55)) {\n    // Some failure code\n}\n\nExternalContract(someAddress).deposit.value(100);\n\n\n\n\nDon't make control flow assumptions after external calls\n\n\nWhether using \nraw calls\n or \ncontract calls\n, assume that malicious code will execute if \nExternalContract\n is untrusted. Even if \nExternalContract\n is not malicious, malicious code can be executed by any contracts \nit\n calls. One particular danger is malicious code may hijack the control flow, leading to race conditions. (See \nRace Conditions\n for a fuller discussion of this problem).\n\n\nFavor \npull\n over \npush\n for external calls\n\n\nAs we've seen, external calls can fail for a number of reasons, including external errors. To minimize the damage caused by such failures, it is often better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of \nproblems with the gas limit\n.)\n\n\n// bad\ncontract auction {\n    address highestBidder;\n    uint highestBid;\n\n    function bid() {\n        if (msg.value \n highestBid) throw;\n\n        if (highestBidder != 0) {\n            if (!highestBidder.send(highestBid)) { // if this call consistently fails, no one else can bid\n                throw;\n            }\n        }\n\n       highestBidder = msg.sender;\n       highestBid = msg.value;\n    }\n}\n\n// good\ncontract auction {\n    address highestBidder;\n    uint highestBid;\n    mapping(address =\n uint) refunds;\n\n    function bid() external {\n        if (msg.value \n highestBid) throw;\n\n        if (highestBidder != 0) {\n            refunds[highestBidder] += highestBid; // record the refund that this user can claim\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdrawRefund() external {\n        uint refund = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        if (!msg.sender.send(refund)) {\n            refunds[msg.sender] = refund; // reverting state because send failed\n        }\n    }\n}\n\n\n\n\nMark untrusted contracts\n\n\nWhen interacting with external contracts, name your variables, methods, and contract interfaces in a way that makes it clear that interacting with them is potentially unsafe. This applies to your own functions that call external contracts.\n\n\n// bad\n\n\nBank\n.\nwithdraw\n(\n100\n);\n \n// Unclear whether trusted or untrusted\n\n\n\nfunction\n \nmakeWithdrawal\n(\nuint\n \namount\n)\n \n{\n \n// Isn\nt clear that this function is potentially unsafe\n\n    \nUntrustedBank\n.\nwithdraw\n(\namount\n);\n\n\n}\n\n\n\n// good\n\n\nUntrustedBank\n.\nwithdraw\n(\n100\n);\n \n// untrusted external call\n\n\nTrustedBank\n.\nwithdraw\n(\n100\n);\n \n// external but trusted bank contract maintained by XYZ Corp\n\n\n\nfunction\n \nmakeUntrustedWithdrawal\n(\nuint\n \namount\n)\n \n{\n\n    \nUntrustedBank\n.\nwithdraw\n(\namount\n);\n\n\n}\n\n\n\n\n\nBeware rounding with integer division\n\n\nAll integer divison rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator.\n\n\n(In the future, Solidity will have a fixed-point type, which will make this easier.)\n\n\n// bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n\n// good\nuint multiplier = 10;\nuint x = (5 * multiplier) / 2;\n\nuint numerator = 5;\nuint denominator = 2;\n\n\n\n\nRemember that on-chain data is public\n\n\nMany applications require submitted data to be private up until some point in time in order to work. Games (eg. on-chain rock-paper-scissors) and auction mechanisms (eg. sealed-bid second-price auctions) are two major categories of examples. If you are building an application where privacy is an issue, take care to avoid requiring users to publish information too early.\n\n\nExamples:\n\n\n\n\nIn rock paper scissors, require both players to submit a hash of their intended move first, then require both players to submit their move; if the submitted move does not match the hash throw it out.\n\n\nIn an auction, require players to submit a hash of their bid value in an initial phase (along with a deposit greater than their bid value), and then submit their action bid value in the second phase.\n\n\nWhen developing an application that depends on a random number generator, the order should always be (1) players submit moves, (2) random number generated, (3) players paid out. The method by which random numbers are generated is itself an area of active research; current best-in-class solutions include Bitcoin block headers (verified through http://btcrelay.org), hash-commit-reveal schemes (ie. one party generates a number, publishes its hash to \"commit\" to the value, and then reveals the value later) and \nRANDAO\n.\n\n\nIf you are implementing a frequent batch auction, a hash-commit scheme is also desirable.\n\n\n\n\nIn 2-party or N-party contracts, beware of the possibility that some participants may \"drop offline\" and not return\n\n\nDo not make refund or claim processes dependent on a specific party performing a particular action with no other way of getting the funds out. For example, in a rock-paper-scissors game, one common mistake is to not make a payout until both players submit their moves; however, a malicious player can \"grief\" the other by simply never submitting their move - in fact, if a player sees the other player's revealed move and determiners that they lost, they have no reason to submit their own move at all. This issue may also arise in the context of state channel settlement. When such situations are an issue, (1) provide a way of circumventing non-participating participants, perhaps through a time limit, and (2) consider adding an additional economic incentive for participants to submit information in all of the situations in which they are supposed to do so.\n\n\nKeep fallback functions simple\n\n\nFallback functions\n are called when a contract is sent a message with no arguments (or when no function matches), and only has access to 2,300 gas when called from a \n.send()\n. If you wish to be able to receive Ether from a \n.send()\n, the most you can do in a fallback function is log an event. Use a proper function if a computation or more gas is required.\n\n\n// bad\n\n\nfunction\n()\n \n{\n \nbalances\n[\nmsg\n.\nsender\n]\n \n+=\n \nmsg\n.\nvalue\n;\n \n}\n\n\n\n// good\n\n\nfunction\n()\n \n{\n \nthrow\n;\n \n}\n\n\nfunction\n \ndeposit\n()\n \nexternal\n \n{\n \nbalances\n[\nmsg\n.\nsender\n]\n \n+=\n \nmsg\n.\nvalue\n;\n \n}\n\n\n\nfunction\n()\n \n{\n \nLogDepositReceived\n(\nmsg\n.\nsender\n);\n \n}\n\n\n\n\n\nExplicitly mark visibility in functions and state variables\n\n\nExplicitly label the visibility of functions and state variables. Functions can be specified as being \nexternal\n, \npublic\n, \ninternal\n or \nprivate\n. For state variables, \nexternal\n is not possible. Labeling the visibility explicitly will make it easier to catch incorrect assumptions about who can call the function or access the variable.\n\n\n// bad\n\n\nuint\n \nx\n;\n \n// the default is private for state variables, but it should be made explicit\n\n\nfunction\n \ntransfer() {\n \n// the default is public\n\n    \n// public code\n\n\n}\n\n\n\n// good\n\n\nuint\n \nprivate\n \ny\n;\n\n\nfunction\n \ntransfer\n()\n \npublic\n \n{\n\n    \n// public code\n\n\n}\n\n\n\nfunction\n \ninternalAction\n()\n \ninternal\n \n{\n\n    \n// internal code\n\n\n}\n\n\n\n\n\nBeware division by zero\n\n\nCurrently, Solidity \nreturns zero\n and does not \nthrow\n an exception when a number is divided by zero. You therefore need to check for division by zero manually.\n\n\n// bad\n\n\nfunction\n \ndivide\n(\nuint\n \nx\n,\n \nuint\n \ny\n)\n \nreturns\n(\nuint\n)\n \n{\n\n    \nreturn\n \nx\n \n/\n \ny\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \ndivide\n(\nuint\n \nx\n,\n \nuint\n \ny\n)\n \nreturns\n(\nuint\n)\n \n{\n\n   \nif\n \n(\ny\n \n==\n \n0\n)\n \n{\n \nthrow\n;\n \n}\n\n\n   \nreturn\n \nx\n \n/\n \ny\n;\n\n\n}\n\n\n\n\n\nDifferentiate functions and events\n\n\nFavor capitalization and a prefix in front of events (we suggest \nLog\n), to prevent the risk of confusion between functions and events. For functions, always start with a lowercase letter, except for the constructor.\n\n\n// bad\n\n\nevent\n \nTransfer() {\n}\n\n\nfunction\n \ntransfer() {\n}\n\n\n\n// good\n\n\nevent\n \nLogTransfer() {\n}\n\n\nfunction\n \ntransfer\n()\n \nexternal\n \n{}\n\n\n\n\n\nKnown Attacks\n\n\nCall Depth Attack \n(Deprecated)\n\n\nWith the Call Depth Attack, \nany\n call (even a fully trusted and correct one) can fail. This is because there is a limit on how deep the \"call stack\" can go. If the attacker does a bunch of recursive calls and brings the stack depth to 1023, then they can call your function and automatically cause all of its subcalls to fail (subcalls include \nsend()\n).\n\n\nAn example based on the previous auction code:\n\n\n// INSECURE\ncontract auction {\n    mapping(address =\n uint) refunds;\n\n    // [...]\n\n    function withdrawRefund(address recipient) {\n      uint refund = refunds[recipient];\n      refunds[recipient] = 0;\n      recipient.send(refund); // this line is vulnerable to a call depth attack\n    }\n}\n\n\n\n\nThe send() can fail if the call depth is too large, causing ether to not be sent. However, the rest of the function would succeed, including the previous line which set the victim's refund balance to 0. The solution is to explicitly check for errors, as discussed previously:\n\n\ncontract auction {\n    mapping(address =\n uint) refunds;\n\n    // [...]\n\n    function withdrawRefund(address recipient) {\n      uint refund = refunds[recipient];\n      refunds[recipient] = 0;\n      if (!recipient.send(refund)) { throw; } // the transaction will be reverted in case of call depth attack\n    }\n}\n\n\n\n\nRace Conditions\n*\n\n\nOne of the major dangers of calling external contracts is that they can take over the control flow, and make changes to your data that the calling function wasn't expecting. This class of bug can take many forms, and both of the major bugs that led to the DAO's collapse were bugs of this sort.\n\n\nReentrancy\n\n\nThe first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways.\n\n\n// INSECURE\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nuserBalances\n;\n\n\n\nfunction\n \nwithdrawBalance\n()\n \npublic\n \n{\n\n    \nuint\n \namountToWithdraw\n \n=\n \nuserBalances\n[\nmsg\n.\nsender\n];\n\n    \nif\n \n(\n!\n(\nmsg\n.\nsender\n.\ncall\n.\nvalue\n(\namountToWithdraw\n)()))\n \n{\n \nthrow\n;\n \n}\n \n// At this point, the caller\ns code is executed, and can call withdrawBalance again\n\n    \nuserBalances\n[\nmsg\n.\nsender\n]\n \n=\n \n0\n;\n\n\n}\n\n\n\n\n\nSince the user's balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed, and will withdraw the balance over and over again. A very similar bug was one of the vulnerabilities in the DAO attack.\n\n\nIn the example given, the best way to avoid the problem is to \nuse \nsend()\n instead of \ncall.value()()\n. This will prevent any external code from being executed.\n\n\nHowever, if you can't remove the external call, the next simplest way to prevent this attack is to make sure you don't call an external function until you've done all the internal work you need to do:\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nuserBalances\n;\n\n\n\nfunction\n \nwithdrawBalance\n()\n \npublic\n \n{\n\n    \nuint\n \namountToWithdraw\n \n=\n \nuserBalances\n[\nmsg\n.\nsender\n];\n\n    \nuserBalances\n[\nmsg\n.\nsender\n]\n \n=\n \n0\n;\n\n    \nif\n \n(\n!\n(\nmsg\n.\nsender\n.\ncall\n.\nvalue\n(\namountToWithdraw\n)()))\n \n{\n \nthrow\n;\n \n}\n \n// The user\ns balance is already 0, so future invocations won\nt withdraw anything\n\n\n}\n\n\n\n\n\nNote that if you had another function which called \nwithdrawBalance()\n, it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions.\n\n\nCross-function Race Conditions\n\n\nAn attacker may also be able to do a similar attack using two different functions that share the same state.\n\n\n// INSECURE\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nuserBalances\n;\n\n\n\nfunction\n \ntransfer\n(\naddress\n \nto\n,\n \nuint\n \namount\n)\n \n{\n\n    \nif\n \n(\nuserBalances\n[\nmsg\n.\nsender\n]\n \n=\n \namount\n)\n \n{\n\n       \nuserBalances\n[\nto\n]\n \n+=\n \namount\n;\n\n       \nuserBalances\n[\nmsg\n.\nsender\n]\n \n-=\n \namount\n;\n\n    \n}\n\n\n}\n\n\n\nfunction\n \nwithdrawBalance\n()\n \npublic\n \n{\n\n    \nuint\n \namountToWithdraw\n \n=\n \nuserBalances\n[\nmsg\n.\nsender\n];\n\n    \nif\n \n(\n!\n(\nmsg\n.\nsender\n.\ncall\n.\nvalue\n(\namountToWithdraw\n)()))\n \n{\n \nthrow\n;\n \n}\n \n// At this point, the caller\ns code is executed, and can call transfer()\n\n    \nuserBalances\n[\nmsg\n.\nsender\n]\n \n=\n \n0\n;\n\n\n}\n\n\n\n\n\nIn this case, the attacker calls \ntransfer()\n when their code is executed on the external call in \nwithdrawBalance\n. Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack.\n\n\nThe same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.\n\n\nPitfalls in Race Condition Solutions\n\n\nSince race conditions can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentry will not be sufficient.\n\n\nInstead, we have recommended finishing all internal work first, and only then calling the external function. This rule, if followed carefully, will allow you to avoid race conditions. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure:\n\n\n// INSECURE\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nuserBalances\n;\n\n\nmapping\n \n(\naddress\n \n=\n \nbool\n)\n \nprivate\n \nclaimedBonus\n;\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nrewardsForA\n;\n\n\n\nfunction\n \nwithdraw\n(\naddress\n \nrecipient\n)\n \npublic\n \n{\n\n    \nuint\n \namountToWithdraw\n \n=\n \nuserBalances\n[\nrecipient\n];\n\n    \nrewardsForA\n[\nrecipient\n]\n \n=\n \n0\n;\n\n    \nif\n \n(\n!\n(\nrecipient\n.\ncall\n.\nvalue\n(\namountToWithdraw\n)()))\n \n{\n \nthrow\n;\n \n}\n\n\n}\n\n\n\nfunction\n \ngetFirstWithdrawalBonus\n(\naddress\n \nrecipient\n)\n \npublic\n \n{\n\n    \nif\n \n(\nclaimedBonus\n[\nrecipient\n])\n \n{\n \nthrow\n;\n \n}\n \n// Each recipient should only be able to claim the bonus once\n\n\n    \nrewardsForA\n[\nrecipient\n]\n \n+=\n \n100\n;\n\n    \nwithdraw\n(\nrecipient\n);\n \n// At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n\n    \nclaimedBonus\n[\nrecipient\n]\n \n=\n \ntrue\n;\n\n\n}\n\n\n\n\n\nEven though \ngetFirstWithdrawalBonus()\n doesn't directly call an external contract, the call in \nwithdraw()\n is enough to make it vulnerable to a race condition. you therefore need to treat \nwithdraw()\n as if it were also untrusted.\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nuserBalances\n;\n\n\nmapping\n \n(\naddress\n \n=\n \nbool\n)\n \nprivate\n \nclaimedBonus\n;\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nrewardsForA\n;\n\n\n\nfunction\n \nuntrustedWithdraw\n(\naddress\n \nrecipient\n)\n \npublic\n \n{\n\n    \nuint\n \namountToWithdraw\n \n=\n \nuserBalances\n[\nrecipient\n];\n\n    \nrewardsForA\n[\nrecipient\n]\n \n=\n \n0\n;\n\n    \nif\n \n(\n!\n(\nrecipient\n.\ncall\n.\nvalue\n(\namountToWithdraw\n)()))\n \n{\n \nthrow\n;\n \n}\n\n\n}\n\n\n\nfunction\n \nuntrustedGetFirstWithdrawalBonus\n(\naddress\n \nrecipient\n)\n \npublic\n \n{\n\n    \nif\n \n(\nclaimedBonus\n[\nrecipient\n])\n \n{\n \nthrow\n;\n \n}\n \n// Each recipient should only be able to claim the bonus once\n\n\n    \nclaimedBonus\n[\nrecipient\n]\n \n=\n \ntrue\n;\n\n    \nrewardsForA\n[\nrecipient\n]\n \n+=\n \n100\n;\n\n    \nuntrustedWithdraw\n(\nrecipient\n);\n \n// claimedBonus has been set to true, so reentry is impossible\n\n\n}\n\n\n\n\n\nIn addition to the fix making reentry impossible, \nuntrusted functions have been marked.\n This same pattern repeats at every level: since \nuntrustedGetFirstWithdrawalBonus()\n calls \nuntrustedWithdraw()\n, which calls an external contract, you must also treat \nuntrustedGetFirstWithdrawalBonus()\n as insecure.\n\n\nAnother solution often suggested is a \nmutex\n. This allows you to \"lock\" some state so it can only be changed by the owner of the lock. A simple example might look like this:\n\n\n// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nbalances\n;\n\n\nbool\n \nprivate\n \nlockBalances\n;\n\n\n\nfunction\n \ndeposit\n()\n \npublic\n \nreturns\n \n(\nbool\n)\n \n{\n\n    \nif\n \n(\n!\nlockBalances\n)\n \n{\n\n        \nlockBalances\n \n=\n \ntrue\n;\n\n        \nbalances\n[\nmsg\n.\nsender\n]\n \n+=\n \nmsg\n.\nvalue\n;\n\n        \nlockBalances\n \n=\n \nfalse\n;\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nthrow\n;\n\n\n}\n\n\n\nfunction\n \nwithdraw\n(\nuint\n \namount\n)\n \npublic\n \nreturns\n \n(\nbool\n)\n \n{\n\n    \nif\n \n(\n!\nlockBalances\n \n \namount\n \n \n0\n \n \nbalances\n[\nmsg\n.\nsender\n]\n \n=\n \namount\n)\n \n{\n\n        \nlockBalances\n \n=\n \ntrue\n;\n\n\n        \nif\n \n(\nmsg\n.\nsender\n.\ncall\n(\namount\n)())\n \n{\n \n// Normally insecure, but the mutex saves it\n\n          \nbalances\n[\nmsg\n.\nsender\n]\n \n-=\n \namount\n;\n\n        \n}\n\n\n        \nlockBalances\n \n=\n \nfalse\n;\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n    \nthrow\n;\n\n\n}\n\n\n\n\n\nIf the user tries to call \nwithdraw()\n again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure:\n\n\n// INSECURE\ncontract StateHolder {\n    uint private n;\n    address private lockHolder;\n\n    function getLock() {\n        if (lockHolder != 0) { throw; }\n        lockHolder = msg.sender;\n    }\n\n    function releaseLock() {\n        lockHolder = 0;\n    }\n\n    function set(uint newState) {\n        if (msg.sender != lockHolder) { throw; }\n        n = newState;\n    }\n}\n\n\n\n\nAn attacker can call \ngetLock()\n, and then never call \nreleaseLock()\n. If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against race conditions, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.)\n\n\n* Some may object to the use of the term \nrace condition\n, since Ethereum does not currently have true parallelism. However, there is still the fundamental feature of logically distinct processes contending for resources, and the same sorts of pitfalls and potential solutions apply.\n\n\n\nDoS with (Unexpected) Throw\n\n\nConsider a simple auction contract:\n\n\n// INSECURE\ncontract Auction {\n    address currentLeader;\n    uint highestBid;\n\n    function bid() {\n        if (msg.value \n= highestBid) { throw; }\n\n        if (!currentLeader.send(highestBid)) { throw; } // Refund the old leader, and throw if it fails\n\n        currentLeader = msg.sender;\n        highestBid = msg.value;\n    }\n}\n\n\n\n\nWhen it tries to refund the old leader, it throws if the refund fails. This means that a malicious bidder can become the leader, while making sure that any refunds to their address will \nalways\n fail. In this way, they can prevent anyone else from calling the \nbid()\n function, and stay the leader forever. A natural solution might be to continue even if the refund fails, under the theory that it's their own fault if they can't accept the refund.\n\n\nAnother example is when a contract may iterate through an array to pay users (e.g., supporters in a crowdfunding contract). It's common to want to make sure that each payment succeeds. If not, one should throw. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never complete. No one gets paid, because one address is forcing an error.\n\n\naddress\n[]\n \nprivate\n \nrefundAddresses\n;\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \npublic\n \nrefunds\n;\n\n\n\n// bad\n\n\nfunction\n \nrefundAll\n()\n \npublic\n \n{\n\n    \nfor\n(\nuint\n \nx\n;\n \nx\n \n \nrefundAddresses\n.\nlength\n;\n \nx\n++\n)\n \n{\n \n// arbitrary length iteration based on how many addresses participated\n\n        \nif\n(\nrefundAddresses\n[\nx\n].\nsend\n(\nrefunds\n[\nrefundAddresses\n[\nx\n]]))\n \n{\n\n            \nthrow\n;\n \n// doubly bad, now a single failure on send will hold up all funds\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nAgain, the recommended solution is to \nfavor pull over push payments\n.\n\n\nDoS with Block Gas Limit\n\n\nYou may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit. Each Ethereum block can process a certain maximum amount of computation. If you try to go over that, your transaction will fail.\n\n\nThis can lead to problems even in the absence of an intentional attack. However, it's especially bad if an attacker can manipulate the amount of gas needed. In the case of the previous example, the attacker could add a bunch of addresses, each of which needs to get a very small refund. The gas cost of refunding each of the attacker's addresses could therefore end up being more than the gas limit, blocking the refund transaction from happening at all.\n\n\nThis is another reason to \nfavor pull over push payments\n.\n\n\nIf you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you've gone, and be able to resume from that point, as in the following example:\n\n\nstruct\n \nPayee\n \n{\n\n    \naddress\n \naddr\n;\n\n    \nuint256\n \nvalue\n;\n\n\n}\n\n\nPayee\n \npayees\n[];\n\n\nuint256\n \nnextPayeeIndex\n;\n\n\n\nfunction\n \npayOut() {\n\n    \nuint256\n \ni\n \n=\n \nnextPayeeIndex\n;\n\n    \nwhile\n \n(\ni\n \n \npayees\n.\nlength\n \n \nmsg\n.\ngas\n \n \n200000\n)\n \n{\n\n      \npayees\n[\ni\n].\naddr\n.\nsend\n(\npayees\n[\ni\n].\nvalue\n);\n\n      \ni\n++\n;\n\n    \n}\n\n    \nnextPayeeIndex\n \n=\n \ni\n;\n\n\n}\n\n\n\n\n\nYou will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the \npayOut()\n function. So only use this pattern if absolutely necessary.\n\n\nTimestamp Dependence\n\n\nThe timestamp of the block can be manipulated by the miner, and so should not be used for critical components of the contract. \nBlock numbers\n and \naverage block time\n can be used to estimate time, but this is not future proof as block times may change (such as the changes expected during Casper).\n\n\nuint startTime = SOME_START_TIME;\n\nif (now \n startTime + 1 week) { // the now can be manipulated by the miner\n\n}\n\n\n\n\nTransaction-Ordering Dependence (TOD)\n\n\nSince a transaction is in the mempool for a short while, one can know what actions will occur, before it is included in a block. This can be troublesome for things like decentralized markets, where a transaction to buy some tokens can be seen, and a market order implemented before the other transaction gets included. Protecting against this is difficult, as it would come down to the specific contract itself. For example, in markets, it would be better to implement batch auctions (this also protects against high frequency trading concerns). Another way to use a pre-commit scheme (\u201cI\u2019m going to submit the details later\u201d).\n\n\nSoftware Engineering Techniques\n\n\nAs we discussed in the \nGeneral Philosophy\n section, it is not enough to protect yourself against the known attacks. Since the cost of failure on a blockchain can be very high, you must also adapt the way you write software, to account for that risk.\n\n\nThe approach we advocate is to \"prepare for failure\". It is impossible to know in advance whether your code is secure. However, you can architect your contracts in a way that allows them to fail gracefully, and with minimal damage. This section presents a variety of techniques that will help you prepare for failure.\n\n\nNote: There's always a risk when you add a new component to your system. A badly designed fail-safe could itself become a vulnerability - as can the interaction between a number of well designed fail-safes. Be thoughtful about each technique you use in your contracts, and consider carefully how they work together to create a robust system.\n\n\nUpgrading Broken Contracts\n\n\nCode will need to be changed if errors are discovered or if improvements need to be made. It is no good to discover a bug, but have no way to deal with it.\n\n\nDesigning an effective upgrade system for smart contracts is an area of active research, and we won't be able to cover all of the complications in this document. However, there are two basic approaches that are most commonly used. The simpler of the two is to have a registry contract that holds the address of the latest version of the contract. A more seamless approach for contract users is to have a contract that forwards calls and data onto the latest version of the contract.\n\n\nWhatever the technique, it's important to have modularization and good separation between components, so that code changes do not break functionality, orphan data, or require substantial costs to port. In particular, it is usually beneficial to separate complex logic from your data storage, so that you do not have to recreate all of the data in order to change the functionality.\n\n\nIt's also critical to have a secure way for parties to decide to upgrade the code. Depending on your contract, code changes may need to be approved by a single trusted party, a group of members, or a vote of the full set of stakeholders. If this process can take some time, you will want to consider if there are other ways to react more quickly in case of an attack, such as an \nemergency stop or circuit-breaker\n.\n\n\nExample 1: Use a registry contract to store latest version of a contract\n\n\nIn this example, the calls aren't forwarded, so users should fetch the current address each time before interacting with it.\n\n\ncontract SomeRegister {\n    address backendContract;\n    address[] previousBackends;\n    address owner;\n\n    function SomeRegister() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _\n    }\n\n    function changeBackend(address newBackend) public\n    onlyOwner()\n    returns (bool)\n    {\n        if(newBackend != backendContract) {\n            previousBackends.push(backendContract);\n            backendContract = newBackend;\n            return true;\n        }\n\n        return false;\n    }\n}\n\n\n\n\nThere are two main disadvantages to this approach:\n\n\n\n\nUsers must always look up the current address, and anyone who fails to do so risks using an old version of the contract\n\n\nYou will need to think carefully about how to deal with the contract data, when you replace the contract\n\n\n\n\nThe alternate approach is to have a contract forward calls and data to the latest version of the contract:\n\n\nExample 2: \nUse a \nDELEGATECALL\n to forward data and calls\n\n\ncontract Relay {\n    address public currentVersion;\n    address public owner;\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _\n    }\n\n    function Relay(address initAddr) {\n        currentVersion = initAddr;\n        owner = msg.sender; // this owner may be another contract with multisig, not a single contract owner\n    }\n\n    function changeContract(address newVersion) public\n    onlyOwner()\n    {\n        currentVersion = newVersion;\n    }\n\n    function() {\n        if(!currentVersion.delegatecall(msg.data)) throw;\n    }\n}\n\n\n\n\nThis approach avoids the previous problems, but has problems of its own. You must be extremely careful with how you store data in this contract. If your new contract has a different storage layout than the first, your data may end up corrupted. Additionally, this simple version of the pattern cannot return values from functions, only forward them, which limits its applicability. (\nMore complex implementations\n attempt to solve this with in-line assembly code and a registry of return sizes.)\n\n\nRegardless of your approach, it is important to have some way to upgrade your contracts, or they will become unusable when the inevitable bugs are discovered in them.\n\n\nCircuit Breakers (Pause contract functionality)\n\n\nCircuit breakers stop execution if certain conditions are met, and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a bug is discovered, and the only action now active is a withdrawal. You can either give certain trusted parties the ability to trigger the circuit breaker, or else have programmatic rules that automatically trigger the certain breaker when certain conditions are met.\n\n\nExample:\n\n\nbool\n \nprivate\n \nstopped\n \n=\n \nfalse\n;\n\n\naddress\n \nprivate\n \nowner\n;\n\n\n\nmodifier\n \nisAdmin() {\n\n    \nif\n(\nmsg\n.\nsender\n \n!=\n \nowner\n)\n \n{\n\n        \nthrow\n;\n\n    \n}\n\n    \n_\n\n\n}\n\n\n\nfunction\n \ntoggleContractActive\n()\n \nisAdmin\n \npublic\n\n\n{\n\n    \n// You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users\n\n    \nstopped\n \n=\n \n!\nstopped\n;\n\n\n}\n\n\n\nmodifier\n \nstopInEmergency\n \n{\n \nif\n \n(\n!\nstopped\n)\n \n_\n \n}\n\n\nmodifier\n \nonlyInEmergency\n \n{\n \nif\n \n(\nstopped\n)\n \n_\n \n}\n\n\n\nfunction\n \ndeposit\n()\n \nstopInEmergency\n \npublic\n\n\n{\n\n    \n// some code\n\n\n}\n\n\n\nfunction\n \nwithdraw\n()\n \nonlyInEmergency\n \npublic\n\n\n{\n\n    \n// some code\n\n\n}\n\n\n\n\n\nSpeed Bumps (Delay contract actions)\n\n\nSpeed bumps slow down actions, so that if malicious actions occur, there is time to recover. For example, \nThe DAO\n required 27 days between a successful request to split the DAO and the ability to do so. This ensured the funds were kept within the contract, increasing the likelihood of recovery. In the case of the DAO, there was no effective action that could be taken during the time given by the speed bump, but in combination with our other techniques, they can be quite effective.\n\n\nExample:\n\n\nstruct\n \nRequestedWithdrawal\n \n{\n\n    \nuint\n \namount\n;\n\n    \nuint\n \ntime\n;\n\n\n}\n\n\n\nmapping\n \n(\naddress\n \n=\n \nuint\n)\n \nprivate\n \nbalances\n;\n\n\nmapping\n \n(\naddress\n \n=\n \nRequestedWithdrawal\n)\n \nprivate\n \nrequestedWithdrawals\n;\n\n\nuint\n \nconstant\n \nwithdrawalWaitPeriod\n \n=\n \n28\n \ndays\n;\n \n// 4 weeks\n\n\n\nfunction\n \nrequestWithdrawal\n()\n \npublic\n \n{\n\n    \nif\n \n(\nbalances\n[\nmsg\n.\nsender\n]\n \n \n0\n)\n \n{\n\n        \nuint\n \namountToWithdraw\n \n=\n \nbalances\n[\nmsg\n.\nsender\n];\n\n        \nbalances\n[\nmsg\n.\nsender\n]\n \n=\n \n0\n;\n \n// for simplicity, we withdraw everything;\n\n        \n// presumably, the deposit function prevents new deposits when withdrawals are in progress\n\n\n        \nrequestedWithdrawals\n[\nmsg\n.\nsender\n]\n \n=\n \nRequestedWithdrawal\n({\n\n            \namount\n: \namountToWithdraw\n,\n\n            \ntime\n: \nnow\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\nfunction\n \nwithdraw\n()\n \npublic\n \n{\n\n    \nif\n(\nrequestedWithdrawals\n[\nmsg\n.\nsender\n].\namount\n \n \n0\n \n \nnow\n \n \nrequestedWithdrawals\n[\nmsg\n.\nsender\n].\ntime\n \n+\n \nwithdrawalWaitPeriod\n)\n \n{\n\n        \nuint\n \namountToWithdraw\n \n=\n \nrequestedWithdrawals\n[\nmsg\n.\nsender\n].\namount\n;\n\n        \nrequestedWithdrawals\n[\nmsg\n.\nsender\n].\namount\n \n=\n \n0\n;\n\n\n        \nif\n(\n!\nmsg\n.\nsender\n.\nsend\n(\namountToWithdraw\n))\n \n{\n\n            \nthrow\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nRate Limiting\n\n\nRate limiting halts or requires approval for substantial changes. For example, a depositor may only be allowed to withdraw a certain amount or percentage of total deposits over a certain time period (e.g., max 100 ether over 1 day) - additional withdrawals in that time period may fail or require some sort of special approval. Or the rate limit could be at the contract level, with only a certain amount of tokens issued by the contract over a time period.\n\n\nExample\n\n\nAssert Guards\n\n\nAn assert guard triggers when an assertion fails - such as an invariant property changing. For example, the token to ether issuance ratio, in a token issuance contract, may be fixed. You can verify that this is the case at all times with an assertion. Assert guards should often be combined with other techniques, such as pausing the contract and allowing upgrades. (Otherwise you may end up stuck, with an assertion that is always failing.)\n\n\nThe following example reverts transactions if the ratio of ether to total number of tokens changes:\n\n\ncontract TokenWithInvariants {\n    mapping(address =\n uint) public balanceOf;\n    uint public totalSupply;\n\n    modifier checkInvariants {\n        _\n        if (this.balance \n totalSupply) throw;\n    }\n\n    function deposit(uint amount) public checkInvariants {\n        // intentionally vulnerable\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n    }\n\n    function transfer(address to, uint value) public checkInvariants {\n        if (balanceOf[msg.sender] \n= value) {\n            balanceOf[to] += value;\n            balanceOf[msg.sender] -= value;\n        }\n    }\n\n    function withdraw() public checkInvariants {\n        // intentionally vulnerable\n        uint balance = balanceOf[msg.sender];\n        if (msg.sender.call.value(balance)()) {\n            totalSupply -= balance;\n            balanceOf[msg.sender] = 0;\n        }\n    }\n}\n\n\n\n\nContract Rollout\n\n\nContracts should have a substantial and prolonged testing period - before substantial money is put at risk.\n\n\nAt minimum, you should:\n\n\n\n\nHave a full test suite with 100% test coverage (or close to it)\n\n\nDeploy on your own testnet\n\n\nDeploy on the public testnet with substantial testing and bug bounties\n\n\nExhaustive testing should allow various players to interact with the contract at volume\n\n\nDeploy on the mainnet in beta, with limits to the amount at risk\n\n\n\n\nAutomatic Deprecation\n\n\nDuring testing, you can force an automatic deprecation by preventing any actions, after a certain time period. For example, an alpha contract may work for several weeks and then automatically shut down all actions, except for the final withdrawal.\n\n\nmodifier\n \nisActive() {\n\n    \nif\n \n(\nblock\n.\nnumber\n \n \nSOME_BLOCK_NUMBER\n)\n \n{\n\n        \nthrow\n;\n\n    \n}\n\n    \n_\n\n\n}\n\n\n\nfunction\n \ndeposit\n()\n \npublic\n\n\nisActive() {\n\n    \n// some code\n\n\n}\n\n\n\nfunction\n \nwithdraw\n()\n \npublic\n \n{\n\n    \n// some code\n\n\n}\n\n\n\n\n\nRestrict amount of Ether per user/contract\n\n\nIn the early stages, you can restrict the amount of Ether for any user (or for the entire contract) - reducing the risk.\n\n\nSecurity-related Documentation and Procedures\n\n\nWhen launching a contract that will have substantial funds or is required to be mission critical, it is important to include proper documentation. Some documentation related to security includes:\n\n\nStatus\n\n\n\n\nWhere current code is deployed\n\n\nCurrent status of deployed code (including outstanding issues, performance stats, etc.)\n\n\n\n\nKnown Issues\n\n\n\n\nKey risks with contract\n\n\ne.g., You can lose all your money, hacker can vote for certain outcomes\n\n\nAll known bugs/limitations\n\n\nPotential attacks and mitigants\n\n\nPotential conflicts of interest (e.g., will be using yourself, like Slock.it did with the DAO)\n\n\n\n\nHistory\n\n\n\n\nTesting (including usage stats, discovered bugs, length of testing)\n\n\nPeople who have reviewed code (and their key feedback)\n\n\n\n\nProcedures\n\n\n\n\nAction plan in case a bug is discovered (e.g., emergency options, public notification process, etc.)\n\n\nWind down process if something goes wrong (e.g., funders will get percentage of your balance before attack, from remaining funds)\n\n\nResponsible disclosure policy (e.g., where to report bugs found, the rules of any bug bounty program)\n\n\nRecourse in case of failure (e.g., insurance, penalty fund, no recourse)\n\n\n\n\nContact Information\n\n\n\n\nWho to contact with issues\n\n\nNames of programmers and/or other important parties\n\n\nChat room where questions can be asked\n\n\n\n\nSecurity Tools\n\n\n\n\n\n\nOyente\n - An upcoming tool, will analyze Ethereum code to find common vulnerabilities (e.g., Transaction Order Dependence, no checking for exceptions)\n\n\n\n\n\n\nSolgraph\n - Generates a DOT graph that visualizes function control flow of a Solidity contract and highlights potential security vulnerabilities.\n\n\n\n\n\n\nsolint\n - Another upcoming tool, will provide Solidity linting that helps you enforce consistent conventions and avoid errors in your Solidity smart-contracts.\n\n\n\n\n\n\nFuture improvements\n\n\n\n\n\n\nEditor Security Warnings\n: Editors will soon alert for common security errors, not just compilation errors. Browser Solidity is getting these features soon.\n\n\n\n\n\n\nNew functional languages that compile to EVM bytecode\n: Functional languages gives certain guarantees over procedural languages like Solidity, namely immutability within a function and strong compile time checking. This can reduce the risk of errors by providing deterministic behavior. (for more see \nthis\n, Curry-Howard correspondence, and linear logic)\n\n\n\n\n\n\nSmart Contract Security Bibliography\n\n\nA lot of this document contains code, examples and insights gained from various parts already written by the community.\nHere are some of them.  Feel free to add more.\n\n\nBy Ethereum core developers\n\n\n\n\nHow to Write Safe Smart Contracts\n (Christian Reitwiessner)\n\n\nSmart Contract Security\n (Christian Reitwiessner)\n\n\nThinking about Smart Contract Security\n (Vitalik Buterin)\n\n\nSolidity\n\n\nSolidity Security Considerations\n\n\n\n\nBy Community\n\n\n\n\nhttp://forum.ethereum.org/discussion/1317/reentrant-contracts\n\n\nhttp://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/\n\n\nhttp://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/\n\n\nhttp://hackingdistributed.com/2016/06/22/smart-contract-escape-hatches/\n\n\nhttp://martin.swende.se/blog/Devcon1-and-contract-security.html\n\n\nhttp://publications.lib.chalmers.se/records/fulltext/234939/234939.pdf\n\n\nhttp://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour\n\n\nhttp://vessenes.com/ethereum-griefing-wallets-send-w-throw-considered-harmful\n\n\nhttp://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal\n\n\nhttps://blog.blockstack.org/simple-contracts-are-better-contracts-what-we-can-learn-from-the-dao-6293214bad3a\n\n\nhttps://blog.slock.it/deja-vu-dao-smart-contracts-audit-results-d26bc088e32e\n\n\nhttps://github.com/Bunjin/Rouleth/blob/master/Security.md\n\n\nhttps://github.com/LeastAuthority/ethereum-analyses\n\n\nhttps://medium.com/@ConsenSys/assert-guards-towards-automated-code-bounties-safe-smart-contract-coding-on-ethereum-8e74364b795c\n\n\nhttps://medium.com/@coriacetic/in-bits-we-trust-4e464b418f0b\n\n\nhttps://medium.com/@hrishiolickel/why-smart-contracts-fail-undiscovered-bugs-and-what-we-can-do-about-them-119aa2843007\n\n\nhttps://medium.com/@peterborah/we-need-fault-tolerant-smart-contracts-ec1b56596dbc\n\n\nhttps://pdaian.com/blog/chasing-the-dao-attackers-wake\n\n\nhttp://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf\n\n\n\n\nAttribution\n\n\nThis work, \"Safety\", is a derivative of \n\"Smart Contract Best Practices\"\n, used under CC BY. \"Safety\" is licensed under CC BY by the Ethereum community.\n\n\nLicense\n\n\nLicensed under \nApache 2.0\n\n\nLicensed under \nCreative Commons Attribution-NonCommercial-ShareAlike 4.0 International", 
            "title": "\u5b89\u5168\u6280\u672f"
        }, 
        {
            "location": "/Dapps/Safety/#_1", 
            "text": "The community is encouraged to keep this wiki updated: it becomes more complete as more contributions are added.  Currently this wiki is out-of-date and see its source  \"Smart Contract Best Practices\"  for more recent updates and corrections.", 
            "title": "\u4ee5\u592a\u574a\u5408\u540c\u5b89\u5168\u6280\u672f\u548c\u6280\u5de7"
        }, 
        {
            "location": "/Dapps/Safety/#additional-requested-content", 
            "text": "We especially welcome content in the following areas:   Testing Solidity code (structure, frameworks, common test idioms)  Software engineering practices for smart contracts and/or blockchain-based programming", 
            "title": "Additional Requested Content"
        }, 
        {
            "location": "/Dapps/Safety/#general-philosophy", 
            "text": "Ethereum and complex blockchain programs are new and highly experimental. Therefore, you should expect constant changes in the security landscape, as new bugs and security risks are discovered, and new best practices are developed. Following the security practices in this document is therefore only the beginning of the security work you will need to do as a smart contract developer.  Smart contract programming requires a different engineering mindset than you may be used to. The cost of failure can be high, and change can be difficult, making it in some ways more similar to hardware programming or financial services programming than web or mobile development. It is therefore not enough to defend against known vulnerabilities. Instead, you will need to learn a new philosophy of development:   Prepare for failure . Any non-trivial contract will have errors in it. Your code must therefore be able to respond to bugs and vulnerabilities gracefully.  Pause the contract when things are going wrong ('circuit breaker')  Manage the amount of money at risk (rate limiting, maximum usage)   Have an effective upgrade path for bugfixes and improvements    Roll out carefully . It is always better to catch bugs before a full production release.   Test contracts thoroughly, and add tests whenever new attack vectors are discovered  Provide bug bounties starting from alpha testnet releases   Rollout in phases, with increasing usage and testing in each phase    Keep contracts simple . Complexity increases the likelihood of errors.   Ensure the contract logic is simple  Modularize code to keep contracts and functions small  Use already-written tools or code where possible (eg. don't roll your own random number generator)  Prefer clarity to performance whenever possible   Only use the blockchain for the parts of your system that require decentralization    Stay up to date . Use the resources listed in the next section to keep track of new security developments.   Check your contracts for any new bug that's discovered  Upgrade to the latest version of any tool or library as soon as possible   Adopt new security techniques that appear useful    Be aware of blockchain properties . While much of your programming experience will be relevant to Ethereum programming, there are some pitfalls to be aware of.   Be extremely careful about external contract calls, which may execute malicious code and change control flow.  Understand that your public functions are public, and may be called maliciously. Your private data is also viewable by anyone.  Keep gas costs and the block gas limit in mind.", 
            "title": "General Philosophy"
        }, 
        {
            "location": "/Dapps/Safety/#security-notifications", 
            "text": "This is a list of resources that will often highlight discovered exploits in Ethereum or Solidity. The official source of security notifications is the Ethereum Blog, but in many cases vulnerabilities will be disclosed and discussed earlier in other locations.   Ethereum Blog : The official Ethereum blog  Ethereum Blog - Security only : All blog posts that are tagged  Security  Ethereum Gitter  chat rooms  Solidity  Go-Ethereum  CPP-Ethereum  Research  Reddit  Network Stats   It's highly recommended that you  regularly  read all these sources, as exploits they note may impact your contracts.  Additionally, here is a list of Ethereum core developers who may write about security, and see the  bibliography  for more from the community.   Vitalik Buterin :  Twitter ,  Github ,  Reddit ,  Ethereum Blog  Dr. Christian Reitwiessner :  Twitter ,  Github ,  Ethereum Blog  Dr. Gavin Wood :  Twitter ,  Blog ,  Github  Vlad Zamfir :  Twitter ,  Github ,  Ethereum Blog   Beyond following core developers, it is critical to participate in the wider blockchain-related security community - as security disclosures or observations will come through a variety of parties.", 
            "title": "Security Notifications"
        }, 
        {
            "location": "/Dapps/Safety/#recommendations-for-smart-contract-security-in-solidity", 
            "text": "", 
            "title": "Recommendations for Smart Contract Security in Solidity"
        }, 
        {
            "location": "/Dapps/Safety/#external-calls", 
            "text": "", 
            "title": "External Calls"
        }, 
        {
            "location": "/Dapps/Safety/#avoid-external-calls-when-possible", 
            "text": "Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract  or  any other contract that it depends upon. As such, every external call should be treated as a potential security risk, and removed if possible. When it is not possible to remove external calls, use the recommendations in the rest of this section to minimize the danger.", 
            "title": "Avoid external calls when possible"
        }, 
        {
            "location": "/Dapps/Safety/#use-send-avoid-callvalue", 
            "text": "When sending Ether, use  someAddress.send()  and avoid  someAddress.call.value()() .  External calls such as  someAddress.call.value()()  can trigger malicious code. While  send()  also triggers code, it is safe because it only has access to gas stipend of 2,300 gas. Currently, this is only enough to log an event, not enough to launch an attack.  // bad\nif(!someAddress.call.value(100)()) {\n    // Some failure code\n}\n\n// good\nif(!someAddress.send(100)) {\n    // Some failure code\n}", 
            "title": "Use send(), avoid call.value()"
        }, 
        {
            "location": "/Dapps/Safety/#handle-errors-in-external-calls", 
            "text": "Solidity offers low-level call methods that work on raw addresses:  address.call() ,  address.callcode() ,  address.delegatecall() , and  address.send . These low-level methods never throw an exception, but will return  false  if the call encounters an exception. On the other hand,  contract calls  (e.g.,  ExternalContract.doSomething() ) will automatically propagate a throw (for example,  ExternalContract.doSomething()  will also  throw  if  doSomething()  throws).  If you choose to use the low-level call methods, make sure to handle the possibility that the call will fail, by checking the return value.  // bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn t check for result\nsomeAddress.call.value(100)(bytes4(sha3( deposit() ))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\nif(!someAddress.send(55)) {\n    // Some failure code\n}\n\nExternalContract(someAddress).deposit.value(100);", 
            "title": "Handle errors in external calls"
        }, 
        {
            "location": "/Dapps/Safety/#dont-make-control-flow-assumptions-after-external-calls", 
            "text": "Whether using  raw calls  or  contract calls , assume that malicious code will execute if  ExternalContract  is untrusted. Even if  ExternalContract  is not malicious, malicious code can be executed by any contracts  it  calls. One particular danger is malicious code may hijack the control flow, leading to race conditions. (See  Race Conditions  for a fuller discussion of this problem).", 
            "title": "Don't make control flow assumptions after external calls"
        }, 
        {
            "location": "/Dapps/Safety/#favor-pull-over-push-for-external-calls", 
            "text": "As we've seen, external calls can fail for a number of reasons, including external errors. To minimize the damage caused by such failures, it is often better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of  problems with the gas limit .)  // bad\ncontract auction {\n    address highestBidder;\n    uint highestBid;\n\n    function bid() {\n        if (msg.value   highestBid) throw;\n\n        if (highestBidder != 0) {\n            if (!highestBidder.send(highestBid)) { // if this call consistently fails, no one else can bid\n                throw;\n            }\n        }\n\n       highestBidder = msg.sender;\n       highestBid = msg.value;\n    }\n}\n\n// good\ncontract auction {\n    address highestBidder;\n    uint highestBid;\n    mapping(address =  uint) refunds;\n\n    function bid() external {\n        if (msg.value   highestBid) throw;\n\n        if (highestBidder != 0) {\n            refunds[highestBidder] += highestBid; // record the refund that this user can claim\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdrawRefund() external {\n        uint refund = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        if (!msg.sender.send(refund)) {\n            refunds[msg.sender] = refund; // reverting state because send failed\n        }\n    }\n}", 
            "title": "Favor pull over push for external calls"
        }, 
        {
            "location": "/Dapps/Safety/#mark-untrusted-contracts", 
            "text": "When interacting with external contracts, name your variables, methods, and contract interfaces in a way that makes it clear that interacting with them is potentially unsafe. This applies to your own functions that call external contracts.  // bad  Bank . withdraw ( 100 );   // Unclear whether trusted or untrusted  function   makeWithdrawal ( uint   amount )   {   // Isn t clear that this function is potentially unsafe \n     UntrustedBank . withdraw ( amount );  }  // good  UntrustedBank . withdraw ( 100 );   // untrusted external call  TrustedBank . withdraw ( 100 );   // external but trusted bank contract maintained by XYZ Corp  function   makeUntrustedWithdrawal ( uint   amount )   { \n     UntrustedBank . withdraw ( amount );  }", 
            "title": "Mark untrusted contracts"
        }, 
        {
            "location": "/Dapps/Safety/#beware-rounding-with-integer-division", 
            "text": "All integer divison rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator.  (In the future, Solidity will have a fixed-point type, which will make this easier.)  // bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n\n// good\nuint multiplier = 10;\nuint x = (5 * multiplier) / 2;\n\nuint numerator = 5;\nuint denominator = 2;", 
            "title": "Beware rounding with integer division"
        }, 
        {
            "location": "/Dapps/Safety/#remember-that-on-chain-data-is-public", 
            "text": "Many applications require submitted data to be private up until some point in time in order to work. Games (eg. on-chain rock-paper-scissors) and auction mechanisms (eg. sealed-bid second-price auctions) are two major categories of examples. If you are building an application where privacy is an issue, take care to avoid requiring users to publish information too early.  Examples:   In rock paper scissors, require both players to submit a hash of their intended move first, then require both players to submit their move; if the submitted move does not match the hash throw it out.  In an auction, require players to submit a hash of their bid value in an initial phase (along with a deposit greater than their bid value), and then submit their action bid value in the second phase.  When developing an application that depends on a random number generator, the order should always be (1) players submit moves, (2) random number generated, (3) players paid out. The method by which random numbers are generated is itself an area of active research; current best-in-class solutions include Bitcoin block headers (verified through http://btcrelay.org), hash-commit-reveal schemes (ie. one party generates a number, publishes its hash to \"commit\" to the value, and then reveals the value later) and  RANDAO .  If you are implementing a frequent batch auction, a hash-commit scheme is also desirable.", 
            "title": "Remember that on-chain data is public"
        }, 
        {
            "location": "/Dapps/Safety/#in-2-party-or-n-party-contracts-beware-of-the-possibility-that-some-participants-may-drop-offline-and-not-return", 
            "text": "Do not make refund or claim processes dependent on a specific party performing a particular action with no other way of getting the funds out. For example, in a rock-paper-scissors game, one common mistake is to not make a payout until both players submit their moves; however, a malicious player can \"grief\" the other by simply never submitting their move - in fact, if a player sees the other player's revealed move and determiners that they lost, they have no reason to submit their own move at all. This issue may also arise in the context of state channel settlement. When such situations are an issue, (1) provide a way of circumventing non-participating participants, perhaps through a time limit, and (2) consider adding an additional economic incentive for participants to submit information in all of the situations in which they are supposed to do so.", 
            "title": "In 2-party or N-party contracts, beware of the possibility that some participants may \"drop offline\" and not return"
        }, 
        {
            "location": "/Dapps/Safety/#keep-fallback-functions-simple", 
            "text": "Fallback functions  are called when a contract is sent a message with no arguments (or when no function matches), and only has access to 2,300 gas when called from a  .send() . If you wish to be able to receive Ether from a  .send() , the most you can do in a fallback function is log an event. Use a proper function if a computation or more gas is required.  // bad  function ()   {   balances [ msg . sender ]   +=   msg . value ;   }  // good  function ()   {   throw ;   }  function   deposit ()   external   {   balances [ msg . sender ]   +=   msg . value ;   }  function ()   {   LogDepositReceived ( msg . sender );   }", 
            "title": "Keep fallback functions simple"
        }, 
        {
            "location": "/Dapps/Safety/#explicitly-mark-visibility-in-functions-and-state-variables", 
            "text": "Explicitly label the visibility of functions and state variables. Functions can be specified as being  external ,  public ,  internal  or  private . For state variables,  external  is not possible. Labeling the visibility explicitly will make it easier to catch incorrect assumptions about who can call the function or access the variable.  // bad  uint   x ;   // the default is private for state variables, but it should be made explicit  function   transfer() {   // the default is public \n     // public code  }  // good  uint   private   y ;  function   transfer ()   public   { \n     // public code  }  function   internalAction ()   internal   { \n     // internal code  }", 
            "title": "Explicitly mark visibility in functions and state variables"
        }, 
        {
            "location": "/Dapps/Safety/#beware-division-by-zero", 
            "text": "Currently, Solidity  returns zero  and does not  throw  an exception when a number is divided by zero. You therefore need to check for division by zero manually.  // bad  function   divide ( uint   x ,   uint   y )   returns ( uint )   { \n     return   x   /   y ;  }  // good  function   divide ( uint   x ,   uint   y )   returns ( uint )   { \n    if   ( y   ==   0 )   {   throw ;   } \n\n    return   x   /   y ;  }", 
            "title": "Beware division by zero"
        }, 
        {
            "location": "/Dapps/Safety/#differentiate-functions-and-events", 
            "text": "Favor capitalization and a prefix in front of events (we suggest  Log ), to prevent the risk of confusion between functions and events. For functions, always start with a lowercase letter, except for the constructor.  // bad  event   Transfer() { }  function   transfer() { }  // good  event   LogTransfer() { }  function   transfer ()   external   {}", 
            "title": "Differentiate functions and events"
        }, 
        {
            "location": "/Dapps/Safety/#known-attacks", 
            "text": "", 
            "title": "Known Attacks"
        }, 
        {
            "location": "/Dapps/Safety/#call-depth-attack-deprecated", 
            "text": "With the Call Depth Attack,  any  call (even a fully trusted and correct one) can fail. This is because there is a limit on how deep the \"call stack\" can go. If the attacker does a bunch of recursive calls and brings the stack depth to 1023, then they can call your function and automatically cause all of its subcalls to fail (subcalls include  send() ).  An example based on the previous auction code:  // INSECURE\ncontract auction {\n    mapping(address =  uint) refunds;\n\n    // [...]\n\n    function withdrawRefund(address recipient) {\n      uint refund = refunds[recipient];\n      refunds[recipient] = 0;\n      recipient.send(refund); // this line is vulnerable to a call depth attack\n    }\n}  The send() can fail if the call depth is too large, causing ether to not be sent. However, the rest of the function would succeed, including the previous line which set the victim's refund balance to 0. The solution is to explicitly check for errors, as discussed previously:  contract auction {\n    mapping(address =  uint) refunds;\n\n    // [...]\n\n    function withdrawRefund(address recipient) {\n      uint refund = refunds[recipient];\n      refunds[recipient] = 0;\n      if (!recipient.send(refund)) { throw; } // the transaction will be reverted in case of call depth attack\n    }\n}", 
            "title": "Call Depth Attack (Deprecated)"
        }, 
        {
            "location": "/Dapps/Safety/#race-conditions42", 
            "text": "One of the major dangers of calling external contracts is that they can take over the control flow, and make changes to your data that the calling function wasn't expecting. This class of bug can take many forms, and both of the major bugs that led to the DAO's collapse were bugs of this sort.", 
            "title": "Race Conditions*"
        }, 
        {
            "location": "/Dapps/Safety/#reentrancy", 
            "text": "The first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways.  // INSECURE  mapping   ( address   =   uint )   private   userBalances ;  function   withdrawBalance ()   public   { \n     uint   amountToWithdraw   =   userBalances [ msg . sender ]; \n     if   ( ! ( msg . sender . call . value ( amountToWithdraw )()))   {   throw ;   }   // At this point, the caller s code is executed, and can call withdrawBalance again \n     userBalances [ msg . sender ]   =   0 ;  }   Since the user's balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed, and will withdraw the balance over and over again. A very similar bug was one of the vulnerabilities in the DAO attack.  In the example given, the best way to avoid the problem is to  use  send()  instead of  call.value()() . This will prevent any external code from being executed.  However, if you can't remove the external call, the next simplest way to prevent this attack is to make sure you don't call an external function until you've done all the internal work you need to do:  mapping   ( address   =   uint )   private   userBalances ;  function   withdrawBalance ()   public   { \n     uint   amountToWithdraw   =   userBalances [ msg . sender ]; \n     userBalances [ msg . sender ]   =   0 ; \n     if   ( ! ( msg . sender . call . value ( amountToWithdraw )()))   {   throw ;   }   // The user s balance is already 0, so future invocations won t withdraw anything  }   Note that if you had another function which called  withdrawBalance() , it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions.", 
            "title": "Reentrancy"
        }, 
        {
            "location": "/Dapps/Safety/#cross-function-race-conditions", 
            "text": "An attacker may also be able to do a similar attack using two different functions that share the same state.  // INSECURE  mapping   ( address   =   uint )   private   userBalances ;  function   transfer ( address   to ,   uint   amount )   { \n     if   ( userBalances [ msg . sender ]   =   amount )   { \n        userBalances [ to ]   +=   amount ; \n        userBalances [ msg . sender ]   -=   amount ; \n     }  }  function   withdrawBalance ()   public   { \n     uint   amountToWithdraw   =   userBalances [ msg . sender ]; \n     if   ( ! ( msg . sender . call . value ( amountToWithdraw )()))   {   throw ;   }   // At this point, the caller s code is executed, and can call transfer() \n     userBalances [ msg . sender ]   =   0 ;  }   In this case, the attacker calls  transfer()  when their code is executed on the external call in  withdrawBalance . Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack.  The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.", 
            "title": "Cross-function Race Conditions"
        }, 
        {
            "location": "/Dapps/Safety/#pitfalls-in-race-condition-solutions", 
            "text": "Since race conditions can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentry will not be sufficient.  Instead, we have recommended finishing all internal work first, and only then calling the external function. This rule, if followed carefully, will allow you to avoid race conditions. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure:  // INSECURE  mapping   ( address   =   uint )   private   userBalances ;  mapping   ( address   =   bool )   private   claimedBonus ;  mapping   ( address   =   uint )   private   rewardsForA ;  function   withdraw ( address   recipient )   public   { \n     uint   amountToWithdraw   =   userBalances [ recipient ]; \n     rewardsForA [ recipient ]   =   0 ; \n     if   ( ! ( recipient . call . value ( amountToWithdraw )()))   {   throw ;   }  }  function   getFirstWithdrawalBonus ( address   recipient )   public   { \n     if   ( claimedBonus [ recipient ])   {   throw ;   }   // Each recipient should only be able to claim the bonus once \n\n     rewardsForA [ recipient ]   +=   100 ; \n     withdraw ( recipient );   // At this point, the caller will be able to execute getFirstWithdrawalBonus again. \n     claimedBonus [ recipient ]   =   true ;  }   Even though  getFirstWithdrawalBonus()  doesn't directly call an external contract, the call in  withdraw()  is enough to make it vulnerable to a race condition. you therefore need to treat  withdraw()  as if it were also untrusted.  mapping   ( address   =   uint )   private   userBalances ;  mapping   ( address   =   bool )   private   claimedBonus ;  mapping   ( address   =   uint )   private   rewardsForA ;  function   untrustedWithdraw ( address   recipient )   public   { \n     uint   amountToWithdraw   =   userBalances [ recipient ]; \n     rewardsForA [ recipient ]   =   0 ; \n     if   ( ! ( recipient . call . value ( amountToWithdraw )()))   {   throw ;   }  }  function   untrustedGetFirstWithdrawalBonus ( address   recipient )   public   { \n     if   ( claimedBonus [ recipient ])   {   throw ;   }   // Each recipient should only be able to claim the bonus once \n\n     claimedBonus [ recipient ]   =   true ; \n     rewardsForA [ recipient ]   +=   100 ; \n     untrustedWithdraw ( recipient );   // claimedBonus has been set to true, so reentry is impossible  }   In addition to the fix making reentry impossible,  untrusted functions have been marked.  This same pattern repeats at every level: since  untrustedGetFirstWithdrawalBonus()  calls  untrustedWithdraw() , which calls an external contract, you must also treat  untrustedGetFirstWithdrawalBonus()  as insecure.  Another solution often suggested is a  mutex . This allows you to \"lock\" some state so it can only be changed by the owner of the lock. A simple example might look like this:  // Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state  mapping   ( address   =   uint )   private   balances ;  bool   private   lockBalances ;  function   deposit ()   public   returns   ( bool )   { \n     if   ( ! lockBalances )   { \n         lockBalances   =   true ; \n         balances [ msg . sender ]   +=   msg . value ; \n         lockBalances   =   false ; \n         return   true ; \n     } \n     throw ;  }  function   withdraw ( uint   amount )   public   returns   ( bool )   { \n     if   ( ! lockBalances     amount     0     balances [ msg . sender ]   =   amount )   { \n         lockBalances   =   true ; \n\n         if   ( msg . sender . call ( amount )())   {   // Normally insecure, but the mutex saves it \n           balances [ msg . sender ]   -=   amount ; \n         } \n\n         lockBalances   =   false ; \n         return   true ; \n     } \n\n     throw ;  }   If the user tries to call  withdraw()  again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure:  // INSECURE\ncontract StateHolder {\n    uint private n;\n    address private lockHolder;\n\n    function getLock() {\n        if (lockHolder != 0) { throw; }\n        lockHolder = msg.sender;\n    }\n\n    function releaseLock() {\n        lockHolder = 0;\n    }\n\n    function set(uint newState) {\n        if (msg.sender != lockHolder) { throw; }\n        n = newState;\n    }\n}  An attacker can call  getLock() , and then never call  releaseLock() . If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against race conditions, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.)  * Some may object to the use of the term  race condition , since Ethereum does not currently have true parallelism. However, there is still the fundamental feature of logically distinct processes contending for resources, and the same sorts of pitfalls and potential solutions apply.", 
            "title": "Pitfalls in Race Condition Solutions"
        }, 
        {
            "location": "/Dapps/Safety/#dos-with-unexpected-throw", 
            "text": "Consider a simple auction contract:  // INSECURE\ncontract Auction {\n    address currentLeader;\n    uint highestBid;\n\n    function bid() {\n        if (msg.value  = highestBid) { throw; }\n\n        if (!currentLeader.send(highestBid)) { throw; } // Refund the old leader, and throw if it fails\n\n        currentLeader = msg.sender;\n        highestBid = msg.value;\n    }\n}  When it tries to refund the old leader, it throws if the refund fails. This means that a malicious bidder can become the leader, while making sure that any refunds to their address will  always  fail. In this way, they can prevent anyone else from calling the  bid()  function, and stay the leader forever. A natural solution might be to continue even if the refund fails, under the theory that it's their own fault if they can't accept the refund.  Another example is when a contract may iterate through an array to pay users (e.g., supporters in a crowdfunding contract). It's common to want to make sure that each payment succeeds. If not, one should throw. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never complete. No one gets paid, because one address is forcing an error.  address []   private   refundAddresses ;  mapping   ( address   =   uint )   public   refunds ;  // bad  function   refundAll ()   public   { \n     for ( uint   x ;   x     refundAddresses . length ;   x ++ )   {   // arbitrary length iteration based on how many addresses participated \n         if ( refundAddresses [ x ]. send ( refunds [ refundAddresses [ x ]]))   { \n             throw ;   // doubly bad, now a single failure on send will hold up all funds \n         } \n     }  }   Again, the recommended solution is to  favor pull over push payments .", 
            "title": "DoS with (Unexpected) Throw"
        }, 
        {
            "location": "/Dapps/Safety/#dos-with-block-gas-limit", 
            "text": "You may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit. Each Ethereum block can process a certain maximum amount of computation. If you try to go over that, your transaction will fail.  This can lead to problems even in the absence of an intentional attack. However, it's especially bad if an attacker can manipulate the amount of gas needed. In the case of the previous example, the attacker could add a bunch of addresses, each of which needs to get a very small refund. The gas cost of refunding each of the attacker's addresses could therefore end up being more than the gas limit, blocking the refund transaction from happening at all.  This is another reason to  favor pull over push payments .  If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you've gone, and be able to resume from that point, as in the following example:  struct   Payee   { \n     address   addr ; \n     uint256   value ;  }  Payee   payees [];  uint256   nextPayeeIndex ;  function   payOut() { \n     uint256   i   =   nextPayeeIndex ; \n     while   ( i     payees . length     msg . gas     200000 )   { \n       payees [ i ]. addr . send ( payees [ i ]. value ); \n       i ++ ; \n     } \n     nextPayeeIndex   =   i ;  }   You will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the  payOut()  function. So only use this pattern if absolutely necessary.", 
            "title": "DoS with Block Gas Limit"
        }, 
        {
            "location": "/Dapps/Safety/#timestamp-dependence", 
            "text": "The timestamp of the block can be manipulated by the miner, and so should not be used for critical components of the contract.  Block numbers  and  average block time  can be used to estimate time, but this is not future proof as block times may change (such as the changes expected during Casper).  uint startTime = SOME_START_TIME;\n\nif (now   startTime + 1 week) { // the now can be manipulated by the miner\n\n}", 
            "title": "Timestamp Dependence"
        }, 
        {
            "location": "/Dapps/Safety/#transaction-ordering-dependence-tod", 
            "text": "Since a transaction is in the mempool for a short while, one can know what actions will occur, before it is included in a block. This can be troublesome for things like decentralized markets, where a transaction to buy some tokens can be seen, and a market order implemented before the other transaction gets included. Protecting against this is difficult, as it would come down to the specific contract itself. For example, in markets, it would be better to implement batch auctions (this also protects against high frequency trading concerns). Another way to use a pre-commit scheme (\u201cI\u2019m going to submit the details later\u201d).", 
            "title": "Transaction-Ordering Dependence (TOD)"
        }, 
        {
            "location": "/Dapps/Safety/#software-engineering-techniques", 
            "text": "As we discussed in the  General Philosophy  section, it is not enough to protect yourself against the known attacks. Since the cost of failure on a blockchain can be very high, you must also adapt the way you write software, to account for that risk.  The approach we advocate is to \"prepare for failure\". It is impossible to know in advance whether your code is secure. However, you can architect your contracts in a way that allows them to fail gracefully, and with minimal damage. This section presents a variety of techniques that will help you prepare for failure.  Note: There's always a risk when you add a new component to your system. A badly designed fail-safe could itself become a vulnerability - as can the interaction between a number of well designed fail-safes. Be thoughtful about each technique you use in your contracts, and consider carefully how they work together to create a robust system.", 
            "title": "Software Engineering Techniques"
        }, 
        {
            "location": "/Dapps/Safety/#upgrading-broken-contracts", 
            "text": "Code will need to be changed if errors are discovered or if improvements need to be made. It is no good to discover a bug, but have no way to deal with it.  Designing an effective upgrade system for smart contracts is an area of active research, and we won't be able to cover all of the complications in this document. However, there are two basic approaches that are most commonly used. The simpler of the two is to have a registry contract that holds the address of the latest version of the contract. A more seamless approach for contract users is to have a contract that forwards calls and data onto the latest version of the contract.  Whatever the technique, it's important to have modularization and good separation between components, so that code changes do not break functionality, orphan data, or require substantial costs to port. In particular, it is usually beneficial to separate complex logic from your data storage, so that you do not have to recreate all of the data in order to change the functionality.  It's also critical to have a secure way for parties to decide to upgrade the code. Depending on your contract, code changes may need to be approved by a single trusted party, a group of members, or a vote of the full set of stakeholders. If this process can take some time, you will want to consider if there are other ways to react more quickly in case of an attack, such as an  emergency stop or circuit-breaker .  Example 1: Use a registry contract to store latest version of a contract  In this example, the calls aren't forwarded, so users should fetch the current address each time before interacting with it.  contract SomeRegister {\n    address backendContract;\n    address[] previousBackends;\n    address owner;\n\n    function SomeRegister() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _\n    }\n\n    function changeBackend(address newBackend) public\n    onlyOwner()\n    returns (bool)\n    {\n        if(newBackend != backendContract) {\n            previousBackends.push(backendContract);\n            backendContract = newBackend;\n            return true;\n        }\n\n        return false;\n    }\n}  There are two main disadvantages to this approach:   Users must always look up the current address, and anyone who fails to do so risks using an old version of the contract  You will need to think carefully about how to deal with the contract data, when you replace the contract   The alternate approach is to have a contract forward calls and data to the latest version of the contract:  Example 2:  Use a  DELEGATECALL  to forward data and calls  contract Relay {\n    address public currentVersion;\n    address public owner;\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _\n    }\n\n    function Relay(address initAddr) {\n        currentVersion = initAddr;\n        owner = msg.sender; // this owner may be another contract with multisig, not a single contract owner\n    }\n\n    function changeContract(address newVersion) public\n    onlyOwner()\n    {\n        currentVersion = newVersion;\n    }\n\n    function() {\n        if(!currentVersion.delegatecall(msg.data)) throw;\n    }\n}  This approach avoids the previous problems, but has problems of its own. You must be extremely careful with how you store data in this contract. If your new contract has a different storage layout than the first, your data may end up corrupted. Additionally, this simple version of the pattern cannot return values from functions, only forward them, which limits its applicability. ( More complex implementations  attempt to solve this with in-line assembly code and a registry of return sizes.)  Regardless of your approach, it is important to have some way to upgrade your contracts, or they will become unusable when the inevitable bugs are discovered in them.", 
            "title": "Upgrading Broken Contracts"
        }, 
        {
            "location": "/Dapps/Safety/#circuit-breakers-pause-contract-functionality", 
            "text": "Circuit breakers stop execution if certain conditions are met, and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a bug is discovered, and the only action now active is a withdrawal. You can either give certain trusted parties the ability to trigger the circuit breaker, or else have programmatic rules that automatically trigger the certain breaker when certain conditions are met.  Example:  bool   private   stopped   =   false ;  address   private   owner ;  modifier   isAdmin() { \n     if ( msg . sender   !=   owner )   { \n         throw ; \n     } \n     _  }  function   toggleContractActive ()   isAdmin   public  { \n     // You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users \n     stopped   =   ! stopped ;  }  modifier   stopInEmergency   {   if   ( ! stopped )   _   }  modifier   onlyInEmergency   {   if   ( stopped )   _   }  function   deposit ()   stopInEmergency   public  { \n     // some code  }  function   withdraw ()   onlyInEmergency   public  { \n     // some code  }", 
            "title": "Circuit Breakers (Pause contract functionality)"
        }, 
        {
            "location": "/Dapps/Safety/#speed-bumps-delay-contract-actions", 
            "text": "Speed bumps slow down actions, so that if malicious actions occur, there is time to recover. For example,  The DAO  required 27 days between a successful request to split the DAO and the ability to do so. This ensured the funds were kept within the contract, increasing the likelihood of recovery. In the case of the DAO, there was no effective action that could be taken during the time given by the speed bump, but in combination with our other techniques, they can be quite effective.  Example:  struct   RequestedWithdrawal   { \n     uint   amount ; \n     uint   time ;  }  mapping   ( address   =   uint )   private   balances ;  mapping   ( address   =   RequestedWithdrawal )   private   requestedWithdrawals ;  uint   constant   withdrawalWaitPeriod   =   28   days ;   // 4 weeks  function   requestWithdrawal ()   public   { \n     if   ( balances [ msg . sender ]     0 )   { \n         uint   amountToWithdraw   =   balances [ msg . sender ]; \n         balances [ msg . sender ]   =   0 ;   // for simplicity, we withdraw everything; \n         // presumably, the deposit function prevents new deposits when withdrawals are in progress \n\n         requestedWithdrawals [ msg . sender ]   =   RequestedWithdrawal ({ \n             amount :  amountToWithdraw , \n             time :  now \n         }); \n     }  }  function   withdraw ()   public   { \n     if ( requestedWithdrawals [ msg . sender ]. amount     0     now     requestedWithdrawals [ msg . sender ]. time   +   withdrawalWaitPeriod )   { \n         uint   amountToWithdraw   =   requestedWithdrawals [ msg . sender ]. amount ; \n         requestedWithdrawals [ msg . sender ]. amount   =   0 ; \n\n         if ( ! msg . sender . send ( amountToWithdraw ))   { \n             throw ; \n         } \n     }  }", 
            "title": "Speed Bumps (Delay contract actions)"
        }, 
        {
            "location": "/Dapps/Safety/#rate-limiting", 
            "text": "Rate limiting halts or requires approval for substantial changes. For example, a depositor may only be allowed to withdraw a certain amount or percentage of total deposits over a certain time period (e.g., max 100 ether over 1 day) - additional withdrawals in that time period may fail or require some sort of special approval. Or the rate limit could be at the contract level, with only a certain amount of tokens issued by the contract over a time period.  Example", 
            "title": "Rate Limiting"
        }, 
        {
            "location": "/Dapps/Safety/#assert-guards", 
            "text": "An assert guard triggers when an assertion fails - such as an invariant property changing. For example, the token to ether issuance ratio, in a token issuance contract, may be fixed. You can verify that this is the case at all times with an assertion. Assert guards should often be combined with other techniques, such as pausing the contract and allowing upgrades. (Otherwise you may end up stuck, with an assertion that is always failing.)  The following example reverts transactions if the ratio of ether to total number of tokens changes:  contract TokenWithInvariants {\n    mapping(address =  uint) public balanceOf;\n    uint public totalSupply;\n\n    modifier checkInvariants {\n        _\n        if (this.balance   totalSupply) throw;\n    }\n\n    function deposit(uint amount) public checkInvariants {\n        // intentionally vulnerable\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n    }\n\n    function transfer(address to, uint value) public checkInvariants {\n        if (balanceOf[msg.sender]  = value) {\n            balanceOf[to] += value;\n            balanceOf[msg.sender] -= value;\n        }\n    }\n\n    function withdraw() public checkInvariants {\n        // intentionally vulnerable\n        uint balance = balanceOf[msg.sender];\n        if (msg.sender.call.value(balance)()) {\n            totalSupply -= balance;\n            balanceOf[msg.sender] = 0;\n        }\n    }\n}", 
            "title": "Assert Guards"
        }, 
        {
            "location": "/Dapps/Safety/#contract-rollout", 
            "text": "Contracts should have a substantial and prolonged testing period - before substantial money is put at risk.  At minimum, you should:   Have a full test suite with 100% test coverage (or close to it)  Deploy on your own testnet  Deploy on the public testnet with substantial testing and bug bounties  Exhaustive testing should allow various players to interact with the contract at volume  Deploy on the mainnet in beta, with limits to the amount at risk", 
            "title": "Contract Rollout"
        }, 
        {
            "location": "/Dapps/Safety/#automatic-deprecation", 
            "text": "During testing, you can force an automatic deprecation by preventing any actions, after a certain time period. For example, an alpha contract may work for several weeks and then automatically shut down all actions, except for the final withdrawal.  modifier   isActive() { \n     if   ( block . number     SOME_BLOCK_NUMBER )   { \n         throw ; \n     } \n     _  }  function   deposit ()   public  isActive() { \n     // some code  }  function   withdraw ()   public   { \n     // some code  }", 
            "title": "Automatic Deprecation"
        }, 
        {
            "location": "/Dapps/Safety/#restrict-amount-of-ether-per-usercontract", 
            "text": "In the early stages, you can restrict the amount of Ether for any user (or for the entire contract) - reducing the risk.", 
            "title": "Restrict amount of Ether per user/contract"
        }, 
        {
            "location": "/Dapps/Safety/#security-related-documentation-and-procedures", 
            "text": "When launching a contract that will have substantial funds or is required to be mission critical, it is important to include proper documentation. Some documentation related to security includes:  Status   Where current code is deployed  Current status of deployed code (including outstanding issues, performance stats, etc.)   Known Issues   Key risks with contract  e.g., You can lose all your money, hacker can vote for certain outcomes  All known bugs/limitations  Potential attacks and mitigants  Potential conflicts of interest (e.g., will be using yourself, like Slock.it did with the DAO)   History   Testing (including usage stats, discovered bugs, length of testing)  People who have reviewed code (and their key feedback)   Procedures   Action plan in case a bug is discovered (e.g., emergency options, public notification process, etc.)  Wind down process if something goes wrong (e.g., funders will get percentage of your balance before attack, from remaining funds)  Responsible disclosure policy (e.g., where to report bugs found, the rules of any bug bounty program)  Recourse in case of failure (e.g., insurance, penalty fund, no recourse)   Contact Information   Who to contact with issues  Names of programmers and/or other important parties  Chat room where questions can be asked", 
            "title": "Security-related Documentation and Procedures"
        }, 
        {
            "location": "/Dapps/Safety/#security-tools", 
            "text": "Oyente  - An upcoming tool, will analyze Ethereum code to find common vulnerabilities (e.g., Transaction Order Dependence, no checking for exceptions)    Solgraph  - Generates a DOT graph that visualizes function control flow of a Solidity contract and highlights potential security vulnerabilities.    solint  - Another upcoming tool, will provide Solidity linting that helps you enforce consistent conventions and avoid errors in your Solidity smart-contracts.", 
            "title": "Security Tools"
        }, 
        {
            "location": "/Dapps/Safety/#future-improvements", 
            "text": "Editor Security Warnings : Editors will soon alert for common security errors, not just compilation errors. Browser Solidity is getting these features soon.    New functional languages that compile to EVM bytecode : Functional languages gives certain guarantees over procedural languages like Solidity, namely immutability within a function and strong compile time checking. This can reduce the risk of errors by providing deterministic behavior. (for more see  this , Curry-Howard correspondence, and linear logic)", 
            "title": "Future improvements"
        }, 
        {
            "location": "/Dapps/Safety/#smart-contract-security-bibliography", 
            "text": "A lot of this document contains code, examples and insights gained from various parts already written by the community.\nHere are some of them.  Feel free to add more.", 
            "title": "Smart Contract Security Bibliography"
        }, 
        {
            "location": "/Dapps/Safety/#by-ethereum-core-developers", 
            "text": "How to Write Safe Smart Contracts  (Christian Reitwiessner)  Smart Contract Security  (Christian Reitwiessner)  Thinking about Smart Contract Security  (Vitalik Buterin)  Solidity  Solidity Security Considerations", 
            "title": "By Ethereum core developers"
        }, 
        {
            "location": "/Dapps/Safety/#by-community", 
            "text": "http://forum.ethereum.org/discussion/1317/reentrant-contracts  http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/  http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/  http://hackingdistributed.com/2016/06/22/smart-contract-escape-hatches/  http://martin.swende.se/blog/Devcon1-and-contract-security.html  http://publications.lib.chalmers.se/records/fulltext/234939/234939.pdf  http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour  http://vessenes.com/ethereum-griefing-wallets-send-w-throw-considered-harmful  http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal  https://blog.blockstack.org/simple-contracts-are-better-contracts-what-we-can-learn-from-the-dao-6293214bad3a  https://blog.slock.it/deja-vu-dao-smart-contracts-audit-results-d26bc088e32e  https://github.com/Bunjin/Rouleth/blob/master/Security.md  https://github.com/LeastAuthority/ethereum-analyses  https://medium.com/@ConsenSys/assert-guards-towards-automated-code-bounties-safe-smart-contract-coding-on-ethereum-8e74364b795c  https://medium.com/@coriacetic/in-bits-we-trust-4e464b418f0b  https://medium.com/@hrishiolickel/why-smart-contracts-fail-undiscovered-bugs-and-what-we-can-do-about-them-119aa2843007  https://medium.com/@peterborah/we-need-fault-tolerant-smart-contracts-ec1b56596dbc  https://pdaian.com/blog/chasing-the-dao-attackers-wake  http://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf", 
            "title": "By Community"
        }, 
        {
            "location": "/Dapps/Safety/#attribution", 
            "text": "This work, \"Safety\", is a derivative of  \"Smart Contract Best Practices\" , used under CC BY. \"Safety\" is licensed under CC BY by the Ethereum community.", 
            "title": "Attribution"
        }, 
        {
            "location": "/Dapps/Safety/#license", 
            "text": "Licensed under  Apache 2.0  Licensed under  Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International", 
            "title": "License"
        }, 
        {
            "location": "/Dapps/Resources/", 
            "text": "As a \u00d0app developer you have three main resources which allow \u00d0app development.\n\n\nMain Resources\n\n\n\n\nWeb3 JavaScript API\n - This is the main JavaScript SDK to use when you want to interact with a nodes API\n\n\nJSON RPC API\n - This is the low level JSON RPC 2.0 interface to interface with a node. This API is used by the \nWeb3 JavaScript API\n.\n\n\nSolidity Documentation\n - Solidity is the Ethereum-developed Smart Contract language, which compiles to EVM (Ethereum Virtual Machine) opcodes.\n\n\n\n\nOther Resources:\n\n\n\n\nStandardized Contract APIs\n - Standard contract API, which should be used to make some contract types accessible by other \u00d0apps. (Not yet finalised)\n\n\nUseful \u00d0app Patterns\n - Code snippets which are useful for \u00d0app development.\n\n\nDapp using Meteor\n - This short tutorial gives an intro on how to start building a \u00d0app using \nMeteor\n, and also why Meteor is a good fit for \u00d0apps.\n\n\n\n\nUseful read\n\n\n\n\nFAQ\n - Collection of links, useful for understanding the Ethereum eco system.\n\n\nGlossary\n - Great explanation of Blockchain related terms.\n\n\n\n\nGitter Chats\n\n\n\n\nweb3.js \n\n\nMist \n\n\nGO Ethereum \n\n\nC++ Ethereum \n\n\nSwarm \n\n\nWhisper", 
            "title": "\u5f00\u53d1\u8d44\u6e90"
        }, 
        {
            "location": "/Dapps/Resources/#main-resources", 
            "text": "Web3 JavaScript API  - This is the main JavaScript SDK to use when you want to interact with a nodes API  JSON RPC API  - This is the low level JSON RPC 2.0 interface to interface with a node. This API is used by the  Web3 JavaScript API .  Solidity Documentation  - Solidity is the Ethereum-developed Smart Contract language, which compiles to EVM (Ethereum Virtual Machine) opcodes.", 
            "title": "Main Resources"
        }, 
        {
            "location": "/Dapps/Resources/#other-resources", 
            "text": "Standardized Contract APIs  - Standard contract API, which should be used to make some contract types accessible by other \u00d0apps. (Not yet finalised)  Useful \u00d0app Patterns  - Code snippets which are useful for \u00d0app development.  Dapp using Meteor  - This short tutorial gives an intro on how to start building a \u00d0app using  Meteor , and also why Meteor is a good fit for \u00d0apps.", 
            "title": "Other Resources:"
        }, 
        {
            "location": "/Dapps/Resources/#useful-read", 
            "text": "FAQ  - Collection of links, useful for understanding the Ethereum eco system.  Glossary  - Great explanation of Blockchain related terms.", 
            "title": "Useful read"
        }, 
        {
            "location": "/Dapps/Resources/#gitter-chats", 
            "text": "web3.js   Mist   GO Ethereum   C++ Ethereum   Swarm   Whisper", 
            "title": "Gitter Chats"
        }, 
        {
            "location": "/Dapps/JavaScript-API/", 
            "text": "Web3 JavaScript app API for 0.2x.x\n\n\nNOTE: These docs are for web3.js version 0.2x.x. If you\u2019re using web3.js 1.0 please refer to \nthis documentation\n.\n\n\nTo make your app work on Ethereum, you can use the \nweb3\n object provided by the \nweb3.js library\n. Under the hood it communicates to a local node through \nRPC calls\n. web3.js works with any Ethereum node, which exposes an RPC layer.\n\n\nweb3\n contains the \neth\n object - \nweb3.eth\n (for specifically Ethereum blockchain interactions) and the \nshh\n object - \nweb3.shh\n (for Whisper interaction). Over time we'll introduce other objects for each of the other web3 protocols. Working  \nexamples can be found here\n.\n\n\nIf you want to look at some more sophisticated examples using web3.js check out these \nuseful app patterns\n.\n\n\nGetting Started\n\n\n\n\nAdding web3\n\n\nUsing Callbacks\n\n\nBatch requests\n\n\nA note on big numbers in web3.js\n\n\n-\n API Reference\n\n\n\n\nAdding web3\n\n\nFirst you need to get web3.js into your project. This can be done using the following methods:\n\n\n\n\nnpm: \nnpm install web3\n\n\nbower: \nbower install web3\n\n\nmeteor: \nmeteor add ethereum:web3\n\n\nvanilla: link the \ndist./web3.min.js\n\n\n\n\nThen you need to create a web3 instance, setting a provider.\nTo make sure you don't overwrite the already set provider when in mist, check first if the web3 is available:\n\n\nif\n \n(\ntypeof\n \nweb3\n \n!==\n \nundefined\n)\n \n{\n\n  \nweb3\n \n=\n \nnew\n \nWeb3\n(\nweb3\n.\ncurrentProvider\n);\n\n\n}\n \nelse\n \n{\n\n  \n// set the provider you want from Web3.providers\n\n  \nweb3\n \n=\n \nnew\n \nWeb3\n(\nnew\n \nWeb3\n.\nproviders\n.\nHttpProvider\n(\nhttp://localhost:8545\n));\n\n\n}\n\n\n\n\n\nAfter that you can use the \nAPI\n of the \nweb3\n object.\n\n\nUsing callbacks\n\n\nAs this API is designed to work with a local RPC node, all its functions use synchronous HTTP requests by default.\n\n\nIf you want to make an asynchronous request, you can pass an optional callback as the last parameter to most functions.\nAll callbacks are using an \nerror first callback\n style:\n\n\nweb3\n.\neth\n.\ngetBlock\n(\n48\n,\n \nfunction\n(\nerror\n,\n \nresult\n){\n\n    \nif\n(\n!\nerror\n)\n\n        \nconsole\n.\nlog\n(\nresult\n)\n\n    \nelse\n\n        \nconsole\n.\nerror\n(\nerror\n);\n\n\n})\n\n\n\n\n\nBatch requests\n\n\nBatch requests allow queuing up requests and processing them at once.\n\n\nNote\n Batch requests are not faster! In fact making many requests at once will in some cases be faster, as requests are processed asynchronously. Batch requests are mainly useful to ensure the serial processing of requests.\n\n\nvar\n \nbatch\n \n=\n \nweb3\n.\ncreateBatch\n();\n\n\nbatch\n.\nadd\n(\nweb3\n.\neth\n.\ngetBalance\n.\nrequest\n(\n0x0000000000000000000000000000000000000000\n,\n \nlatest\n,\n \ncallback\n));\n\n\nbatch\n.\nadd\n(\nweb3\n.\neth\n.\nContract\n(\nabi\n).\nat\n(\naddress\n).\nbalance\n.\nrequest\n(\naddress\n,\n \ncallback2\n));\n\n\nbatch\n.\nexecute\n();\n\n\n\n\n\nA note on big numbers in web3.js\n\n\nYou will always get a BigNumber object for number values as JavaScript is not able to handle big numbers correctly.\nLook at the following examples:\n\n\n101010100324325345346456456456456456456\n\n\n// \n101010100324325345346456456456456456456\n\n\n101010100324325345346456456456456456456\n\n\n// 1.0101010032432535e+38\n\n\n\n\n\nweb3.js depends on the \nBigNumber Library\n and adds it automatically.\n\n\nvar\n \nbalance\n \n=\n \nnew\n \nBigNumber\n(\n131242344353464564564574574567456\n);\n\n\n// or var balance = web3.eth.getBalance(someAddress);\n\n\n\nbalance\n.\nplus\n(\n21\n).\ntoString\n(\n10\n);\n \n// toString(10) converts it to a number string\n\n\n// \n131242344353464564564574574567477\n\n\n\n\n\nThe next example wouldn't work as we have more than 20 floating points, therefore it is recommended to always keep your balance in \nwei\n and only transform it to other units when presenting to the user:\n\nvar\n \nbalance\n \n=\n \nnew\n \nBigNumber\n(\n13124.234435346456466666457455567456\n);\n\n\n\nbalance\n.\nplus\n(\n21\n).\ntoString\n(\n10\n);\n \n// toString(10) converts it to a number string, but can only show max 20 floating points\n\n\n// \n13145.23443534645646666646\n // you number would be cut after the 20 floating point\n\n\n\n\nWeb3.js API Reference\n\n\n\n\nweb3\n\n\nversion\n\n\napi\n\n\nnode/getNode\n\n\nnetwork/getNetwork\n\n\nethereum/getEthereum\n\n\nwhisper/getWhisper\n\n\n\n\n\n\nisConnected()\n\n\nsetProvider(provider)\n\n\ncurrentProvider\n\n\nreset()\n\n\nsha3(string, options)\n\n\ntoHex(stringOrNumber)\n\n\ntoAscii(hexString)\n\n\nfromAscii(textString, [padding])\n\n\ntoDecimal(hexString)\n\n\nfromDecimal(number)\n\n\nfromWei(numberStringOrBigNumber, unit)\n\n\ntoWei(numberStringOrBigNumber, unit)\n\n\ntoBigNumber(numberOrHexString)\n\n\nisAddress(hexString)\n\n\nnet\n\n\nlistening/getListening\n\n\npeerCount/getPeerCount\n\n\n\n\n\n\neth\n\n\ndefaultAccount\n\n\ndefaultBlock\n\n\nsyncing/getSyncing\n\n\nisSyncing\n\n\ncoinbase/getCoinbase\n\n\nhashrate/getHashrate\n\n\ngasPrice/getGasPrice\n\n\naccounts/getAccounts\n\n\nmining/getMining\n\n\nblockNumber/getBlockNumber\n\n\nregister(hexString)\n (Not implemented yet)\n\n\nunRegister(hexString)\n (Not implemented yet)\n\n\ngetBalance(address)\n\n\ngetStorageAt(address, position)\n\n\ngetCode(address)\n\n\ngetBlock(hash/number)\n\n\ngetBlockTransactionCount(hash/number)\n\n\ngetUncle(hash/number)\n\n\ngetBlockUncleCount(hash/number)\n\n\ngetTransaction(hash)\n\n\ngetTransactionFromBlock(hashOrNumber, indexNumber)\n\n\ngetTransactionReceipt(hash)\n\n\ngetTransactionCount(address)\n\n\nsendTransaction(object)\n\n\nsendRawTransaction(object)\n\n\nsign(object)\n\n\ncall(object)\n\n\nestimateGas(object)\n\n\nfilter(array (, options) )\n\n\nwatch(callback)\n\n\nstopWatching(callback)\n\n\nget()\n\n\n\n\n\n\nContract(abiArray)\n\n\ncontract.myMethod()\n\n\ncontract.myEvent()\n\n\ncontract.allEvents()\n\n\ngetCompilers()\n\n\ncompile.lll(string)\n\n\ncompile.solidity(string)\n\n\ncompile.serpent(string)\n\n\nnamereg\n\n\nsendIBANTransaction\n\n\niban\n\n\nfromAddress\n\n\nfromBban\n\n\ncreateIndirect\n\n\nisValid\n\n\nisDirect\n\n\nisIndirect\n\n\nchecksum\n\n\ninstitution\n\n\nclient\n\n\naddress\n\n\ntoString\n\n\n\n\n\n\ndb\n\n\nputString(name, key, value)\n\n\ngetString(-       var rXArray = stringToNumberArray(form.rX.value);\nname, key)\n\n\nputHex(name, key, value)\n\n\ngetHex(name, key)\n\n\n\n\n\n\nshh\n\n\npost(postObject)\n\n\nnewIdentity()\n\n\nhasIdentity(hexString)\n\n\nnewGroup(_id, _who)\n\n\naddToGroup(_id, _who)\n\n\nfilter(object/string)\n\n\nwatch(callback)\n\n\nstopWatching(callback)\n\n\nget(callback)\n\n\n\n\n\n\n\n\nUsage\n\n\nweb3\n\n\nThe \nweb3\n object provides all methods.\n\n\nExample\n\n\nvar\n \nWeb3\n \n=\n \nrequire\n(\nweb3\n);\n\n\n// create an instance of web3 using the HTTP provider.\n\n\n// NOTE in mist web3 is already available, so check first if it\ns available before instantiating\n\n\nvar\n \nweb3\n \n=\n \nnew\n \nWeb3\n(\nnew\n \nWeb3\n.\nproviders\n.\nHttpProvider\n(\nhttp://localhost:8545\n));\n\n\n\n\n\nExample using HTTP Basic Authentication\n\n\nvar\n \nWeb3\n \n=\n \nrequire\n(\nweb3\n);\n\n\nvar\n \nweb3\n \n=\n \nnew\n \nWeb3\n(\nnew\n \nWeb3\n.\nproviders\n.\nHttpProvider\n(\nhttp://localhost:8545\n,\n \n0\n,\n \nBasicAuthUsername\n,\n \nBasicAuthPassword\n));\n\n\n//Note: HttpProvider takes 4 arguments (host, timeout, user, password)\n\n\n\n\n\n\n\nweb3.version.api\n\n\nweb3\n.\nversion\n.\napi\n\n\n\n\n\nReturns\n\n\nString\n - The ethereum js api version.\n\n\nExample\n\n\nvar\n \nversion\n \n=\n \nweb3\n.\nversion\n.\napi\n;\n\n\nconsole\n.\nlog\n(\nversion\n);\n \n// \n0.2.0\n\n\n\n\n\n\n\nweb3.version.node\n\n\nweb3.version.node\n// or async\nweb3.version.getNode(callback(error, result){ ... })\n\n\n\n\n\nReturns\n\n\nString\n - The client/node version.\n\n\nExample\n\n\nvar\n \nversion\n \n=\n \nweb3\n.\nversion\n.\nnode\n;\n\n\nconsole\n.\nlog\n(\nversion\n);\n \n// \nMist/v0.9.3/darwin/go1.4.1\n\n\n\n\n\n\n\nweb3.version.network\n\n\nweb3.version.network\n// or async\nweb3.version.getNetwork(callback(error, result){ ... })\n\n\n\n\n\nReturns\n\n\nString\n - The network protocol version.\n\n\nExample\n\n\nvar\n \nversion\n \n=\n \nweb3\n.\nversion\n.\nnetwork\n;\n\n\nconsole\n.\nlog\n(\nversion\n);\n \n// 54\n\n\n\n\n\n\n\nweb3.version.ethereum\n\n\nweb3.version.ethereum\n// or async\nweb3.version.getEthereum(callback(error, result){ ... })\n\n\n\n\n\nReturns\n\n\nString\n - The ethereum protocol version.\n\n\nExample\n\n\nvar\n \nversion\n \n=\n \nweb3\n.\nversion\n.\nethereum\n;\n\n\nconsole\n.\nlog\n(\nversion\n);\n \n// 60\n\n\n\n\n\n\n\nweb3.version.whisper\n\n\nweb3.version.whisper\n// or async\nweb3.version.getWhisper(callback(error, result){ ... })\n\n\n\n\n\nReturns\n\n\nString\n - The whisper protocol version.\n\n\nExample\n\n\nvar\n \nversion\n \n=\n \nweb3\n.\nversion\n.\nwhisper\n;\n\n\nconsole\n.\nlog\n(\nversion\n);\n \n// 20\n\n\n\n\n\n\n\nweb3.isConnected\n\n\nweb3.isConnected()\n\n\n\n\n\nShould be called to check if a connection to a node exists\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nBoolean\n\n\nExample\n\n\nif\n(\n!\nweb3\n.\nisConnected\n())\n \n{\n\n\n   \n// show some dialog to ask the user to start a node\n\n\n\n}\n \nelse\n \n{\n\n\n   \n// start web3 filters, calls, etc\n\n\n\n}\n\n\n\n\n\n\n\nweb3.setProvider\n\n\nweb3.setProvider(provider)\n\n\n\n\n\nShould be called to set provider.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nundefined\n\n\nExample\n\n\nweb3\n.\nsetProvider\n(\nnew\n \nweb3\n.\nproviders\n.\nHttpProvider\n(\nhttp://localhost:8545\n));\n \n// 8080 for cpp/AZ, 8545 for go/mist\n\n\n\n\n\n\n\nweb3.currentProvider\n\n\nweb3.currentProvider\n\n\n\n\n\nWill contain the current provider, if one is set. This can be used to check if mist etc. has set already a provider.\n\n\nReturns\n\n\nObject\n - The provider set or \nnull\n;\n\n\nExample\n\n\n// Check if mist etc. already set a provider\n\n\nif\n(\n!\nweb3\n.\ncurrentProvider\n)\n\n    \nweb3\n.\nsetProvider\n(\nnew\n \nweb3\n.\nproviders\n.\nHttpProvider\n(\nhttp://localhost:8545\n));\n\n\n\n\n\n\n\nweb3.reset\n\n\nweb3.reset(keepIsSyncing)\n\n\n\n\n\nShould be called to reset state of web3. Resets everything except manager. Uninstalls all filters. Stops polling.\n\n\nParameters\n\n\n\n\nBoolean\n - If \ntrue\n it will uninstall all filters, but will keep the \nweb3.eth.isSyncing()\n polls\n\n\n\n\nReturns\n\n\nundefined\n\n\nExample\n\n\nweb3\n.\nreset\n();\n\n\n\n\n\n\n\nweb3.sha3\n\n\nweb3.sha3(string [, options])\n\n\n\n\n\nParameters\n\n\n\n\nString\n - The string to hash using the Keccak-256 SHA3 algorithm\n\n\nObject\n - (optional) Set \nencoding\n to \nhex\n if the string to hash is encoded in hex. A leading \n0x\n will be automatically ignored.\n\n\n\n\nReturns\n\n\nString\n - The Keccak-256 SHA3 of the given data.\n\n\nExample\n\n\nvar\n \nhash\n \n=\n \nweb3\n.\nsha3\n(\nSome string to be hashed\n);\n\n\nconsole\n.\nlog\n(\nhash\n);\n \n// \n0xed973b234cf2238052c9ac87072c71bcf33abc1bbd721018e0cca448ef79b379\n\n\n\nvar\n \nhashOfHash\n \n=\n \nweb3\n.\nsha3\n(\nhash\n,\n \n{\nencoding\n:\n \nhex\n});\n\n\nconsole\n.\nlog\n(\nhashOfHash\n);\n \n// \n0x85dd39c91a64167ba20732b228251e67caed1462d4bcf036af88dc6856d0fdcc\n\n\n\n\n\n\n\nweb3.toHex\n\n\nweb3.toHex(mixed);\n\n\n\n\n\nConverts any value into HEX.\n\n\nParameters\n\n\n\n\nString|Number|Object|Array|BigNumber\n - The value to parse to HEX. If its an object or array it will be \nJSON.stringify\n first. If its a BigNumber it will make it the HEX value of a number.\n\n\n\n\nReturns\n\n\nString\n - The hex string of \nmixed\n.\n\n\nExample\n\n\nvar\n \nstr\n \n=\n \nweb3\n.\ntoHex\n({\ntest\n:\n \ntest\n});\n\n\nconsole\n.\nlog\n(\nstr\n);\n \n// \n0x7b2274657374223a2274657374227d\n\n\n\n\n\n\n\nweb3.toAscii\n\n\nweb3.toAscii(hexString);\n\n\n\n\n\nConverts a HEX string into a ASCII string.\n\n\nParameters\n\n\n\n\nString\n - A HEX string to be converted to ascii.\n\n\n\n\nReturns\n\n\nString\n - An ASCII string made from the given \nhexString\n.\n\n\nExample\n\n\nvar\n \nstr\n \n=\n \nweb3\n.\ntoAscii\n(\n0x657468657265756d000000000000000000000000000000000000000000000000\n);\n\n\nconsole\n.\nlog\n(\nstr\n);\n \n// \nethereum\n\n\n\n\n\n\n\nweb3.fromAscii\n\n\nweb3.fromAscii(string [, padding]);\n\n\n\n\n\nConverts any ASCII string to a HEX string.\n\n\nParameters\n\n\n\n\nString\n - An ASCII string to be converted to HEX.\n\n\nNumber\n - (optional) The number of bytes the returned HEX string should have.\n\n\n\n\nReturns\n\n\nString\n - The converted HEX string.\n\n\nExample\n\n\nvar\n \nstr\n \n=\n \nweb3\n.\nfromAscii\n(\nethereum\n);\n\n\nconsole\n.\nlog\n(\nstr\n);\n \n// \n0x657468657265756d\n\n\n\nvar\n \nstr2\n \n=\n \nweb3\n.\nfromAscii\n(\nethereum\n,\n \n32\n);\n\n\nconsole\n.\nlog\n(\nstr2\n);\n \n// \n0x657468657265756d000000000000000000000000000000000000000000000000\n\n\n\n\n\n\n\nweb3.toDecimal\n\n\nweb3.toDecimal(hexString);\n\n\n\n\n\nConverts a HEX string to its number representation.\n\n\nParameters\n\n\n\n\nString\n - An HEX string to be converted to a number.\n\n\n\n\nReturns\n\n\nNumber\n - The number representing the data \nhexString\n.\n\n\nExample\n\n\nvar\n \nnumber\n \n=\n \nweb3\n.\ntoDecimal\n(\n0x15\n);\n\n\nconsole\n.\nlog\n(\nnumber\n);\n \n// 21\n\n\n\n\n\n\n\nweb3.fromDecimal\n\n\nweb3.fromDecimal(number);\n\n\n\n\n\nConverts a number or number string to its HEX representation.\n\n\nParameters\n\n\n\n\nNumber|String\n - A number to be converted to a HEX string.\n\n\n\n\nReturns\n\n\nString\n - The HEX string representing of the given \nnumber\n.\n\n\nExample\n\n\nvar\n \nvalue\n \n=\n \nweb3\n.\nfromDecimal\n(\n21\n);\n\n\nconsole\n.\nlog\n(\nvalue\n);\n \n// \n0x15\n\n\n\n\n\n\n\nweb3.fromWei\n\n\nweb3.fromWei(number, unit)\n\n\n\n\n\nConverts a number of wei into the following ethereum units:\n\n\n\n\nkwei\n/\nada\n\n\nmwei\n/\nbabbage\n\n\ngwei\n/\nshannon\n\n\nszabo\n\n\nfinney\n\n\nether\n\n\nkether\n/\ngrand\n/\neinstein\n\n\nmether\n\n\ngether\n\n\ntether\n\n\n\n\nParameters\n\n\n\n\nNumber|String|BigNumber\n - A number or BigNumber instance.\n\n\nString\n - One of the above ether units.\n\n\n\n\nReturns\n\n\nString|BigNumber\n - Either a number string, or a BigNumber instance, depending on the given \nnumber\n parameter.\n\n\nExample\n\n\nvar\n \nvalue\n \n=\n \nweb3\n.\nfromWei\n(\n21000000000000\n,\n \nfinney\n);\n\n\nconsole\n.\nlog\n(\nvalue\n);\n \n// \n0.021\n\n\n\n\n\n\n\nweb3.toWei\n\n\nweb3.toWei(number, unit)\n\n\n\n\n\nConverts an ethereum unit into wei. Possible units are:\n\n\n\n\nkwei\n/\nada\n\n\nmwei\n/\nbabbage\n\n\ngwei\n/\nshannon\n\n\nszabo\n\n\nfinney\n\n\nether\n\n\nkether\n/\ngrand\n/\neinstein\n\n\nmether\n\n\ngether\n\n\ntether\n\n\n\n\nParameters\n\n\n\n\nNumber|String|BigNumber\n - A number or BigNumber instance.\n\n\nString\n - One of the above ether units.\n\n\n\n\nReturns\n\n\nString|BigNumber\n - Either a number string, or a BigNumber instance, depending on the given \nnumber\n parameter.\n\n\nExample\n\n\nvar\n \nvalue\n \n=\n \nweb3\n.\ntoWei\n(\n1\n,\n \nether\n);\n\n\nconsole\n.\nlog\n(\nvalue\n);\n \n// \n1000000000000000000\n\n\n\n\n\n\n\nweb3.toBigNumber\n\n\nweb3.toBigNumber(numberOrHexString);\n\n\n\n\n\nConverts a given number into a BigNumber instance.\n\n\nSee the \nnote on BigNumber\n.\n\n\nParameters\n\n\n\n\nNumber|String\n - A number, number string or HEX string of a number.\n\n\n\n\nReturns\n\n\nBigNumber\n - A BigNumber instance representing the given value.\n\n\nExample\n\n\nvar\n \nvalue\n \n=\n \nweb3\n.\ntoBigNumber\n(\n200000000000000000000001\n);\n\n\nconsole\n.\nlog\n(\nvalue\n);\n \n// instanceOf BigNumber\n\n\nconsole\n.\nlog\n(\nvalue\n.\ntoNumber\n());\n \n// 2.0000000000000002e+23\n\n\nconsole\n.\nlog\n(\nvalue\n.\ntoString\n(\n10\n));\n \n// \n200000000000000000000001\n\n\n\n\n\n\n\nweb3.isAddress\n\n\nweb3.isAddress(HexString);\n\n\n\n\n\nChecks if the given string is an address.\n\n\nParameters\n\n\n\n\nString\n - An HEX string.\n\n\n\n\nReturns\n\n\nBoolean\n - \nfalse\n if it's not on a valid address format. Returns \ntrue\n if it's an all lowercase or all uppercase valid address. If it's a mixed case address, it checks using \nweb3.isChecksumAddress()\n.\n\n\nExample\n\n\nvar\n \nisAddress\n \n=\n \nweb3\n.\nisAddress\n(\n0x8888f1f195afa192cfee860698584c030f4c9db1\n);\n\n\nconsole\n.\nlog\n(\nisAddress\n);\n \n// true\n\n\n\n\n\n\n\nweb3.net\n\n\nweb3.net.listening\n\n\nweb3.net.listening\n// or async\nweb3.net.getListening(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and says whether the node is actively listening for network connections or not.\n\n\nReturns\n\n\nBoolean\n - \ntrue\n if the client is actively listening for network connections, otherwise \nfalse\n.\n\n\nExample\n\n\nvar\n \nlistening\n \n=\n \nweb3\n.\nnet\n.\nlistening\n;\n\n\nconsole\n.\nlog\n(\nlistening\n);\n \n// true of false\n\n\n\n\n\n\n\nweb3.net.peerCount\n\n\nweb3.net.peerCount\n// or async\nweb3.net.getPeerCount(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns the number of connected peers.\n\n\nReturns\n\n\nNumber\n - The number of peers currently connected to the client.\n\n\nExample\n\n\nvar\n \npeerCount\n \n=\n \nweb3\n.\nnet\n.\npeerCount\n;\n\n\nconsole\n.\nlog\n(\npeerCount\n);\n \n// 4\n\n\n\n\n\n\n\nweb3.eth\n\n\nContains the ethereum blockchain related methods.\n\n\nExample\n\n\nvar\n \neth\n \n=\n \nweb3\n.\neth\n;\n\n\n\n\n\n\n\nweb3.eth.defaultAccount\n\n\nweb3.eth.defaultAccount\n\n\n\n\n\nThis default address is used for the following methods (optionally you can overwrite it by specifying the \nfrom\n property):\n\n\n\n\nweb3.eth.sendTransaction()\n\n\nweb3.eth.call()\n\n\n\n\nValues\n\n\nString\n, 20 Bytes - Any address you own, or where you have the private key for.\n\n\nDefault is\n \nundefined\n.\n\n\nReturns\n\n\nString\n, 20 Bytes - The currently set default address.\n\n\nExample\n\n\nvar\n \ndefaultAccount\n \n=\n \nweb3\n.\neth\n.\ndefaultAccount\n;\n\n\nconsole\n.\nlog\n(\ndefaultAccount\n);\n \n// \n\n\n\n// set the default account\n\n\nweb3\n.\neth\n.\ndefaultAccount\n \n=\n \n0x8888f1f195afa192cfee860698584c030f4c9db1\n;\n\n\n\n\n\n\n\nweb3.eth.defaultBlock\n\n\nweb3.eth.defaultBlock\n\n\n\n\n\nThis default block is used for the following methods (optionally you can override it by passing the defaultBlock parameter):\n\n\n\n\nweb3.eth.getBalance()\n\n\nweb3.eth.getCode()\n\n\nweb3.eth.getTransactionCount()\n\n\nweb3.eth.getStorageAt()\n\n\nweb3.eth.call()\n\n\ncontract.myMethod.call()\n\n\ncontract.myMethod.estimateGas()\n\n\n\n\nValues\n\n\nDefault block parameters can be one of the following:\n\n\n\n\nNumber\n - a block number\n\n\nString\n - \n\"earliest\"\n, the genisis block\n\n\nString\n - \n\"latest\"\n, the latest block (current head of the blockchain)\n\n\nString\n - \n\"pending\"\n, the currently mined block (including pending transactions)\n\n\n\n\nDefault is\n \nlatest\n\n\nReturns\n\n\nNumber|String\n - The default block number to use when querying a state.\n\n\nExample\n\n\nvar\n \ndefaultBlock\n \n=\n \nweb3\n.\neth\n.\ndefaultBlock\n;\n\n\nconsole\n.\nlog\n(\ndefaultBlock\n);\n \n// \nlatest\n\n\n\n// set the default block\n\n\nweb3\n.\neth\n.\ndefaultBlock\n \n=\n \n231\n;\n\n\n\n\n\n\n\nweb3.eth.syncing\n\n\nweb3.eth.syncing\n// or async\nweb3.eth.getSyncing(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns the either a sync object, when the node is syncing or \nfalse\n.\n\n\nReturns\n\n\nObject|Boolean\n - A sync object as follows, when the node is currently syncing or \nfalse\n:\n   - \nstartingBlock\n: \nNumber\n - The block number where the sync started.\n   - \ncurrentBlock\n: \nNumber\n - The block number where at which block the node currently synced to already.\n   - \nhighestBlock\n: \nNumber\n - The estimated block number to sync to.\n\n\nExample\n\n\nvar\n \nsync\n \n=\n \nweb3\n.\neth\n.\nsyncing\n;\n\n\nconsole\n.\nlog\n(\nsync\n);\n\n\n/*\n\n\n{\n\n\n   startingBlock: 300,\n\n\n   currentBlock: 312,\n\n\n   highestBlock: 512\n\n\n}\n\n\n*/\n\n\n\n\n\n\n\nweb3.eth.isSyncing\n\n\nweb3.eth.isSyncing(callback);\n\n\n\n\n\nThis convenience function calls the \ncallback\n everytime a sync starts, updates and stops.\n\n\nReturns\n\n\nObject\n - a isSyncing object with the following methods:\n\n\n\n\nsyncing.addCallback()\n: Adds another callback, which will be called when the node starts or stops syncing.\n\n\nsyncing.stopWatching()\n: Stops the syncing callbacks.\n\n\n\n\nCallback return value\n\n\n\n\nBoolean\n - The callback will be fired with \ntrue\n when the syncing starts and with \nfalse\n when it stopped.\n\n\nObject\n - While syncing it will return the syncing object:\n\n\nstartingBlock\n: \nNumber\n - The block number where the sync started.\n\n\ncurrentBlock\n: \nNumber\n - The block number where at which block the node currently synced to already.\n\n\nhighestBlock\n: \nNumber\n - The estimated block number to sync to.\n\n\n\n\nExample\n\n\nweb3\n.\neth\n.\nisSyncing\n(\nfunction\n(\nerror\n,\n \nsync\n){\n\n    \nif\n(\n!\nerror\n)\n \n{\n\n        \n// stop all app activity\n\n        \nif\n(\nsync\n \n===\n \ntrue\n)\n \n{\n\n           \n// we use `true`, so it stops all filters, but not the web3.eth.syncing polling\n\n           \nweb3\n.\nreset\n(\ntrue\n);\n\n\n        \n// show sync info\n\n        \n}\n \nelse\n \nif\n(\nsync\n)\n \n{\n\n           \nconsole\n.\nlog\n(\nsync\n.\ncurrentBlock\n);\n\n\n        \n// re-gain app operation\n\n        \n}\n \nelse\n \n{\n\n            \n// run your app init function...\n\n        \n}\n\n    \n}\n\n\n});\n\n\n\n\n\n\n\nweb3.eth.coinbase\n\n\nweb3.eth.coinbase\n// or async\nweb3.eth.getCoinbase(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns the coinbase address where the mining rewards go to.\n\n\nReturns\n\n\nString\n - The coinbase address of the client.\n\n\nExample\n\n\nvar\n \ncoinbase\n \n=\n \nweb3\n.\neth\n.\ncoinbase\n;\n\n\nconsole\n.\nlog\n(\ncoinbase\n);\n \n// \n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n\n\n\n\n\n\n\nweb3.eth.mining\n\n\nweb3.eth.mining\n// or async\nweb3.eth.getMining(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and says whether the node is mining or not.\n\n\nReturns\n\n\nBoolean\n - \ntrue\n if the client is mining, otherwise \nfalse\n.\n\n\nExample\n\n\nvar\n \nmining\n \n=\n \nweb3\n.\neth\n.\nmining\n;\n\n\nconsole\n.\nlog\n(\nmining\n);\n \n// true or false\n\n\n\n\n\n\n\nweb3.eth.hashrate\n\n\nweb3.eth.hashrate\n// or async\nweb3.eth.getHashrate(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns the number of hashes per second that the node is mining with.\n\n\nReturns\n\n\nNumber\n - number of hashes per second.\n\n\nExample\n\n\nvar\n \nhashrate\n \n=\n \nweb3\n.\neth\n.\nhashrate\n;\n\n\nconsole\n.\nlog\n(\nhashrate\n);\n \n// 493736\n\n\n\n\n\n\n\nweb3.eth.gasPrice\n\n\nweb3.eth.gasPrice\n// or async\nweb3.eth.getGasPrice(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns the current gas price.\nThe gas price is determined by the x latest blocks median gas price.\n\n\nReturns\n\n\nBigNumber\n - A BigNumber instance of the current gas price in wei.\n\n\nSee the \nnote on BigNumber\n.\n\n\nExample\n\n\nvar\n \ngasPrice\n \n=\n \nweb3\n.\neth\n.\ngasPrice\n;\n\n\nconsole\n.\nlog\n(\ngasPrice\n.\ntoString\n(\n10\n));\n \n// \n10000000000000\n\n\n\n\n\n\n\nweb3.eth.accounts\n\n\nweb3.eth.accounts\n// or async\nweb3.eth.getAccounts(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns a list of accounts the node controls.\n\n\nReturns\n\n\nArray\n - An array of addresses controlled by client.\n\n\nExample\n\n\nvar\n \naccounts\n \n=\n \nweb3\n.\neth\n.\naccounts\n;\n\n\nconsole\n.\nlog\n(\naccounts\n);\n \n// [\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n]\n\n\n\n\n\n\n\nweb3.eth.blockNumber\n\n\nweb3.eth.blockNumber\n// or async\nweb3.eth.getBlockNumber(callback(error, result){ ... })\n\n\n\n\n\nThis property is read only and returns the current block number.\n\n\nReturns\n\n\nNumber\n - The number of the most recent block.\n\n\nExample\n\n\nvar\n \nnumber\n \n=\n \nweb3\n.\neth\n.\nblockNumber\n;\n\n\nconsole\n.\nlog\n(\nnumber\n);\n \n// 2744\n\n\n\n\n\n\n\nweb3.eth.register\n\n\nweb3.eth.register(addressHexString [, callback])\n\n\n\n\n\n(Not Implemented yet)\nRegisters the given address to be included in \nweb3.eth.accounts\n. This allows non-private-key owned accounts to be associated as an owned account (e.g., contract wallets).\n\n\nParameters\n\n\n\n\nString\n - The address to register\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\n?\n\n\nExample\n\n\nweb3\n.\neth\n.\nregister\n(\n0x407d73d8a49eeb85d32cf465507dd71d507100ca\n)\n\n\n\n\n\n\n\nweb3.eth.unRegister\n\n\n web3.eth.unRegister(addressHexString [, callback])\n\n\n\n\n\n(Not Implemented yet)\nUnregisters a given address.\n\n\nParameters\n\n\n\n\nString\n - The address to unregister.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\n?\n\n\nExample\n\n\nweb3\n.\neth\n.\nunregister\n(\n0x407d73d8a49eeb85d32cf465507dd71d507100ca\n)\n\n\n\n\n\n\n\nweb3.eth.getBalance\n\n\nweb3.eth.getBalance(addressHexString [, defaultBlock] [, callback])\n\n\n\n\n\nGet the balance of an address at a given block.\n\n\nParameters\n\n\n\n\nString\n - The address to get the balance of.\n\n\nNumber|String\n - (optional) If you pass this parameter it will not use the default block set with \nweb3.eth.defaultBlock\n.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - A BigNumber instance of the current balance for the given address in wei.\n\n\nSee the \nnote on BigNumber\n.\n\n\nExample\n\n\nvar\n \nbalance\n \n=\n \nweb3\n.\neth\n.\ngetBalance\n(\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n);\n\n\nconsole\n.\nlog\n(\nbalance\n);\n \n// instanceof BigNumber\n\n\nconsole\n.\nlog\n(\nbalance\n.\ntoString\n(\n10\n));\n \n// \n1000000000000\n\n\nconsole\n.\nlog\n(\nbalance\n.\ntoNumber\n());\n \n// 1000000000000\n\n\n\n\n\n\n\nweb3.eth.getStorageAt\n\n\nweb3.eth.getStorageAt(addressHexString, position [, defaultBlock] [, callback])\n\n\n\n\n\nGet the storage at a specific position of an address.\n\n\nParameters\n\n\n\n\nString\n - The address to get the storage from.\n\n\nNumber\n - The index position of the storage.\n\n\nNumber|String\n - (optional) If you pass this parameter it will not use the default block set with \nweb3.eth.defaultBlock\n.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The value in storage at the given position.\n\n\nExample\n\n\nvar\n \nstate\n \n=\n \nweb3\n.\neth\n.\ngetStorageAt\n(\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n,\n \n0\n);\n\n\nconsole\n.\nlog\n(\nstate\n);\n \n// \n0x03\n\n\n\n\n\n\n\nweb3.eth.getCode\n\n\nweb3.eth.getCode(addressHexString [, defaultBlock] [, callback])\n\n\n\n\n\nGet the code at a specific address.\n\n\nParameters\n\n\n\n\nString\n - The address to get the code from.\n\n\nNumber|String\n - (optional) If you pass this parameter it will not use the default block set with \nweb3.eth.defaultBlock\n.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The data at given address \naddressHexString\n.\n\n\nExample\n\n\nvar\n \ncode\n \n=\n \nweb3\n.\neth\n.\ngetCode\n(\n0xd5677cf67b5aa051bb40496e68ad359eb97cfbf8\n);\n\n\nconsole\n.\nlog\n(\ncode\n);\n \n// \n0x600160008035811a818181146012578301005b601b6001356025565b8060005260206000f25b600060078202905091905056\n\n\n\n\n\n\n\nweb3.eth.getBlock\n\n\n web3.eth.getBlock(blockHashOrBlockNumber [, returnTransactionObjects] [, callback])\n\n\n\n\n\nReturns a block matching the block number or block hash.\n\n\nParameters\n\n\n\n\nString|Number\n - The block number or hash. Or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n as in the \ndefault block parameter\n.\n\n\nBoolean\n - (optional, default \nfalse\n) If \ntrue\n, the returned block will contain all transactions as objects, if \nfalse\n it will only contains the transaction hashes.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nObject\n - The block object:\n\n\n\n\nnumber\n: \nNumber\n - the block number. \nnull\n when its pending block.\n\n\nhash\n: \nString\n, 32 Bytes - hash of the block. \nnull\n when its pending block.\n\n\nparentHash\n: \nString\n, 32 Bytes - hash of the parent block.\n\n\nnonce\n: \nString\n, 8 Bytes - hash of the generated proof-of-work. \nnull\n when its pending block.\n\n\nsha3Uncles\n: \nString\n, 32 Bytes - SHA3 of the uncles data in the block.\n\n\nlogsBloom\n: \nString\n, 256 Bytes - the bloom filter for the logs of the block. \nnull\n when its pending block.\n\n\ntransactionsRoot\n: \nString\n, 32 Bytes - the root of the transaction trie of the block\n\n\nstateRoot\n: \nString\n, 32 Bytes - the root of the final state trie of the block.\n\n\nminer\n: \nString\n, 20 Bytes - the address of the beneficiary to whom the mining rewards were given.\n\n\ndifficulty\n: \nBigNumber\n - integer of the difficulty for this block.\n\n\ntotalDifficulty\n: \nBigNumber\n - integer of the total difficulty of the chain until this block.\n\n\nextraData\n: \nString\n - the \"extra data\" field of this block.\n\n\nsize\n: \nNumber\n - integer the size of this block in bytes.\n\n\ngasLimit\n: \nNumber\n - the maximum gas allowed in this block.\n\n\ngasUsed\n: \nNumber\n - the total used gas by all transactions in this block.\n\n\ntimestamp\n: \nNumber\n - the unix timestamp for when the block was collated.\n\n\ntransactions\n: \nArray\n - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter.\n\n\nuncles\n: \nArray\n - Array of uncle hashes.\n\n\n\n\nExample\n\n\nvar\n \ninfo\n \n=\n \nweb3\n.\neth\n.\ngetBlock\n(\n3150\n);\n\n\nconsole\n.\nlog\n(\ninfo\n);\n\n\n/*\n\n\n{\n\n\n  \nnumber\n: 3,\n\n\n  \nhash\n: \n0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46\n,\n\n\n  \nparentHash\n: \n0x2302e1c0b972d00932deb5dab9eb2982f570597d9d42504c05d9c2147eaf9c88\n,\n\n\n  \nnonce\n: \n0xfb6e1a62d119228b\n,\n\n\n  \nsha3Uncles\n: \n0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\n,\n\n\n  \nlogsBloom\n: \n0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n,\n\n\n  \ntransactionsRoot\n: \n0x3a1b03875115b79539e5bd33fb00d8f7b7cd61929d5a3c574f507b8acf415bee\n,\n\n\n  \nstateRoot\n: \n0xf1133199d44695dfa8fd1bcfe424d82854b5cebef75bddd7e40ea94cda515bcb\n,\n\n\n  \nminer\n: \n0x8888f1f195afa192cfee860698584c030f4c9db1\n,\n\n\n  \ndifficulty\n: BigNumber,\n\n\n  \ntotalDifficulty\n: BigNumber,\n\n\n  \nsize\n: 616,\n\n\n  \nextraData\n: \n0x\n,\n\n\n  \ngasLimit\n: 3141592,\n\n\n  \ngasUsed\n: 21662,\n\n\n  \ntimestamp\n: 1429287689,\n\n\n  \ntransactions\n: [\n\n\n    \n0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\n\n\n  ],\n\n\n  \nuncles\n: []\n\n\n}\n\n\n*/\n\n\n\n\n\n\n\nweb3.eth.getBlockTransactionCount\n\n\nweb3.eth.getBlockTransactionCount(hashStringOrBlockNumber [, callback])\n\n\n\n\n\nReturns the number of transaction in a given block.\n\n\nParameters\n\n\n\n\nString|Number\n - The block number or hash. Or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n as in the \ndefault block parameter\n.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nNumber\n - The number of transactions in the given block.\n\n\nExample\n\n\nvar\n \nnumber\n \n=\n \nweb3\n.\neth\n.\ngetBlockTransactionCount\n(\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n);\n\n\nconsole\n.\nlog\n(\nnumber\n);\n \n// 1\n\n\n\n\n\n\n\nweb3.eth.getUncle\n\n\nweb3.eth.getUncle(blockHashStringOrNumber, uncleNumber [, returnTransactionObjects] [, callback])\n\n\n\n\n\nReturns a blocks uncle by a given uncle index position.\n\n\nParameters\n\n\n\n\nString|Number\n - The block number or hash. Or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n as in the \ndefault block parameter\n.\n\n\nNumber\n - The index position of the uncle.\n\n\nBoolean\n - (optional, default \nfalse\n) If \ntrue\n, the returned block will contain all transactions as objects, if \nfalse\n it will only contains the transaction hashes.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nObject\n - the returned uncle. For a return value see \nweb3.eth.getBlock()\n.\n\n\nNote\n: An uncle doesn't contain individual transactions.\n\n\nExample\n\n\nvar\n \nuncle\n \n=\n \nweb3\n.\neth\n.\ngetUncle\n(\n500\n,\n \n0\n);\n\n\nconsole\n.\nlog\n(\nuncle\n);\n \n// see web3.eth.getBlock\n\n\n\n\n\n\n\nweb3.eth.getTransaction\n\n\nweb3.eth.getTransaction(transactionHash [, callback])\n\n\n\n\n\nReturns a transaction matching the given transaction hash.\n\n\nParameters\n\n\n\n\nString\n - The transaction hash.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nObject\n - A transaction object its hash \ntransactionHash\n:\n\n\n\n\nhash\n: \nString\n, 32 Bytes - hash of the transaction.\n\n\nnonce\n: \nNumber\n - the number of transactions made by the sender prior to this one.\n\n\nblockHash\n: \nString\n, 32 Bytes - hash of the block where this transaction was in. \nnull\n when its pending.\n\n\nblockNumber\n: \nNumber\n - block number where this transaction was in. \nnull\n when its pending.\n\n\ntransactionIndex\n: \nNumber\n - integer of the transactions index position in the block. \nnull\n when its pending.\n\n\nfrom\n: \nString\n, 20 Bytes - address of the sender.\n\n\nto\n: \nString\n, 20 Bytes - address of the receiver. \nnull\n when its a contract creation transaction.\n\n\nvalue\n: \nBigNumber\n - value transferred in Wei.\n\n\ngasPrice\n: \nBigNumber\n - gas price provided by the sender in Wei.\n\n\ngas\n: \nNumber\n - gas provided by the sender.\n\n\ninput\n: \nString\n - the data sent along with the transaction.\n\n\n\n\nExample\n\n\nvar\n \ntransaction\n \n=\n \nweb3\n.\neth\n.\ngetTransaction\n(\n0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\n);\n\n\nconsole\n.\nlog\n(\ntransaction\n);\n\n\n/*\n\n\n{\n\n\n  \nhash\n: \n0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\n,\n\n\n  \nnonce\n: 2,\n\n\n  \nblockHash\n: \n0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46\n,\n\n\n  \nblockNumber\n: 3,\n\n\n  \ntransactionIndex\n: 0,\n\n\n  \nfrom\n: \n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\n,\n\n\n  \nto\n: \n0x6295ee1b4f6dd65047762f924ecd367c17eabf8f\n,\n\n\n  \nvalue\n: BigNumber,\n\n\n  \ngas\n: 314159,\n\n\n  \ngasPrice\n: BigNumber,\n\n\n  \ninput\n: \n0x57cb2fc4\n\n\n}\n\n\n*/\n\n\n\n\n\n\n\nweb3.eth.getTransactionFromBlock\n\n\ngetTransactionFromBlock(hashStringOrNumber, indexNumber [, callback])\n\n\n\n\n\nReturns a transaction based on a block hash or number and the transactions index position.\n\n\nParameters\n\n\n\n\nString\n - A block number or hash. Or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n as in the \ndefault block parameter\n.\n\n\nNumber\n - The transactions index position.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nObject\n - A transaction object, see \nweb3.eth.getTransaction\n:\n\n\nExample\n\n\nvar\n \ntransaction\n \n=\n \nweb3\n.\neth\n.\ngetTransactionFromBlock\n(\n0x4534534534\n,\n \n2\n);\n\n\nconsole\n.\nlog\n(\ntransaction\n);\n \n// see web3.eth.getTransaction\n\n\n\n\n\n\n\nweb3.eth.getTransactionReceipt\n\n\nweb3.eth.getTransactionReceipt(hashString [, callback])\n\n\n\n\n\nReturns the receipt of a transaction by transaction hash.\n\n\nNote\n That the receipt is not available for pending transactions.\n\n\nParameters\n\n\n\n\nString\n - The transaction hash.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nObject\n - A transaction receipt object, or \nnull\n when no receipt was found:\n\n\n\n\nblockHash\n: \nString\n, 32 Bytes - hash of the block where this transaction was in.\n\n\nblockNumber\n: \nNumber\n - block number where this transaction was in.\n\n\ntransactionHash\n: \nString\n, 32 Bytes - hash of the transaction.\n\n\ntransactionIndex\n: \nNumber\n - integer of the transactions index position in the block.\n\n\nfrom\n: \nString\n, 20 Bytes - address of the sender.\n\n\nto\n: \nString\n, 20 Bytes - address of the receiver. \nnull\n when its a contract creation transaction.\n\n\ncumulativeGasUsed\n: \nNumber\n - The total amount of gas used when this transaction was executed in the block.\n\n\ngasUsed\n: \nNumber\n -  The amount of gas used by this specific transaction alone.\n\n\ncontractAddress\n: \nString\n - 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise \nnull\n.\n\n\nlogs\n:  \nArray\n - Array of log objects, which this transaction generated.\n\n\nstatus\n:  \nNumber\n - 0 indicates transaction failure , 1 indicates transaction succeeded.\n\n\n\n\nExample\n\n\nvar\n \nreceipt\n \n=\n \nweb3\n.\neth\n.\ngetTransactionReceipt\n(\n0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\n);\n\n\nconsole\n.\nlog\n(\nreceipt\n);\n\n\n{\n\n  \ntransactionHash\n:\n \n0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\n,\n\n  \ntransactionIndex\n:\n \n0\n,\n\n  \nblockHash\n:\n \n0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46\n,\n\n  \nblockNumber\n:\n \n3\n,\n\n  \ncontractAddress\n:\n \n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\n,\n\n  \ncumulativeGasUsed\n:\n \n314159\n,\n\n  \ngasUsed\n:\n \n30234\n,\n\n  \nlogs\n:\n \n[{\n\n         \n// logs as returned by getFilterLogs, etc.\n\n     \n},\n \n...],\n\n  \nstatus\n:\n \n0x1\n\n\n}\n\n\n\n\n\n\n\nweb3.eth.getTransactionCount\n\n\nweb3.eth.getTransactionCount(addressHexString [, defaultBlock] [, callback])\n\n\n\n\n\nGet the numbers of transactions sent from this address.\n\n\nParameters\n\n\n\n\nString\n - The address to get the numbers of transactions from.\n\n\nNumber|String\n - (optional) If you pass this parameter it will not use the default block set with \nweb3.eth.defaultBlock\n.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nNumber\n - The number of transactions sent from the given address.\n\n\nExample\n\n\nvar\n \nnumber\n \n=\n \nweb3\n.\neth\n.\ngetTransactionCount\n(\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n);\n\n\nconsole\n.\nlog\n(\nnumber\n);\n \n// 1\n\n\n\n\n\n\n\nweb3.eth.sendTransaction\n\n\nweb3.eth.sendTransaction(transactionObject [, callback])\n\n\n\n\n\nSends a transaction to the network.\n\n\nParameters\n\n\n\n\nObject\n - The transaction object to send:\n\n\nfrom\n: \nString\n - The address for the sending account. Uses the \nweb3.eth.defaultAccount\n property, if not specified.\n\n\nto\n: \nString\n - (optional) The destination address of the message, left undefined for a contract-creation transaction.\n\n\nvalue\n: \nNumber|String|BigNumber\n - (optional) The value transferred for the transaction in Wei, also the endowment if it's a contract-creation transaction.\n\n\ngas\n: \nNumber|String|BigNumber\n - (optional, default: To-Be-Determined) The amount of gas to use for the transaction (unused gas is refunded).\n\n\ngasPrice\n: \nNumber|String|BigNumber\n - (optional, default: To-Be-Determined) The price of gas for this transaction in wei, defaults to the mean network gas price.\n\n\ndata\n: \nString\n - (optional) Either a \nbyte string\n containing the associated data of the message, or in the case of a contract-creation transaction, the initialisation code.\n\n\nnonce\n: \nNumber\n  - (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The 32 Bytes transaction hash as HEX string.\n\n\nIf the transaction was a contract creation use \nweb3.eth.getTransactionReceipt()\n to get the contract address, after the transaction was mined.\n\n\nExample\n\n\n// compiled solidity source code using https://chriseth.github.io/cpp-ethereum/\n\n\nvar\n \ncode\n \n=\n \n603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3\n;\n\n\n\nweb3\n.\neth\n.\nsendTransaction\n({\ndata\n:\n \ncode\n},\n \nfunction\n(\nerr\n,\n \ntransactionHash\n)\n \n{\n\n  \nif\n \n(\n!\nerr\n)\n\n    \nconsole\n.\nlog\n(\ntransactionHash\n);\n \n// \n0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385\n\n\n});\n\n\n\n\n\n\n\nweb3.eth.sendRawTransaction\n\n\nweb3.eth.sendRawTransaction(signedTransactionData [, callback])\n\n\n\n\n\nSends an already signed transaction. For example can be signed using: https://github.com/SilentCicero/ethereumjs-accounts\n\n\nParameters\n\n\n\n\nString\n - Signed transaction data in HEX format\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The 32 Bytes transaction hash as HEX string.\n\n\nIf the transaction was a contract creation use \nweb3.eth.getTransactionReceipt()\n to get the contract address, after the transaction was mined.\n\n\nExample\n\n\nvar\n \nTx\n \n=\n \nrequire\n(\nethereumjs-tx\n);\n\n\nvar\n \nprivateKey\n \n=\n \nnew\n \nBuffer\n(\ne331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109\n,\n \nhex\n)\n\n\n\nvar\n \nrawTx\n \n=\n \n{\n\n  \nnonce\n:\n \n0x00\n,\n\n  \ngasPrice\n:\n \n0x09184e72a000\n,\n\n  \ngasLimit\n:\n \n0x2710\n,\n\n  \nto\n:\n \n0x0000000000000000000000000000000000000000\n,\n\n  \nvalue\n:\n \n0x00\n,\n\n  \ndata\n:\n \n0x7f7465737432000000000000000000000000000000000000000000000000000000600057\n\n\n}\n\n\n\nvar\n \ntx\n \n=\n \nnew\n \nTx\n(\nrawTx\n);\n\n\ntx\n.\nsign\n(\nprivateKey\n);\n\n\n\nvar\n \nserializedTx\n \n=\n \ntx\n.\nserialize\n();\n\n\n\n//console.log(serializedTx.toString(\nhex\n));\n\n\n//f889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f\n\n\n\nweb3\n.\neth\n.\nsendRawTransaction\n(\n0x\n \n+\n \nserializedTx\n.\ntoString\n(\nhex\n),\n \nfunction\n(\nerr\n,\n \nhash\n)\n \n{\n\n  \nif\n \n(\n!\nerr\n)\n\n    \nconsole\n.\nlog\n(\nhash\n);\n \n// \n0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385\n\n\n});\n\n\n\n\n\n\n\nweb3.eth.sign\n\n\nweb3.eth.sign(address, dataToSign, [, callback])\n\n\n\n\n\nSigns data from a specific account. This account needs to be unlocked.\n\n\nParameters\n\n\n\n\nString\n - Address to sign with.\n\n\nString\n - Data to sign.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The signed data.\n\n\nAfter the hex prefix, characters correspond to ECDSA values like this:\n\nr = signature[0:64]\ns = signature[64:128]\nv = signature[128:130]\n\n\n\nNote that if you are using \necrecover\n, \nv\n will be either \n\"00\"\n or \n\"01\"\n. As a result, in order to use this value, you will have to parse it to an integer and then add \n27\n. This will result in either a \n27\n or a \n28\n.\n\n\nExample\n\n\nvar\n \nresult\n \n=\n \nweb3\n.\neth\n.\nsign\n(\n0x135a7de83802408321b74c322f8558db1679ac20\n,\n\n    \n0x9dd2c369a187b4e6b9c402f030e50743e619301ea62aa4c0737d4ef7e10a3d49\n);\n \n// second argument is web3.sha3(\nxyz\n)\n\n\nconsole\n.\nlog\n(\nresult\n);\n \n// \n0x30755ed65396facf86c53e6217c52b4daebe72aa4941d89635409de4c9c7f9466d4e9aaec7977f05e923889b33c0d0dd27d7226b6e6f56ce737465c5cfd04be400\n\n\n\n\n\n\n\nweb3.eth.call\n\n\nweb3.eth.call(callObject [, defaultBlock] [, callback])\n\n\n\n\n\nExecutes a message call transaction, which is directly executed in the VM of the node, but never mined into the blockchain.\n\n\nParameters\n\n\n\n\nObject\n - A transaction object see \nweb3.eth.sendTransaction\n, with the difference that for calls the \nfrom\n property is optional as well.\n\n\nNumber|String\n - (optional) If you pass this parameter it will not use the default block set with \nweb3.eth.defaultBlock\n.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The returned data of the call, e.g. a codes functions return value.\n\n\nExample\n\n\nvar\n \nresult\n \n=\n \nweb3\n.\neth\n.\ncall\n({\n\n    \nto\n:\n \n0xc4abd0339eb8d57087278718986382264244252f\n,\n\n    \ndata\n:\n \n0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\n\n\n});\n\n\nconsole\n.\nlog\n(\nresult\n);\n \n// \n0x0000000000000000000000000000000000000000000000000000000000000015\n\n\n\n\n\n\n\nweb3.eth.estimateGas\n\n\nweb3.eth.estimateGas(callObject [, callback])\n\n\n\n\n\nExecutes a message call or transaction, which is directly executed in the VM of the node, but never mined into the blockchain and returns the amount of the gas used.\n\n\nParameters\n\n\nSee \nweb3.eth.sendTransaction\n, except that all properties are optional.\n\n\nReturns\n\n\nNumber\n - the used gas for the simulated call/transaction.\n\n\nExample\n\n\nvar\n \nresult\n \n=\n \nweb3\n.\neth\n.\nestimateGas\n({\n\n    \nto\n:\n \n0xc4abd0339eb8d57087278718986382264244252f\n,\n\n    \ndata\n:\n \n0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\n\n\n});\n\n\nconsole\n.\nlog\n(\nresult\n);\n \n// \n0x0000000000000000000000000000000000000000000000000000000000000015\n\n\n\n\n\n\n\nweb3.eth.filter\n\n\n// can be \nlatest\n or \npending\n\n\nvar\n \nfilter\n \n=\n \nweb3\n.\neth\n.\nfilter\n(\nfilterString\n);\n\n\n// OR object are log filter options\n\n\nvar\n \nfilter\n \n=\n \nweb3\n.\neth\n.\nfilter\n(\noptions\n);\n\n\n\n// watch for changes\n\n\nfilter\n.\nwatch\n(\nfunction\n(\nerror\n,\n \nresult\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nresult\n);\n\n\n});\n\n\n\n// Additionally you can start watching right away, by passing a callback:\n\n\nweb3\n.\neth\n.\nfilter\n(\noptions\n,\n \nfunction\n(\nerror\n,\n \nresult\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nresult\n);\n\n\n});\n\n\n\n\n\nParameters\n\n\n\n\nString|Object\n - The string \n\"latest\"\n or \n\"pending\"\n to watch for changes in the latest block or pending transactions respectively. Or a filter options object as follows:\n\n\nfromBlock\n: \nNumber|String\n - The number of the earliest block (\nlatest\n may be given to mean the most recent and \npending\n currently mining, block). By default \nlatest\n.\n\n\ntoBlock\n: \nNumber|String\n - The number of the latest block (\nlatest\n may be given to mean the most recent and \npending\n currently mining, block). By default \nlatest\n.\n\n\naddress\n: \nString\n - An address or a list of addresses to only get logs from particular account(s).\n\n\ntopics\n: \nArray of Strings\n - An array of values which must each appear in the log entries. The order is important, if you want to leave topics out use \nnull\n, e.g. \n[null, '0x00...']\n. You can also pass another array for each topic with options for that topic e.g. \n[null, ['option1', 'option2']]\n\n\n\n\nReturns\n\n\nObject\n - A filter object with the following methods:\n\n\n\n\nfilter.get(callback)\n: Returns all of the log entries that fit the filter.\n\n\nfilter.watch(callback)\n: Watches for state changes that fit the filter and calls the callback. See \nthis note\n for details.\n\n\nfilter.stopWatching()\n: Stops the watch and uninstalls the filter in the node. Should always be called once it is done.\n\n\n\n\nWatch callback return value\n\n\n\n\nString\n - When using the \n\"latest\"\n parameter, it returns the block hash of the last incoming block.\n\n\nString\n - When using the \n\"pending\"\n parameter, it returns a transaction hash of the most recent pending transaction.\n\n\nObject\n - When using manual filter options, it returns a log object as follows:\n\n\nlogIndex\n: \nNumber\n - integer of the log index position in the block. \nnull\n when its pending log.\n\n\ntransactionIndex\n: \nNumber\n - integer of the transactions index position log was created from. \nnull\n when its pending log.\n\n\ntransactionHash\n: \nString\n, 32 Bytes - hash of the transactions this log was created from. \nnull\n when its pending log.\n\n\nblockHash\n: \nString\n, 32 Bytes - hash of the block where this log was in. \nnull\n when its pending. \nnull\n when its pending log.\n\n\nblockNumber\n: \nNumber\n - the block number where this log was in. \nnull\n when its pending. \nnull\n when its pending log.\n\n\naddress\n: \nString\n, 32 Bytes - address from which this log originated.\n\n\ndata\n: \nString\n - contains one or more 32 Bytes non-indexed arguments of the log.\n\n\ntopics\n: \nArray of Strings\n - Array of 0 to 4 32 Bytes \nDATA\n of indexed log arguments. (In \nsolidity\n: The first topic is the \nhash\n of the signature of the event (e.g. \nDeposit(address,bytes32,uint256)\n), except if you declared the event with the \nanonymous\n specifier.)\n\n\n\n\n\n\n\n\nNote\n For event filter return values see \nContract Events\n\n\nExample\n\n\nvar\n \nfilter\n \n=\n \nweb3\n.\neth\n.\nfilter\n(\npending\n);\n\n\n\nfilter\n.\nwatch\n(\nfunction\n \n(\nerror\n,\n \nlog\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nlog\n);\n \n//  {\naddress\n:\n0x0000000000000000000000000000000000000000\n, \ndata\n:\n0x0000000000000000000000000000000000000000000000000000000000000000\n, ...}\n\n\n});\n\n\n\n// get all past logs again.\n\n\nvar\n \nmyResults\n \n=\n \nfilter\n.\nget\n(\nfunction\n(\nerror\n,\n \nlogs\n){\n \n...\n \n});\n\n\n\n...\n\n\n\n// stops and uninstalls the filter\n\n\nfilter\n.\nstopWatching\n();\n\n\n\n\n\n\n\nweb3.eth.contract\n\n\nweb3.eth.contract(abiArray)\n\n\n\n\n\nCreates a contract object for a solidity contract, which can be used to initiate contracts on an address.\nYou can read more about events \nhere\n.\n\n\nParameters\n\n\n\n\nArray\n - ABI array with descriptions of functions and events of the contract.\n\n\n\n\nReturns\n\n\nObject\n - A contract object, which can be initiated as follows:\n\n\nvar\n \nMyContract\n \n=\n \nweb3\n.\neth\n.\ncontract\n(\nabiArray\n);\n\n\n\n// instantiate by address\n\n\nvar\n \ncontractInstance\n \n=\n \nMyContract\n.\nat\n(\naddress\n);\n\n\n\n// deploy new contract\n\n\nvar\n \ncontractInstance\n \n=\n \nMyContract\n.\nnew\n([\nconstructorParam1\n]\n \n[,\n \nconstructorParam2\n],\n \n{\ndata\n:\n \n0x12345...\n,\n \nfrom\n:\n \nmyAccount\n,\n \ngas\n:\n \n1000000\n});\n\n\n\n// Get the data to deploy the contract manually\n\n\nvar\n \ncontractData\n \n=\n \nMyContract\n.\nnew\n.\ngetData\n([\nconstructorParam1\n]\n \n[,\n \nconstructorParam2\n],\n \n{\ndata\n:\n \n0x12345...\n});\n\n\n// contractData = \n0x12345643213456000000000023434234\n\n\n\n\n\nAnd then you can either initiate an existing contract on an address,\nor deploy the contract using the compiled byte code:\n\n\n// Instantiate from an existing address:\n\n\nvar\n \nmyContractInstance\n \n=\n \nMyContract\n.\nat\n(\nmyContractAddress\n);\n\n\n\n\n// Or deploy a new contract:\n\n\n\n// Deploy the contract asynchronous from Solidity file:\n\n\n...\n\n\nconst\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\nconst\n \nsolc\n \n=\n \nrequire\n(\nsolc\n)\n\n\n\nlet\n \nsource\n \n=\n \nfs\n.\nreadFileSync\n(\nnameContract.sol\n,\n \nutf8\n);\n\n\nlet\n \ncompiledContract\n \n=\n \nsolc\n.\ncompile\n(\nsource\n,\n \n1\n);\n\n\nlet\n \nabi\n \n=\n \ncompiledContract\n.\ncontracts\n[\nnameContract\n].\ninterface\n;\n\n\nlet\n \nbytecode\n \n=\n \ncompiledContract\n.\ncontracts\n[\nnameContract\n].\nbytecode\n;\n\n\nlet\n \ngasEstimate\n \n=\n \nweb3\n.\neth\n.\nestimateGas\n({\ndata\n:\n \nbytecode\n});\n\n\nlet\n \nMyContract\n \n=\n \nweb3\n.\neth\n.\ncontract\n(\nJSON\n.\nparse\n(\nabi\n));\n\n\n\nvar\n \nmyContractReturned\n \n=\n \nMyContract\n.\nnew\n(\nparam1\n,\n \nparam2\n,\n \n{\n\n   \nfrom\n:\nmySenderAddress\n,\n\n   \ndata\n:\nbytecode\n,\n\n   \ngas\n:\ngasEstimate\n},\n \nfunction\n(\nerr\n,\n \nmyContract\n){\n\n    \nif\n(\n!\nerr\n)\n \n{\n\n       \n// NOTE: The callback will fire twice!\n\n       \n// Once the contract has the transactionHash property set and once its deployed on an address.\n\n\n       \n// e.g. check tx hash on the first call (transaction send)\n\n       \nif\n(\n!\nmyContract\n.\naddress\n)\n \n{\n\n           \nconsole\n.\nlog\n(\nmyContract\n.\ntransactionHash\n)\n \n// The hash of the transaction, which deploys the contract\n\n\n       \n// check address on the second call (contract deployed)\n\n       \n}\n \nelse\n \n{\n\n           \nconsole\n.\nlog\n(\nmyContract\n.\naddress\n)\n \n// the contract address\n\n       \n}\n\n\n       \n// Note that the returned \nmyContractReturned\n === \nmyContract\n,\n\n       \n// so the returned \nmyContractReturned\n object will also get the address set.\n\n    \n}\n\n  \n});\n\n\n\n// Deploy contract syncronous: The address will be added as soon as the contract is mined.\n\n\n// Additionally you can watch the transaction by using the \ntransactionHash\n property\n\n\nvar\n \nmyContractInstance\n \n=\n \nMyContract\n.\nnew\n(\nparam1\n,\n \nparam2\n,\n \n{\ndata\n:\n \nmyContractCode\n,\n \ngas\n:\n \n300000\n,\n \nfrom\n:\n \nmySenderAddress\n});\n\n\nmyContractInstance\n.\ntransactionHash\n \n// The hash of the transaction, which created the contract\n\n\nmyContractInstance\n.\naddress\n \n// undefined at start, but will be auto-filled later\n\n\n\n\n\nExample\n\n\n// contract abi\n\n\nvar\n \nabi\n \n=\n \n[{\n\n     \nname\n:\n \nmyConstantMethod\n,\n\n     \ntype\n:\n \nfunction\n,\n\n     \nconstant\n:\n \ntrue\n,\n\n     \ninputs\n:\n \n[{\n \nname\n:\n \na\n,\n \ntype\n:\n \nstring\n \n}],\n\n     \noutputs\n:\n \n[{\nname\n:\n \nd\n,\n \ntype\n:\n \nstring\n \n}]\n\n\n},\n \n{\n\n     \nname\n:\n \nmyStateChangingMethod\n,\n\n     \ntype\n:\n \nfunction\n,\n\n     \nconstant\n:\n \nfalse\n,\n\n     \ninputs\n:\n \n[{\n \nname\n:\n \na\n,\n \ntype\n:\n \nstring\n \n},\n \n{\n \nname\n:\n \nb\n,\n \ntype\n:\n \nint\n \n}],\n\n     \noutputs\n:\n \n[]\n\n\n},\n \n{\n\n     \nname\n:\n \nmyEvent\n,\n\n     \ntype\n:\n \nevent\n,\n\n     \ninputs\n:\n \n[{\nname\n:\n \na\n,\n \ntype\n:\n \nint\n,\n \nindexed\n:\n \ntrue\n},{\nname\n:\n \nb\n,\n \ntype\n:\n \nbool\n,\n \nindexed\n:\n \nfalse\n}]\n\n\n}];\n\n\n\n// creation of contract object\n\n\nvar\n \nMyContract\n \n=\n \nweb3\n.\neth\n.\ncontract\n(\nabi\n);\n\n\n\n// initiate contract for an address\n\n\nvar\n \nmyContractInstance\n \n=\n \nMyContract\n.\nat\n(\n0xc4abd0339eb8d57087278718986382264244252f\n);\n\n\n\n// call constant function\n\n\nvar\n \nresult\n \n=\n \nmyContractInstance\n.\nmyConstantMethod\n(\nmyParam\n);\n\n\nconsole\n.\nlog\n(\nresult\n)\n \n// \n0x25434534534\n\n\n\n// send a transaction to a function\n\n\nmyContractInstance\n.\nmyStateChangingMethod\n(\nsomeParam1\n,\n \n23\n,\n \n{\nvalue\n:\n \n200\n,\n \ngas\n:\n \n2000\n});\n\n\n\n// short hand style\n\n\nweb3\n.\neth\n.\ncontract\n(\nabi\n).\nat\n(\naddress\n).\nmyAwesomeMethod\n(...);\n\n\n\n// create filter\n\n\nvar\n \nfilter\n \n=\n \nmyContractInstance\n.\nmyEvent\n({\na\n:\n \n5\n},\n \nfunction\n \n(\nerror\n,\n \nresult\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nresult\n);\n\n    \n/*\n\n\n    {\n\n\n        address: \n0x8718986382264244252fc4abd0339eb8d5708727\n,\n\n\n        topics: \n0x12345678901234567890123456789012\n, \n0x0000000000000000000000000000000000000000000000000000000000000005\n,\n\n\n        data: \n0x0000000000000000000000000000000000000000000000000000000000000001\n,\n\n\n        ...\n\n\n    }\n\n\n    */\n\n\n});\n\n\n\n\n\n\n\nContract Methods\n\n\n// Automatically determines the use of call or sendTransaction based on the method type\n\n\nmyContractInstance\n.\nmyMethod\n(\nparam1\n \n[,\n \nparam2\n,\n \n...]\n \n[,\n \ntransactionObject\n]\n \n[,\n \ndefaultBlock\n]\n \n[,\n \ncallback\n]);\n\n\n\n// Explicitly calling this method\n\n\nmyContractInstance\n.\nmyMethod\n.\ncall\n(\nparam1\n \n[,\n \nparam2\n,\n \n...]\n \n[,\n \ntransactionObject\n]\n \n[,\n \ndefaultBlock\n]\n \n[,\n \ncallback\n]);\n\n\n\n// Explicitly sending a transaction to this method\n\n\nmyContractInstance\n.\nmyMethod\n.\nsendTransaction\n(\nparam1\n \n[,\n \nparam2\n,\n \n...]\n \n[,\n \ntransactionObject\n]\n \n[,\n \ncallback\n]);\n\n\n\n// Get the call data, so you can call the contract through some other means\n\n\nvar\n \nmyCallData\n \n=\n \nmyContractInstance\n.\nmyMethod\n.\ngetData\n(\nparam1\n \n[,\n \nparam2\n,\n \n...]);\n\n\n// myCallData = \n0x45ff3ff6000000000004545345345345..\n\n\n\n\n\nThe contract object exposes the contract's methods, which can be called using parameters and a transaction object.\n\n\nParameters\n\n\n\n\nString|Number|BigNumber\n - (optional) Zero or more parameters of the function. If passing in a string, it must be formatted as a hex number, e.g. \"0xdeadbeef\" If you have already created BigNumber object, then you can just pass it too.\n\n\nObject\n - (optional) The (previous) last parameter can be a transaction object, see \nweb3.eth.sendTransaction\n parameter 1 for more. \nNote\n: \ndata\n and \nto\n properties will not be taken into account.\n\n\nNumber|String\n - (optional) If you pass this parameter it will not use the default block set with \nweb3.eth.defaultBlock\n.\n\n\nFunction\n - (optional) If you pass a callback as the last parameter the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - If its a call the result data, if its a send transaction a created contract address, or the transaction hash, see \nweb3.eth.sendTransaction\n for details.\n\n\nExample\n\n\n// creation of contract object\n\n\nvar\n \nMyContract\n \n=\n \nweb3\n.\neth\n.\ncontract\n(\nabi\n);\n\n\n\n// initiate contract for an address\n\n\nvar\n \nmyContractInstance\n \n=\n \nMyContract\n.\nat\n(\n0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9\n);\n\n\n\nvar\n \nresult\n \n=\n \nmyContractInstance\n.\nmyConstantMethod\n(\nmyParam\n);\n\n\nconsole\n.\nlog\n(\nresult\n)\n \n// \n0x25434534534\n\n\n\nmyContractInstance\n.\nmyStateChangingMethod\n(\nsomeParam1\n,\n \n23\n,\n \n{\nvalue\n:\n \n200\n,\n \ngas\n:\n \n2000\n},\n \nfunction\n(\nerr\n,\n \nresult\n){\n \n...\n \n});\n\n\n\n\n\n\n\nContract Events\n\n\nvar\n \nevent\n \n=\n \nmyContractInstance\n.\nMyEvent\n({\nvalueA\n:\n \n23\n}\n \n[,\n \nadditionalFilterObject\n])\n\n\n\n// watch for changes\n\n\nevent\n.\nwatch\n(\nfunction\n(\nerror\n,\n \nresult\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nresult\n);\n\n\n});\n\n\n\n// Or pass a callback to start watching immediately\n\n\nvar\n \nevent\n \n=\n \nmyContractInstance\n.\nMyEvent\n([{\nvalueA\n:\n \n23\n}]\n \n[,\n \nadditionalFilterObject\n]\n \n,\n \nfunction\n(\nerror\n,\n \nresult\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nresult\n);\n\n\n});\n\n\n\n\n\nYou can use events like \nfilters\n and they have the same methods, but you pass different objects to create the event filter.\n\n\nParameters\n\n\n\n\nObject\n - Indexed return values you want to filter the logs by, e.g. \n{'valueA': 1, 'valueB': [myFirstAddress, mySecondAddress]}\n. By default all filter values are set to \nnull\n. It means, that they will match any event of given type sent from this contract.\n\n\nObject\n - Additional filter options, see \nfilters\n parameter 1 for more. By default filterObject has field 'address' set to address of the contract. Also first topic is the signature of event.\n\n\nFunction\n - (optional) If you pass a callback as the last parameter it will immediately start watching and you don't need to call \nmyEvent.watch(function(){})\n. See \nthis note\n for details.\n\n\n\n\nCallback return\n\n\nObject\n - An event object as follows:\n\n\n\n\naddress\n: \nString\n, 32 Bytes - address from which this log originated.\n\n\nargs\n: \nObject\n - The arguments coming from the event.\n\n\nblockHash\n: \nString\n, 32 Bytes - hash of the block where this log was in. \nnull\n when its pending.\n\n\nblockNumber\n: \nNumber\n - the block number where this log was in. \nnull\n when its pending.\n\n\nlogIndex\n: \nNumber\n - integer of the log index position in the block.\n\n\nevent\n: \nString\n - The event name.\n\n\nremoved\n: \nbool\n -  indicate if the transaction this event was created from was removed from the blockchain (due to orphaned block) or never get to it (due to rejected transaction).\n\n\ntransactionIndex\n: \nNumber\n - integer of the transactions index position log was created from.\n\n\ntransactionHash\n: \nString\n, 32 Bytes - hash of the transactions this log was created from.\n\n\n\n\nExample\n\n\nvar\n \nMyContract\n \n=\n \nweb3\n.\neth\n.\ncontract\n(\nabi\n);\n\n\nvar\n \nmyContractInstance\n \n=\n \nMyContract\n.\nat\n(\n0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9\n);\n\n\n\n// watch for an event with {some: \nargs\n}\n\n\nvar\n \nmyEvent\n \n=\n \nmyContractInstance\n.\nMyEvent\n({\nsome\n:\n \nargs\n},\n \n{\nfromBlock\n:\n \n0\n,\n \ntoBlock\n:\n \nlatest\n});\n\n\nmyEvent\n.\nwatch\n(\nfunction\n(\nerror\n,\n \nresult\n){\n\n   \n...\n\n\n});\n\n\n\n// would get all past logs again.\n\n\nvar\n \nmyResults\n \n=\n \nmyEvent\n.\nget\n(\nfunction\n(\nerror\n,\n \nlogs\n){\n \n...\n \n});\n\n\n\n...\n\n\n\n// would stop and uninstall the filter\n\n\nmyEvent\n.\nstopWatching\n();\n\n\n\n\n\n\n\nContract allEvents\n\n\nvar\n \nevents\n \n=\n \nmyContractInstance\n.\nallEvents\n([\nadditionalFilterObject\n]);\n\n\n\n// watch for changes\n\n\nevents\n.\nwatch\n(\nfunction\n(\nerror\n,\n \nevent\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nevent\n);\n\n\n});\n\n\n\n// Or pass a callback to start watching immediately\n\n\nvar\n \nevents\n \n=\n \nmyContractInstance\n.\nallEvents\n([\nadditionalFilterObject\n,]\n \nfunction\n(\nerror\n,\n \nlog\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nlog\n);\n\n\n});\n\n\n\n\n\nWill call the callback for all events which are created by this contract.\n\n\nParameters\n\n\n\n\nObject\n - Additional filter options, see \nfilters\n parameter 1 for more. By default filterObject has field 'address' set to address of the contract. This method sets the topic to the signature of event, and does not support additional topics.\n\n\nFunction\n - (optional) If you pass a callback as the last parameter it will immediately start watching and you don't need to call \nmyEvent.watch(function(){})\n. See \nthis note\n for details.\n\n\n\n\nCallback return\n\n\nObject\n - See \nContract Events\n for more.\n\n\nExample\n\n\nvar\n \nMyContract\n \n=\n \nweb3\n.\neth\n.\ncontract\n(\nabi\n);\n\n\nvar\n \nmyContractInstance\n \n=\n \nMyContract\n.\nat\n(\n0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9\n);\n\n\n\n// watch for an event with {some: \nargs\n}\n\n\nvar\n \nevents\n \n=\n \nmyContractInstance\n.\nallEvents\n({\nfromBlock\n:\n \n0\n,\n \ntoBlock\n:\n \nlatest\n});\n\n\nevents\n.\nwatch\n(\nfunction\n(\nerror\n,\n \nresult\n){\n\n   \n...\n\n\n});\n\n\n\n// would get all past logs again.\n\n\nevents\n.\nget\n(\nfunction\n(\nerror\n,\n \nlogs\n){\n \n...\n \n});\n\n\n\n...\n\n\n\n// would stop and uninstall the filter\n\n\nevents\n.\nstopWatching\n();\n\n\n\n\n\n\n\nweb3.eth.getCompilers\n\n\nCompiling features being deprecated https://github.com/ethereum/EIPs/issues/209\n\n\nweb3.eth.getCompilers([callback])\n\n\n\n\n\nGets a list of available compilers.\n\n\nParameters\n\n\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nArray\n - An array of strings of available compilers.\n\n\nExample\n\n\nvar\n \nnumber\n \n=\n \nweb3\n.\neth\n.\ngetCompilers\n();\n\n\nconsole\n.\nlog\n(\nnumber\n);\n \n// [\nlll\n, \nsolidity\n, \nserpent\n]\n\n\n\n\n\n\n\nweb3.eth.compile.solidity\n\n\nweb3.eth.compile.solidity(sourceString [, callback])\n\n\n\n\n\nCompiles solidity source code.\n\n\nParameters\n\n\n\n\nString\n - The solidity source code.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nObject\n - Contract and compiler info.\n\n\nExample\n\n\nvar\n \nsource\n \n=\n \n \n+\n\n    \ncontract test {\\n\n \n+\n\n    \n   function multiply(uint a) returns(uint d) {\\n\n \n+\n\n    \n       return a * 7;\\n\n \n+\n\n    \n   }\\n\n \n+\n\n    \n}\\n\n;\n\n\nvar\n \ncompiled\n \n=\n \nweb3\n.\neth\n.\ncompile\n.\nsolidity\n(\nsource\n);\n\n\nconsole\n.\nlog\n(\ncompiled\n);\n\n\n// {\n\n  \ntest\n:\n \n{\n\n    \ncode\n:\n \n0x605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056\n,\n\n    \ninfo\n:\n \n{\n\n      \nsource\n:\n \ncontract test {\\n\\tfunction multiply(uint a) returns(uint d) {\\n\\t\\treturn a * 7;\\n\\t}\\n}\\n\n,\n\n      \nlanguage\n:\n \nSolidity\n,\n\n      \nlanguageVersion\n:\n \n0\n,\n\n      \ncompilerVersion\n:\n \n0.8.2\n,\n\n      \nabiDefinition\n:\n \n[\n\n        \n{\n\n          \nconstant\n:\n \nfalse\n,\n\n          \ninputs\n:\n \n[\n\n            \n{\n\n              \nname\n:\n \na\n,\n\n              \ntype\n:\n \nuint256\n\n            \n}\n\n          \n],\n\n          \nname\n:\n \nmultiply\n,\n\n          \noutputs\n:\n \n[\n\n            \n{\n\n              \nname\n:\n \nd\n,\n\n              \ntype\n:\n \nuint256\n\n            \n}\n\n          \n],\n\n          \ntype\n:\n \nfunction\n\n        \n}\n\n      \n],\n\n      \nuserDoc\n:\n \n{\n\n        \nmethods\n:\n \n{}\n\n      \n},\n\n      \ndeveloperDoc\n:\n \n{\n\n        \nmethods\n:\n \n{}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nweb3.eth.compile.lll\n\n\nweb3. eth.compile.lll(sourceString [, callback])\n\n\n\n\n\nCompiles LLL source code.\n\n\nParameters\n\n\n\n\nString\n - The LLL source code.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The compiled LLL code as HEX string.\n\n\nExample\n\n\nvar\n \nsource\n \n=\n \n...\n;\n\n\n\nvar\n \ncode\n \n=\n \nweb3\n.\neth\n.\ncompile\n.\nlll\n(\nsource\n);\n\n\nconsole\n.\nlog\n(\ncode\n);\n \n// \n0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056\n\n\n\n\n\n\n\nweb3.eth.compile.serpent\n\n\nweb3.eth.compile.serpent(sourceString [, callback])\n\n\n\n\n\nCompiles serpent source code.\n\n\nParameters\n\n\n\n\nString\n - The serpent source code.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - The compiled serpent code as HEX string.\n\n\nvar\n \nsource\n \n=\n \n...\n;\n\n\n\nvar\n \ncode\n \n=\n \nweb3\n.\neth\n.\ncompile\n.\nserpent\n(\nsource\n);\n\n\nconsole\n.\nlog\n(\ncode\n);\n \n// \n0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056\n\n\n\n\n\n\n\nweb3.eth.namereg\n\n\nweb3.eth.namereg\n\n\n\n\n\nReturns GlobalRegistrar object.\n\n\nUsage\n\n\nsee \nnamereg\n example.\n\n\n\n\nweb3.db\n\n\nweb3.db.putString\n\n\nweb3.db.putString(db, key, value)\n\n\n\n\n\nThis method should be called, when we want to store a string in the local leveldb database.\n\n\nParameters\n\n\n\n\nString\n - The database to store to.\n\n\nString\n - The name of the store.\n\n\nString\n - The string value to store.\n\n\n\n\nReturns\n\n\nBoolean\n - \ntrue\n if successfull, otherwise \nfalse\n.\n\n\nExample\n\n\nparam is db name, second is the key, and third is the string value.\n\nweb3\n.\ndb\n.\nputString\n(\ntestDB\n,\n \nkey\n,\n \nmyString\n)\n \n// true\n\n\n\n\n\n\nweb3.db.getString\n\n\nweb3.db.getString(db, key)\n\n\n\n\n\nThis method should be called, when we want to get string from the local leveldb database.\n\n\nParameters\n\n\n\n\nString\n - The database string name to retrieve from.\n\n\nString\n - The name of the store.\n\n\n\n\nReturns\n\n\nString\n - The stored value.\n\n\nExample\n\n\nparam is db name and second is the key of string value.\n\nvar\n \nvalue\n \n=\n \nweb3\n.\ndb\n.\ngetString\n(\ntestDB\n,\n \nkey\n);\n\n\nconsole\n.\nlog\n(\nvalue\n);\n \n// \nmyString\n\n\n\n\n\n\nweb3.db.putHex\n\n\nweb3.db.putHex(db, key, value)\n\n\n\n\n\nThis method should be called, when we want to store binary data in HEX form in the local leveldb database.\n\n\nParameters\n\n\n\n\nString\n - The database to store to.\n\n\nString\n - The name of the store.\n\n\nString\n - The HEX string to store.\n\n\n\n\nReturns\n\n\nBoolean\n - \ntrue\n if successfull, otherwise \nfalse\n.\n\n\nExample\n\n\nweb3\n.\ndb\n.\nputHex\n(\ntestDB\n,\n \nkey\n,\n \n0x4f554b443\n);\n \n// true\n\n\n\n\n\n\n\nweb3.db.getHex\n\n\nweb3.db.getHex(db, key)\n\n\n\n\n\nThis method should be called, when we want to get a binary data in HEX form from the local leveldb database.\n\n\nParameters\n\n\n\n\nString\n - The database to store to.\n\n\nString\n - The name of the store.\n\n\n\n\nReturns\n\n\nString\n - The stored HEX value.\n\n\nExample\n\n\nparam is db name and second is the key of value.\n\nvar\n \nvalue\n \n=\n \nweb3\n.\ndb\n.\ngetHex\n(\ntestDB\n,\n \nkey\n);\n\n\nconsole\n.\nlog\n(\nvalue\n);\n \n// \n0x4f554b443\n\n\n\n\n\n\nweb3.shh\n\n\nWhisper  Overview\n\n\nExample\n\n\nvar\n \nshh\n \n=\n \nweb3\n.\nshh\n;\n\n\n\n\n\n\n\nweb3.shh.post\n\n\nweb3.shh.post(object [, callback])\n\n\nThis method should be called, when we want to post whisper message to the network.\n\n\nParameters\n\n\n\n\nObject\n - The post object:\n\n\nfrom\n: \nString\n, 60 Bytes HEX - (optional) The identity of the sender.\n\n\nto\n: \nString\n, 60 Bytes  HEX - (optional) The identity of the receiver. When present whisper will encrypt the message so that only the receiver can decrypt it.\n\n\ntopics\n: \nArray of Strings\n - Array of topics \nStrings\n, for the receiver to identify messages.\n\n\npayload\n: \nString|Number|Object\n - The payload of the message. Will be autoconverted to a HEX string before.\n\n\npriority\n: \nNumber\n - The integer of the priority in a range from ... (?).\n\n\nttl\n: \nNumber\n - integer of the time to live in seconds.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the message was sent, otherwise \nfalse\n.\n\n\nExample\n\n\nvar\n \nidentity\n \n=\n \nweb3\n.\nshh\n.\nnewIdentity\n();\n\n\nvar\n \ntopic\n \n=\n \nexample\n;\n\n\nvar\n \npayload\n \n=\n \nhello whisper world!\n;\n\n\n\nvar\n \nmessage\n \n=\n \n{\n\n  \nfrom\n:\n \nidentity\n,\n\n  \ntopics\n:\n \n[\ntopic\n],\n\n  \npayload\n:\n \npayload\n,\n\n  \nttl\n:\n \n100\n,\n\n  \nworkToProve\n:\n \n100\n \n// or priority TODO\n\n\n};\n\n\n\nweb3\n.\nshh\n.\npost\n(\nmessage\n);\n\n\n\n\n\n\n\nweb3.shh.newIdentity\n\n\nweb3.shh.newIdentity([callback])\n\n\n\n\n\nShould be called to create new identity.\n\n\nParameters\n\n\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nString\n - A new identity HEX string.\n\n\nExample\n\n\nvar\n \nidentity\n \n=\n \nweb3\n.\nshh\n.\nnewIdentity\n();\n\n\nconsole\n.\nlog\n(\nidentity\n);\n \n// \n0xc931d93e97ab07fe42d923478ba2465f283f440fd6cabea4dd7a2c807108f651b7135d1d6ca9007d5b68aa497e4619ac10aa3b27726e1863c1fd9b570d99bbaf\n\n\n\n\n\n\n\nweb3.shh.hasIdentity\n\n\nweb3.shh.hasIdentity(identity, [callback])\n\n\n\n\n\nShould be called, if we want to check if user has given identity.\n\n\nParameters\n\n\n\n\nString\n - The identity to check.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the identity exists, otherwise \nfalse\n.\n\n\nExample\n\n\nvar\n \nidentity\n \n=\n \nweb3\n.\nshh\n.\nnewIdentity\n();\n\n\nvar\n \nresult\n \n=\n \nweb3\n.\nshh\n.\nhasIdentity\n(\nidentity\n);\n\n\nconsole\n.\nlog\n(\nresult\n);\n \n// true\n\n\n\nvar\n \nresult2\n \n=\n \nweb3\n.\nshh\n.\nhasIdentity\n(\nidentity\n \n+\n \n0\n);\n\n\nconsole\n.\nlog\n(\nresult2\n);\n \n// false\n\n\n\n\n\n\n\nweb3.shh.newGroup\n\n\nExample\n\n\n// TODO: not implemented yet\n\n\n\n\n\n\n\nweb3.shh.addToGroup\n\n\nExample\n\n\n// TODO: not implemented yet\n\n\n\n\n\n\n\nweb3.shh.filter\n\n\nvar\n \nfilter\n \n=\n \nweb3\n.\nshh\n.\nfilter\n(\noptions\n)\n\n\n\n// watch for changes\n\n\nfilter\n.\nwatch\n(\nfunction\n(\nerror\n,\n \nresult\n){\n\n  \nif\n \n(\n!\nerror\n)\n\n    \nconsole\n.\nlog\n(\nresult\n);\n\n\n});\n\n\n\n\n\nWatch for incoming whisper messages.\n\n\nParameters\n\n\n\n\nObject\n - The filter options:\n\n\ntopics\n: \nArray of Strings\n - Filters messages by this topic(s). You can use the following combinations:\n\n\n['topic1', 'topic2'] == 'topic1' \n 'topic2'\n\n\n['topic1', ['topic2', 'topic3']] == 'topic1' \n ('topic2' || 'topic3')\n\n\n[null, 'topic1', 'topic2'] == ANYTHING \n 'topic1' \n 'topic2'\n -\n \nnull\n works as a wildcard\n\n\n\n\n\n\nto\n: Filter by identity of receiver of the message. If provided and the node has this identity, it will decrypt incoming encrypted messages.\n\n\nFunction\n - (optional) If you pass a callback the HTTP request is made asynchronous. See \nthis note\n for details.\n\n\n\n\nCallback return\n\n\nObject\n - The incoming message:\n\n\n\n\nfrom\n: \nString\n, 60 Bytes - The sender of the message, if a sender was specified.\n\n\nto\n: \nString\n, 60 Bytes - The receiver of the message, if a receiver was specified.\n\n\nexpiry\n: \nNumber\n - Integer of the time in seconds when this message should expire (?).\n\n\nttl\n: \nNumber\n -  Integer of the time the message should float in the system in seconds (?).\n\n\nsent\n: \nNumber\n -  Integer of the unix timestamp when the message was sent.\n\n\ntopics\n: \nArray of String\n - Array of \nString\n topics the message contained.\n\n\npayload\n: \nString\n - The payload of the message.\n\n\nworkProved\n: \nNumber\n - Integer of the work this message required before it was send (?).\n\n\n\n\n\n\nweb3.eth.sendIBANTransaction\n\n\nvar\n \ntxHash\n \n=\n \nweb3\n.\neth\n.\nsendIBANTransaction\n(\n0x00c5496aee77c1ba1f0854206a26dda82a81d6d8\n,\n \nXE81ETHXREGGAVOFYORK\n,\n \n0x100\n);\n\n\n\n\n\nSends IBAN transaction from user account to destination IBAN address.\n\n\nParameters\n\n\n\n\nstring\n - address from which we want to send transaction\n\n\nstring\n - IBAN address to which we want to send transaction\n\n\nvalue\n - value that we want to send in IBAN transaction\n\n\n\n\n\n\nweb3.eth.iban\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\n\n\n\n\n\nweb3.eth.iban.fromAddress\n\n\nvar\n \ni\n \n=\n \nweb3\n.\neth\n.\niban\n.\nfromAddress\n(\n0x00c5496aee77c1ba1f0854206a26dda82a81d6d8\n);\n\n\nconsole\n.\nlog\n(\ni\n.\ntoString\n());\n \n// \nXE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS\n\n\n\n\n\n\n\nweb3.eth.iban.fromBban\n\n\nvar\n \ni\n \n=\n \nweb3\n.\neth\n.\niban\n.\nfromBban\n(\nETHXREGGAVOFYORK\n);\n\n\nconsole\n.\nlog\n(\ni\n.\ntoString\n());\n \n// \nXE81ETHXREGGAVOFYORK\n\n\n\n\n\n\n\nweb3.eth.iban.createIndirect\n\n\nvar\n \ni\n \n=\n \nweb3\n.\neth\n.\niban\n.\ncreateIndirect\n({\n\n  \ninstitution\n:\n \nXREG\n,\n\n  \nidentifier\n:\n \nGAVOFYORK\n\n\n});\n\n\nconsole\n.\nlog\n(\ni\n.\ntoString\n());\n \n// \nXE81ETHXREGGAVOFYORK\n\n\n\n\n\n\n\nweb3.eth.iban.isValid\n\n\nvar\n \nvalid\n \n=\n \nweb3\n.\neth\n.\niban\n.\nisValid\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nconsole\n.\nlog\n(\nvalid\n);\n \n// true\n\n\n\nvar\n \nvalid2\n \n=\n \nweb3\n.\neth\n.\niban\n.\nisValid\n(\nXE82ETHXREGGAVOFYORK\n);\n\n\nconsole\n.\nlog\n(\nvalid2\n);\n \n// false, cause checksum is incorrect\n\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nvar\n \nvalid3\n \n=\n \ni\n.\nisValid\n();\n\n\nconsole\n.\nlog\n(\nvalid3\n);\n \n// true\n\n\n\n\n\n\n\nweb3.eth.iban.isDirect\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nvar\n \ndirect\n \n=\n \ni\n.\nisDirect\n();\n\n\nconsole\n.\nlog\n(\ndirect\n);\n \n// false\n\n\n\n\n\n\n\nweb3.eth.iban.isIndirect\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nvar\n \nindirect\n \n=\n \ni\n.\nisIndirect\n();\n\n\nconsole\n.\nlog\n(\nindirect\n);\n \n// true\n\n\n\n\n\n\n\nweb3.eth.iban.checksum\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nvar\n \nchecksum\n \n=\n \ni\n.\nchecksum\n();\n\n\nconsole\n.\nlog\n(\nchecksum\n);\n \n// \n81\n\n\n\n\n\n\n\nweb3.eth.iban.institution\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nvar\n \ninstitution\n \n=\n \ni\n.\ninstitution\n();\n\n\nconsole\n.\nlog\n(\ninstitution\n);\n \n// \nXREG\n\n\n\n\n\n\n\nweb3.eth.iban.client\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE81ETHXREGGAVOFYORK\n);\n\n\nvar\n \nclient\n \n=\n \ni\n.\nclient\n();\n\n\nconsole\n.\nlog\n(\nclient\n);\n \n// \nGAVOFYORK\n\n\n\n\n\n\n\nweb3.eth.iban.address\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS\n);\n\n\nvar\n \naddress\n \n=\n \ni\n.\naddress\n();\n\n\nconsole\n.\nlog\n(\naddress\n);\n \n// \n00c5496aee77c1ba1f0854206a26dda82a81d6d8\n\n\n\n\n\n\n\nweb3.eth.iban.toString\n\n\nvar\n \ni\n \n=\n \nnew\n \nweb3\n.\neth\n.\niban\n(\nXE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS\n);\n\n\nconsole\n.\nlog\n(\ni\n.\ntoString\n());\n \n// \nXE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS", 
            "title": "JS API"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3-javascript-app-api-for-02xx", 
            "text": "NOTE: These docs are for web3.js version 0.2x.x. If you\u2019re using web3.js 1.0 please refer to  this documentation .  To make your app work on Ethereum, you can use the  web3  object provided by the  web3.js library . Under the hood it communicates to a local node through  RPC calls . web3.js works with any Ethereum node, which exposes an RPC layer.  web3  contains the  eth  object -  web3.eth  (for specifically Ethereum blockchain interactions) and the  shh  object -  web3.shh  (for Whisper interaction). Over time we'll introduce other objects for each of the other web3 protocols. Working   examples can be found here .  If you want to look at some more sophisticated examples using web3.js check out these  useful app patterns .", 
            "title": "Web3 JavaScript app API for 0.2x.x"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#getting-started", 
            "text": "Adding web3  Using Callbacks  Batch requests  A note on big numbers in web3.js  -  API Reference", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#adding-web3", 
            "text": "First you need to get web3.js into your project. This can be done using the following methods:   npm:  npm install web3  bower:  bower install web3  meteor:  meteor add ethereum:web3  vanilla: link the  dist./web3.min.js   Then you need to create a web3 instance, setting a provider.\nTo make sure you don't overwrite the already set provider when in mist, check first if the web3 is available:  if   ( typeof   web3   !==   undefined )   { \n   web3   =   new   Web3 ( web3 . currentProvider );  }   else   { \n   // set the provider you want from Web3.providers \n   web3   =   new   Web3 ( new   Web3 . providers . HttpProvider ( http://localhost:8545 ));  }   After that you can use the  API  of the  web3  object.", 
            "title": "Adding web3"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#using-callbacks", 
            "text": "As this API is designed to work with a local RPC node, all its functions use synchronous HTTP requests by default.  If you want to make an asynchronous request, you can pass an optional callback as the last parameter to most functions.\nAll callbacks are using an  error first callback  style:  web3 . eth . getBlock ( 48 ,   function ( error ,   result ){ \n     if ( ! error ) \n         console . log ( result ) \n     else \n         console . error ( error );  })", 
            "title": "Using callbacks"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#batch-requests", 
            "text": "Batch requests allow queuing up requests and processing them at once.  Note  Batch requests are not faster! In fact making many requests at once will in some cases be faster, as requests are processed asynchronously. Batch requests are mainly useful to ensure the serial processing of requests.  var   batch   =   web3 . createBatch ();  batch . add ( web3 . eth . getBalance . request ( 0x0000000000000000000000000000000000000000 ,   latest ,   callback ));  batch . add ( web3 . eth . Contract ( abi ). at ( address ). balance . request ( address ,   callback2 ));  batch . execute ();", 
            "title": "Batch requests"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#a-note-on-big-numbers-in-web3js", 
            "text": "You will always get a BigNumber object for number values as JavaScript is not able to handle big numbers correctly.\nLook at the following examples:  101010100324325345346456456456456456456  //  101010100324325345346456456456456456456  101010100324325345346456456456456456456  // 1.0101010032432535e+38   web3.js depends on the  BigNumber Library  and adds it automatically.  var   balance   =   new   BigNumber ( 131242344353464564564574574567456 );  // or var balance = web3.eth.getBalance(someAddress);  balance . plus ( 21 ). toString ( 10 );   // toString(10) converts it to a number string  //  131242344353464564564574574567477   The next example wouldn't work as we have more than 20 floating points, therefore it is recommended to always keep your balance in  wei  and only transform it to other units when presenting to the user: var   balance   =   new   BigNumber ( 13124.234435346456466666457455567456 );  balance . plus ( 21 ). toString ( 10 );   // toString(10) converts it to a number string, but can only show max 20 floating points  //  13145.23443534645646666646  // you number would be cut after the 20 floating point", 
            "title": "A note on big numbers in web3.js"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3js-api-reference", 
            "text": "web3  version  api  node/getNode  network/getNetwork  ethereum/getEthereum  whisper/getWhisper    isConnected()  setProvider(provider)  currentProvider  reset()  sha3(string, options)  toHex(stringOrNumber)  toAscii(hexString)  fromAscii(textString, [padding])  toDecimal(hexString)  fromDecimal(number)  fromWei(numberStringOrBigNumber, unit)  toWei(numberStringOrBigNumber, unit)  toBigNumber(numberOrHexString)  isAddress(hexString)  net  listening/getListening  peerCount/getPeerCount    eth  defaultAccount  defaultBlock  syncing/getSyncing  isSyncing  coinbase/getCoinbase  hashrate/getHashrate  gasPrice/getGasPrice  accounts/getAccounts  mining/getMining  blockNumber/getBlockNumber  register(hexString)  (Not implemented yet)  unRegister(hexString)  (Not implemented yet)  getBalance(address)  getStorageAt(address, position)  getCode(address)  getBlock(hash/number)  getBlockTransactionCount(hash/number)  getUncle(hash/number)  getBlockUncleCount(hash/number)  getTransaction(hash)  getTransactionFromBlock(hashOrNumber, indexNumber)  getTransactionReceipt(hash)  getTransactionCount(address)  sendTransaction(object)  sendRawTransaction(object)  sign(object)  call(object)  estimateGas(object)  filter(array (, options) )  watch(callback)  stopWatching(callback)  get()    Contract(abiArray)  contract.myMethod()  contract.myEvent()  contract.allEvents()  getCompilers()  compile.lll(string)  compile.solidity(string)  compile.serpent(string)  namereg  sendIBANTransaction  iban  fromAddress  fromBban  createIndirect  isValid  isDirect  isIndirect  checksum  institution  client  address  toString    db  putString(name, key, value)  getString(-       var rXArray = stringToNumberArray(form.rX.value);\nname, key)  putHex(name, key, value)  getHex(name, key)    shh  post(postObject)  newIdentity()  hasIdentity(hexString)  newGroup(_id, _who)  addToGroup(_id, _who)  filter(object/string)  watch(callback)  stopWatching(callback)  get(callback)", 
            "title": "Web3.js API Reference"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3", 
            "text": "The  web3  object provides all methods.", 
            "title": "web3"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example", 
            "text": "var   Web3   =   require ( web3 );  // create an instance of web3 using the HTTP provider.  // NOTE in mist web3 is already available, so check first if it s available before instantiating  var   web3   =   new   Web3 ( new   Web3 . providers . HttpProvider ( http://localhost:8545 ));", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example-using-http-basic-authentication", 
            "text": "var   Web3   =   require ( web3 );  var   web3   =   new   Web3 ( new   Web3 . providers . HttpProvider ( http://localhost:8545 ,   0 ,   BasicAuthUsername ,   BasicAuthPassword ));  //Note: HttpProvider takes 4 arguments (host, timeout, user, password)", 
            "title": "Example using HTTP Basic Authentication"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3versionapi", 
            "text": "web3 . version . api", 
            "title": "web3.version.api"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns", 
            "text": "String  - The ethereum js api version.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_1", 
            "text": "var   version   =   web3 . version . api ;  console . log ( version );   //  0.2.0", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3versionnode", 
            "text": "web3.version.node\n// or async\nweb3.version.getNode(callback(error, result){ ... })", 
            "title": "web3.version.node"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_1", 
            "text": "String  - The client/node version.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_2", 
            "text": "var   version   =   web3 . version . node ;  console . log ( version );   //  Mist/v0.9.3/darwin/go1.4.1", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3versionnetwork", 
            "text": "web3.version.network\n// or async\nweb3.version.getNetwork(callback(error, result){ ... })", 
            "title": "web3.version.network"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_2", 
            "text": "String  - The network protocol version.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_3", 
            "text": "var   version   =   web3 . version . network ;  console . log ( version );   // 54", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3versionethereum", 
            "text": "web3.version.ethereum\n// or async\nweb3.version.getEthereum(callback(error, result){ ... })", 
            "title": "web3.version.ethereum"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_3", 
            "text": "String  - The ethereum protocol version.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_4", 
            "text": "var   version   =   web3 . version . ethereum ;  console . log ( version );   // 60", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3versionwhisper", 
            "text": "web3.version.whisper\n// or async\nweb3.version.getWhisper(callback(error, result){ ... })", 
            "title": "web3.version.whisper"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_4", 
            "text": "String  - The whisper protocol version.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_5", 
            "text": "var   version   =   web3 . version . whisper ;  console . log ( version );   // 20", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3isconnected", 
            "text": "web3.isConnected()  Should be called to check if a connection to a node exists", 
            "title": "web3.isConnected"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_5", 
            "text": "Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_6", 
            "text": "if ( ! web3 . isConnected ())   { \n\n    // show some dialog to ask the user to start a node  }   else   { \n\n    // start web3 filters, calls, etc  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3setprovider", 
            "text": "web3.setProvider(provider)  Should be called to set provider.", 
            "title": "web3.setProvider"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_6", 
            "text": "undefined", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_7", 
            "text": "web3 . setProvider ( new   web3 . providers . HttpProvider ( http://localhost:8545 ));   // 8080 for cpp/AZ, 8545 for go/mist", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3currentprovider", 
            "text": "web3.currentProvider  Will contain the current provider, if one is set. This can be used to check if mist etc. has set already a provider.", 
            "title": "web3.currentProvider"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_7", 
            "text": "Object  - The provider set or  null ;", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_8", 
            "text": "// Check if mist etc. already set a provider  if ( ! web3 . currentProvider ) \n     web3 . setProvider ( new   web3 . providers . HttpProvider ( http://localhost:8545 ));", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3reset", 
            "text": "web3.reset(keepIsSyncing)  Should be called to reset state of web3. Resets everything except manager. Uninstalls all filters. Stops polling.", 
            "title": "web3.reset"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_2", 
            "text": "Boolean  - If  true  it will uninstall all filters, but will keep the  web3.eth.isSyncing()  polls", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_8", 
            "text": "undefined", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_9", 
            "text": "web3 . reset ();", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3sha3", 
            "text": "web3.sha3(string [, options])", 
            "title": "web3.sha3"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_3", 
            "text": "String  - The string to hash using the Keccak-256 SHA3 algorithm  Object  - (optional) Set  encoding  to  hex  if the string to hash is encoded in hex. A leading  0x  will be automatically ignored.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_9", 
            "text": "String  - The Keccak-256 SHA3 of the given data.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_10", 
            "text": "var   hash   =   web3 . sha3 ( Some string to be hashed );  console . log ( hash );   //  0xed973b234cf2238052c9ac87072c71bcf33abc1bbd721018e0cca448ef79b379  var   hashOfHash   =   web3 . sha3 ( hash ,   { encoding :   hex });  console . log ( hashOfHash );   //  0x85dd39c91a64167ba20732b228251e67caed1462d4bcf036af88dc6856d0fdcc", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3tohex", 
            "text": "web3.toHex(mixed);  Converts any value into HEX.", 
            "title": "web3.toHex"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_4", 
            "text": "String|Number|Object|Array|BigNumber  - The value to parse to HEX. If its an object or array it will be  JSON.stringify  first. If its a BigNumber it will make it the HEX value of a number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_10", 
            "text": "String  - The hex string of  mixed .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_11", 
            "text": "var   str   =   web3 . toHex ({ test :   test });  console . log ( str );   //  0x7b2274657374223a2274657374227d", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3toascii", 
            "text": "web3.toAscii(hexString);  Converts a HEX string into a ASCII string.", 
            "title": "web3.toAscii"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_5", 
            "text": "String  - A HEX string to be converted to ascii.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_11", 
            "text": "String  - An ASCII string made from the given  hexString .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_12", 
            "text": "var   str   =   web3 . toAscii ( 0x657468657265756d000000000000000000000000000000000000000000000000 );  console . log ( str );   //  ethereum", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3fromascii", 
            "text": "web3.fromAscii(string [, padding]);  Converts any ASCII string to a HEX string.", 
            "title": "web3.fromAscii"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_6", 
            "text": "String  - An ASCII string to be converted to HEX.  Number  - (optional) The number of bytes the returned HEX string should have.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_12", 
            "text": "String  - The converted HEX string.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_13", 
            "text": "var   str   =   web3 . fromAscii ( ethereum );  console . log ( str );   //  0x657468657265756d  var   str2   =   web3 . fromAscii ( ethereum ,   32 );  console . log ( str2 );   //  0x657468657265756d000000000000000000000000000000000000000000000000", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3todecimal", 
            "text": "web3.toDecimal(hexString);  Converts a HEX string to its number representation.", 
            "title": "web3.toDecimal"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_7", 
            "text": "String  - An HEX string to be converted to a number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_13", 
            "text": "Number  - The number representing the data  hexString .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_14", 
            "text": "var   number   =   web3 . toDecimal ( 0x15 );  console . log ( number );   // 21", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3fromdecimal", 
            "text": "web3.fromDecimal(number);  Converts a number or number string to its HEX representation.", 
            "title": "web3.fromDecimal"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_8", 
            "text": "Number|String  - A number to be converted to a HEX string.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_14", 
            "text": "String  - The HEX string representing of the given  number .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_15", 
            "text": "var   value   =   web3 . fromDecimal ( 21 );  console . log ( value );   //  0x15", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3fromwei", 
            "text": "web3.fromWei(number, unit)  Converts a number of wei into the following ethereum units:   kwei / ada  mwei / babbage  gwei / shannon  szabo  finney  ether  kether / grand / einstein  mether  gether  tether", 
            "title": "web3.fromWei"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_9", 
            "text": "Number|String|BigNumber  - A number or BigNumber instance.  String  - One of the above ether units.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_15", 
            "text": "String|BigNumber  - Either a number string, or a BigNumber instance, depending on the given  number  parameter.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_16", 
            "text": "var   value   =   web3 . fromWei ( 21000000000000 ,   finney );  console . log ( value );   //  0.021", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3towei", 
            "text": "web3.toWei(number, unit)  Converts an ethereum unit into wei. Possible units are:   kwei / ada  mwei / babbage  gwei / shannon  szabo  finney  ether  kether / grand / einstein  mether  gether  tether", 
            "title": "web3.toWei"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_10", 
            "text": "Number|String|BigNumber  - A number or BigNumber instance.  String  - One of the above ether units.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_16", 
            "text": "String|BigNumber  - Either a number string, or a BigNumber instance, depending on the given  number  parameter.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_17", 
            "text": "var   value   =   web3 . toWei ( 1 ,   ether );  console . log ( value );   //  1000000000000000000", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3tobignumber", 
            "text": "web3.toBigNumber(numberOrHexString);  Converts a given number into a BigNumber instance.  See the  note on BigNumber .", 
            "title": "web3.toBigNumber"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_11", 
            "text": "Number|String  - A number, number string or HEX string of a number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_17", 
            "text": "BigNumber  - A BigNumber instance representing the given value.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_18", 
            "text": "var   value   =   web3 . toBigNumber ( 200000000000000000000001 );  console . log ( value );   // instanceOf BigNumber  console . log ( value . toNumber ());   // 2.0000000000000002e+23  console . log ( value . toString ( 10 ));   //  200000000000000000000001", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3isaddress", 
            "text": "web3.isAddress(HexString);  Checks if the given string is an address.", 
            "title": "web3.isAddress"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_12", 
            "text": "String  - An HEX string.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_18", 
            "text": "Boolean  -  false  if it's not on a valid address format. Returns  true  if it's an all lowercase or all uppercase valid address. If it's a mixed case address, it checks using  web3.isChecksumAddress() .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_19", 
            "text": "var   isAddress   =   web3 . isAddress ( 0x8888f1f195afa192cfee860698584c030f4c9db1 );  console . log ( isAddress );   // true", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3net", 
            "text": "", 
            "title": "web3.net"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3netlistening", 
            "text": "web3.net.listening\n// or async\nweb3.net.getListening(callback(error, result){ ... })  This property is read only and says whether the node is actively listening for network connections or not.", 
            "title": "web3.net.listening"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_19", 
            "text": "Boolean  -  true  if the client is actively listening for network connections, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_20", 
            "text": "var   listening   =   web3 . net . listening ;  console . log ( listening );   // true of false", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3netpeercount", 
            "text": "web3.net.peerCount\n// or async\nweb3.net.getPeerCount(callback(error, result){ ... })  This property is read only and returns the number of connected peers.", 
            "title": "web3.net.peerCount"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_20", 
            "text": "Number  - The number of peers currently connected to the client.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_21", 
            "text": "var   peerCount   =   web3 . net . peerCount ;  console . log ( peerCount );   // 4", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3eth", 
            "text": "Contains the ethereum blockchain related methods.", 
            "title": "web3.eth"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_22", 
            "text": "var   eth   =   web3 . eth ;", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethdefaultaccount", 
            "text": "web3.eth.defaultAccount  This default address is used for the following methods (optionally you can overwrite it by specifying the  from  property):   web3.eth.sendTransaction()  web3.eth.call()", 
            "title": "web3.eth.defaultAccount"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#values", 
            "text": "String , 20 Bytes - Any address you own, or where you have the private key for.  Default is   undefined .", 
            "title": "Values"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_21", 
            "text": "String , 20 Bytes - The currently set default address.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_23", 
            "text": "var   defaultAccount   =   web3 . eth . defaultAccount ;  console . log ( defaultAccount );   //   // set the default account  web3 . eth . defaultAccount   =   0x8888f1f195afa192cfee860698584c030f4c9db1 ;", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethdefaultblock", 
            "text": "web3.eth.defaultBlock  This default block is used for the following methods (optionally you can override it by passing the defaultBlock parameter):   web3.eth.getBalance()  web3.eth.getCode()  web3.eth.getTransactionCount()  web3.eth.getStorageAt()  web3.eth.call()  contract.myMethod.call()  contract.myMethod.estimateGas()", 
            "title": "web3.eth.defaultBlock"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#values_1", 
            "text": "Default block parameters can be one of the following:   Number  - a block number  String  -  \"earliest\" , the genisis block  String  -  \"latest\" , the latest block (current head of the blockchain)  String  -  \"pending\" , the currently mined block (including pending transactions)   Default is   latest", 
            "title": "Values"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_22", 
            "text": "Number|String  - The default block number to use when querying a state.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_24", 
            "text": "var   defaultBlock   =   web3 . eth . defaultBlock ;  console . log ( defaultBlock );   //  latest  // set the default block  web3 . eth . defaultBlock   =   231 ;", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethsyncing", 
            "text": "web3.eth.syncing\n// or async\nweb3.eth.getSyncing(callback(error, result){ ... })  This property is read only and returns the either a sync object, when the node is syncing or  false .", 
            "title": "web3.eth.syncing"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_23", 
            "text": "Object|Boolean  - A sync object as follows, when the node is currently syncing or  false :\n   -  startingBlock :  Number  - The block number where the sync started.\n   -  currentBlock :  Number  - The block number where at which block the node currently synced to already.\n   -  highestBlock :  Number  - The estimated block number to sync to.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_25", 
            "text": "var   sync   =   web3 . eth . syncing ;  console . log ( sync );  /*  {     startingBlock: 300,     currentBlock: 312,     highestBlock: 512  }  */", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethissyncing", 
            "text": "web3.eth.isSyncing(callback);  This convenience function calls the  callback  everytime a sync starts, updates and stops.", 
            "title": "web3.eth.isSyncing"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_24", 
            "text": "Object  - a isSyncing object with the following methods:   syncing.addCallback() : Adds another callback, which will be called when the node starts or stops syncing.  syncing.stopWatching() : Stops the syncing callbacks.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#callback-return-value", 
            "text": "Boolean  - The callback will be fired with  true  when the syncing starts and with  false  when it stopped.  Object  - While syncing it will return the syncing object:  startingBlock :  Number  - The block number where the sync started.  currentBlock :  Number  - The block number where at which block the node currently synced to already.  highestBlock :  Number  - The estimated block number to sync to.", 
            "title": "Callback return value"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_26", 
            "text": "web3 . eth . isSyncing ( function ( error ,   sync ){ \n     if ( ! error )   { \n         // stop all app activity \n         if ( sync   ===   true )   { \n            // we use `true`, so it stops all filters, but not the web3.eth.syncing polling \n            web3 . reset ( true ); \n\n         // show sync info \n         }   else   if ( sync )   { \n            console . log ( sync . currentBlock ); \n\n         // re-gain app operation \n         }   else   { \n             // run your app init function... \n         } \n     }  });", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethcoinbase", 
            "text": "web3.eth.coinbase\n// or async\nweb3.eth.getCoinbase(callback(error, result){ ... })  This property is read only and returns the coinbase address where the mining rewards go to.", 
            "title": "web3.eth.coinbase"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_25", 
            "text": "String  - The coinbase address of the client.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_27", 
            "text": "var   coinbase   =   web3 . eth . coinbase ;  console . log ( coinbase );   //  0x407d73d8a49eeb85d32cf465507dd71d507100c1", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethmining", 
            "text": "web3.eth.mining\n// or async\nweb3.eth.getMining(callback(error, result){ ... })  This property is read only and says whether the node is mining or not.", 
            "title": "web3.eth.mining"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_26", 
            "text": "Boolean  -  true  if the client is mining, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_28", 
            "text": "var   mining   =   web3 . eth . mining ;  console . log ( mining );   // true or false", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethhashrate", 
            "text": "web3.eth.hashrate\n// or async\nweb3.eth.getHashrate(callback(error, result){ ... })  This property is read only and returns the number of hashes per second that the node is mining with.", 
            "title": "web3.eth.hashrate"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_27", 
            "text": "Number  - number of hashes per second.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_29", 
            "text": "var   hashrate   =   web3 . eth . hashrate ;  console . log ( hashrate );   // 493736", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgasprice", 
            "text": "web3.eth.gasPrice\n// or async\nweb3.eth.getGasPrice(callback(error, result){ ... })  This property is read only and returns the current gas price.\nThe gas price is determined by the x latest blocks median gas price.", 
            "title": "web3.eth.gasPrice"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_28", 
            "text": "BigNumber  - A BigNumber instance of the current gas price in wei.  See the  note on BigNumber .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_30", 
            "text": "var   gasPrice   =   web3 . eth . gasPrice ;  console . log ( gasPrice . toString ( 10 ));   //  10000000000000", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethaccounts", 
            "text": "web3.eth.accounts\n// or async\nweb3.eth.getAccounts(callback(error, result){ ... })  This property is read only and returns a list of accounts the node controls.", 
            "title": "web3.eth.accounts"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_29", 
            "text": "Array  - An array of addresses controlled by client.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_31", 
            "text": "var   accounts   =   web3 . eth . accounts ;  console . log ( accounts );   // [ 0x407d73d8a49eeb85d32cf465507dd71d507100c1 ]", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethblocknumber", 
            "text": "web3.eth.blockNumber\n// or async\nweb3.eth.getBlockNumber(callback(error, result){ ... })  This property is read only and returns the current block number.", 
            "title": "web3.eth.blockNumber"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_30", 
            "text": "Number  - The number of the most recent block.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_32", 
            "text": "var   number   =   web3 . eth . blockNumber ;  console . log ( number );   // 2744", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethregister", 
            "text": "web3.eth.register(addressHexString [, callback])  (Not Implemented yet)\nRegisters the given address to be included in  web3.eth.accounts . This allows non-private-key owned accounts to be associated as an owned account (e.g., contract wallets).", 
            "title": "web3.eth.register"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_13", 
            "text": "String  - The address to register  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_31", 
            "text": "?", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_33", 
            "text": "web3 . eth . register ( 0x407d73d8a49eeb85d32cf465507dd71d507100ca )", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethunregister", 
            "text": "web3.eth.unRegister(addressHexString [, callback])  (Not Implemented yet)\nUnregisters a given address.", 
            "title": "web3.eth.unRegister"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_14", 
            "text": "String  - The address to unregister.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_32", 
            "text": "?", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_34", 
            "text": "web3 . eth . unregister ( 0x407d73d8a49eeb85d32cf465507dd71d507100ca )", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetbalance", 
            "text": "web3.eth.getBalance(addressHexString [, defaultBlock] [, callback])  Get the balance of an address at a given block.", 
            "title": "web3.eth.getBalance"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_15", 
            "text": "String  - The address to get the balance of.  Number|String  - (optional) If you pass this parameter it will not use the default block set with  web3.eth.defaultBlock .  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_33", 
            "text": "String  - A BigNumber instance of the current balance for the given address in wei.  See the  note on BigNumber .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_35", 
            "text": "var   balance   =   web3 . eth . getBalance ( 0x407d73d8a49eeb85d32cf465507dd71d507100c1 );  console . log ( balance );   // instanceof BigNumber  console . log ( balance . toString ( 10 ));   //  1000000000000  console . log ( balance . toNumber ());   // 1000000000000", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetstorageat", 
            "text": "web3.eth.getStorageAt(addressHexString, position [, defaultBlock] [, callback])  Get the storage at a specific position of an address.", 
            "title": "web3.eth.getStorageAt"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_16", 
            "text": "String  - The address to get the storage from.  Number  - The index position of the storage.  Number|String  - (optional) If you pass this parameter it will not use the default block set with  web3.eth.defaultBlock .  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_34", 
            "text": "String  - The value in storage at the given position.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_36", 
            "text": "var   state   =   web3 . eth . getStorageAt ( 0x407d73d8a49eeb85d32cf465507dd71d507100c1 ,   0 );  console . log ( state );   //  0x03", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetcode", 
            "text": "web3.eth.getCode(addressHexString [, defaultBlock] [, callback])  Get the code at a specific address.", 
            "title": "web3.eth.getCode"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_17", 
            "text": "String  - The address to get the code from.  Number|String  - (optional) If you pass this parameter it will not use the default block set with  web3.eth.defaultBlock .  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_35", 
            "text": "String  - The data at given address  addressHexString .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_37", 
            "text": "var   code   =   web3 . eth . getCode ( 0xd5677cf67b5aa051bb40496e68ad359eb97cfbf8 );  console . log ( code );   //  0x600160008035811a818181146012578301005b601b6001356025565b8060005260206000f25b600060078202905091905056", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetblock", 
            "text": "web3.eth.getBlock(blockHashOrBlockNumber [, returnTransactionObjects] [, callback])  Returns a block matching the block number or block hash.", 
            "title": "web3.eth.getBlock"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_18", 
            "text": "String|Number  - The block number or hash. Or the string  \"earliest\" ,  \"latest\"  or  \"pending\"  as in the  default block parameter .  Boolean  - (optional, default  false ) If  true , the returned block will contain all transactions as objects, if  false  it will only contains the transaction hashes.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_36", 
            "text": "Object  - The block object:   number :  Number  - the block number.  null  when its pending block.  hash :  String , 32 Bytes - hash of the block.  null  when its pending block.  parentHash :  String , 32 Bytes - hash of the parent block.  nonce :  String , 8 Bytes - hash of the generated proof-of-work.  null  when its pending block.  sha3Uncles :  String , 32 Bytes - SHA3 of the uncles data in the block.  logsBloom :  String , 256 Bytes - the bloom filter for the logs of the block.  null  when its pending block.  transactionsRoot :  String , 32 Bytes - the root of the transaction trie of the block  stateRoot :  String , 32 Bytes - the root of the final state trie of the block.  miner :  String , 20 Bytes - the address of the beneficiary to whom the mining rewards were given.  difficulty :  BigNumber  - integer of the difficulty for this block.  totalDifficulty :  BigNumber  - integer of the total difficulty of the chain until this block.  extraData :  String  - the \"extra data\" field of this block.  size :  Number  - integer the size of this block in bytes.  gasLimit :  Number  - the maximum gas allowed in this block.  gasUsed :  Number  - the total used gas by all transactions in this block.  timestamp :  Number  - the unix timestamp for when the block was collated.  transactions :  Array  - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter.  uncles :  Array  - Array of uncle hashes.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_38", 
            "text": "var   info   =   web3 . eth . getBlock ( 3150 );  console . log ( info );  /*  {     number : 3,     hash :  0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46 ,     parentHash :  0x2302e1c0b972d00932deb5dab9eb2982f570597d9d42504c05d9c2147eaf9c88 ,     nonce :  0xfb6e1a62d119228b ,     sha3Uncles :  0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 ,     logsBloom :  0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 ,     transactionsRoot :  0x3a1b03875115b79539e5bd33fb00d8f7b7cd61929d5a3c574f507b8acf415bee ,     stateRoot :  0xf1133199d44695dfa8fd1bcfe424d82854b5cebef75bddd7e40ea94cda515bcb ,     miner :  0x8888f1f195afa192cfee860698584c030f4c9db1 ,     difficulty : BigNumber,     totalDifficulty : BigNumber,     size : 616,     extraData :  0x ,     gasLimit : 3141592,     gasUsed : 21662,     timestamp : 1429287689,     transactions : [       0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b    ],     uncles : []  }  */", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetblocktransactioncount", 
            "text": "web3.eth.getBlockTransactionCount(hashStringOrBlockNumber [, callback])  Returns the number of transaction in a given block.", 
            "title": "web3.eth.getBlockTransactionCount"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_19", 
            "text": "String|Number  - The block number or hash. Or the string  \"earliest\" ,  \"latest\"  or  \"pending\"  as in the  default block parameter .  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_37", 
            "text": "Number  - The number of transactions in the given block.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_39", 
            "text": "var   number   =   web3 . eth . getBlockTransactionCount ( 0x407d73d8a49eeb85d32cf465507dd71d507100c1 );  console . log ( number );   // 1", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetuncle", 
            "text": "web3.eth.getUncle(blockHashStringOrNumber, uncleNumber [, returnTransactionObjects] [, callback])  Returns a blocks uncle by a given uncle index position.", 
            "title": "web3.eth.getUncle"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_20", 
            "text": "String|Number  - The block number or hash. Or the string  \"earliest\" ,  \"latest\"  or  \"pending\"  as in the  default block parameter .  Number  - The index position of the uncle.  Boolean  - (optional, default  false ) If  true , the returned block will contain all transactions as objects, if  false  it will only contains the transaction hashes.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_38", 
            "text": "Object  - the returned uncle. For a return value see  web3.eth.getBlock() .  Note : An uncle doesn't contain individual transactions.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_40", 
            "text": "var   uncle   =   web3 . eth . getUncle ( 500 ,   0 );  console . log ( uncle );   // see web3.eth.getBlock", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgettransaction", 
            "text": "web3.eth.getTransaction(transactionHash [, callback])  Returns a transaction matching the given transaction hash.", 
            "title": "web3.eth.getTransaction"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_21", 
            "text": "String  - The transaction hash.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_39", 
            "text": "Object  - A transaction object its hash  transactionHash :   hash :  String , 32 Bytes - hash of the transaction.  nonce :  Number  - the number of transactions made by the sender prior to this one.  blockHash :  String , 32 Bytes - hash of the block where this transaction was in.  null  when its pending.  blockNumber :  Number  - block number where this transaction was in.  null  when its pending.  transactionIndex :  Number  - integer of the transactions index position in the block.  null  when its pending.  from :  String , 20 Bytes - address of the sender.  to :  String , 20 Bytes - address of the receiver.  null  when its a contract creation transaction.  value :  BigNumber  - value transferred in Wei.  gasPrice :  BigNumber  - gas price provided by the sender in Wei.  gas :  Number  - gas provided by the sender.  input :  String  - the data sent along with the transaction.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_41", 
            "text": "var   transaction   =   web3 . eth . getTransaction ( 0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b );  console . log ( transaction );  /*  {     hash :  0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b ,     nonce : 2,     blockHash :  0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46 ,     blockNumber : 3,     transactionIndex : 0,     from :  0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b ,     to :  0x6295ee1b4f6dd65047762f924ecd367c17eabf8f ,     value : BigNumber,     gas : 314159,     gasPrice : BigNumber,     input :  0x57cb2fc4  }  */", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgettransactionfromblock", 
            "text": "getTransactionFromBlock(hashStringOrNumber, indexNumber [, callback])  Returns a transaction based on a block hash or number and the transactions index position.", 
            "title": "web3.eth.getTransactionFromBlock"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_22", 
            "text": "String  - A block number or hash. Or the string  \"earliest\" ,  \"latest\"  or  \"pending\"  as in the  default block parameter .  Number  - The transactions index position.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_40", 
            "text": "Object  - A transaction object, see  web3.eth.getTransaction :", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_42", 
            "text": "var   transaction   =   web3 . eth . getTransactionFromBlock ( 0x4534534534 ,   2 );  console . log ( transaction );   // see web3.eth.getTransaction", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgettransactionreceipt", 
            "text": "web3.eth.getTransactionReceipt(hashString [, callback])  Returns the receipt of a transaction by transaction hash.  Note  That the receipt is not available for pending transactions.", 
            "title": "web3.eth.getTransactionReceipt"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_23", 
            "text": "String  - The transaction hash.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_41", 
            "text": "Object  - A transaction receipt object, or  null  when no receipt was found:   blockHash :  String , 32 Bytes - hash of the block where this transaction was in.  blockNumber :  Number  - block number where this transaction was in.  transactionHash :  String , 32 Bytes - hash of the transaction.  transactionIndex :  Number  - integer of the transactions index position in the block.  from :  String , 20 Bytes - address of the sender.  to :  String , 20 Bytes - address of the receiver.  null  when its a contract creation transaction.  cumulativeGasUsed :  Number  - The total amount of gas used when this transaction was executed in the block.  gasUsed :  Number  -  The amount of gas used by this specific transaction alone.  contractAddress :  String  - 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise  null .  logs :   Array  - Array of log objects, which this transaction generated.  status :   Number  - 0 indicates transaction failure , 1 indicates transaction succeeded.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_43", 
            "text": "var   receipt   =   web3 . eth . getTransactionReceipt ( 0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b );  console . log ( receipt );  { \n   transactionHash :   0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b , \n   transactionIndex :   0 , \n   blockHash :   0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46 , \n   blockNumber :   3 , \n   contractAddress :   0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b , \n   cumulativeGasUsed :   314159 , \n   gasUsed :   30234 , \n   logs :   [{ \n          // logs as returned by getFilterLogs, etc. \n      },   ...], \n   status :   0x1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgettransactioncount", 
            "text": "web3.eth.getTransactionCount(addressHexString [, defaultBlock] [, callback])  Get the numbers of transactions sent from this address.", 
            "title": "web3.eth.getTransactionCount"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_24", 
            "text": "String  - The address to get the numbers of transactions from.  Number|String  - (optional) If you pass this parameter it will not use the default block set with  web3.eth.defaultBlock .  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_42", 
            "text": "Number  - The number of transactions sent from the given address.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_44", 
            "text": "var   number   =   web3 . eth . getTransactionCount ( 0x407d73d8a49eeb85d32cf465507dd71d507100c1 );  console . log ( number );   // 1", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethsendtransaction", 
            "text": "web3.eth.sendTransaction(transactionObject [, callback])  Sends a transaction to the network.", 
            "title": "web3.eth.sendTransaction"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_25", 
            "text": "Object  - The transaction object to send:  from :  String  - The address for the sending account. Uses the  web3.eth.defaultAccount  property, if not specified.  to :  String  - (optional) The destination address of the message, left undefined for a contract-creation transaction.  value :  Number|String|BigNumber  - (optional) The value transferred for the transaction in Wei, also the endowment if it's a contract-creation transaction.  gas :  Number|String|BigNumber  - (optional, default: To-Be-Determined) The amount of gas to use for the transaction (unused gas is refunded).  gasPrice :  Number|String|BigNumber  - (optional, default: To-Be-Determined) The price of gas for this transaction in wei, defaults to the mean network gas price.  data :  String  - (optional) Either a  byte string  containing the associated data of the message, or in the case of a contract-creation transaction, the initialisation code.  nonce :  Number   - (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_43", 
            "text": "String  - The 32 Bytes transaction hash as HEX string.  If the transaction was a contract creation use  web3.eth.getTransactionReceipt()  to get the contract address, after the transaction was mined.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_45", 
            "text": "// compiled solidity source code using https://chriseth.github.io/cpp-ethereum/  var   code   =   603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3 ;  web3 . eth . sendTransaction ({ data :   code },   function ( err ,   transactionHash )   { \n   if   ( ! err ) \n     console . log ( transactionHash );   //  0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385  });", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethsendrawtransaction", 
            "text": "web3.eth.sendRawTransaction(signedTransactionData [, callback])  Sends an already signed transaction. For example can be signed using: https://github.com/SilentCicero/ethereumjs-accounts", 
            "title": "web3.eth.sendRawTransaction"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_26", 
            "text": "String  - Signed transaction data in HEX format  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_44", 
            "text": "String  - The 32 Bytes transaction hash as HEX string.  If the transaction was a contract creation use  web3.eth.getTransactionReceipt()  to get the contract address, after the transaction was mined.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_46", 
            "text": "var   Tx   =   require ( ethereumjs-tx );  var   privateKey   =   new   Buffer ( e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109 ,   hex )  var   rawTx   =   { \n   nonce :   0x00 , \n   gasPrice :   0x09184e72a000 , \n   gasLimit :   0x2710 , \n   to :   0x0000000000000000000000000000000000000000 , \n   value :   0x00 , \n   data :   0x7f7465737432000000000000000000000000000000000000000000000000000000600057  }  var   tx   =   new   Tx ( rawTx );  tx . sign ( privateKey );  var   serializedTx   =   tx . serialize ();  //console.log(serializedTx.toString( hex ));  //f889808609184e72a00082271094000000000000000000000000000000000000000080a47f74657374320000000000000000000000000000000000000000000000000000006000571ca08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f  web3 . eth . sendRawTransaction ( 0x   +   serializedTx . toString ( hex ),   function ( err ,   hash )   { \n   if   ( ! err ) \n     console . log ( hash );   //  0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385  });", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethsign", 
            "text": "web3.eth.sign(address, dataToSign, [, callback])  Signs data from a specific account. This account needs to be unlocked.", 
            "title": "web3.eth.sign"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_27", 
            "text": "String  - Address to sign with.  String  - Data to sign.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_45", 
            "text": "String  - The signed data.  After the hex prefix, characters correspond to ECDSA values like this: r = signature[0:64]\ns = signature[64:128]\nv = signature[128:130]  Note that if you are using  ecrecover ,  v  will be either  \"00\"  or  \"01\" . As a result, in order to use this value, you will have to parse it to an integer and then add  27 . This will result in either a  27  or a  28 .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_47", 
            "text": "var   result   =   web3 . eth . sign ( 0x135a7de83802408321b74c322f8558db1679ac20 , \n     0x9dd2c369a187b4e6b9c402f030e50743e619301ea62aa4c0737d4ef7e10a3d49 );   // second argument is web3.sha3( xyz )  console . log ( result );   //  0x30755ed65396facf86c53e6217c52b4daebe72aa4941d89635409de4c9c7f9466d4e9aaec7977f05e923889b33c0d0dd27d7226b6e6f56ce737465c5cfd04be400", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethcall", 
            "text": "web3.eth.call(callObject [, defaultBlock] [, callback])  Executes a message call transaction, which is directly executed in the VM of the node, but never mined into the blockchain.", 
            "title": "web3.eth.call"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_28", 
            "text": "Object  - A transaction object see  web3.eth.sendTransaction , with the difference that for calls the  from  property is optional as well.  Number|String  - (optional) If you pass this parameter it will not use the default block set with  web3.eth.defaultBlock .  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_46", 
            "text": "String  - The returned data of the call, e.g. a codes functions return value.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_48", 
            "text": "var   result   =   web3 . eth . call ({ \n     to :   0xc4abd0339eb8d57087278718986382264244252f , \n     data :   0xc6888fa10000000000000000000000000000000000000000000000000000000000000003  });  console . log ( result );   //  0x0000000000000000000000000000000000000000000000000000000000000015", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethestimategas", 
            "text": "web3.eth.estimateGas(callObject [, callback])  Executes a message call or transaction, which is directly executed in the VM of the node, but never mined into the blockchain and returns the amount of the gas used.", 
            "title": "web3.eth.estimateGas"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_29", 
            "text": "See  web3.eth.sendTransaction , except that all properties are optional.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_47", 
            "text": "Number  - the used gas for the simulated call/transaction.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_49", 
            "text": "var   result   =   web3 . eth . estimateGas ({ \n     to :   0xc4abd0339eb8d57087278718986382264244252f , \n     data :   0xc6888fa10000000000000000000000000000000000000000000000000000000000000003  });  console . log ( result );   //  0x0000000000000000000000000000000000000000000000000000000000000015", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethfilter", 
            "text": "// can be  latest  or  pending  var   filter   =   web3 . eth . filter ( filterString );  // OR object are log filter options  var   filter   =   web3 . eth . filter ( options );  // watch for changes  filter . watch ( function ( error ,   result ){ \n   if   ( ! error ) \n     console . log ( result );  });  // Additionally you can start watching right away, by passing a callback:  web3 . eth . filter ( options ,   function ( error ,   result ){ \n   if   ( ! error ) \n     console . log ( result );  });", 
            "title": "web3.eth.filter"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_30", 
            "text": "String|Object  - The string  \"latest\"  or  \"pending\"  to watch for changes in the latest block or pending transactions respectively. Or a filter options object as follows:  fromBlock :  Number|String  - The number of the earliest block ( latest  may be given to mean the most recent and  pending  currently mining, block). By default  latest .  toBlock :  Number|String  - The number of the latest block ( latest  may be given to mean the most recent and  pending  currently mining, block). By default  latest .  address :  String  - An address or a list of addresses to only get logs from particular account(s).  topics :  Array of Strings  - An array of values which must each appear in the log entries. The order is important, if you want to leave topics out use  null , e.g.  [null, '0x00...'] . You can also pass another array for each topic with options for that topic e.g.  [null, ['option1', 'option2']]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_48", 
            "text": "Object  - A filter object with the following methods:   filter.get(callback) : Returns all of the log entries that fit the filter.  filter.watch(callback) : Watches for state changes that fit the filter and calls the callback. See  this note  for details.  filter.stopWatching() : Stops the watch and uninstalls the filter in the node. Should always be called once it is done.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#watch-callback-return-value", 
            "text": "String  - When using the  \"latest\"  parameter, it returns the block hash of the last incoming block.  String  - When using the  \"pending\"  parameter, it returns a transaction hash of the most recent pending transaction.  Object  - When using manual filter options, it returns a log object as follows:  logIndex :  Number  - integer of the log index position in the block.  null  when its pending log.  transactionIndex :  Number  - integer of the transactions index position log was created from.  null  when its pending log.  transactionHash :  String , 32 Bytes - hash of the transactions this log was created from.  null  when its pending log.  blockHash :  String , 32 Bytes - hash of the block where this log was in.  null  when its pending.  null  when its pending log.  blockNumber :  Number  - the block number where this log was in.  null  when its pending.  null  when its pending log.  address :  String , 32 Bytes - address from which this log originated.  data :  String  - contains one or more 32 Bytes non-indexed arguments of the log.  topics :  Array of Strings  - Array of 0 to 4 32 Bytes  DATA  of indexed log arguments. (In  solidity : The first topic is the  hash  of the signature of the event (e.g.  Deposit(address,bytes32,uint256) ), except if you declared the event with the  anonymous  specifier.)     Note  For event filter return values see  Contract Events", 
            "title": "Watch callback return value"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_50", 
            "text": "var   filter   =   web3 . eth . filter ( pending );  filter . watch ( function   ( error ,   log )   { \n   console . log ( log );   //  { address : 0x0000000000000000000000000000000000000000 ,  data : 0x0000000000000000000000000000000000000000000000000000000000000000 , ...}  });  // get all past logs again.  var   myResults   =   filter . get ( function ( error ,   logs ){   ...   });  ...  // stops and uninstalls the filter  filter . stopWatching ();", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethcontract", 
            "text": "web3.eth.contract(abiArray)  Creates a contract object for a solidity contract, which can be used to initiate contracts on an address.\nYou can read more about events  here .", 
            "title": "web3.eth.contract"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_31", 
            "text": "Array  - ABI array with descriptions of functions and events of the contract.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_49", 
            "text": "Object  - A contract object, which can be initiated as follows:  var   MyContract   =   web3 . eth . contract ( abiArray );  // instantiate by address  var   contractInstance   =   MyContract . at ( address );  // deploy new contract  var   contractInstance   =   MyContract . new ([ constructorParam1 ]   [,   constructorParam2 ],   { data :   0x12345... ,   from :   myAccount ,   gas :   1000000 });  // Get the data to deploy the contract manually  var   contractData   =   MyContract . new . getData ([ constructorParam1 ]   [,   constructorParam2 ],   { data :   0x12345... });  // contractData =  0x12345643213456000000000023434234   And then you can either initiate an existing contract on an address,\nor deploy the contract using the compiled byte code:  // Instantiate from an existing address:  var   myContractInstance   =   MyContract . at ( myContractAddress );  // Or deploy a new contract:  // Deploy the contract asynchronous from Solidity file:  ...  const   fs   =   require ( fs );  const   solc   =   require ( solc )  let   source   =   fs . readFileSync ( nameContract.sol ,   utf8 );  let   compiledContract   =   solc . compile ( source ,   1 );  let   abi   =   compiledContract . contracts [ nameContract ]. interface ;  let   bytecode   =   compiledContract . contracts [ nameContract ]. bytecode ;  let   gasEstimate   =   web3 . eth . estimateGas ({ data :   bytecode });  let   MyContract   =   web3 . eth . contract ( JSON . parse ( abi ));  var   myContractReturned   =   MyContract . new ( param1 ,   param2 ,   { \n    from : mySenderAddress , \n    data : bytecode , \n    gas : gasEstimate },   function ( err ,   myContract ){ \n     if ( ! err )   { \n        // NOTE: The callback will fire twice! \n        // Once the contract has the transactionHash property set and once its deployed on an address. \n\n        // e.g. check tx hash on the first call (transaction send) \n        if ( ! myContract . address )   { \n            console . log ( myContract . transactionHash )   // The hash of the transaction, which deploys the contract \n\n        // check address on the second call (contract deployed) \n        }   else   { \n            console . log ( myContract . address )   // the contract address \n        } \n\n        // Note that the returned  myContractReturned  ===  myContract , \n        // so the returned  myContractReturned  object will also get the address set. \n     } \n   });  // Deploy contract syncronous: The address will be added as soon as the contract is mined.  // Additionally you can watch the transaction by using the  transactionHash  property  var   myContractInstance   =   MyContract . new ( param1 ,   param2 ,   { data :   myContractCode ,   gas :   300000 ,   from :   mySenderAddress });  myContractInstance . transactionHash   // The hash of the transaction, which created the contract  myContractInstance . address   // undefined at start, but will be auto-filled later", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_51", 
            "text": "// contract abi  var   abi   =   [{ \n      name :   myConstantMethod , \n      type :   function , \n      constant :   true , \n      inputs :   [{   name :   a ,   type :   string   }], \n      outputs :   [{ name :   d ,   type :   string   }]  },   { \n      name :   myStateChangingMethod , \n      type :   function , \n      constant :   false , \n      inputs :   [{   name :   a ,   type :   string   },   {   name :   b ,   type :   int   }], \n      outputs :   []  },   { \n      name :   myEvent , \n      type :   event , \n      inputs :   [{ name :   a ,   type :   int ,   indexed :   true },{ name :   b ,   type :   bool ,   indexed :   false }]  }];  // creation of contract object  var   MyContract   =   web3 . eth . contract ( abi );  // initiate contract for an address  var   myContractInstance   =   MyContract . at ( 0xc4abd0339eb8d57087278718986382264244252f );  // call constant function  var   result   =   myContractInstance . myConstantMethod ( myParam );  console . log ( result )   //  0x25434534534  // send a transaction to a function  myContractInstance . myStateChangingMethod ( someParam1 ,   23 ,   { value :   200 ,   gas :   2000 });  // short hand style  web3 . eth . contract ( abi ). at ( address ). myAwesomeMethod (...);  // create filter  var   filter   =   myContractInstance . myEvent ({ a :   5 },   function   ( error ,   result )   { \n   if   ( ! error ) \n     console . log ( result ); \n     /*      {          address:  0x8718986382264244252fc4abd0339eb8d5708727 ,          topics:  0x12345678901234567890123456789012 ,  0x0000000000000000000000000000000000000000000000000000000000000005 ,          data:  0x0000000000000000000000000000000000000000000000000000000000000001 ,          ...      }      */  });", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#contract-methods", 
            "text": "// Automatically determines the use of call or sendTransaction based on the method type  myContractInstance . myMethod ( param1   [,   param2 ,   ...]   [,   transactionObject ]   [,   defaultBlock ]   [,   callback ]);  // Explicitly calling this method  myContractInstance . myMethod . call ( param1   [,   param2 ,   ...]   [,   transactionObject ]   [,   defaultBlock ]   [,   callback ]);  // Explicitly sending a transaction to this method  myContractInstance . myMethod . sendTransaction ( param1   [,   param2 ,   ...]   [,   transactionObject ]   [,   callback ]);  // Get the call data, so you can call the contract through some other means  var   myCallData   =   myContractInstance . myMethod . getData ( param1   [,   param2 ,   ...]);  // myCallData =  0x45ff3ff6000000000004545345345345..   The contract object exposes the contract's methods, which can be called using parameters and a transaction object.", 
            "title": "Contract Methods"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_32", 
            "text": "String|Number|BigNumber  - (optional) Zero or more parameters of the function. If passing in a string, it must be formatted as a hex number, e.g. \"0xdeadbeef\" If you have already created BigNumber object, then you can just pass it too.  Object  - (optional) The (previous) last parameter can be a transaction object, see  web3.eth.sendTransaction  parameter 1 for more.  Note :  data  and  to  properties will not be taken into account.  Number|String  - (optional) If you pass this parameter it will not use the default block set with  web3.eth.defaultBlock .  Function  - (optional) If you pass a callback as the last parameter the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_50", 
            "text": "String  - If its a call the result data, if its a send transaction a created contract address, or the transaction hash, see  web3.eth.sendTransaction  for details.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_52", 
            "text": "// creation of contract object  var   MyContract   =   web3 . eth . contract ( abi );  // initiate contract for an address  var   myContractInstance   =   MyContract . at ( 0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9 );  var   result   =   myContractInstance . myConstantMethod ( myParam );  console . log ( result )   //  0x25434534534  myContractInstance . myStateChangingMethod ( someParam1 ,   23 ,   { value :   200 ,   gas :   2000 },   function ( err ,   result ){   ...   });", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#contract-events", 
            "text": "var   event   =   myContractInstance . MyEvent ({ valueA :   23 }   [,   additionalFilterObject ])  // watch for changes  event . watch ( function ( error ,   result ){ \n   if   ( ! error ) \n     console . log ( result );  });  // Or pass a callback to start watching immediately  var   event   =   myContractInstance . MyEvent ([{ valueA :   23 }]   [,   additionalFilterObject ]   ,   function ( error ,   result ){ \n   if   ( ! error ) \n     console . log ( result );  });   You can use events like  filters  and they have the same methods, but you pass different objects to create the event filter.", 
            "title": "Contract Events"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_33", 
            "text": "Object  - Indexed return values you want to filter the logs by, e.g.  {'valueA': 1, 'valueB': [myFirstAddress, mySecondAddress]} . By default all filter values are set to  null . It means, that they will match any event of given type sent from this contract.  Object  - Additional filter options, see  filters  parameter 1 for more. By default filterObject has field 'address' set to address of the contract. Also first topic is the signature of event.  Function  - (optional) If you pass a callback as the last parameter it will immediately start watching and you don't need to call  myEvent.watch(function(){}) . See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#callback-return", 
            "text": "Object  - An event object as follows:   address :  String , 32 Bytes - address from which this log originated.  args :  Object  - The arguments coming from the event.  blockHash :  String , 32 Bytes - hash of the block where this log was in.  null  when its pending.  blockNumber :  Number  - the block number where this log was in.  null  when its pending.  logIndex :  Number  - integer of the log index position in the block.  event :  String  - The event name.  removed :  bool  -  indicate if the transaction this event was created from was removed from the blockchain (due to orphaned block) or never get to it (due to rejected transaction).  transactionIndex :  Number  - integer of the transactions index position log was created from.  transactionHash :  String , 32 Bytes - hash of the transactions this log was created from.", 
            "title": "Callback return"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_53", 
            "text": "var   MyContract   =   web3 . eth . contract ( abi );  var   myContractInstance   =   MyContract . at ( 0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9 );  // watch for an event with {some:  args }  var   myEvent   =   myContractInstance . MyEvent ({ some :   args },   { fromBlock :   0 ,   toBlock :   latest });  myEvent . watch ( function ( error ,   result ){ \n    ...  });  // would get all past logs again.  var   myResults   =   myEvent . get ( function ( error ,   logs ){   ...   });  ...  // would stop and uninstall the filter  myEvent . stopWatching ();", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#contract-allevents", 
            "text": "var   events   =   myContractInstance . allEvents ([ additionalFilterObject ]);  // watch for changes  events . watch ( function ( error ,   event ){ \n   if   ( ! error ) \n     console . log ( event );  });  // Or pass a callback to start watching immediately  var   events   =   myContractInstance . allEvents ([ additionalFilterObject ,]   function ( error ,   log ){ \n   if   ( ! error ) \n     console . log ( log );  });   Will call the callback for all events which are created by this contract.", 
            "title": "Contract allEvents"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_34", 
            "text": "Object  - Additional filter options, see  filters  parameter 1 for more. By default filterObject has field 'address' set to address of the contract. This method sets the topic to the signature of event, and does not support additional topics.  Function  - (optional) If you pass a callback as the last parameter it will immediately start watching and you don't need to call  myEvent.watch(function(){}) . See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#callback-return_1", 
            "text": "Object  - See  Contract Events  for more.", 
            "title": "Callback return"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_54", 
            "text": "var   MyContract   =   web3 . eth . contract ( abi );  var   myContractInstance   =   MyContract . at ( 0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9 );  // watch for an event with {some:  args }  var   events   =   myContractInstance . allEvents ({ fromBlock :   0 ,   toBlock :   latest });  events . watch ( function ( error ,   result ){ \n    ...  });  // would get all past logs again.  events . get ( function ( error ,   logs ){   ...   });  ...  // would stop and uninstall the filter  events . stopWatching ();", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethgetcompilers", 
            "text": "", 
            "title": "web3.eth.getCompilers"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#compiling-features-being-deprecated-httpsgithubcomethereumeipsissues209", 
            "text": "web3.eth.getCompilers([callback])  Gets a list of available compilers.", 
            "title": "Compiling features being deprecated https://github.com/ethereum/EIPs/issues/209"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_35", 
            "text": "Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_51", 
            "text": "Array  - An array of strings of available compilers.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_55", 
            "text": "var   number   =   web3 . eth . getCompilers ();  console . log ( number );   // [ lll ,  solidity ,  serpent ]", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethcompilesolidity", 
            "text": "web3.eth.compile.solidity(sourceString [, callback])  Compiles solidity source code.", 
            "title": "web3.eth.compile.solidity"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_36", 
            "text": "String  - The solidity source code.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_52", 
            "text": "Object  - Contract and compiler info.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_56", 
            "text": "var   source   =     + \n     contract test {\\n   + \n        function multiply(uint a) returns(uint d) {\\n   + \n            return a * 7;\\n   + \n        }\\n   + \n     }\\n ;  var   compiled   =   web3 . eth . compile . solidity ( source );  console . log ( compiled );  // { \n   test :   { \n     code :   0x605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056 , \n     info :   { \n       source :   contract test {\\n\\tfunction multiply(uint a) returns(uint d) {\\n\\t\\treturn a * 7;\\n\\t}\\n}\\n , \n       language :   Solidity , \n       languageVersion :   0 , \n       compilerVersion :   0.8.2 , \n       abiDefinition :   [ \n         { \n           constant :   false , \n           inputs :   [ \n             { \n               name :   a , \n               type :   uint256 \n             } \n           ], \n           name :   multiply , \n           outputs :   [ \n             { \n               name :   d , \n               type :   uint256 \n             } \n           ], \n           type :   function \n         } \n       ], \n       userDoc :   { \n         methods :   {} \n       }, \n       developerDoc :   { \n         methods :   {} \n       } \n     } \n   }  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethcompilelll", 
            "text": "web3. eth.compile.lll(sourceString [, callback])  Compiles LLL source code.", 
            "title": "web3.eth.compile.lll"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_37", 
            "text": "String  - The LLL source code.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_53", 
            "text": "String  - The compiled LLL code as HEX string.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_57", 
            "text": "var   source   =   ... ;  var   code   =   web3 . eth . compile . lll ( source );  console . log ( code );   //  0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethcompileserpent", 
            "text": "web3.eth.compile.serpent(sourceString [, callback])  Compiles serpent source code.", 
            "title": "web3.eth.compile.serpent"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_38", 
            "text": "String  - The serpent source code.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_54", 
            "text": "String  - The compiled serpent code as HEX string.  var   source   =   ... ;  var   code   =   web3 . eth . compile . serpent ( source );  console . log ( code );   //  0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethnamereg", 
            "text": "web3.eth.namereg  Returns GlobalRegistrar object.", 
            "title": "web3.eth.namereg"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#usage_1", 
            "text": "see  namereg  example.", 
            "title": "Usage"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3db", 
            "text": "", 
            "title": "web3.db"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3dbputstring", 
            "text": "web3.db.putString(db, key, value)  This method should be called, when we want to store a string in the local leveldb database.", 
            "title": "web3.db.putString"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_39", 
            "text": "String  - The database to store to.  String  - The name of the store.  String  - The string value to store.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_55", 
            "text": "Boolean  -  true  if successfull, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_58", 
            "text": "param is db name, second is the key, and third is the string value. web3 . db . putString ( testDB ,   key ,   myString )   // true", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3dbgetstring", 
            "text": "web3.db.getString(db, key)  This method should be called, when we want to get string from the local leveldb database.", 
            "title": "web3.db.getString"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_40", 
            "text": "String  - The database string name to retrieve from.  String  - The name of the store.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_56", 
            "text": "String  - The stored value.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_59", 
            "text": "param is db name and second is the key of string value. var   value   =   web3 . db . getString ( testDB ,   key );  console . log ( value );   //  myString", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3dbputhex", 
            "text": "web3.db.putHex(db, key, value)  This method should be called, when we want to store binary data in HEX form in the local leveldb database.", 
            "title": "web3.db.putHex"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_41", 
            "text": "String  - The database to store to.  String  - The name of the store.  String  - The HEX string to store.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_57", 
            "text": "Boolean  -  true  if successfull, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_60", 
            "text": "web3 . db . putHex ( testDB ,   key ,   0x4f554b443 );   // true", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3dbgethex", 
            "text": "web3.db.getHex(db, key)  This method should be called, when we want to get a binary data in HEX form from the local leveldb database.", 
            "title": "web3.db.getHex"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_42", 
            "text": "String  - The database to store to.  String  - The name of the store.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_58", 
            "text": "String  - The stored HEX value.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_61", 
            "text": "param is db name and second is the key of value. var   value   =   web3 . db . getHex ( testDB ,   key );  console . log ( value );   //  0x4f554b443", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shh", 
            "text": "Whisper  Overview", 
            "title": "web3.shh"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_62", 
            "text": "var   shh   =   web3 . shh ;", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shhpost", 
            "text": "web3.shh.post(object [, callback])  This method should be called, when we want to post whisper message to the network.", 
            "title": "web3.shh.post"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_43", 
            "text": "Object  - The post object:  from :  String , 60 Bytes HEX - (optional) The identity of the sender.  to :  String , 60 Bytes  HEX - (optional) The identity of the receiver. When present whisper will encrypt the message so that only the receiver can decrypt it.  topics :  Array of Strings  - Array of topics  Strings , for the receiver to identify messages.  payload :  String|Number|Object  - The payload of the message. Will be autoconverted to a HEX string before.  priority :  Number  - The integer of the priority in a range from ... (?).  ttl :  Number  - integer of the time to live in seconds.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_59", 
            "text": "Boolean  - returns  true  if the message was sent, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_63", 
            "text": "var   identity   =   web3 . shh . newIdentity ();  var   topic   =   example ;  var   payload   =   hello whisper world! ;  var   message   =   { \n   from :   identity , \n   topics :   [ topic ], \n   payload :   payload , \n   ttl :   100 , \n   workToProve :   100   // or priority TODO  };  web3 . shh . post ( message );", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shhnewidentity", 
            "text": "web3.shh.newIdentity([callback])  Should be called to create new identity.", 
            "title": "web3.shh.newIdentity"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_44", 
            "text": "Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_60", 
            "text": "String  - A new identity HEX string.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_64", 
            "text": "var   identity   =   web3 . shh . newIdentity ();  console . log ( identity );   //  0xc931d93e97ab07fe42d923478ba2465f283f440fd6cabea4dd7a2c807108f651b7135d1d6ca9007d5b68aa497e4619ac10aa3b27726e1863c1fd9b570d99bbaf", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shhhasidentity", 
            "text": "web3.shh.hasIdentity(identity, [callback])  Should be called, if we want to check if user has given identity.", 
            "title": "web3.shh.hasIdentity"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_45", 
            "text": "String  - The identity to check.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#returns_61", 
            "text": "Boolean  - returns  true  if the identity exists, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_65", 
            "text": "var   identity   =   web3 . shh . newIdentity ();  var   result   =   web3 . shh . hasIdentity ( identity );  console . log ( result );   // true  var   result2   =   web3 . shh . hasIdentity ( identity   +   0 );  console . log ( result2 );   // false", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shhnewgroup", 
            "text": "", 
            "title": "web3.shh.newGroup"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_66", 
            "text": "// TODO: not implemented yet", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shhaddtogroup", 
            "text": "", 
            "title": "web3.shh.addToGroup"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#example_67", 
            "text": "// TODO: not implemented yet", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3shhfilter", 
            "text": "var   filter   =   web3 . shh . filter ( options )  // watch for changes  filter . watch ( function ( error ,   result ){ \n   if   ( ! error ) \n     console . log ( result );  });   Watch for incoming whisper messages.", 
            "title": "web3.shh.filter"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_46", 
            "text": "Object  - The filter options:  topics :  Array of Strings  - Filters messages by this topic(s). You can use the following combinations:  ['topic1', 'topic2'] == 'topic1'   'topic2'  ['topic1', ['topic2', 'topic3']] == 'topic1'   ('topic2' || 'topic3')  [null, 'topic1', 'topic2'] == ANYTHING   'topic1'   'topic2'  -   null  works as a wildcard    to : Filter by identity of receiver of the message. If provided and the node has this identity, it will decrypt incoming encrypted messages.  Function  - (optional) If you pass a callback the HTTP request is made asynchronous. See  this note  for details.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#callback-return_2", 
            "text": "Object  - The incoming message:   from :  String , 60 Bytes - The sender of the message, if a sender was specified.  to :  String , 60 Bytes - The receiver of the message, if a receiver was specified.  expiry :  Number  - Integer of the time in seconds when this message should expire (?).  ttl :  Number  -  Integer of the time the message should float in the system in seconds (?).  sent :  Number  -  Integer of the unix timestamp when the message was sent.  topics :  Array of String  - Array of  String  topics the message contained.  payload :  String  - The payload of the message.  workProved :  Number  - Integer of the work this message required before it was send (?).", 
            "title": "Callback return"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethsendibantransaction", 
            "text": "var   txHash   =   web3 . eth . sendIBANTransaction ( 0x00c5496aee77c1ba1f0854206a26dda82a81d6d8 ,   XE81ETHXREGGAVOFYORK ,   0x100 );   Sends IBAN transaction from user account to destination IBAN address.", 
            "title": "web3.eth.sendIBANTransaction"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#parameters_47", 
            "text": "string  - address from which we want to send transaction  string  - IBAN address to which we want to send transaction  value  - value that we want to send in IBAN transaction", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethiban", 
            "text": "var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );", 
            "title": "web3.eth.iban"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanfromaddress", 
            "text": "var   i   =   web3 . eth . iban . fromAddress ( 0x00c5496aee77c1ba1f0854206a26dda82a81d6d8 );  console . log ( i . toString ());   //  XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS", 
            "title": "web3.eth.iban.fromAddress"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanfrombban", 
            "text": "var   i   =   web3 . eth . iban . fromBban ( ETHXREGGAVOFYORK );  console . log ( i . toString ());   //  XE81ETHXREGGAVOFYORK", 
            "title": "web3.eth.iban.fromBban"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibancreateindirect", 
            "text": "var   i   =   web3 . eth . iban . createIndirect ({ \n   institution :   XREG , \n   identifier :   GAVOFYORK  });  console . log ( i . toString ());   //  XE81ETHXREGGAVOFYORK", 
            "title": "web3.eth.iban.createIndirect"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanisvalid", 
            "text": "var   valid   =   web3 . eth . iban . isValid ( XE81ETHXREGGAVOFYORK );  console . log ( valid );   // true  var   valid2   =   web3 . eth . iban . isValid ( XE82ETHXREGGAVOFYORK );  console . log ( valid2 );   // false, cause checksum is incorrect  var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );  var   valid3   =   i . isValid ();  console . log ( valid3 );   // true", 
            "title": "web3.eth.iban.isValid"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanisdirect", 
            "text": "var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );  var   direct   =   i . isDirect ();  console . log ( direct );   // false", 
            "title": "web3.eth.iban.isDirect"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanisindirect", 
            "text": "var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );  var   indirect   =   i . isIndirect ();  console . log ( indirect );   // true", 
            "title": "web3.eth.iban.isIndirect"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanchecksum", 
            "text": "var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );  var   checksum   =   i . checksum ();  console . log ( checksum );   //  81", 
            "title": "web3.eth.iban.checksum"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibaninstitution", 
            "text": "var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );  var   institution   =   i . institution ();  console . log ( institution );   //  XREG", 
            "title": "web3.eth.iban.institution"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanclient", 
            "text": "var   i   =   new   web3 . eth . iban ( XE81ETHXREGGAVOFYORK );  var   client   =   i . client ();  console . log ( client );   //  GAVOFYORK", 
            "title": "web3.eth.iban.client"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibanaddress", 
            "text": "var   i   =   new   web3 . eth . iban ( XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS );  var   address   =   i . address ();  console . log ( address );   //  00c5496aee77c1ba1f0854206a26dda82a81d6d8", 
            "title": "web3.eth.iban.address"
        }, 
        {
            "location": "/Dapps/JavaScript-API/#web3ethibantostring", 
            "text": "var   i   =   new   web3 . eth . iban ( XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS );  console . log ( i . toString ());   //  XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS", 
            "title": "web3.eth.iban.toString"
        }, 
        {
            "location": "/Dapps/JSON-RPC/", 
            "text": "JSON RPC API\n\n\nJSON\n is a lightweight data-interchange format. It can represent numbers, strings, ordered sequences of values, and collections of name/value pairs.\n\n\nJSON-RPC\n is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over HTTP, or in many various message passing environments. It uses JSON (\nRFC 4627\n) as data format.\n\n\nGeth 1.4 has experimental pub/sub support. See \nthis\n page for more information.\n\n\nParity 1.6 has experimental pub/sub support See \nthis\n for more information.\n\n\nJavaScript API\n\n\nTo talk to an ethereum node from inside a JavaScript application use the \nweb3.js\n library, which gives a convenient interface for the RPC methods.\nSee the \nJavaScript API\n for more.\n\n\nJSON-RPC Endpoint\n\n\nDefault JSON-RPC endpoints:\n\n\n\n\n\n\n\n\nClient\n\n\nURL\n\n\n\n\n\n\n\n\n\n\nC++\n\n\nhttp://localhost:8545\n\n\n\n\n\n\nGo\n\n\nhttp://localhost:8545\n\n\n\n\n\n\nPy\n\n\nhttp://localhost:4000\n\n\n\n\n\n\nParity\n\n\nhttp://localhost:8545\n\n\n\n\n\n\n\n\nGo\n\n\nYou can start the HTTP JSON-RPC with the \n--rpc\n flag\n\ngeth --rpc\n\n\n\nchange the default port (8545) and listing address (localhost) with:\n\n\ngeth --rpc --rpcaddr \nip\n --rpcport \nportnumber\n\n\n\n\n\nIf accessing the RPC from a browser, CORS will need to be enabled with the appropriate domain set. Otherwise, JavaScript calls are limit by the same-origin policy and requests will fail:\n\n\ngeth --rpc --rpccorsdomain \nhttp://localhost:3000\n\n\n\n\n\nThe JSON RPC can also be started from the \ngeth console\n using the \nadmin.startRPC(addr, port)\n command.\n\n\nC++\n\n\nYou can start it by running \neth\n application with \n-j\n option:\n\n./eth -j\n\n\n\nYou can also specify JSON-RPC port (default is 8545):\n\n./eth -j --json-rpc-port \n8079\n\n\n\n\nPython\n\n\nIn python the JSONRPC server is currently started by default and listens on \n127.0.0.1:4000\n\n\nYou can change the port and listen address by giving a config option.\n\n\npyethapp -c jsonrpc.listen_port=4002 -c jsonrpc.listen_host=127.0.0.2 run\n\n\nJSON-RPC support\n\n\n\n\n\n\n\n\n\n\ncpp-ethereum\n\n\ngo-ethereum\n\n\npy-ethereum\n\n\nparity\n\n\n\n\n\n\n\n\n\n\nJSON-RPC 1.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJSON-RPC 2.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBatch requests\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIPC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHEX value encoding\n\n\nAt present there are two key datatypes that are passed over JSON: unformatted byte arrays and quantities. Both are passed with a hex encoding, however with different requirements to formatting:\n\n\nWhen encoding \nQUANTITIES\n (integers, numbers): encode as hex, prefix with \"0x\", the most compact representation (slight exception: zero should be represented as \"0x0\"). Examples:\n- 0x41 (65 in decimal)\n- 0x400 (1024 in decimal)\n- WRONG: 0x (should always have at least one digit - zero is \"0x0\")\n- WRONG: 0x0400 (no leading zeroes allowed)\n- WRONG: ff (must be prefixed 0x)\n\n\nWhen encoding \nUNFORMATTED DATA\n (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with \"0x\", two hex digits per byte. Examples:\n- 0x41 (size 1, \"A\")\n- 0x004200 (size 3, \"\\0B\\0\")\n- 0x (size 0, \"\")\n- WRONG: 0xf0f0f (must be even number of digits)\n- WRONG: 004200 (must be prefixed 0x)\n\n\nCurrently \ncpp-ethereum\n,\ngo-ethereum\n, and \nparity\n provide JSON-RPC communication over http and IPC (unix socket Linux and OSX/named pipes on Windows). Version 1.4 of go-ethereum and version 1.6 of Parity onwards have websocket support.\n\n\nThe default block parameter\n\n\nThe following methods have an extra default block parameter:\n\n\n\n\neth_getBalance\n\n\neth_getCode\n\n\neth_getTransactionCount\n\n\neth_getStorageAt\n\n\neth_call\n\n\n\n\nWhen requests are made that act on the state of ethereum, the last default block parameter determines the height of the block.\n\n\nThe following options are possible for the defaultBlock parameter:\n\n\n\n\nHEX String\n - an integer block number\n\n\nString \"earliest\"\n for the earliest/genesis block\n\n\nString \"latest\"\n - for the latest mined block\n\n\nString \"pending\"\n - for the pending state/transactions\n\n\n\n\nCurl Examples Explained\n\n\nThe curl options below might return a response where the node complains about the content type, this is because the --data option sets the content type to application/x-www-form-urlencoded . If your node does complain, manually set the header by placing -H \"Content-Type: application/json\" at the start of the call.\n\n\nThe examples also do not include the URL/IP \n port combination which must be the last argument given to curl e.x. 127.0.0.1:8545\n\n\nJSON-RPC methods\n\n\n\n\nweb3_clientVersion\n\n\nweb3_sha3\n\n\nnet_version\n\n\nnet_peerCount\n\n\nnet_listening\n\n\neth_protocolVersion\n\n\neth_syncing\n\n\neth_coinbase\n\n\neth_mining\n\n\neth_hashrate\n\n\neth_gasPrice\n\n\neth_accounts\n\n\neth_blockNumber\n\n\neth_getBalance\n\n\neth_getStorageAt\n\n\neth_getTransactionCount\n\n\neth_getBlockTransactionCountByHash\n\n\neth_getBlockTransactionCountByNumber\n\n\neth_getUncleCountByBlockHash\n\n\neth_getUncleCountByBlockNumber\n\n\neth_getCode\n\n\neth_sign\n\n\neth_sendTransaction\n\n\neth_sendRawTransaction\n\n\neth_call\n\n\neth_estimateGas\n\n\neth_getBlockByHash\n\n\neth_getBlockByNumber\n\n\neth_getTransactionByHash\n\n\neth_getTransactionByBlockHashAndIndex\n\n\neth_getTransactionByBlockNumberAndIndex\n\n\neth_getTransactionReceipt\n\n\neth_getUncleByBlockHashAndIndex\n\n\neth_getUncleByBlockNumberAndIndex\n\n\neth_getCompilers\n\n\neth_compileLLL\n\n\neth_compileSolidity\n\n\neth_compileSerpent\n\n\neth_newFilter\n\n\neth_newBlockFilter\n\n\neth_newPendingTransactionFilter\n\n\neth_uninstallFilter\n\n\neth_getFilterChanges\n\n\neth_getFilterLogs\n\n\neth_getLogs\n\n\neth_getWork\n\n\neth_submitWork\n\n\neth_submitHashrate\n\n\ndb_putString\n\n\ndb_getString\n\n\ndb_putHex\n\n\ndb_getHex\n\n\nshh_post\n\n\nshh_version\n\n\nshh_newIdentity\n\n\nshh_hasIdentity\n\n\nshh_newGroup\n\n\nshh_addToGroup\n\n\nshh_newFilter\n\n\nshh_uninstallFilter\n\n\nshh_getFilterChanges\n\n\nshh_getMessages\n\n\n\n\nJSON RPC API Reference\n\n\n\n\nweb3_clientVersion\n\n\nReturns the current client version.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nString\n - The current client version\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nweb3_clientVersion\n,\nparams\n:[],\nid\n:67}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n67\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \nMist/v0.9.3/darwin/go1.4.1\n\n\n}\n\n\n\n\n\n\n\nweb3_sha3\n\n\nReturns Keccak-256 (\nnot\n the standardized SHA3-256) of the given data.\n\n\nParameters\n\n\n\n\nDATA\n - the data to convert into a SHA3 hash\n\n\n\n\nparams\n:\n \n[\n\n  \n0x68656c6c6f20776f726c64\n\n\n]\n\n\n\n\n\nReturns\n\n\nDATA\n - The SHA3 result of the given string.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nweb3_sha3\n,\nparams\n:[\n0x68656c6c6f20776f726c64\n],\nid\n:64}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n64\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad\n\n\n}\n\n\n\n\n\n\n\nnet_version\n\n\nReturns the current network id.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nString\n - The current network id.\n- \n\"1\"\n: Ethereum Mainnet\n- \n\"2\"\n: Morden Testnet  (deprecated)\n- \n\"3\"\n: Ropsten Testnet\n- \n\"4\"\n: Rinkeby Testnet\n- \n\"42\"\n: Kovan Testnet\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nnet_version\n,\nparams\n:[],\nid\n:67}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n67\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n3\n\n\n}\n\n\n\n\n\n\n\nnet_listening\n\n\nReturns \ntrue\n if client is actively listening for network connections.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nBoolean\n - \ntrue\n when listening, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nnet_listening\n,\nparams\n:[],\nid\n:67}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n67\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\ntrue\n\n\n}\n\n\n\n\n\n\n\nnet_peerCount\n\n\nReturns number of peers currently connected to the client.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nQUANTITY\n - integer of the number of connected peers.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nnet_peerCount\n,\nparams\n:[],\nid\n:74}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n74\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x2\n \n// 2\n\n\n}\n\n\n\n\n\n\n\neth_protocolVersion\n\n\nReturns the current ethereum protocol version.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nString\n - The current ethereum protocol version\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_protocolVersion\n,\nparams\n:[],\nid\n:67}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n67\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n54\n\n\n}\n\n\n\n\n\n\n\neth_syncing\n\n\nReturns an object with data about the sync status or \nfalse\n.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nObject|Boolean\n, An object with sync status data or \nFALSE\n, when not syncing:\n  - \nstartingBlock\n: \nQUANTITY\n - The block at which the import started (will only be reset, after the sync reached his head)\n  - \ncurrentBlock\n: \nQUANTITY\n - The current block, same as eth_blockNumber\n  - \nhighestBlock\n: \nQUANTITY\n - The estimated highest block\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_syncing\n,\nparams\n:[],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n{\n\n    \nstartingBlock\n:\n \n0x384\n,\n\n    \ncurrentBlock\n:\n \n0x386\n,\n\n    \nhighestBlock\n:\n \n0x454\n\n  \n}\n\n\n}\n\n\n// Or when not syncing\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \nfalse\n\n\n}\n\n\n\n\n\n\n\neth_coinbase\n\n\nReturns the client coinbase address.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nDATA\n, 20 bytes - the current coinbase address.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_coinbase\n,\nparams\n:[],\nid\n:64}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n64\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n\n\n}\n\n\n\n\n\n\n\neth_mining\n\n\nReturns \ntrue\n if client is actively mining new blocks.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n of the client is mining, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_mining\n,\nparams\n:[],\nid\n:71}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n71\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\neth_hashrate\n\n\nReturns the number of hashes per second that the node is mining with.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nQUANTITY\n - number of hashes per second.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_hashrate\n,\nparams\n:[],\nid\n:71}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n71\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x38a\n\n\n}\n\n\n\n\n\n\n\neth_gasPrice\n\n\nReturns the current price per gas in wei.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nQUANTITY\n - integer of the current gas price in wei.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_gasPrice\n,\nparams\n:[],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n73\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x09184e72a000\n \n// 10000000000000\n\n\n}\n\n\n\n\n\n\n\neth_accounts\n\n\nReturns a list of addresses owned by client.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nArray of DATA\n, 20 Bytes - addresses owned by the client.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_accounts\n,\nparams\n:[],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n[\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n]\n\n\n}\n\n\n\n\n\n\n\neth_blockNumber\n\n\nReturns the number of most recent block.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nQUANTITY\n - integer of the current block number the client is on.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_blockNumber\n,\nparams\n:[],\nid\n:83}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n83\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x4b7\n \n// 1207\n\n\n}\n\n\n\n\n\n\n\neth_getBalance\n\n\nReturns the balance of the account of given address.\n\n\nParameters\n\n\n\n\nDATA\n, 20 Bytes - address to check for balance.\n\n\nQUANTITY|TAG\n - integer block number, or the string \n\"latest\"\n, \n\"earliest\"\n or \n\"pending\"\n, see the \ndefault block parameter\n\n\n\n\nparams\n:\n \n[\n\n   \n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n,\n\n   \nlatest\n\n\n]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - integer of the current balance in wei.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getBalance\n,\nparams\n:[\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n, \nlatest\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x0234c8a3397aab58\n \n// 158972490234375000\n\n\n}\n\n\n\n\n\n\n\neth_getStorageAt\n\n\nReturns the value from a storage position at a given address.\n\n\nParameters\n\n\n\n\nDATA\n, 20 Bytes - address of the storage.\n\n\nQUANTITY\n - integer of the position in the storage.\n\n\nQUANTITY|TAG\n - integer block number, or the string \n\"latest\"\n, \n\"earliest\"\n or \n\"pending\"\n, see the \ndefault block parameter\n\n\n\n\nReturns\n\n\nDATA\n - the value at this storage position.\n\n\nExample\n\n\nCalculating the correct position depends on the storage to retrieve. Consider the following contract deployed at \n0x295a70b2de5e3953354a6a8344e616ed314d7251\n by address \n0x391694e7e0b0cce554cb130d723a9d27458f9298\n.\n\n\ncontract Storage {\n    uint pos0;\n    mapping(address =\n uint) pos1;\n\n    function Storage() {\n        pos0 = 1234;\n        pos1[msg.sender] = 5678;\n    }\n}\n\n\n\n\nRetrieving the value of pos0 is straight forward:\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n, \nmethod\n: \neth_getStorageAt\n, \nparams\n: [\n0x295a70b2de5e3953354a6a8344e616ed314d7251\n, \n0x0\n, \nlatest\n], \nid\n: 1}\n \nlocalhost\n:\n8545\n\n\n\n{\njsonrpc\n:\n2.0\n,\nid\n:\n1\n,\nresult\n:\n0x00000000000000000000000000000000000000000000000000000000000004d2\n}\n\n\n\n\n\nRetrieving an element of the map is harder. The position of an element in the map is calculated with:\n\nkeccack\n(\nLeftPad32\n(\nkey\n,\n \n0\n),\n \nLeftPad32\n(\nmap\n \nposition\n,\n \n0\n))\n\n\n\n\nThis means to retrieve the storage on pos1[\"0x391694e7e0b0cce554cb130d723a9d27458f9298\"] we need to calculate the position with:\n\nkeccak\n(\ndecodeHex\n(\n000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298\n \n+\n \n0000000000000000000000000000000000000000000000000000000000000001\n))\n\n\n\nThe geth console which comes with the web3 library can be used to make the calculation:\n\n \nvar\n \nkey\n \n=\n \n000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298\n \n+\n \n0000000000000000000000000000000000000000000000000000000000000001\n\n\nundefined\n\n\n \nweb3\n.\nsha3\n(\nkey\n,\n \n{\nencoding\n:\n \nhex\n})\n\n\n0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9\n\n\n\nNow to fetch the storage:\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n, \nmethod\n: \neth_getStorageAt\n, \nparams\n: [\n0x295a70b2de5e3953354a6a8344e616ed314d7251\n, \n0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9\n, \nlatest\n], \nid\n: 1}\n \nlocalhost\n:\n8545\n\n\n\n{\njsonrpc\n:\n2.0\n,\nid\n:\n1\n,\nresult\n:\n0x000000000000000000000000000000000000000000000000000000000000162e\n}\n\n\n\n\n\n\neth_getTransactionCount\n\n\nReturns the number of transactions \nsent\n from an address.\n\n\nParameters\n\n\n\n\nDATA\n, 20 Bytes - address.\n\n\nQUANTITY|TAG\n - integer block number, or the string \n\"latest\"\n, \n\"earliest\"\n or \n\"pending\"\n, see the \ndefault block parameter\n\n\n\n\nparams\n:\n \n[\n\n   \n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n,\n\n   \nlatest\n \n// state at the latest block\n\n\n]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - integer of the number of transactions send from this address.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getTransactionCount\n,\nparams\n:[\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n,\nlatest\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x1\n \n// 1\n\n\n}\n\n\n\n\n\n\n\neth_getBlockTransactionCountByHash\n\n\nReturns the number of transactions in a block from a block matching the given block hash.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - hash of a block\n\n\n\n\nparams\n:\n \n[\n\n   \n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n\n\n]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - integer of the number of transactions in this block.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getBlockTransactionCountByHash\n,\nparams\n:[\n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xb\n \n// 11\n\n\n}\n\n\n\n\n\n\n\neth_getBlockTransactionCountByNumber\n\n\nReturns the number of transactions in a block matching the given block number.\n\n\nParameters\n\n\n\n\nQUANTITY|TAG\n - integer of a block number, or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n, as in the \ndefault block parameter\n.\n\n\n\n\nparams\n:\n \n[\n\n   \n0xe8\n,\n \n// 232\n\n\n]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - integer of the number of transactions in this block.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getBlockTransactionCountByNumber\n,\nparams\n:[\n0xe8\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xa\n \n// 10\n\n\n}\n\n\n\n\n\n\n\neth_getUncleCountByBlockHash\n\n\nReturns the number of uncles in a block from a block matching the given block hash.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - hash of a block\n\n\n\n\nparams\n:\n \n[\n\n   \n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n\n\n]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - integer of the number of uncles in this block.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getUncleCountByBlockHash\n,\nparams\n:[\n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x1\n \n// 1\n\n\n}\n\n\n\n\n\n\n\neth_getUncleCountByBlockNumber\n\n\nReturns the number of uncles in a block from a block matching the given block number.\n\n\nParameters\n\n\n\n\nQUANTITY|TAG\n - integer of a block number, or the string \"latest\", \"earliest\" or \"pending\", see the \ndefault block parameter\n\n\n\n\nparams\n:\n \n[\n\n   \n0xe8\n,\n \n// 232\n\n\n]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - integer of the number of uncles in this block.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getUncleCountByBlockNumber\n,\nparams\n:[\n0xe8\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x1\n \n// 1\n\n\n}\n\n\n\n\n\n\n\neth_getCode\n\n\nReturns code at a given address.\n\n\nParameters\n\n\n\n\nDATA\n, 20 Bytes - address\n\n\nQUANTITY|TAG\n - integer block number, or the string \n\"latest\"\n, \n\"earliest\"\n or \n\"pending\"\n, see the \ndefault block parameter\n\n\n\n\nparams\n:\n \n[\n\n   \n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\n,\n\n   \n0x2\n  \n// 2\n\n\n]\n\n\n\n\n\nReturns\n\n\nDATA\n - the code from the given address.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getCode\n,\nparams\n:[\n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\n, \n0x2\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x600160008035811a818181146012578301005b601b6001356025565b8060005260206000f25b600060078202905091905056\n\n\n}\n\n\n\n\n\n\n\neth_sign\n\n\nThe sign method calculates an Ethereum specific signature with: \nsign(keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message)))\n.\n\n\nBy adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.\n\n\nNote\n the address to sign with must be unlocked.\n\n\nParameters\n\n\naccount, message\n\n\n\n\nDATA\n, 20 Bytes - address\n\n\nDATA\n, N Bytes - message to sign\n\n\n\n\nReturns\n\n\nDATA\n: Signature\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_sign\n,\nparams\n:[\n0x9b2055d370f73ec7d8a03e965129118dc8f5bf83\n, \n0xdeadbeaf\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\n\n\n}\n\n\n\n\n\nAn example how to use solidity ecrecover to verify the signature calculated with \neth_sign\n can be found \nhere\n. The contract is deployed on the testnet Ropsten and Rinkeby.\n\n\n\n\neth_sendTransaction\n\n\nCreates new message call transaction or a contract creation, if the data field contains code.\n\n\nParameters\n\n\n\n\nObject\n - The transaction object\n\n\nfrom\n: \nDATA\n, 20 Bytes - The address the transaction is send from.\n\n\nto\n: \nDATA\n, 20 Bytes - (optional when creating new contract) The address the transaction is directed to.\n\n\ngas\n: \nQUANTITY\n  - (optional, default: 90000) Integer of the gas provided for the transaction execution. It will return unused gas.\n\n\ngasPrice\n: \nQUANTITY\n  - (optional, default: To-Be-Determined) Integer of the gasPrice used for each paid gas\n\n\nvalue\n: \nQUANTITY\n  - (optional) Integer of the value send with this transaction\n\n\ndata\n: \nDATA\n  - The compiled code of a contract OR the hash of the invoked method signature and encoded parameters. For details see \nEthereum Contract ABI\n\n\nnonce\n: \nQUANTITY\n  - (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.\n\n\n\n\nparams\n:\n \n[{\n\n  \nfrom\n:\n \n0xb60e8dd61c5d32be8058bb8eb970870f07233155\n,\n\n  \nto\n:\n \n0xd46e8dd67c5d32be8058bb8eb970870f07244567\n,\n\n  \ngas\n:\n \n0x76c0\n,\n \n// 30400\n\n  \ngasPrice\n:\n \n0x9184e72a000\n,\n \n// 10000000000000\n\n  \nvalue\n:\n \n0x9184e72a\n,\n \n// 2441406250\n\n  \ndata\n:\n \n0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\n\n\n}]\n\n\n\n\n\nReturns\n\n\nDATA\n, 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.\n\n\nUse \neth_getTransactionReceipt\n to get the contract address, after the transaction was mined, when you created a contract.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_sendTransaction\n,\nparams\n:[{see above}],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n\n\n}\n\n\n\n\n\n\n\neth_sendRawTransaction\n\n\nCreates new message call transaction or a contract creation for signed transactions.\n\n\nParameters\n\n\n\n\nDATA\n, The signed transaction data.\n\n\n\n\nparams\n:\n \n[\n0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\n]\n\n\n\n\n\nReturns\n\n\nDATA\n, 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.\n\n\nUse \neth_getTransactionReceipt\n to get the contract address, after the transaction was mined, when you created a contract.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_sendRawTransaction\n,\nparams\n:[{see above}],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n\n\n}\n\n\n\n\n\n\n\neth_call\n\n\nExecutes a new message call immediately without creating a transaction on the block chain.\n\n\nParameters\n\n\n\n\nObject\n - The transaction call object\n\n\nfrom\n: \nDATA\n, 20 Bytes - (optional) The address the transaction is sent from.\n\n\nto\n: \nDATA\n, 20 Bytes  - The address the transaction is directed to.\n\n\ngas\n: \nQUANTITY\n  - (optional) Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter may be needed by some executions.\n\n\ngasPrice\n: \nQUANTITY\n  - (optional) Integer of the gasPrice used for each paid gas\n\n\nvalue\n: \nQUANTITY\n  - (optional) Integer of the value send with this transaction\n\n\ndata\n: \nDATA\n  - (optional) Hash of the method signature and encoded parameters. For details see \nEthereum Contract ABI\n\n\nQUANTITY|TAG\n - integer block number, or the string \n\"latest\"\n, \n\"earliest\"\n or \n\"pending\"\n, see the \ndefault block parameter\n\n\n\n\nReturns\n\n\nDATA\n - the return value of executed contract.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_call\n,\nparams\n:[{see above}],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x\n\n\n}\n\n\n\n\n\n\n\neth_estimateGas\n\n\nMakes a call or transaction, which won't be added to the blockchain and returns the used gas, which can be used for estimating the used gas.\n\n\nParameters\n\n\nSee \neth_call\n parameters, expect that all properties are optional. If no gas limit is specified geth uses the block gas limit from the pending block as an upper bound. As a result the returned estimate might not be enough to executed the call/transaction when the amount of gas is higher than the pending block gas limit.\n\n\nReturns\n\n\nQUANTITY\n - the amount of gas used.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_estimateGas\n,\nparams\n:[{see above}],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x5208\n \n// 21000\n\n\n}\n\n\n\n\n\n\n\neth_getBlockByHash\n\n\nReturns information about a block by hash.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - Hash of a block.\n\n\nBoolean\n - If \ntrue\n it returns the full transaction objects, if \nfalse\n only the hashes of the transactions.\n\n\n\n\nparams\n:\n \n[\n\n   \n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n,\n\n   \ntrue\n\n\n]\n\n\n\n\n\nReturns\n\n\nObject\n - A block object, or \nnull\n when no block was found:\n\n\n\n\nnumber\n: \nQUANTITY\n - the block number. \nnull\n when its pending block.\n\n\nhash\n: \nDATA\n, 32 Bytes - hash of the block. \nnull\n when its pending block.\n\n\nparentHash\n: \nDATA\n, 32 Bytes - hash of the parent block.\n\n\nnonce\n: \nDATA\n, 8 Bytes - hash of the generated proof-of-work. \nnull\n when its pending block.\n\n\nsha3Uncles\n: \nDATA\n, 32 Bytes - SHA3 of the uncles data in the block.\n\n\nlogsBloom\n: \nDATA\n, 256 Bytes - the bloom filter for the logs of the block. \nnull\n when its pending block.\n\n\ntransactionsRoot\n: \nDATA\n, 32 Bytes - the root of the transaction trie of the block.\n\n\nstateRoot\n: \nDATA\n, 32 Bytes - the root of the final state trie of the block.\n\n\nreceiptsRoot\n: \nDATA\n, 32 Bytes - the root of the receipts trie of the block.\n\n\nminer\n: \nDATA\n, 20 Bytes - the address of the beneficiary to whom the mining rewards were given.\n\n\ndifficulty\n: \nQUANTITY\n - integer of the difficulty for this block.\n\n\ntotalDifficulty\n: \nQUANTITY\n - integer of the total difficulty of the chain until this block.\n\n\nextraData\n: \nDATA\n - the \"extra data\" field of this block.\n\n\nsize\n: \nQUANTITY\n - integer the size of this block in bytes.\n\n\ngasLimit\n: \nQUANTITY\n - the maximum gas allowed in this block.\n\n\ngasUsed\n: \nQUANTITY\n - the total used gas by all transactions in this block.\n\n\ntimestamp\n: \nQUANTITY\n - the unix timestamp for when the block was collated.\n\n\ntransactions\n: \nArray\n - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter.\n\n\nuncles\n: \nArray\n - Array of uncle hashes.\n\n\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getBlockByHash\n,\nparams\n:[\n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n, true],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n\nid\n:\n1\n,\n\n\njsonrpc\n:\n2.0\n,\n\n\nresult\n:\n \n{\n\n    \nnumber\n:\n \n0x1b4\n,\n \n// 436\n\n    \nhash\n:\n \n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n,\n\n    \nparentHash\n:\n \n0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\n,\n\n    \nnonce\n:\n \n0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\n,\n\n    \nsha3Uncles\n:\n \n0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\n,\n\n    \nlogsBloom\n:\n \n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n,\n\n    \ntransactionsRoot\n:\n \n0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\n,\n\n    \nstateRoot\n:\n \n0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\n,\n\n    \nminer\n:\n \n0x4e65fda2159562a496f9f3522f89122a3088497a\n,\n\n    \ndifficulty\n:\n \n0x027f07\n,\n \n// 163591\n\n    \ntotalDifficulty\n:\n  \n0x027f07\n,\n \n// 163591\n\n    \nextraData\n:\n \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n\n    \nsize\n:\n  \n0x027f07\n,\n \n// 163591\n\n    \ngasLimit\n:\n \n0x9f759\n,\n \n// 653145\n\n    \ngasUsed\n:\n \n0x9f759\n,\n \n// 653145\n\n    \ntimestamp\n:\n \n0x54e34e8e\n \n// 1424182926\n\n    \ntransactions\n:\n \n[{...},{\n \n...\n \n}]\n\n    \nuncles\n:\n \n[\n0x1606e5...\n,\n \n0xd5145a9...\n]\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\neth_getBlockByNumber\n\n\nReturns information about a block by block number.\n\n\nParameters\n\n\n\n\nQUANTITY|TAG\n - integer of a block number, or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n, as in the \ndefault block parameter\n.\n\n\nBoolean\n - If \ntrue\n it returns the full transaction objects, if \nfalse\n only the hashes of the transactions.\n\n\n\n\nparams\n:\n \n[\n\n   \n0x1b4\n,\n \n// 436\n\n   \ntrue\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \neth_getBlockByHash\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getBlockByNumber\n,\nparams\n:[\n0x1b4\n, true],\nid\n:1}\n\n\n\n\n\nResult see \neth_getBlockByHash\n\n\n\n\neth_getTransactionByHash\n\n\nReturns the information about a transaction requested by transaction hash.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - hash of a transaction\n\n\n\n\nparams\n:\n \n[\n\n   \n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n\n\n]\n\n\n\n\n\nReturns\n\n\nObject\n - A transaction object, or \nnull\n when no transaction was found:\n\n\n\n\nhash\n: \nDATA\n, 32 Bytes - hash of the transaction.\n\n\nnonce\n: \nQUANTITY\n - the number of transactions made by the sender prior to this one.\n\n\nblockHash\n: \nDATA\n, 32 Bytes - hash of the block where this transaction was in. \nnull\n when its pending.\n\n\nblockNumber\n: \nQUANTITY\n - block number where this transaction was in. \nnull\n when its pending.\n\n\ntransactionIndex\n: \nQUANTITY\n - integer of the transactions index position in the block. \nnull\n when its pending.\n\n\nfrom\n: \nDATA\n, 20 Bytes - address of the sender.\n\n\nto\n: \nDATA\n, 20 Bytes - address of the receiver. \nnull\n when its a contract creation transaction.\n\n\nvalue\n: \nQUANTITY\n - value transferred in Wei.\n\n\ngasPrice\n: \nQUANTITY\n - gas price provided by the sender in Wei.\n\n\ngas\n: \nQUANTITY\n - gas provided by the sender.\n\n\ninput\n: \nDATA\n - the data send along with the transaction.\n\n\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getTransactionByHash\n,\nparams\n:[\n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n\nid\n:\n1\n,\n\n\njsonrpc\n:\n2.0\n,\n\n\nresult\n:\n \n{\n\n    \nhash\n:\n0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b\n,\n\n    \nnonce\n:\n0x\n,\n\n    \nblockHash\n:\n \n0xbeab0aa2411b7ab17f30a99d3cb9c6ef2fc5426d6ad6fd9e2a26a6aed1d1055b\n,\n\n    \nblockNumber\n:\n \n0x15df\n,\n \n// 5599\n\n    \ntransactionIndex\n:\n  \n0x1\n,\n \n// 1\n\n    \nfrom\n:\n0x407d73d8a49eeb85d32cf465507dd71d507100c1\n,\n\n    \nto\n:\n0x85h43d8a49eeb85d32cf465507dd71d507100c1\n,\n\n    \nvalue\n:\n0x7f110\n \n// 520464\n\n    \ngas\n:\n \n0x7f110\n \n// 520464\n\n    \ngasPrice\n:\n0x09184e72a000\n,\n\n    \ninput\n:\n0x603880600c6000396000f300603880600c6000396000f3603880600c6000396000f360\n,\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\neth_getTransactionByBlockHashAndIndex\n\n\nReturns information about a transaction by block hash and transaction index position.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - hash of a block.\n\n\nQUANTITY\n - integer of the transaction index position.\n\n\n\n\nparams\n:\n \n[\n\n   \n0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\n,\n\n   \n0x0\n \n// 0\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \neth_getBlockByHash\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getTransactionByBlockHashAndIndex\n,\nparams\n:[0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b, \n0x0\n],\nid\n:1}\n\n\n\n\n\nResult see \neth_getTransactionByHash\n\n\n\n\neth_getTransactionByBlockNumberAndIndex\n\n\nReturns information about a transaction by block number and transaction index position.\n\n\nParameters\n\n\n\n\nQUANTITY|TAG\n - a block number, or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n, as in the \ndefault block parameter\n.\n\n\nQUANTITY\n - the transaction index position.\n\n\n\n\nparams\n:\n \n[\n\n   \n0x29c\n,\n \n// 668\n\n   \n0x0\n \n// 0\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \neth_gettransactionbyhash\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getTransactionByBlockNumberAndIndex\n,\nparams\n:[\n0x29c\n, \n0x0\n],\nid\n:1}\n\n\n\n\n\nResult see \neth_getTransactionByHash\n\n\n\n\neth_getTransactionReceipt\n\n\nReturns the receipt of a transaction by transaction hash.\n\n\nNote\n That the receipt is not available for pending transactions.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - hash of a transaction\n\n\n\n\nparams\n:\n \n[\n\n   \n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n\n\n]\n\n\n\n\n\nReturns\n\n\nObject\n - A transaction receipt object, or \nnull\n when no receipt was found:\n\n\n\n\ntransactionHash\n: \nDATA\n, 32 Bytes - hash of the transaction.\n\n\ntransactionIndex\n: \nQUANTITY\n - integer of the transactions index position in the block.\n\n\nblockHash\n: \nDATA\n, 32 Bytes - hash of the block where this transaction was in.\n\n\nblockNumber\n: \nQUANTITY\n - block number where this transaction was in.\n\n\ncumulativeGasUsed\n: \nQUANTITY\n - The total amount of gas used when this transaction was executed in the block.\n\n\ngasUsed\n: \nQUANTITY\n - The amount of gas used by this specific transaction alone.\n\n\ncontractAddress\n: \nDATA\n, 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise \nnull\n.\n\n\nlogs\n: \nArray\n - Array of log objects, which this transaction generated.\n\n\nlogsBloom\n: \nDATA\n, 256 Bytes - Bloom filter for light clients to quickly retrieve related logs.\n\n\n\n\nIt also returns \neither\n :\n\n\n\n\nroot\n : \nDATA\n 32 bytes of post-transaction stateroot (pre Byzantium)\n\n\nstatus\n: \nQUANTITY\n either \n1\n (success) or \n0\n (failure)\n\n\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getTransactionReceipt\n,\nparams\n:[\n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n\nid\n:\n1\n,\n\n\njsonrpc\n:\n2.0\n,\n\n\nresult\n:\n \n{\n\n     \ntransactionHash\n:\n \n0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\n,\n\n     \ntransactionIndex\n:\n  \n0x1\n,\n \n// 1\n\n     \nblockNumber\n:\n \n0xb\n,\n \n// 11\n\n     \nblockHash\n:\n \n0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b\n,\n\n     \ncumulativeGasUsed\n:\n \n0x33bc\n,\n \n// 13244\n\n     \ngasUsed\n:\n \n0x4dc\n,\n \n// 1244\n\n     \ncontractAddress\n:\n \n0xb60e8dd61c5d32be8058bb8eb970870f07233155\n \n// or null, if none was created\n\n     \nlogs\n:\n \n[{\n\n         \n// logs as returned by getFilterLogs, etc.\n\n     \n},\n \n...],\n\n     \nlogsBloom\n:\n \n0x00...0\n \n// 256 byte bloom filter\n\n     \nstatus\n:\n \n0x1\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\neth_getUncleByBlockHashAndIndex\n\n\nReturns information about a uncle of a block by hash and uncle index position.\n\n\nParameters\n\n\n\n\nDATA\n, 32 Bytes - hash a block.\n\n\nQUANTITY\n - the uncle's index position.\n\n\n\n\nparams\n:\n \n[\n\n   \n0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b\n,\n\n   \n0x0\n \n// 0\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \neth_getBlockByHash\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getUncleByBlockHashAndIndex\n,\nparams\n:[\n0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b\n, \n0x0\n],\nid\n:1}\n\n\n\n\n\nResult see \neth_getBlockByHash\n\n\nNote\n: An uncle doesn't contain individual transactions.\n\n\n\n\neth_getUncleByBlockNumberAndIndex\n\n\nReturns information about a uncle of a block by number and uncle index position.\n\n\nParameters\n\n\n\n\nQUANTITY|TAG\n - a block number, or the string \n\"earliest\"\n, \n\"latest\"\n or \n\"pending\"\n, as in the \ndefault block parameter\n.\n\n\nQUANTITY\n - the uncle's index position.\n\n\n\n\nparams\n:\n \n[\n\n   \n0x29c\n,\n \n// 668\n\n   \n0x0\n \n// 0\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \neth_getBlockByHash\n\n\nNote\n: An uncle doesn't contain individual transactions.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getUncleByBlockNumberAndIndex\n,\nparams\n:[\n0x29c\n, \n0x0\n],\nid\n:1}\n\n\n\n\n\nResult see \neth_getBlockByHash\n\n\n\n\neth_getCompilers\n\n\nReturns a list of available compilers in the client.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nArray\n - Array of available compilers.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getCompilers\n,\nparams\n:[],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n[\nsolidity\n,\n \nlll\n,\n \nserpent\n]\n\n\n}\n\n\n\n\n\n\n\neth_compileSolidity\n\n\nReturns compiled solidity code.\n\n\nParameters\n\n\n\n\nString\n - The source code.\n\n\n\n\nparams\n:\n \n[\n\n   \ncontract test { function multiply(uint a) returns(uint d) {   return a * 7;   } }\n,\n\n\n]\n\n\n\n\n\nReturns\n\n\nDATA\n - The compiled source code.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_compileSolidity\n,\nparams\n:[\ncontract test { function multiply(uint a) returns(uint d) {   return a * 7;   } }\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n{\n\n      \ncode\n:\n \n0x605880600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b603d6004803590602001506047565b8060005260206000f35b60006007820290506053565b91905056\n,\n\n      \ninfo\n:\n \n{\n\n        \nsource\n:\n \ncontract test {\\n   function multiply(uint a) constant returns(uint d) {\\n       return a * 7;\\n   }\\n}\\n\n,\n\n        \nlanguage\n:\n \nSolidity\n,\n\n        \nlanguageVersion\n:\n \n0\n,\n\n        \ncompilerVersion\n:\n \n0.9.19\n,\n\n        \nabiDefinition\n:\n \n[\n\n          \n{\n\n            \nconstant\n:\n \ntrue\n,\n\n            \ninputs\n:\n \n[\n\n              \n{\n\n                \nname\n:\n \na\n,\n\n                \ntype\n:\n \nuint256\n\n              \n}\n\n            \n],\n\n            \nname\n:\n \nmultiply\n,\n\n            \noutputs\n:\n \n[\n\n              \n{\n\n                \nname\n:\n \nd\n,\n\n                \ntype\n:\n \nuint256\n\n              \n}\n\n            \n],\n\n            \ntype\n:\n \nfunction\n\n          \n}\n\n        \n],\n\n        \nuserDoc\n:\n \n{\n\n          \nmethods\n:\n \n{}\n\n        \n},\n\n        \ndeveloperDoc\n:\n \n{\n\n          \nmethods\n:\n \n{}\n\n        \n}\n\n      \n}\n\n\n\n}\n\n\n\n\n\n\n\neth_compileLLL\n\n\nReturns compiled LLL code.\n\n\nParameters\n\n\n\n\nString\n - The source code.\n\n\n\n\nparams\n:\n \n[\n\n   \n(returnlll (suicide (caller)))\n,\n\n\n]\n\n\n\n\n\nReturns\n\n\nDATA\n - The compiled source code.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_compileLLL\n,\nparams\n:[\n(returnlll (suicide (caller)))\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056\n \n// the compiled source code\n\n\n}\n\n\n\n\n\n\n\neth_compileSerpent\n\n\nReturns compiled serpent code.\n\n\nParameters\n\n\n\n\nString\n - The source code.\n\n\n\n\nparams\n:\n \n[\n\n   \n/* some serpent */\n,\n\n\n]\n\n\n\n\n\nReturns\n\n\nDATA\n - The compiled source code.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_compileSerpent\n,\nparams\n:[\n/* some serpent */\n],\nid\n:1}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056\n \n// the compiled source code\n\n\n}\n\n\n\n\n\n\n\neth_newFilter\n\n\nCreates a filter object, based on filter options, to notify when the state changes (logs).\nTo check if the state has changed, call \neth_getFilterChanges\n.\n\n\nA note on specifying topic filters:\n\n\nTopics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:\n\n \n[]\n \"anything\"\n\n \n[A]\n \"A in first position (and anything after)\"\n\n \n[null, B]\n \"anything in first position AND B in second position (and anything after)\"\n\n \n[A, B]\n \"A in first position AND B in second position (and anything after)\"\n* \n[[A, B], [A, B]]\n \"(A OR B) in first position AND (A OR B) in second position (and anything after)\"\n\n\nParameters\n\n\n\n\nObject\n - The filter options:\n\n\nfromBlock\n: \nQUANTITY|TAG\n - (optional, default: \n\"latest\"\n) Integer block number, or \n\"latest\"\n for the last mined block or \n\"pending\"\n, \n\"earliest\"\n for not yet mined transactions.\n\n\ntoBlock\n: \nQUANTITY|TAG\n - (optional, default: \n\"latest\"\n) Integer block number, or \n\"latest\"\n for the last mined block or \n\"pending\"\n, \n\"earliest\"\n for not yet mined transactions.\n\n\naddress\n: \nDATA|Array\n, 20 Bytes - (optional) Contract address or a list of addresses from which logs should originate.\n\n\ntopics\n: \nArray of DATA\n,  - (optional) Array of 32 Bytes \nDATA\n topics. Topics are order-dependent. Each topic can also be an array of DATA with \"or\" options.\n\n\n\n\nparams\n:\n \n[{\n\n  \nfromBlock\n:\n \n0x1\n,\n\n  \ntoBlock\n:\n \n0x2\n,\n\n  \naddress\n:\n \n0x8888f1f195afa192cfee860698584c030f4c9db1\n,\n\n  \ntopics\n:\n \n[\n0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\n,\n \nnull\n,\n \n[\n0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\n,\n \n0x0000000000000000000000000aff3454fce5edbc8cca8697c15331677e6ebccc\n]]\n\n\n}]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - A filter id.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_newFilter\n,\nparams\n:[{\ntopics\n:[\n0x12341234\n]}],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0x1\n \n// 1\n\n\n}\n\n\n\n\n\n\n\neth_newBlockFilter\n\n\nCreates a filter in the node, to notify when a new block arrives.\nTo check if the state has changed, call \neth_getFilterChanges\n.\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nQUANTITY\n - A filter id.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_newBlockFilter\n,\nparams\n:[],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n  \n2.0\n,\n\n  \nresult\n:\n \n0x1\n \n// 1\n\n\n}\n\n\n\n\n\n\n\neth_newPendingTransactionFilter\n\n\nCreates a filter in the node, to notify when new pending transactions arrive.\nTo check if the state has changed, call \neth_getFilterChanges\n.\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nQUANTITY\n - A filter id.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_newPendingTransactionFilter\n,\nparams\n:[],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n  \n2.0\n,\n\n  \nresult\n:\n \n0x1\n \n// 1\n\n\n}\n\n\n\n\n\n\n\neth_uninstallFilter\n\n\nUninstalls a filter with given id. Should always be called when watch is no longer needed.\nAdditonally Filters timeout when they aren't requested with \neth_getFilterChanges\n for a period of time.\n\n\nParameters\n\n\n\n\nQUANTITY\n - The filter id.\n\n\n\n\nparams\n:\n \n[\n\n  \n0xb\n \n// 11\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - \ntrue\n if the filter was successfully uninstalled, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_uninstallFilter\n,\nparams\n:[\n0xb\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\neth_getFilterChanges\n\n\nPolling method for a filter, which returns an array of logs which occurred since last poll.\n\n\nParameters\n\n\n\n\nQUANTITY\n - the filter id.\n\n\n\n\nparams\n:\n \n[\n\n  \n0x16\n \n// 22\n\n\n]\n\n\n\n\n\nReturns\n\n\nArray\n - Array of log objects, or an empty array if nothing has changed since last poll.\n\n\n\n\nFor filters created with \neth_newBlockFilter\n the return are block hashes (\nDATA\n, 32 Bytes), e.g. \n[\"0x3454645634534...\"]\n.\n\n\nFor filters created with \neth_newPendingTransactionFilter\n the return are transaction hashes (\nDATA\n, 32 Bytes), e.g. \n[\"0x6345343454645...\"]\n.\n\n\n\n\nFor filters created with \neth_newFilter\n logs are objects with following params:\n\n\n\n\n\n\nremoved\n: \nTAG\n - \ntrue\n when the log was removed, due to a chain reorganization. \nfalse\n if its a valid log.\n\n\n\n\nlogIndex\n: \nQUANTITY\n - integer of the log index position in the block. \nnull\n when its pending log.\n\n\ntransactionIndex\n: \nQUANTITY\n - integer of the transactions index position log was created from. \nnull\n when its pending log.\n\n\ntransactionHash\n: \nDATA\n, 32 Bytes - hash of the transactions this log was created from. \nnull\n when its pending log.\n\n\nblockHash\n: \nDATA\n, 32 Bytes - hash of the block where this log was in. \nnull\n when its pending. \nnull\n when its pending log.\n\n\nblockNumber\n: \nQUANTITY\n - the block number where this log was in. \nnull\n when its pending. \nnull\n when its pending log.\n\n\naddress\n: \nDATA\n, 20 Bytes - address from which this log originated.\n\n\ndata\n: \nDATA\n - contains one or more 32 Bytes non-indexed arguments of the log.\n\n\ntopics\n: \nArray of DATA\n - Array of 0 to 4 32 Bytes \nDATA\n of indexed log arguments. (In \nsolidity\n: The first topic is the \nhash\n of the signature of the event (e.g. \nDeposit(address,bytes32,uint256)\n), except you declared the event with the \nanonymous\n specifier.)\n\n\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getFilterChanges\n,\nparams\n:[\n0x16\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \n[{\n\n    \nlogIndex\n:\n \n0x1\n,\n \n// 1\n\n    \nblockNumber\n:\n0x1b4\n \n// 436\n\n    \nblockHash\n:\n \n0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\n,\n\n    \ntransactionHash\n:\n  \n0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcf\n,\n\n    \ntransactionIndex\n:\n \n0x0\n,\n \n// 0\n\n    \naddress\n:\n \n0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\n,\n\n    \ndata\n:\n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n\n    \ntopics\n:\n \n[\n0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\n]\n\n    \n},{\n\n      \n...\n\n    \n}]\n\n\n}\n\n\n\n\n\n\n\neth_getFilterLogs\n\n\nReturns an array of all logs matching filter with given id.\n\n\nParameters\n\n\n\n\nQUANTITY\n - The filter id.\n\n\n\n\nparams\n:\n \n[\n\n  \n0x16\n \n// 22\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \neth_getFilterChanges\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getFilterLogs\n,\nparams\n:[\n0x16\n],\nid\n:74}\n\n\n\n\n\nResult see \neth_getFilterChanges\n\n\n\n\neth_getLogs\n\n\nReturns an array of all logs matching a given filter object.\n\n\nParameters\n\n\n\n\nObject\n - the filter object, see \neth_newFilter parameters\n.\n\n\n\n\nparams\n:\n \n[{\n\n  \ntopics\n:\n \n[\n0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\n]\n\n\n}]\n\n\n\n\n\nReturns\n\n\nSee \neth_getFilterChanges\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getLogs\n,\nparams\n:[{\ntopics\n:[\n0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\n]}],\nid\n:74}\n\n\n\n\n\nResult see \neth_getFilterChanges\n\n\n\n\neth_getWork\n\n\nReturns the hash of the current block, the seedHash, and the boundary condition to be met (\"target\").\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nArray\n - Array with the following properties:\n  1. \nDATA\n, 32 Bytes - current block header pow-hash\n  2. \nDATA\n, 32 Bytes - the seed hash used for the DAG.\n  3. \nDATA\n, 32 Bytes - the boundary condition (\"target\"), 2^256 / difficulty.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\neth_getWork\n,\nparams\n:[],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \n[\n\n      \n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n,\n\n      \n0x5EED00000000000000000000000000005EED0000000000000000000000000000\n,\n\n      \n0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\n\n    \n]\n\n\n}\n\n\n\n\n\n\n\neth_submitWork\n\n\nUsed for submitting a proof-of-work solution.\n\n\nParameters\n\n\n\n\nDATA\n, 8 Bytes - The nonce found (64 bits)\n\n\nDATA\n, 32 Bytes - The header's pow-hash (256 bits)\n\n\nDATA\n, 32 Bytes - The mix digest (256 bits)\n\n\n\n\nparams\n:\n \n[\n\n  \n0x0000000000000001\n,\n\n  \n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n,\n\n  \n0xD1FE5700000000000000000000000000D1FE5700000000000000000000000000\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the provided solution is valid, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n, \nmethod\n:\neth_submitWork\n, \nparams\n:[\n0x0000000000000001\n, \n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n, \n0xD1GE5700000000000000000000000000D1GE5700000000000000000000000000\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n73\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\neth_submitHashrate\n\n\nUsed for submitting mining hashrate.\n\n\nParameters\n\n\n\n\nHashrate\n, a hexadecimal string representation (32 bytes) of the hash rate\n\n\nID\n, String - A random hexadecimal(32 bytes) ID identifying the client\n\n\n\n\nparams\n:\n \n[\n\n  \n0x0000000000000000000000000000000000000000000000000000000000500000\n,\n\n  \n0x59daa26581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if submitting went through succesfully and \nfalse\n otherwise.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n, \nmethod\n:\neth_submitHashrate\n, \nparams\n:[\n0x0000000000000000000000000000000000000000000000000000000000500000\n, \n0x59daa26581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n73\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\ndb_putString\n\n\nStores a string in the local database.\n\n\nNote\n this function is deprecated and will be removed in the future.\n\n\nParameters\n\n\n\n\nString\n - Database name.\n\n\nString\n - Key name.\n\n\nString\n - String to store.\n\n\n\n\nparams\n:\n \n[\n\n  \ntestDB\n,\n\n  \nmyKey\n,\n\n  \nmyString\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the value was stored, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\ndb_putString\n,\nparams\n:[\ntestDB\n,\nmyKey\n,\nmyString\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\ndb_getString\n\n\nReturns string from the local database.\n\n\nNote\n this function is deprecated and will be removed in the future.\n\n\nParameters\n\n\n\n\nString\n - Database name.\n\n\nString\n - Key name.\n\n\n\n\nparams\n:\n \n[\n\n  \ntestDB\n,\n\n  \nmyKey\n,\n\n\n]\n\n\n\n\n\nReturns\n\n\nString\n - The previously stored string.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\ndb_getString\n,\nparams\n:[\ntestDB\n,\nmyKey\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \nmyString\n\n\n}\n\n\n\n\n\n\n\ndb_putHex\n\n\nStores binary data in the local database.\n\n\nNote\n this function is deprecated and will be removed in the future.\n\n\nParameters\n\n\n\n\nString\n - Database name.\n\n\nString\n - Key name.\n\n\nDATA\n - The data to store.\n\n\n\n\nparams\n:\n \n[\n\n  \ntestDB\n,\n\n  \nmyKey\n,\n\n  \n0x68656c6c6f20776f726c64\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the value was stored, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\ndb_putHex\n,\nparams\n:[\ntestDB\n,\nmyKey\n,\n0x68656c6c6f20776f726c64\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\ndb_getHex\n\n\nReturns binary data from the local database.\n\n\nNote\n this function is deprecated and will be removed in the future.\n\n\nParameters\n\n\n\n\nString\n - Database name.\n\n\nString\n - Key name.\n\n\n\n\nparams\n:\n \n[\n\n  \ntestDB\n,\n\n  \nmyKey\n,\n\n\n]\n\n\n\n\n\nReturns\n\n\nDATA\n - The previously stored data.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\ndb_getHex\n,\nparams\n:[\ntestDB\n,\nmyKey\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \n0x68656c6c6f20776f726c64\n\n\n}\n\n\n\n\n\n\n\nshh_version\n\n\nReturns the current whisper protocol version.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nString\n - The current whisper protocol version\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_version\n,\nparams\n:[],\nid\n:67}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n67\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n2\n\n\n}\n\n\n\n\n\n\n\nshh_post\n\n\nSends a whisper message.\n\n\nParameters\n\n\n\n\nObject\n - The whisper post object:\n\n\nfrom\n: \nDATA\n, 60 Bytes - (optional) The identity of the sender.\n\n\nto\n: \nDATA\n, 60 Bytes - (optional) The identity of the receiver. When present whisper will encrypt the message so that only the receiver can decrypt it.\n\n\ntopics\n: \nArray of DATA\n - Array of \nDATA\n topics, for the receiver to identify messages.\n\n\npayload\n: \nDATA\n - The payload of the message.\n\n\npriority\n: \nQUANTITY\n - The integer of the priority in a rang from ... (?).\n\n\nttl\n: \nQUANTITY\n - integer of the time to live in seconds.\n\n\n\n\nparams\n:\n \n[{\n\n  \nfrom\n:\n \n0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1\n,\n\n  \nto\n:\n \n0x3e245533f97284d442460f2998cd41858798ddf04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a0d4d661997d3940272b717b1\n,\n\n  \ntopics\n:\n \n[\n0x776869737065722d636861742d636c69656e74\n,\n \n0x4d5a695276454c39425154466b61693532\n],\n\n  \npayload\n:\n \n0x7b2274797065223a226d6\n,\n\n  \npriority\n:\n \n0x64\n,\n\n  \nttl\n:\n \n0x64\n,\n\n\n}]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the message was send, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_post\n,\nparams\n:[{\nfrom\n:\n0xc931d93e97ab07fe42d923478ba2465f2..\n,\ntopics\n: [\n0x68656c6c6f20776f726c64\n],\npayload\n:\n0x68656c6c6f20776f726c64\n,\nttl\n:0x64,\npriority\n:0x64}],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nshh_newIdentity\n\n\nCreates new whisper identity in the client.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nDATA\n, 60 Bytes - the address of the new identiy.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_newIdentity\n,\nparams\n:[],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xc931d93e97ab07fe42d923478ba2465f283f440fd6cabea4dd7a2c807108f651b7135d1d6ca9007d5b68aa497e4619ac10aa3b27726e1863c1fd9b570d99bbaf\n\n\n}\n\n\n\n\n\n\n\nshh_hasIdentity\n\n\nChecks if the client hold the private keys for a given identity.\n\n\nParameters\n\n\n\n\nDATA\n, 60 Bytes - The identity address to check.\n\n\n\n\nparams\n:\n \n[\n\n  \n0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the client holds the privatekey for that identity, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_hasIdentity\n,\nparams\n:[\n0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nshh_newGroup\n\n\n(?)\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nDATA\n, 60 Bytes - the address of the new group. (?)\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_newIdentity\n,\nparams\n:[],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \n0xc65f283f440fd6cabea4dd7a2c807108f651b7135d1d6ca90931d93e97ab07fe42d923478ba2407d5b68aa497e4619ac10aa3b27726e1863c1fd9b570d99bbaf\n\n\n}\n\n\n\n\n\n\n\nshh_addToGroup\n\n\n(?)\n\n\nParameters\n\n\n\n\nDATA\n, 60 Bytes - The identity address to add to a group (?).\n\n\n\n\nparams\n:\n \n[\n\n  \n0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - returns \ntrue\n if the identity was successfully added to the group, otherwise \nfalse\n (?).\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_hasIdentity\n,\nparams\n:[\n0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n \n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nshh_newFilter\n\n\nCreates filter to notify, when client receives whisper message matching the filter options.\n\n\nParameters\n\n\n\n\nObject\n - The filter options:\n\n\nto\n: \nDATA\n, 60 Bytes - (optional) Identity of the receiver. \nWhen present it will try to decrypt any incoming message if the client holds the private key to this identity.\n\n\ntopics\n: \nArray of DATA\n - Array of \nDATA\n topics which the incoming message's topics should match.  You can use the following combinations:\n\n\n[A, B] = A \n B\n\n\n[A, [B, C]] = A \n (B || C)\n\n\n[null, A, B] = ANYTHING \n A \n B\n \nnull\n works as a wildcard\n\n\n\n\n\n\n\n\nparams\n:\n \n[{\n\n   \ntopics\n:\n \n[\n0x12341234bf4b564f\n],\n\n   \nto\n:\n \n0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1\n\n\n}]\n\n\n\n\n\nReturns\n\n\nQUANTITY\n - The newly created filter.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_newFilter\n,\nparams\n:[{\ntopics\n: [\n0x12341234bf4b564f\n],\nto\n: \n0x2341234bf4b2341234bf4b564f...\n}],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \n0x7\n \n// 7\n\n\n}\n\n\n\n\n\n\n\nshh_uninstallFilter\n\n\nUninstalls a filter with given id. Should always be called when watch is no longer needed.\nAdditonally Filters timeout when they aren't requested with \nshh_getFilterChanges\n for a period of time.\n\n\nParameters\n\n\n\n\nQUANTITY\n - The filter id.\n\n\n\n\nparams\n:\n \n[\n\n  \n0x7\n \n// 7\n\n\n]\n\n\n\n\n\nReturns\n\n\nBoolean\n - \ntrue\n if the filter was successfully uninstalled, otherwise \nfalse\n.\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_uninstallFilter\n,\nparams\n:[\n0x7\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nshh_getFilterChanges\n\n\nPolling method for whisper filters. Returns new messages since the last call of this method.\n\n\nNote\n calling the \nshh_getMessages\n method, will reset the buffer for this method, so that you won't receive duplicate messages.\n\n\nParameters\n\n\n\n\nQUANTITY\n - The filter id.\n\n\n\n\nparams\n:\n \n[\n\n  \n0x7\n \n// 7\n\n\n]\n\n\n\n\n\nReturns\n\n\nArray\n - Array of messages received since last poll:\n\n\n\n\nhash\n: \nDATA\n, 32 Bytes (?) - The hash of the message.\n\n\nfrom\n: \nDATA\n, 60 Bytes - The sender of the message, if a sender was specified.\n\n\nto\n: \nDATA\n, 60 Bytes - The receiver of the message, if a receiver was specified.\n\n\nexpiry\n: \nQUANTITY\n - Integer of the time in seconds when this message should expire (?).\n\n\nttl\n: \nQUANTITY\n -  Integer of the time the message should float in the system in seconds (?).\n\n\nsent\n: \nQUANTITY\n -  Integer of the unix timestamp when the message was sent.\n\n\ntopics\n: \nArray of DATA\n - Array of \nDATA\n topics the message contained.\n\n\npayload\n: \nDATA\n - The payload of the message.\n\n\nworkProved\n: \nQUANTITY\n - Integer of the work this message required before it was send (?).\n\n\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_getFilterChanges\n,\nparams\n:[\n0x7\n],\nid\n:73}\n\n\n\n// Result\n\n\n{\n\n  \nid\n:\n1\n,\n\n  \njsonrpc\n:\n2.0\n,\n\n  \nresult\n:\n \n[{\n\n    \nhash\n:\n \n0x33eb2da77bf3527e28f8bf493650b1879b08c4f2a362beae4ba2f71bafcd91f9\n,\n\n    \nfrom\n:\n \n0x3ec052fc33..\n,\n\n    \nto\n:\n \n0x87gdf76g8d7fgdfg...\n,\n\n    \nexpiry\n:\n \n0x54caa50a\n,\n \n// 1422566666\n\n    \nsent\n:\n \n0x54ca9ea2\n,\n \n// 1422565026\n\n    \nttl\n:\n \n0x64\n \n// 100\n\n    \ntopics\n:\n \n[\n0x6578616d\n],\n\n    \npayload\n:\n \n0x7b2274797065223a226d657373616765222c2263686...\n,\n\n    \nworkProved\n:\n \n0x0\n\n    \n}]\n\n\n}\n\n\n\n\n\n\n\nshh_getMessages\n\n\nGet all messages matching a filter. Unlike \nshh_getFilterChanges\n this returns all messages.\n\n\nParameters\n\n\n\n\nQUANTITY\n - The filter id.\n\n\n\n\nparams\n:\n \n[\n\n  \n0x7\n \n// 7\n\n\n]\n\n\n\n\n\nReturns\n\n\nSee \nshh_getFilterChanges\n\n\nExample\n\n\n// Request\n\n\ncurl\n \n-\nX\n \nPOST\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\nshh_getMessages\n,\nparams\n:[\n0x7\n],\nid\n:73}\n\n\n\n\n\nResult see \nshh_getFilterChanges", 
            "title": "JSON RPC API"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#json-rpc-api", 
            "text": "JSON  is a lightweight data-interchange format. It can represent numbers, strings, ordered sequences of values, and collections of name/value pairs.  JSON-RPC  is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over HTTP, or in many various message passing environments. It uses JSON ( RFC 4627 ) as data format.  Geth 1.4 has experimental pub/sub support. See  this  page for more information.  Parity 1.6 has experimental pub/sub support See  this  for more information.", 
            "title": "JSON RPC API"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#javascript-api", 
            "text": "To talk to an ethereum node from inside a JavaScript application use the  web3.js  library, which gives a convenient interface for the RPC methods.\nSee the  JavaScript API  for more.", 
            "title": "JavaScript API"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#json-rpc-endpoint", 
            "text": "Default JSON-RPC endpoints:     Client  URL      C++  http://localhost:8545    Go  http://localhost:8545    Py  http://localhost:4000    Parity  http://localhost:8545", 
            "title": "JSON-RPC Endpoint"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#go", 
            "text": "You can start the HTTP JSON-RPC with the  --rpc  flag geth --rpc  change the default port (8545) and listing address (localhost) with:  geth --rpc --rpcaddr  ip  --rpcport  portnumber   If accessing the RPC from a browser, CORS will need to be enabled with the appropriate domain set. Otherwise, JavaScript calls are limit by the same-origin policy and requests will fail:  geth --rpc --rpccorsdomain  http://localhost:3000   The JSON RPC can also be started from the  geth console  using the  admin.startRPC(addr, port)  command.", 
            "title": "Go"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#c", 
            "text": "You can start it by running  eth  application with  -j  option: ./eth -j  You can also specify JSON-RPC port (default is 8545): ./eth -j --json-rpc-port  8079", 
            "title": "C++"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#python", 
            "text": "In python the JSONRPC server is currently started by default and listens on  127.0.0.1:4000  You can change the port and listen address by giving a config option.  pyethapp -c jsonrpc.listen_port=4002 -c jsonrpc.listen_host=127.0.0.2 run", 
            "title": "Python"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#json-rpc-support", 
            "text": "cpp-ethereum  go-ethereum  py-ethereum  parity      JSON-RPC 1.0        JSON-RPC 2.0        Batch requests        HTTP        IPC        WS", 
            "title": "JSON-RPC support"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#hex-value-encoding", 
            "text": "At present there are two key datatypes that are passed over JSON: unformatted byte arrays and quantities. Both are passed with a hex encoding, however with different requirements to formatting:  When encoding  QUANTITIES  (integers, numbers): encode as hex, prefix with \"0x\", the most compact representation (slight exception: zero should be represented as \"0x0\"). Examples:\n- 0x41 (65 in decimal)\n- 0x400 (1024 in decimal)\n- WRONG: 0x (should always have at least one digit - zero is \"0x0\")\n- WRONG: 0x0400 (no leading zeroes allowed)\n- WRONG: ff (must be prefixed 0x)  When encoding  UNFORMATTED DATA  (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with \"0x\", two hex digits per byte. Examples:\n- 0x41 (size 1, \"A\")\n- 0x004200 (size 3, \"\\0B\\0\")\n- 0x (size 0, \"\")\n- WRONG: 0xf0f0f (must be even number of digits)\n- WRONG: 004200 (must be prefixed 0x)  Currently  cpp-ethereum , go-ethereum , and  parity  provide JSON-RPC communication over http and IPC (unix socket Linux and OSX/named pipes on Windows). Version 1.4 of go-ethereum and version 1.6 of Parity onwards have websocket support.", 
            "title": "HEX value encoding"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#the-default-block-parameter", 
            "text": "The following methods have an extra default block parameter:   eth_getBalance  eth_getCode  eth_getTransactionCount  eth_getStorageAt  eth_call   When requests are made that act on the state of ethereum, the last default block parameter determines the height of the block.  The following options are possible for the defaultBlock parameter:   HEX String  - an integer block number  String \"earliest\"  for the earliest/genesis block  String \"latest\"  - for the latest mined block  String \"pending\"  - for the pending state/transactions", 
            "title": "The default block parameter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#curl-examples-explained", 
            "text": "The curl options below might return a response where the node complains about the content type, this is because the --data option sets the content type to application/x-www-form-urlencoded . If your node does complain, manually set the header by placing -H \"Content-Type: application/json\" at the start of the call.  The examples also do not include the URL/IP   port combination which must be the last argument given to curl e.x. 127.0.0.1:8545", 
            "title": "Curl Examples Explained"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#json-rpc-methods", 
            "text": "web3_clientVersion  web3_sha3  net_version  net_peerCount  net_listening  eth_protocolVersion  eth_syncing  eth_coinbase  eth_mining  eth_hashrate  eth_gasPrice  eth_accounts  eth_blockNumber  eth_getBalance  eth_getStorageAt  eth_getTransactionCount  eth_getBlockTransactionCountByHash  eth_getBlockTransactionCountByNumber  eth_getUncleCountByBlockHash  eth_getUncleCountByBlockNumber  eth_getCode  eth_sign  eth_sendTransaction  eth_sendRawTransaction  eth_call  eth_estimateGas  eth_getBlockByHash  eth_getBlockByNumber  eth_getTransactionByHash  eth_getTransactionByBlockHashAndIndex  eth_getTransactionByBlockNumberAndIndex  eth_getTransactionReceipt  eth_getUncleByBlockHashAndIndex  eth_getUncleByBlockNumberAndIndex  eth_getCompilers  eth_compileLLL  eth_compileSolidity  eth_compileSerpent  eth_newFilter  eth_newBlockFilter  eth_newPendingTransactionFilter  eth_uninstallFilter  eth_getFilterChanges  eth_getFilterLogs  eth_getLogs  eth_getWork  eth_submitWork  eth_submitHashrate  db_putString  db_getString  db_putHex  db_getHex  shh_post  shh_version  shh_newIdentity  shh_hasIdentity  shh_newGroup  shh_addToGroup  shh_newFilter  shh_uninstallFilter  shh_getFilterChanges  shh_getMessages", 
            "title": "JSON-RPC methods"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#json-rpc-api-reference", 
            "text": "", 
            "title": "JSON RPC API Reference"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#web3_clientversion", 
            "text": "Returns the current client version.", 
            "title": "web3_clientVersion"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns", 
            "text": "String  - The current client version", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : web3_clientVersion , params :[], id :67}  // Result  { \n   id : 67 , \n   jsonrpc : 2.0 , \n   result :   Mist/v0.9.3/darwin/go1.4.1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#web3_sha3", 
            "text": "Returns Keccak-256 ( not  the standardized SHA3-256) of the given data.", 
            "title": "web3_sha3"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_1", 
            "text": "DATA  - the data to convert into a SHA3 hash   params :   [ \n   0x68656c6c6f20776f726c64  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_1", 
            "text": "DATA  - The SHA3 result of the given string.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_1", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : web3_sha3 , params :[ 0x68656c6c6f20776f726c64 ], id :64}  // Result  { \n   id : 64 , \n   jsonrpc :   2.0 , \n   result :   0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#net_version", 
            "text": "Returns the current network id.", 
            "title": "net_version"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_2", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_2", 
            "text": "String  - The current network id.\n-  \"1\" : Ethereum Mainnet\n-  \"2\" : Morden Testnet  (deprecated)\n-  \"3\" : Ropsten Testnet\n-  \"4\" : Rinkeby Testnet\n-  \"42\" : Kovan Testnet", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_2", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : net_version , params :[], id :67}  // Result  { \n   id : 67 , \n   jsonrpc :   2.0 , \n   result :   3  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#net_listening", 
            "text": "Returns  true  if client is actively listening for network connections.", 
            "title": "net_listening"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_3", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_3", 
            "text": "Boolean  -  true  when listening, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_3", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : net_listening , params :[], id :67}  // Result  { \n   id : 67 , \n   jsonrpc : 2.0 , \n   result : true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#net_peercount", 
            "text": "Returns number of peers currently connected to the client.", 
            "title": "net_peerCount"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_4", 
            "text": "QUANTITY  - integer of the number of connected peers.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_4", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : net_peerCount , params :[], id :74}  // Result  { \n   id : 74 , \n   jsonrpc :   2.0 , \n   result :   0x2   // 2  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_protocolversion", 
            "text": "Returns the current ethereum protocol version.", 
            "title": "eth_protocolVersion"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_5", 
            "text": "String  - The current ethereum protocol version", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_5", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_protocolVersion , params :[], id :67}  // Result  { \n   id : 67 , \n   jsonrpc :   2.0 , \n   result :   54  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_syncing", 
            "text": "Returns an object with data about the sync status or  false .", 
            "title": "eth_syncing"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_6", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_6", 
            "text": "Object|Boolean , An object with sync status data or  FALSE , when not syncing:\n  -  startingBlock :  QUANTITY  - The block at which the import started (will only be reset, after the sync reached his head)\n  -  currentBlock :  QUANTITY  - The current block, same as eth_blockNumber\n  -  highestBlock :  QUANTITY  - The estimated highest block", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_6", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_syncing , params :[], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   { \n     startingBlock :   0x384 , \n     currentBlock :   0x386 , \n     highestBlock :   0x454 \n   }  }  // Or when not syncing  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   false  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_coinbase", 
            "text": "Returns the client coinbase address.", 
            "title": "eth_coinbase"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_7", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_7", 
            "text": "DATA , 20 bytes - the current coinbase address.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_7", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_coinbase , params :[], id :64}  // Result  { \n   id : 64 , \n   jsonrpc :   2.0 , \n   result :   0x407d73d8a49eeb85d32cf465507dd71d507100c1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_mining", 
            "text": "Returns  true  if client is actively mining new blocks.", 
            "title": "eth_mining"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_8", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_8", 
            "text": "Boolean  - returns  true  of the client is mining, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_8", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_mining , params :[], id :71}  // Result  { \n   id : 71 , \n   jsonrpc :   2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_hashrate", 
            "text": "Returns the number of hashes per second that the node is mining with.", 
            "title": "eth_hashrate"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_9", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_9", 
            "text": "QUANTITY  - number of hashes per second.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_9", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_hashrate , params :[], id :71}  // Result  { \n   id : 71 , \n   jsonrpc :   2.0 , \n   result :   0x38a  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_gasprice", 
            "text": "Returns the current price per gas in wei.", 
            "title": "eth_gasPrice"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_10", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_10", 
            "text": "QUANTITY  - integer of the current gas price in wei.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_10", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_gasPrice , params :[], id :73}  // Result  { \n   id : 73 , \n   jsonrpc :   2.0 , \n   result :   0x09184e72a000   // 10000000000000  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_accounts", 
            "text": "Returns a list of addresses owned by client.", 
            "title": "eth_accounts"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_11", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_11", 
            "text": "Array of DATA , 20 Bytes - addresses owned by the client.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_11", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_accounts , params :[], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   [ 0x407d73d8a49eeb85d32cf465507dd71d507100c1 ]  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_blocknumber", 
            "text": "Returns the number of most recent block.", 
            "title": "eth_blockNumber"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_12", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_12", 
            "text": "QUANTITY  - integer of the current block number the client is on.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_12", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_blockNumber , params :[], id :83}  // Result  { \n   id : 83 , \n   jsonrpc :   2.0 , \n   result :   0x4b7   // 1207  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getbalance", 
            "text": "Returns the balance of the account of given address.", 
            "title": "eth_getBalance"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_13", 
            "text": "DATA , 20 Bytes - address to check for balance.  QUANTITY|TAG  - integer block number, or the string  \"latest\" ,  \"earliest\"  or  \"pending\" , see the  default block parameter   params :   [ \n    0x407d73d8a49eeb85d32cf465507dd71d507100c1 , \n    latest  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_13", 
            "text": "QUANTITY  - integer of the current balance in wei.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_13", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getBalance , params :[ 0x407d73d8a49eeb85d32cf465507dd71d507100c1 ,  latest ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x0234c8a3397aab58   // 158972490234375000  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getstorageat", 
            "text": "Returns the value from a storage position at a given address.", 
            "title": "eth_getStorageAt"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_14", 
            "text": "DATA , 20 Bytes - address of the storage.  QUANTITY  - integer of the position in the storage.  QUANTITY|TAG  - integer block number, or the string  \"latest\" ,  \"earliest\"  or  \"pending\" , see the  default block parameter", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_14", 
            "text": "DATA  - the value at this storage position.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_14", 
            "text": "Calculating the correct position depends on the storage to retrieve. Consider the following contract deployed at  0x295a70b2de5e3953354a6a8344e616ed314d7251  by address  0x391694e7e0b0cce554cb130d723a9d27458f9298 .  contract Storage {\n    uint pos0;\n    mapping(address =  uint) pos1;\n\n    function Storage() {\n        pos0 = 1234;\n        pos1[msg.sender] = 5678;\n    }\n}  Retrieving the value of pos0 is straight forward:  curl   - X   POST   -- data   { jsonrpc : 2.0 ,  method :  eth_getStorageAt ,  params : [ 0x295a70b2de5e3953354a6a8344e616ed314d7251 ,  0x0 ,  latest ],  id : 1}   localhost : 8545  { jsonrpc : 2.0 , id : 1 , result : 0x00000000000000000000000000000000000000000000000000000000000004d2 }   Retrieving an element of the map is harder. The position of an element in the map is calculated with: keccack ( LeftPad32 ( key ,   0 ),   LeftPad32 ( map   position ,   0 ))   This means to retrieve the storage on pos1[\"0x391694e7e0b0cce554cb130d723a9d27458f9298\"] we need to calculate the position with: keccak ( decodeHex ( 000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298   +   0000000000000000000000000000000000000000000000000000000000000001 ))  \nThe geth console which comes with the web3 library can be used to make the calculation:   var   key   =   000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298   +   0000000000000000000000000000000000000000000000000000000000000001  undefined    web3 . sha3 ( key ,   { encoding :   hex })  0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9  \nNow to fetch the storage: curl   - X   POST   -- data   { jsonrpc : 2.0 ,  method :  eth_getStorageAt ,  params : [ 0x295a70b2de5e3953354a6a8344e616ed314d7251 ,  0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9 ,  latest ],  id : 1}   localhost : 8545  { jsonrpc : 2.0 , id : 1 , result : 0x000000000000000000000000000000000000000000000000000000000000162e }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_gettransactioncount", 
            "text": "Returns the number of transactions  sent  from an address.", 
            "title": "eth_getTransactionCount"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_15", 
            "text": "DATA , 20 Bytes - address.  QUANTITY|TAG  - integer block number, or the string  \"latest\" ,  \"earliest\"  or  \"pending\" , see the  default block parameter   params :   [ \n    0x407d73d8a49eeb85d32cf465507dd71d507100c1 , \n    latest   // state at the latest block  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_15", 
            "text": "QUANTITY  - integer of the number of transactions send from this address.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_15", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getTransactionCount , params :[ 0x407d73d8a49eeb85d32cf465507dd71d507100c1 , latest ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x1   // 1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getblocktransactioncountbyhash", 
            "text": "Returns the number of transactions in a block from a block matching the given block hash.", 
            "title": "eth_getBlockTransactionCountByHash"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_16", 
            "text": "DATA , 32 Bytes - hash of a block   params :   [ \n    0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_16", 
            "text": "QUANTITY  - integer of the number of transactions in this block.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_16", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getBlockTransactionCountByHash , params :[ 0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238 ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xb   // 11  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getblocktransactioncountbynumber", 
            "text": "Returns the number of transactions in a block matching the given block number.", 
            "title": "eth_getBlockTransactionCountByNumber"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_17", 
            "text": "QUANTITY|TAG  - integer of a block number, or the string  \"earliest\" ,  \"latest\"  or  \"pending\" , as in the  default block parameter .   params :   [ \n    0xe8 ,   // 232  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_17", 
            "text": "QUANTITY  - integer of the number of transactions in this block.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_17", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getBlockTransactionCountByNumber , params :[ 0xe8 ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xa   // 10  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getunclecountbyblockhash", 
            "text": "Returns the number of uncles in a block from a block matching the given block hash.", 
            "title": "eth_getUncleCountByBlockHash"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_18", 
            "text": "DATA , 32 Bytes - hash of a block   params :   [ \n    0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_18", 
            "text": "QUANTITY  - integer of the number of uncles in this block.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_18", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getUncleCountByBlockHash , params :[ 0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238 ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x1   // 1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getunclecountbyblocknumber", 
            "text": "Returns the number of uncles in a block from a block matching the given block number.", 
            "title": "eth_getUncleCountByBlockNumber"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_19", 
            "text": "QUANTITY|TAG  - integer of a block number, or the string \"latest\", \"earliest\" or \"pending\", see the  default block parameter   params :   [ \n    0xe8 ,   // 232  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_19", 
            "text": "QUANTITY  - integer of the number of uncles in this block.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_19", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getUncleCountByBlockNumber , params :[ 0xe8 ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x1   // 1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getcode", 
            "text": "Returns code at a given address.", 
            "title": "eth_getCode"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_20", 
            "text": "DATA , 20 Bytes - address  QUANTITY|TAG  - integer block number, or the string  \"latest\" ,  \"earliest\"  or  \"pending\" , see the  default block parameter   params :   [ \n    0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b , \n    0x2    // 2  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_20", 
            "text": "DATA  - the code from the given address.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_20", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getCode , params :[ 0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b ,  0x2 ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x600160008035811a818181146012578301005b601b6001356025565b8060005260206000f25b600060078202905091905056  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_sign", 
            "text": "The sign method calculates an Ethereum specific signature with:  sign(keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))) .  By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.  Note  the address to sign with must be unlocked.", 
            "title": "eth_sign"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_21", 
            "text": "account, message   DATA , 20 Bytes - address  DATA , N Bytes - message to sign", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_21", 
            "text": "DATA : Signature", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_21", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_sign , params :[ 0x9b2055d370f73ec7d8a03e965129118dc8f5bf83 ,  0xdeadbeaf ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b  }   An example how to use solidity ecrecover to verify the signature calculated with  eth_sign  can be found  here . The contract is deployed on the testnet Ropsten and Rinkeby.", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_sendtransaction", 
            "text": "Creates new message call transaction or a contract creation, if the data field contains code.", 
            "title": "eth_sendTransaction"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_22", 
            "text": "Object  - The transaction object  from :  DATA , 20 Bytes - The address the transaction is send from.  to :  DATA , 20 Bytes - (optional when creating new contract) The address the transaction is directed to.  gas :  QUANTITY   - (optional, default: 90000) Integer of the gas provided for the transaction execution. It will return unused gas.  gasPrice :  QUANTITY   - (optional, default: To-Be-Determined) Integer of the gasPrice used for each paid gas  value :  QUANTITY   - (optional) Integer of the value send with this transaction  data :  DATA   - The compiled code of a contract OR the hash of the invoked method signature and encoded parameters. For details see  Ethereum Contract ABI  nonce :  QUANTITY   - (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.   params :   [{ \n   from :   0xb60e8dd61c5d32be8058bb8eb970870f07233155 , \n   to :   0xd46e8dd67c5d32be8058bb8eb970870f07244567 , \n   gas :   0x76c0 ,   // 30400 \n   gasPrice :   0x9184e72a000 ,   // 10000000000000 \n   value :   0x9184e72a ,   // 2441406250 \n   data :   0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675  }]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_22", 
            "text": "DATA , 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.  Use  eth_getTransactionReceipt  to get the contract address, after the transaction was mined, when you created a contract.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_22", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_sendTransaction , params :[{see above}], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_sendrawtransaction", 
            "text": "Creates new message call transaction or a contract creation for signed transactions.", 
            "title": "eth_sendRawTransaction"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_23", 
            "text": "DATA , The signed transaction data.   params :   [ 0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675 ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_23", 
            "text": "DATA , 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.  Use  eth_getTransactionReceipt  to get the contract address, after the transaction was mined, when you created a contract.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_23", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_sendRawTransaction , params :[{see above}], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_call", 
            "text": "Executes a new message call immediately without creating a transaction on the block chain.", 
            "title": "eth_call"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_24", 
            "text": "Object  - The transaction call object  from :  DATA , 20 Bytes - (optional) The address the transaction is sent from.  to :  DATA , 20 Bytes  - The address the transaction is directed to.  gas :  QUANTITY   - (optional) Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter may be needed by some executions.  gasPrice :  QUANTITY   - (optional) Integer of the gasPrice used for each paid gas  value :  QUANTITY   - (optional) Integer of the value send with this transaction  data :  DATA   - (optional) Hash of the method signature and encoded parameters. For details see  Ethereum Contract ABI  QUANTITY|TAG  - integer block number, or the string  \"latest\" ,  \"earliest\"  or  \"pending\" , see the  default block parameter", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_24", 
            "text": "DATA  - the return value of executed contract.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_24", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_call , params :[{see above}], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_estimategas", 
            "text": "Makes a call or transaction, which won't be added to the blockchain and returns the used gas, which can be used for estimating the used gas.", 
            "title": "eth_estimateGas"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_25", 
            "text": "See  eth_call  parameters, expect that all properties are optional. If no gas limit is specified geth uses the block gas limit from the pending block as an upper bound. As a result the returned estimate might not be enough to executed the call/transaction when the amount of gas is higher than the pending block gas limit.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_25", 
            "text": "QUANTITY  - the amount of gas used.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_25", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_estimateGas , params :[{see above}], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x5208   // 21000  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getblockbyhash", 
            "text": "Returns information about a block by hash.", 
            "title": "eth_getBlockByHash"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_26", 
            "text": "DATA , 32 Bytes - Hash of a block.  Boolean  - If  true  it returns the full transaction objects, if  false  only the hashes of the transactions.   params :   [ \n    0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 , \n    true  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_26", 
            "text": "Object  - A block object, or  null  when no block was found:   number :  QUANTITY  - the block number.  null  when its pending block.  hash :  DATA , 32 Bytes - hash of the block.  null  when its pending block.  parentHash :  DATA , 32 Bytes - hash of the parent block.  nonce :  DATA , 8 Bytes - hash of the generated proof-of-work.  null  when its pending block.  sha3Uncles :  DATA , 32 Bytes - SHA3 of the uncles data in the block.  logsBloom :  DATA , 256 Bytes - the bloom filter for the logs of the block.  null  when its pending block.  transactionsRoot :  DATA , 32 Bytes - the root of the transaction trie of the block.  stateRoot :  DATA , 32 Bytes - the root of the final state trie of the block.  receiptsRoot :  DATA , 32 Bytes - the root of the receipts trie of the block.  miner :  DATA , 20 Bytes - the address of the beneficiary to whom the mining rewards were given.  difficulty :  QUANTITY  - integer of the difficulty for this block.  totalDifficulty :  QUANTITY  - integer of the total difficulty of the chain until this block.  extraData :  DATA  - the \"extra data\" field of this block.  size :  QUANTITY  - integer the size of this block in bytes.  gasLimit :  QUANTITY  - the maximum gas allowed in this block.  gasUsed :  QUANTITY  - the total used gas by all transactions in this block.  timestamp :  QUANTITY  - the unix timestamp for when the block was collated.  transactions :  Array  - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter.  uncles :  Array  - Array of uncle hashes.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_26", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getBlockByHash , params :[ 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 , true], id :1}  // Result  {  id : 1 ,  jsonrpc : 2.0 ,  result :   { \n     number :   0x1b4 ,   // 436 \n     hash :   0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 , \n     parentHash :   0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5 , \n     nonce :   0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2 , \n     sha3Uncles :   0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 , \n     logsBloom :   0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 , \n     transactionsRoot :   0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421 , \n     stateRoot :   0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff , \n     miner :   0x4e65fda2159562a496f9f3522f89122a3088497a , \n     difficulty :   0x027f07 ,   // 163591 \n     totalDifficulty :    0x027f07 ,   // 163591 \n     extraData :   0x0000000000000000000000000000000000000000000000000000000000000000 , \n     size :    0x027f07 ,   // 163591 \n     gasLimit :   0x9f759 ,   // 653145 \n     gasUsed :   0x9f759 ,   // 653145 \n     timestamp :   0x54e34e8e   // 1424182926 \n     transactions :   [{...},{   ...   }] \n     uncles :   [ 0x1606e5... ,   0xd5145a9... ] \n   }  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getblockbynumber", 
            "text": "Returns information about a block by block number.", 
            "title": "eth_getBlockByNumber"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_27", 
            "text": "QUANTITY|TAG  - integer of a block number, or the string  \"earliest\" ,  \"latest\"  or  \"pending\" , as in the  default block parameter .  Boolean  - If  true  it returns the full transaction objects, if  false  only the hashes of the transactions.   params :   [ \n    0x1b4 ,   // 436 \n    true  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_27", 
            "text": "See  eth_getBlockByHash", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_27", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getBlockByNumber , params :[ 0x1b4 , true], id :1}   Result see  eth_getBlockByHash", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_gettransactionbyhash", 
            "text": "Returns the information about a transaction requested by transaction hash.", 
            "title": "eth_getTransactionByHash"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_28", 
            "text": "DATA , 32 Bytes - hash of a transaction   params :   [ \n    0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_28", 
            "text": "Object  - A transaction object, or  null  when no transaction was found:   hash :  DATA , 32 Bytes - hash of the transaction.  nonce :  QUANTITY  - the number of transactions made by the sender prior to this one.  blockHash :  DATA , 32 Bytes - hash of the block where this transaction was in.  null  when its pending.  blockNumber :  QUANTITY  - block number where this transaction was in.  null  when its pending.  transactionIndex :  QUANTITY  - integer of the transactions index position in the block.  null  when its pending.  from :  DATA , 20 Bytes - address of the sender.  to :  DATA , 20 Bytes - address of the receiver.  null  when its a contract creation transaction.  value :  QUANTITY  - value transferred in Wei.  gasPrice :  QUANTITY  - gas price provided by the sender in Wei.  gas :  QUANTITY  - gas provided by the sender.  input :  DATA  - the data send along with the transaction.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_28", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getTransactionByHash , params :[ 0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238 ], id :1}  // Result  {  id : 1 ,  jsonrpc : 2.0 ,  result :   { \n     hash : 0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b , \n     nonce : 0x , \n     blockHash :   0xbeab0aa2411b7ab17f30a99d3cb9c6ef2fc5426d6ad6fd9e2a26a6aed1d1055b , \n     blockNumber :   0x15df ,   // 5599 \n     transactionIndex :    0x1 ,   // 1 \n     from : 0x407d73d8a49eeb85d32cf465507dd71d507100c1 , \n     to : 0x85h43d8a49eeb85d32cf465507dd71d507100c1 , \n     value : 0x7f110   // 520464 \n     gas :   0x7f110   // 520464 \n     gasPrice : 0x09184e72a000 , \n     input : 0x603880600c6000396000f300603880600c6000396000f3603880600c6000396000f360 , \n   }  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_gettransactionbyblockhashandindex", 
            "text": "Returns information about a transaction by block hash and transaction index position.", 
            "title": "eth_getTransactionByBlockHashAndIndex"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_29", 
            "text": "DATA , 32 Bytes - hash of a block.  QUANTITY  - integer of the transaction index position.   params :   [ \n    0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 , \n    0x0   // 0  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_29", 
            "text": "See  eth_getBlockByHash", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_29", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getTransactionByBlockHashAndIndex , params :[0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b,  0x0 ], id :1}   Result see  eth_getTransactionByHash", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_gettransactionbyblocknumberandindex", 
            "text": "Returns information about a transaction by block number and transaction index position.", 
            "title": "eth_getTransactionByBlockNumberAndIndex"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_30", 
            "text": "QUANTITY|TAG  - a block number, or the string  \"earliest\" ,  \"latest\"  or  \"pending\" , as in the  default block parameter .  QUANTITY  - the transaction index position.   params :   [ \n    0x29c ,   // 668 \n    0x0   // 0  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_30", 
            "text": "See  eth_gettransactionbyhash", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_30", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getTransactionByBlockNumberAndIndex , params :[ 0x29c ,  0x0 ], id :1}   Result see  eth_getTransactionByHash", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_gettransactionreceipt", 
            "text": "Returns the receipt of a transaction by transaction hash.  Note  That the receipt is not available for pending transactions.", 
            "title": "eth_getTransactionReceipt"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_31", 
            "text": "DATA , 32 Bytes - hash of a transaction   params :   [ \n    0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_31", 
            "text": "Object  - A transaction receipt object, or  null  when no receipt was found:   transactionHash :  DATA , 32 Bytes - hash of the transaction.  transactionIndex :  QUANTITY  - integer of the transactions index position in the block.  blockHash :  DATA , 32 Bytes - hash of the block where this transaction was in.  blockNumber :  QUANTITY  - block number where this transaction was in.  cumulativeGasUsed :  QUANTITY  - The total amount of gas used when this transaction was executed in the block.  gasUsed :  QUANTITY  - The amount of gas used by this specific transaction alone.  contractAddress :  DATA , 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise  null .  logs :  Array  - Array of log objects, which this transaction generated.  logsBloom :  DATA , 256 Bytes - Bloom filter for light clients to quickly retrieve related logs.   It also returns  either  :   root  :  DATA  32 bytes of post-transaction stateroot (pre Byzantium)  status :  QUANTITY  either  1  (success) or  0  (failure)", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_31", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getTransactionReceipt , params :[ 0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238 ], id :1}  // Result  {  id : 1 ,  jsonrpc : 2.0 ,  result :   { \n      transactionHash :   0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238 , \n      transactionIndex :    0x1 ,   // 1 \n      blockNumber :   0xb ,   // 11 \n      blockHash :   0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b , \n      cumulativeGasUsed :   0x33bc ,   // 13244 \n      gasUsed :   0x4dc ,   // 1244 \n      contractAddress :   0xb60e8dd61c5d32be8058bb8eb970870f07233155   // or null, if none was created \n      logs :   [{ \n          // logs as returned by getFilterLogs, etc. \n      },   ...], \n      logsBloom :   0x00...0   // 256 byte bloom filter \n      status :   0x1 \n   }  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getunclebyblockhashandindex", 
            "text": "Returns information about a uncle of a block by hash and uncle index position.", 
            "title": "eth_getUncleByBlockHashAndIndex"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_32", 
            "text": "DATA , 32 Bytes - hash a block.  QUANTITY  - the uncle's index position.   params :   [ \n    0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b , \n    0x0   // 0  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_32", 
            "text": "See  eth_getBlockByHash", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_32", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getUncleByBlockHashAndIndex , params :[ 0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b ,  0x0 ], id :1}   Result see  eth_getBlockByHash  Note : An uncle doesn't contain individual transactions.", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getunclebyblocknumberandindex", 
            "text": "Returns information about a uncle of a block by number and uncle index position.", 
            "title": "eth_getUncleByBlockNumberAndIndex"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_33", 
            "text": "QUANTITY|TAG  - a block number, or the string  \"earliest\" ,  \"latest\"  or  \"pending\" , as in the  default block parameter .  QUANTITY  - the uncle's index position.   params :   [ \n    0x29c ,   // 668 \n    0x0   // 0  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_33", 
            "text": "See  eth_getBlockByHash  Note : An uncle doesn't contain individual transactions.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_33", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getUncleByBlockNumberAndIndex , params :[ 0x29c ,  0x0 ], id :1}   Result see  eth_getBlockByHash", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getcompilers", 
            "text": "Returns a list of available compilers in the client.", 
            "title": "eth_getCompilers"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_34", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_34", 
            "text": "Array  - Array of available compilers.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_34", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getCompilers , params :[], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   [ solidity ,   lll ,   serpent ]  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_compilesolidity", 
            "text": "Returns compiled solidity code.", 
            "title": "eth_compileSolidity"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_35", 
            "text": "String  - The source code.   params :   [ \n    contract test { function multiply(uint a) returns(uint d) {   return a * 7;   } } ,  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_35", 
            "text": "DATA  - The compiled source code.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_35", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_compileSolidity , params :[ contract test { function multiply(uint a) returns(uint d) {   return a * 7;   } } ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   { \n       code :   0x605880600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b603d6004803590602001506047565b8060005260206000f35b60006007820290506053565b91905056 , \n       info :   { \n         source :   contract test {\\n   function multiply(uint a) constant returns(uint d) {\\n       return a * 7;\\n   }\\n}\\n , \n         language :   Solidity , \n         languageVersion :   0 , \n         compilerVersion :   0.9.19 , \n         abiDefinition :   [ \n           { \n             constant :   true , \n             inputs :   [ \n               { \n                 name :   a , \n                 type :   uint256 \n               } \n             ], \n             name :   multiply , \n             outputs :   [ \n               { \n                 name :   d , \n                 type :   uint256 \n               } \n             ], \n             type :   function \n           } \n         ], \n         userDoc :   { \n           methods :   {} \n         }, \n         developerDoc :   { \n           methods :   {} \n         } \n       }  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_compilelll", 
            "text": "Returns compiled LLL code.", 
            "title": "eth_compileLLL"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_36", 
            "text": "String  - The source code.   params :   [ \n    (returnlll (suicide (caller))) ,  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_36", 
            "text": "DATA  - The compiled source code.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_36", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_compileLLL , params :[ (returnlll (suicide (caller))) ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056   // the compiled source code  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_compileserpent", 
            "text": "Returns compiled serpent code.", 
            "title": "eth_compileSerpent"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_37", 
            "text": "String  - The source code.   params :   [ \n    /* some serpent */ ,  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_37", 
            "text": "DATA  - The compiled source code.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_37", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_compileSerpent , params :[ /* some serpent */ ], id :1}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x603880600c6000396000f3006001600060e060020a600035048063c6888fa114601857005b6021600435602b565b8060005260206000f35b600081600702905091905056   // the compiled source code  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_newfilter", 
            "text": "Creates a filter object, based on filter options, to notify when the state changes (logs).\nTo check if the state has changed, call  eth_getFilterChanges .", 
            "title": "eth_newFilter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#a-note-on-specifying-topic-filters", 
            "text": "Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:   []  \"anything\"   [A]  \"A in first position (and anything after)\"   [null, B]  \"anything in first position AND B in second position (and anything after)\"   [A, B]  \"A in first position AND B in second position (and anything after)\"\n*  [[A, B], [A, B]]  \"(A OR B) in first position AND (A OR B) in second position (and anything after)\"", 
            "title": "A note on specifying topic filters:"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_38", 
            "text": "Object  - The filter options:  fromBlock :  QUANTITY|TAG  - (optional, default:  \"latest\" ) Integer block number, or  \"latest\"  for the last mined block or  \"pending\" ,  \"earliest\"  for not yet mined transactions.  toBlock :  QUANTITY|TAG  - (optional, default:  \"latest\" ) Integer block number, or  \"latest\"  for the last mined block or  \"pending\" ,  \"earliest\"  for not yet mined transactions.  address :  DATA|Array , 20 Bytes - (optional) Contract address or a list of addresses from which logs should originate.  topics :  Array of DATA ,  - (optional) Array of 32 Bytes  DATA  topics. Topics are order-dependent. Each topic can also be an array of DATA with \"or\" options.   params :   [{ \n   fromBlock :   0x1 , \n   toBlock :   0x2 , \n   address :   0x8888f1f195afa192cfee860698584c030f4c9db1 , \n   topics :   [ 0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b ,   null ,   [ 0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b ,   0x0000000000000000000000000aff3454fce5edbc8cca8697c15331677e6ebccc ]]  }]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_38", 
            "text": "QUANTITY  - A filter id.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_38", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_newFilter , params :[{ topics :[ 0x12341234 ]}], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0x1   // 1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_newblockfilter", 
            "text": "Creates a filter in the node, to notify when a new block arrives.\nTo check if the state has changed, call  eth_getFilterChanges .", 
            "title": "eth_newBlockFilter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_39", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_39", 
            "text": "QUANTITY  - A filter id.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_39", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_newBlockFilter , params :[], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :    2.0 , \n   result :   0x1   // 1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_newpendingtransactionfilter", 
            "text": "Creates a filter in the node, to notify when new pending transactions arrive.\nTo check if the state has changed, call  eth_getFilterChanges .", 
            "title": "eth_newPendingTransactionFilter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_40", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_40", 
            "text": "QUANTITY  - A filter id.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_40", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_newPendingTransactionFilter , params :[], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :    2.0 , \n   result :   0x1   // 1  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_uninstallfilter", 
            "text": "Uninstalls a filter with given id. Should always be called when watch is no longer needed.\nAdditonally Filters timeout when they aren't requested with  eth_getFilterChanges  for a period of time.", 
            "title": "eth_uninstallFilter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_41", 
            "text": "QUANTITY  - The filter id.   params :   [ \n   0xb   // 11  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_41", 
            "text": "Boolean  -  true  if the filter was successfully uninstalled, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_41", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_uninstallFilter , params :[ 0xb ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getfilterchanges", 
            "text": "Polling method for a filter, which returns an array of logs which occurred since last poll.", 
            "title": "eth_getFilterChanges"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_42", 
            "text": "QUANTITY  - the filter id.   params :   [ \n   0x16   // 22  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_42", 
            "text": "Array  - Array of log objects, or an empty array if nothing has changed since last poll.   For filters created with  eth_newBlockFilter  the return are block hashes ( DATA , 32 Bytes), e.g.  [\"0x3454645634534...\"] .  For filters created with  eth_newPendingTransactionFilter  the return are transaction hashes ( DATA , 32 Bytes), e.g.  [\"0x6345343454645...\"] .   For filters created with  eth_newFilter  logs are objects with following params:    removed :  TAG  -  true  when the log was removed, due to a chain reorganization.  false  if its a valid log.   logIndex :  QUANTITY  - integer of the log index position in the block.  null  when its pending log.  transactionIndex :  QUANTITY  - integer of the transactions index position log was created from.  null  when its pending log.  transactionHash :  DATA , 32 Bytes - hash of the transactions this log was created from.  null  when its pending log.  blockHash :  DATA , 32 Bytes - hash of the block where this log was in.  null  when its pending.  null  when its pending log.  blockNumber :  QUANTITY  - the block number where this log was in.  null  when its pending.  null  when its pending log.  address :  DATA , 20 Bytes - address from which this log originated.  data :  DATA  - contains one or more 32 Bytes non-indexed arguments of the log.  topics :  Array of DATA  - Array of 0 to 4 32 Bytes  DATA  of indexed log arguments. (In  solidity : The first topic is the  hash  of the signature of the event (e.g.  Deposit(address,bytes32,uint256) ), except you declared the event with the  anonymous  specifier.)", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_42", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getFilterChanges , params :[ 0x16 ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   [{ \n     logIndex :   0x1 ,   // 1 \n     blockNumber : 0x1b4   // 436 \n     blockHash :   0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d , \n     transactionHash :    0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcf , \n     transactionIndex :   0x0 ,   // 0 \n     address :   0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d , \n     data : 0x0000000000000000000000000000000000000000000000000000000000000000 , \n     topics :   [ 0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5 ] \n     },{ \n       ... \n     }]  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getfilterlogs", 
            "text": "Returns an array of all logs matching filter with given id.", 
            "title": "eth_getFilterLogs"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_43", 
            "text": "QUANTITY  - The filter id.   params :   [ \n   0x16   // 22  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_43", 
            "text": "See  eth_getFilterChanges", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_43", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getFilterLogs , params :[ 0x16 ], id :74}   Result see  eth_getFilterChanges", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getlogs", 
            "text": "Returns an array of all logs matching a given filter object.", 
            "title": "eth_getLogs"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_44", 
            "text": "Object  - the filter object, see  eth_newFilter parameters .   params :   [{ \n   topics :   [ 0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b ]  }]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_44", 
            "text": "See  eth_getFilterChanges", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_44", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getLogs , params :[{ topics :[ 0x000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b ]}], id :74}   Result see  eth_getFilterChanges", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_getwork", 
            "text": "Returns the hash of the current block, the seedHash, and the boundary condition to be met (\"target\").", 
            "title": "eth_getWork"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_45", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_45", 
            "text": "Array  - Array with the following properties:\n  1.  DATA , 32 Bytes - current block header pow-hash\n  2.  DATA , 32 Bytes - the seed hash used for the DAG.\n  3.  DATA , 32 Bytes - the boundary condition (\"target\"), 2^256 / difficulty.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_45", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : eth_getWork , params :[], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   [ \n       0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef , \n       0x5EED00000000000000000000000000005EED0000000000000000000000000000 , \n       0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000 \n     ]  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_submitwork", 
            "text": "Used for submitting a proof-of-work solution.", 
            "title": "eth_submitWork"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_46", 
            "text": "DATA , 8 Bytes - The nonce found (64 bits)  DATA , 32 Bytes - The header's pow-hash (256 bits)  DATA , 32 Bytes - The mix digest (256 bits)   params :   [ \n   0x0000000000000001 , \n   0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef , \n   0xD1FE5700000000000000000000000000D1FE5700000000000000000000000000  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_46", 
            "text": "Boolean  - returns  true  if the provided solution is valid, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_46", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 ,  method : eth_submitWork ,  params :[ 0x0000000000000001 ,  0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef ,  0xD1GE5700000000000000000000000000D1GE5700000000000000000000000000 ], id :73}  // Result  { \n   id : 73 , \n   jsonrpc : 2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#eth_submithashrate", 
            "text": "Used for submitting mining hashrate.", 
            "title": "eth_submitHashrate"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_47", 
            "text": "Hashrate , a hexadecimal string representation (32 bytes) of the hash rate  ID , String - A random hexadecimal(32 bytes) ID identifying the client   params :   [ \n   0x0000000000000000000000000000000000000000000000000000000000500000 , \n   0x59daa26581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_47", 
            "text": "Boolean  - returns  true  if submitting went through succesfully and  false  otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_47", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 ,  method : eth_submitHashrate ,  params :[ 0x0000000000000000000000000000000000000000000000000000000000500000 ,  0x59daa26581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c ], id :73}  // Result  { \n   id : 73 , \n   jsonrpc : 2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#db_putstring", 
            "text": "Stores a string in the local database.  Note  this function is deprecated and will be removed in the future.", 
            "title": "db_putString"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_48", 
            "text": "String  - Database name.  String  - Key name.  String  - String to store.   params :   [ \n   testDB , \n   myKey , \n   myString  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_48", 
            "text": "Boolean  - returns  true  if the value was stored, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_48", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : db_putString , params :[ testDB , myKey , myString ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#db_getstring", 
            "text": "Returns string from the local database.  Note  this function is deprecated and will be removed in the future.", 
            "title": "db_getString"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_49", 
            "text": "String  - Database name.  String  - Key name.   params :   [ \n   testDB , \n   myKey ,  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_49", 
            "text": "String  - The previously stored string.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_49", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : db_getString , params :[ testDB , myKey ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   myString  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#db_puthex", 
            "text": "Stores binary data in the local database.  Note  this function is deprecated and will be removed in the future.", 
            "title": "db_putHex"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_50", 
            "text": "String  - Database name.  String  - Key name.  DATA  - The data to store.   params :   [ \n   testDB , \n   myKey , \n   0x68656c6c6f20776f726c64  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_50", 
            "text": "Boolean  - returns  true  if the value was stored, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_50", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : db_putHex , params :[ testDB , myKey , 0x68656c6c6f20776f726c64 ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#db_gethex", 
            "text": "Returns binary data from the local database.  Note  this function is deprecated and will be removed in the future.", 
            "title": "db_getHex"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_51", 
            "text": "String  - Database name.  String  - Key name.   params :   [ \n   testDB , \n   myKey ,  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_51", 
            "text": "DATA  - The previously stored data.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_51", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : db_getHex , params :[ testDB , myKey ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   0x68656c6c6f20776f726c64  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_version", 
            "text": "Returns the current whisper protocol version.", 
            "title": "shh_version"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_52", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_52", 
            "text": "String  - The current whisper protocol version", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_52", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_version , params :[], id :67}  // Result  { \n   id : 67 , \n   jsonrpc :   2.0 , \n   result :   2  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_post", 
            "text": "Sends a whisper message.", 
            "title": "shh_post"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_53", 
            "text": "Object  - The whisper post object:  from :  DATA , 60 Bytes - (optional) The identity of the sender.  to :  DATA , 60 Bytes - (optional) The identity of the receiver. When present whisper will encrypt the message so that only the receiver can decrypt it.  topics :  Array of DATA  - Array of  DATA  topics, for the receiver to identify messages.  payload :  DATA  - The payload of the message.  priority :  QUANTITY  - The integer of the priority in a rang from ... (?).  ttl :  QUANTITY  - integer of the time to live in seconds.   params :   [{ \n   from :   0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1 , \n   to :   0x3e245533f97284d442460f2998cd41858798ddf04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a0d4d661997d3940272b717b1 , \n   topics :   [ 0x776869737065722d636861742d636c69656e74 ,   0x4d5a695276454c39425154466b61693532 ], \n   payload :   0x7b2274797065223a226d6 , \n   priority :   0x64 , \n   ttl :   0x64 ,  }]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_53", 
            "text": "Boolean  - returns  true  if the message was send, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_53", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_post , params :[{ from : 0xc931d93e97ab07fe42d923478ba2465f2.. , topics : [ 0x68656c6c6f20776f726c64 ], payload : 0x68656c6c6f20776f726c64 , ttl :0x64, priority :0x64}], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_newidentity", 
            "text": "Creates new whisper identity in the client.", 
            "title": "shh_newIdentity"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_54", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_54", 
            "text": "DATA , 60 Bytes - the address of the new identiy.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_54", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_newIdentity , params :[], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xc931d93e97ab07fe42d923478ba2465f283f440fd6cabea4dd7a2c807108f651b7135d1d6ca9007d5b68aa497e4619ac10aa3b27726e1863c1fd9b570d99bbaf  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_hasidentity", 
            "text": "Checks if the client hold the private keys for a given identity.", 
            "title": "shh_hasIdentity"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_55", 
            "text": "DATA , 60 Bytes - The identity address to check.   params :   [ \n   0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_55", 
            "text": "Boolean  - returns  true  if the client holds the privatekey for that identity, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_55", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_hasIdentity , params :[ 0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1 ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_newgroup", 
            "text": "(?)", 
            "title": "shh_newGroup"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_56", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_56", 
            "text": "DATA , 60 Bytes - the address of the new group. (?)", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_56", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_newIdentity , params :[], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   0xc65f283f440fd6cabea4dd7a2c807108f651b7135d1d6ca90931d93e97ab07fe42d923478ba2407d5b68aa497e4619ac10aa3b27726e1863c1fd9b570d99bbaf  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_addtogroup", 
            "text": "(?)", 
            "title": "shh_addToGroup"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_57", 
            "text": "DATA , 60 Bytes - The identity address to add to a group (?).   params :   [ \n   0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_57", 
            "text": "Boolean  - returns  true  if the identity was successfully added to the group, otherwise  false  (?).", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_57", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_hasIdentity , params :[ 0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1 ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc :   2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_newfilter", 
            "text": "Creates filter to notify, when client receives whisper message matching the filter options.", 
            "title": "shh_newFilter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_58", 
            "text": "Object  - The filter options:  to :  DATA , 60 Bytes - (optional) Identity of the receiver.  When present it will try to decrypt any incoming message if the client holds the private key to this identity.  topics :  Array of DATA  - Array of  DATA  topics which the incoming message's topics should match.  You can use the following combinations:  [A, B] = A   B  [A, [B, C]] = A   (B || C)  [null, A, B] = ANYTHING   A   B   null  works as a wildcard     params :   [{ \n    topics :   [ 0x12341234bf4b564f ], \n    to :   0x04f96a5e25610293e42a73908e93ccc8c4d4dc0edcfa9fa872f50cb214e08ebf61a03e245533f97284d442460f2998cd41858798ddfd4d661997d3940272b717b1  }]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_58", 
            "text": "QUANTITY  - The newly created filter.", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_58", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_newFilter , params :[{ topics : [ 0x12341234bf4b564f ], to :  0x2341234bf4b2341234bf4b564f... }], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   0x7   // 7  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_uninstallfilter", 
            "text": "Uninstalls a filter with given id. Should always be called when watch is no longer needed.\nAdditonally Filters timeout when they aren't requested with  shh_getFilterChanges  for a period of time.", 
            "title": "shh_uninstallFilter"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_59", 
            "text": "QUANTITY  - The filter id.   params :   [ \n   0x7   // 7  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_59", 
            "text": "Boolean  -  true  if the filter was successfully uninstalled, otherwise  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_59", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_uninstallFilter , params :[ 0x7 ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   true  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_getfilterchanges", 
            "text": "Polling method for whisper filters. Returns new messages since the last call of this method.  Note  calling the  shh_getMessages  method, will reset the buffer for this method, so that you won't receive duplicate messages.", 
            "title": "shh_getFilterChanges"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_60", 
            "text": "QUANTITY  - The filter id.   params :   [ \n   0x7   // 7  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_60", 
            "text": "Array  - Array of messages received since last poll:   hash :  DATA , 32 Bytes (?) - The hash of the message.  from :  DATA , 60 Bytes - The sender of the message, if a sender was specified.  to :  DATA , 60 Bytes - The receiver of the message, if a receiver was specified.  expiry :  QUANTITY  - Integer of the time in seconds when this message should expire (?).  ttl :  QUANTITY  -  Integer of the time the message should float in the system in seconds (?).  sent :  QUANTITY  -  Integer of the unix timestamp when the message was sent.  topics :  Array of DATA  - Array of  DATA  topics the message contained.  payload :  DATA  - The payload of the message.  workProved :  QUANTITY  - Integer of the work this message required before it was send (?).", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_60", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_getFilterChanges , params :[ 0x7 ], id :73}  // Result  { \n   id : 1 , \n   jsonrpc : 2.0 , \n   result :   [{ \n     hash :   0x33eb2da77bf3527e28f8bf493650b1879b08c4f2a362beae4ba2f71bafcd91f9 , \n     from :   0x3ec052fc33.. , \n     to :   0x87gdf76g8d7fgdfg... , \n     expiry :   0x54caa50a ,   // 1422566666 \n     sent :   0x54ca9ea2 ,   // 1422565026 \n     ttl :   0x64   // 100 \n     topics :   [ 0x6578616d ], \n     payload :   0x7b2274797065223a226d657373616765222c2263686... , \n     workProved :   0x0 \n     }]  }", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#shh_getmessages", 
            "text": "Get all messages matching a filter. Unlike  shh_getFilterChanges  this returns all messages.", 
            "title": "shh_getMessages"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#parameters_61", 
            "text": "QUANTITY  - The filter id.   params :   [ \n   0x7   // 7  ]", 
            "title": "Parameters"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#returns_61", 
            "text": "See  shh_getFilterChanges", 
            "title": "Returns"
        }, 
        {
            "location": "/Dapps/JSON-RPC/#example_61", 
            "text": "// Request  curl   - X   POST   -- data   { jsonrpc : 2.0 , method : shh_getMessages , params :[ 0x7 ], id :73}   Result see  shh_getFilterChanges", 
            "title": "Example"
        }, 
        {
            "location": "/Dapps/solidity/", 
            "text": "Solidity\n\n\nhttps://solidity.readthedocs.org/en/latest/", 
            "title": "Solidity"
        }, 
        {
            "location": "/Dapps/solidity/#solidity", 
            "text": "https://solidity.readthedocs.org/en/latest/", 
            "title": "Solidity"
        }, 
        {
            "location": "/Dapps/Solidity-Features/", 
            "text": "Solidity \u7279\u8272\n\n\n\u8bbf\u95ee \nhttps://solidity.readthedocs.io/en/develop/", 
            "title": "Solidity \u7279\u8272"
        }, 
        {
            "location": "/Dapps/Solidity-Features/#solidity", 
            "text": "\u8bbf\u95ee  https://solidity.readthedocs.io/en/develop/", 
            "title": "Solidity \u7279\u8272"
        }, 
        {
            "location": "/Dapps/Solidity-Collections/", 
            "text": "Solidity \u96c6\u5408\n\n\nThis is a list of collections of Solidity code. Please add to this list, preserving alphabetical order.\n\n\n\n\ndapp-bin/library\n: A small collection of utility libraries.\n\n\nDensity\n: Alex Beregszaszi's collection of useful modifiers and methods\n\n\nSolidity Standard Library\n: This is a proof-of-concept standard library that is included with Solidity itself.\n\n\nstandard-contracts\n: Andreas Olofsson's collection of libraries that handle bits, bytes, encoding, decoding, and crypto.\n\n\nstringutils\n: Nick Johnson's string \n slice utility library\n\n\nZeppelin\n: OpenZeppelin library for writing secure smart contracts.", 
            "title": "Solidity \u5408\u96c6"
        }, 
        {
            "location": "/Dapps/Solidity-Collections/#solidity", 
            "text": "This is a list of collections of Solidity code. Please add to this list, preserving alphabetical order.   dapp-bin/library : A small collection of utility libraries.  Density : Alex Beregszaszi's collection of useful modifiers and methods  Solidity Standard Library : This is a proof-of-concept standard library that is included with Solidity itself.  standard-contracts : Andreas Olofsson's collection of libraries that handle bits, bytes, encoding, decoding, and crypto.  stringutils : Nick Johnson's string   slice utility library  Zeppelin : OpenZeppelin library for writing secure smart contracts.", 
            "title": "Solidity \u96c6\u5408"
        }, 
        {
            "location": "/Dapps/solidity-cheatsheet/", 
            "text": "Solidity \u5907\u5fd8\u5355\n\n\nhttps://github.com/manojpramesh/solidity-cheatsheet", 
            "title": "Solidity \u5907\u5fd8\u5355"
        }, 
        {
            "location": "/Dapps/solidity-cheatsheet/#solidity", 
            "text": "https://github.com/manojpramesh/solidity-cheatsheet", 
            "title": "Solidity \u5907\u5fd8\u5355"
        }, 
        {
            "location": "/Dapps/Useful-\u00d0app-Patterns/", 
            "text": "\u4f7f\u7528\u00d0app\u6a21\u5f0f\n\n\nThe following page is a collection of useful patterns, \u00d0apps can use, such as talking to the blockchain reliably.\n\n\nThe example patterns can possibly change, so don't rely fully on them as of yet.\n\n\n\u793a\u4f8b\n\n\n\n\n\n\n3 ways of instantiating web3:\nhttps://gist.github.com/frozeman/fbc7465d0b0e6c1c4c23\n\n\n\n\n\n\nContract deployment by code:\n(Outdated, use \nweb3.contract(abiArray).new({}, function(e, res){...})\n)\nhttps://gist.github.com/frozeman/655a9325a93ac198416e\n\n\n\n\n\n\nTest a contract transaction with a \ncall\n before actually sending:\nhttps://gist.github.com/ethers/2d8dfaaf7f7a2a9e4eaa", 
            "title": "\u6709\u7528\u7684\u00d0app\u6a21\u5f0f"
        }, 
        {
            "location": "/Dapps/Useful-\u00d0app-Patterns/#app", 
            "text": "The following page is a collection of useful patterns, \u00d0apps can use, such as talking to the blockchain reliably.  The example patterns can possibly change, so don't rely fully on them as of yet.", 
            "title": "\u4f7f\u7528\u00d0app\u6a21\u5f0f"
        }, 
        {
            "location": "/Dapps/Useful-\u00d0app-Patterns/#_1", 
            "text": "3 ways of instantiating web3:\nhttps://gist.github.com/frozeman/fbc7465d0b0e6c1c4c23    Contract deployment by code:\n(Outdated, use  web3.contract(abiArray).new({}, function(e, res){...}) )\nhttps://gist.github.com/frozeman/655a9325a93ac198416e    Test a contract transaction with a  call  before actually sending:\nhttps://gist.github.com/ethers/2d8dfaaf7f7a2a9e4eaa", 
            "title": "\u793a\u4f8b"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/", 
            "text": "NOTE\n The token API is currently debated as an ERC (Ethereum request for comment) and may be outdated: https://github.com/ethereum/EIPs/issues/20\n\n\n\n\nAlthough Ethereum allows developers to create absolutely any kind of application without restriction to specific feature types, and prides itself on its \"lack of features\", there is nevertheless a need to standardize certain very common use cases in order to allow users and applications to more easily interact with each other. This includes sending currency units, registering names, making offers on exchanges, and other similar functions. A standard typically consists of a set of function signatures for a few methods, eg. \nsend\n, \nregister\n, \ndelete\n, providing the set of arguments and their formats in the \nEthereum contract ABI\n language.\n\n\nThe standards described below have sample implementations available \nhere\n.\n\n\nAll function names are in lower camelCase (eg. \nsendCoin\n) and all event names are in upper CamelCase (eg. \nCoinTransfer\n). Input variables are in underscore-prefixed lower camelCase (eg. \n_offerId\n), and output variables are \n_r\n for pure getter (ie. constant) functions, \n_success\n (always boolean) when denoting success or failure, and other values (eg. \n_maxValue\n) for methods that perform an action but need to return a value as an identifier. Addresses are referred to using \n_address\n when generic, and otherwise if a more specific description exists (eg. \n_from\n, \n_to\n).\n\n\nTransferable Fungibles (see \nERC 20\n for the latest)\n\n\nAlso known as tokens, coins and sub-currencies.\n\n\nTF Registries (see \nERC 22\n for the latest)\n\n\nToken registries contain information about tokens. There is at least one global registry (though other may create more like the global Registry) to which you can add your token. Adding your token to it would increase the experience of the user that the GUI Client can use or not.\n\n\nRegistries\n\n\nRegistries (eg. domain name systems) have the following API:\n\n\nMethods\n\n\nreserve\n\n\nreserve\n(\nstring\n \n_name\n)\n \nreturns\n \n(\nbool\n \n_success\n)\n\n\n\nReserves a name and sets its owner to you if it is not yet reserved.\n\n\nowner\n\n\nowner\n(\nstring\n \n_name\n)\n \nconstant\n \nreturns\n \n(\naddress\n \n_r\n)\n\n\n\nGet the owner of a particular name.\n\n\ntransfer\n\n\ntransfer\n(\nstring\n \n_name\n,\n \naddress\n \n_newOwner\n)\n\n\n\nTransfer ownership of a name.\n\n\nsetAddr\n\n\nsetAddr\n(\nstring\n \n_name\n,\n \naddress\n \n_address\n)\n\n\n\n\n\nSet the primary address associated with a name (similar to an A record in traditional DNS.)\n\n\naddr\n\n\naddr\n(\nstring\n \n_name\n)\n \nconstant\n \nreturns\n \n(\naddress\n \n_r\n)\n\n\n\nGet the primary address associated with a name.\n\n\nsetContent\n\n\nsetContent\n(\nstring\n \n_name\n,\n \nbytes32\n \n_content\n)\n\n\n\n\n\nIf you are the owner of a name, sets its associated content.\n\n\ncontent\n\n\ncontent\n(\nstring\n \n_name\n)\n \nconstant\n \nreturns\n \n(\nbytes32\n \n_r\n)\n\n\n\n\n\nGet the content associated with a name.\n\n\nsetSubRegistrar\n\n\nsetSubRegistrar\n(\nstring\n \n_name\n,\n \naddress\n \n_subRegistrar\n)\n\n\n\n\n\nRecords the name as referring to a sub-registrar at the given address.\n\n\nsubRegistrar\n\n\nsubRegistrar\n(\nstring\n \n_name\n)\n \nconstant\n \nreturns\n \n(\naddress\n \n_r\n)\n\n\n\nGets the sub-registrar associated with the given name.\n\n\ndisown\n\n\ndisown\n(\nstring\n \n_name\n)\n\n\n\n\n\nRelinquishes control over a name that you currently control.\n\n\nEvents\n\n\nChanged\n\n\nevent\n \nChanged\n(\nstring\n \nname\n,\n \nbytes32\n \nindexed\n \n__hash_name\n)\n\n\n````\n\n\n\nTriggered\n \nwhen\n \nchanged\n \nto\n \na\n \ndomain\n \nhappen\n.\n\n\n\n\n##\n \nData\n \nfeeds\n\n\n\nThe\n \ndata\n \nfeed\n \nstandard\n \nis\n \na\n \n_templated\n \nstandard_\n,\n \nie\n.\n \nin\n \nthe\n \nbelow\n \ndescriptions\n \none\n \nshould\n \nbe\n \nfree\n \nto\n \nreplace\n \n`\nt\n`\n \nwith\n \nany\n \ndesired\n \ndata\n \ntype\n,\n \neg\n.\n \n`uint256`\n,\n \n`bytes32`\n,\n \n`address`\n,\n \n`real192x64`\n.\n\n\n\n###\n \nMethods\n\n\n####\n \nget\n\n\n\n```js\n\n\nget(bytes32 _key) returns (\nt\n _r)\n\n\n\n\n\nGet the value associated with a key.\n\n\nset\n\n\nset\n(\nbytes32\n \n_key\n,\n \nt\n \n_value\n)\n\n\n\n\n\nSet the value associated with a key if you are the owner.\n\n\nsetFee\n\n\nsetFee\n(\nuint256\n \n_fee\n)\n\n\n\n\n\nSets the fee.\n\n\nsetFeeCurrency\n\n\nsetFeeCurrency\n(\naddress\n \n_feeCurrency\n)\n\n\n\n\n\nSets the currency that the fee is paid in\n\n\nThe latter two methods are optional; also, note that the fee may be charged either in ether or subcurrency; if the contract charges in ether then the \nsetFeeCurrency\n method is unnecessary.\n\n\nForwarding contracts (eg. multisig)\n\n\nForwarding contracts will likely work very differently depending on what the authorization policy of each one is. However, there are some standard workflows that should be used as much as possible:\n\n\nMethods\n\n\nexecute\n\n\nexecute\n(\naddress\n \n_to\n,\n \nuint\n \n_value\n,\n \nbytes\n \n_data\n)\n \nreturns\n \n(\nbytes32\n \n_id\n)\n\n\n\n\n\nCreate a message with the desired recipient, value and data. Returns a \"pending ID\" for the transaction.\n\n\nconfirm\n\n\nconfirm\n(\nbytes32\n \n_id\n)\n \nreturns\n \n(\nbool\n \n_success\n)\n\n\n\n\n\nConfirm a pending message with a particular ID using your account; returns success or failure. If enough confirmations are made, sends the message along.\n\n\nAccess policies can be of any form, eg. multisig, an arbitrary CNF boolean formula, a scheme that depends on the \nvalue\n or \ncontents\n of a transaction, etc.", 
            "title": "\u6807\u51c6\u5316\u5408\u7ea6\u63a5\u53e3"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#transferable-fungibles-see-erc-20-for-the-latest", 
            "text": "Also known as tokens, coins and sub-currencies.", 
            "title": "Transferable Fungibles (see ERC 20 for the latest)"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#tf-registries-see-erc-22-for-the-latest", 
            "text": "Token registries contain information about tokens. There is at least one global registry (though other may create more like the global Registry) to which you can add your token. Adding your token to it would increase the experience of the user that the GUI Client can use or not.", 
            "title": "TF Registries (see ERC 22 for the latest)"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#registries", 
            "text": "Registries (eg. domain name systems) have the following API:", 
            "title": "Registries"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#reserve", 
            "text": "reserve ( string   _name )   returns   ( bool   _success )  \nReserves a name and sets its owner to you if it is not yet reserved.", 
            "title": "reserve"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#owner", 
            "text": "owner ( string   _name )   constant   returns   ( address   _r )  \nGet the owner of a particular name.", 
            "title": "owner"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#transfer", 
            "text": "transfer ( string   _name ,   address   _newOwner )  \nTransfer ownership of a name.", 
            "title": "transfer"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#setaddr", 
            "text": "setAddr ( string   _name ,   address   _address )   Set the primary address associated with a name (similar to an A record in traditional DNS.)", 
            "title": "setAddr"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#addr", 
            "text": "addr ( string   _name )   constant   returns   ( address   _r )  \nGet the primary address associated with a name.", 
            "title": "addr"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#setcontent", 
            "text": "setContent ( string   _name ,   bytes32   _content )   If you are the owner of a name, sets its associated content.", 
            "title": "setContent"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#content", 
            "text": "content ( string   _name )   constant   returns   ( bytes32   _r )   Get the content associated with a name.", 
            "title": "content"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#setsubregistrar", 
            "text": "setSubRegistrar ( string   _name ,   address   _subRegistrar )   Records the name as referring to a sub-registrar at the given address.", 
            "title": "setSubRegistrar"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#subregistrar", 
            "text": "subRegistrar ( string   _name )   constant   returns   ( address   _r )  \nGets the sub-registrar associated with the given name.", 
            "title": "subRegistrar"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#disown", 
            "text": "disown ( string   _name )   Relinquishes control over a name that you currently control.", 
            "title": "disown"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#changed", 
            "text": "event   Changed ( string   name ,   bytes32   indexed   __hash_name )  ````  Triggered   when   changed   to   a   domain   happen .  ##   Data   feeds  The   data   feed   standard   is   a   _templated   standard_ ,   ie .   in   the   below   descriptions   one   should   be   free   to   replace   ` t `   with   any   desired   data   type ,   eg .   `uint256` ,   `bytes32` ,   `address` ,   `real192x64` .  ###   Methods  ####   get  ```js  get(bytes32 _key) returns ( t  _r)   Get the value associated with a key.", 
            "title": "Changed"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#set", 
            "text": "set ( bytes32   _key ,   t   _value )   Set the value associated with a key if you are the owner.", 
            "title": "set"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#setfee", 
            "text": "setFee ( uint256   _fee )   Sets the fee.", 
            "title": "setFee"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#setfeecurrency", 
            "text": "setFeeCurrency ( address   _feeCurrency )   Sets the currency that the fee is paid in  The latter two methods are optional; also, note that the fee may be charged either in ether or subcurrency; if the contract charges in ether then the  setFeeCurrency  method is unnecessary.", 
            "title": "setFeeCurrency"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#forwarding-contracts-eg-multisig", 
            "text": "Forwarding contracts will likely work very differently depending on what the authorization policy of each one is. However, there are some standard workflows that should be used as much as possible:", 
            "title": "Forwarding contracts (eg. multisig)"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#methods_1", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#execute", 
            "text": "execute ( address   _to ,   uint   _value ,   bytes   _data )   returns   ( bytes32   _id )   Create a message with the desired recipient, value and data. Returns a \"pending ID\" for the transaction.", 
            "title": "execute"
        }, 
        {
            "location": "/Dapps/Standardized_Contract_APIs/#confirm", 
            "text": "confirm ( bytes32   _id )   returns   ( bool   _success )   Confirm a pending message with a particular ID using your account; returns success or failure. If enough confirmations are made, sends the message along.  Access policies can be of any form, eg. multisig, an arbitrary CNF boolean formula, a scheme that depends on the  value  or  contents  of a transaction, etc.", 
            "title": "confirm"
        }, 
        {
            "location": "/Dapps/Using-Meteor/", 
            "text": "This tutorial will show you how to setup a Meteor app to be used as a \u00d0app and probably answer a few questions on why Meteor should be used.\n\n\n\n\nCreate your \u00d0app\n\n\nStart your \u00d0app\n\n\nConnect your \u00d0app\n\n\nRun your \u00d0app\n\n\nAdd \u00d0app styles\n\n\nUsing ethereum:elements\n\n\n\u00d0app code structure\n\n\nBundle your \u00d0app\n\n\n\n\nFAQ\n\n\nIsn't Meteor a full stack framework, how does that fit into \u00d0app development\n\n\nTrue, Meteor is a full stack framework and its main improvement is realtime web applications, but Meteor is also the first framework (i know of), which fully embraced \ns\ningle \np\nage \na\npp (SPA) development and provided all necessary tools.\n\n\n5 reasons why Meteor is a perfect fit:\n\n\n\n\nIts purely written in JS and has all the tools a SPA needs (Templating engine, Model, on-the-fly compiling, bundling)\n\n\nYou get a development environment, which has live reload, CSS injection and support for many pre-compilers (LESS, Coffeescript, etc) out of the box\n\n\nYou can get all frontend code as single \nindex.html\n with one \njs\n and \ncss\n file plus your assets, using \nmeteor-build-client\n. You can then host it everywhere or simple run the \nindex.html\n itself or distribute it later on \nswarm\n.\n\n\nIt embraces full reactivity, which make building consistent interface much easier (similar to angular.js \n$scope\n or binding)\n\n\nIt has a great model called Minimongo, which gives you a mongoDB like interface for a reactive in-memory database, which can also be \nauto-persisted to localstorage\n or \nindexedDB\n\n\n\n\nDo I need to host my \u00d0app on a server?\n\n\nNo, using \nmeteor-build-client\n you can get all the static assets of your \u00d0app to run without a server, though if you use a router like \niron-\n or \nflow-router\n, you need to use hash (\nindex.html#!/mypath\n) routes instead of clean HTML5 pushstate routes.\n\n\n\n\nCreate your \u00d0app\n\n\nInstall Meteor if don't have already:\n\n\n$ curl https://install.meteor.com/ \n|\n sh\n\n\n\n\nThen create an app:\n\n$ meteor create myDapp\n$ \ncd\n myDapp\n\n\n\nNext add the web3 package:\n\n$ meteor add ethereum:web3\n\n\n\nI recommend also to add the following packages:\n\n\n\n\nethereum:dapp-styles\n - The LESS/CSS framework which gives your dapp a nice Mist-consistent look.\n\n\nethereum:tools\n - This package gives you the \nEthTools\n object with a set of formatting an conversion functions and template helpers for ether.\n\n\nethereum:elements\n - A set of interface elements specifically made for ethereum.\n\n\nethereum:accounts\n - Gives you the reactive \nEthAccounts\n collection with all current available ethereum accounts, where balances will be automatically updated.\n\n\nethereum:blocks\n - Gives you the reactive \nEthBlocks\n collection with the latest 50 blocks. To get the lastest block use \nEthBlocks.latest\n (It will also have the latest default gasPrice)\n\n\nfrozeman:template-var\n - Gives you the \nTemplateVar\n object, that allows you to set reactive variables, which are template instance specific. See the \nreadme\n for more.\n\n\nfrozeman:persistent-minimongo2\n - Allows you to auto persist your minimongo collection in local storage\n\n\n\n\nStart your \u00d0app\n\n\nA short excursion into Meteors folder structure\n\n\nMeteor doesn't force you to have a specific folder structure, though some folders have specific meaning and will be treated differently when bundling/running your application.\n\n\nFolders with specific treatment\n- \nclient\n - files in a folder called \nclient\n will only be loaded by the client part of your app and as we are building a \u00d0app, that's where most of our files go.\n- \nlib\n - files in folders called \nlib\n will load before other files in the same folder. This is an ideal place your init files, libraries, or ethereum specific files.\n- \npublic\n - a folder called \npublic\n contains assets meteor will make available on the root of your webserver (or later bundled \u00d0app)\n- There are a few more specific folders like \nserver\n, \ntests\n, \npackages\n, etc. If you want to get to know them take a look at the \nMeteor docs\n\n\nSo to build a \u00d0app we ideally create the following folder structure in our \nmyDapp\n folder:\n\n\n- myDapp\n   - client\n      - lib\n      - myDapp.html\n      - myDapp.js\n      - myDapp.css\n   - public\n\n\n\n\nNote\n The community provides also Meteor \u00d0app Boilerplates like this one from Nick Dodson: https://github.com/SilentCicero/meteor-dapp-boilerplate\n\n\nConnect your \u00d0app\n\n\nTo connect our dapp we need to start \ngeth\n with the right CORS headers in another terminal:\n\n\n$ geth --rpc --rpccorsdomain \nhttp://localhost:3000\n\n\n\n\n\nWe also need to set the provider. Ideally we create a file in our lib folder called \ninit.js\n and add the following line:\n\n\nif\n(\ntypeof\n \nweb3\n \n===\n \nundefined\n)\n\n    \nweb3\n \n=\n \nnew\n \nWeb3\n(\nnew\n \nWeb3\n.\nproviders\n.\nHttpProvider\n(\nhttp://localhost:8545\n));\n\n\n\n\n\nRun your \u00d0app\n\n\nNow we can run our \u00d0app by simply running:\n\n\n$ meteor\n\n\n\n\nIf we go to \nhttp://localhost:3000\n, we should see a website appear and if we open the browser console we can use the web3 object to query the geth node:\n\n\n \nweb3\n.\neth\n.\naccounts\n\n\n[\n0xfff2b43a7433ddf50bb82227ed519cd6b142d382\n]\n\n\n\n\n\nAdd \u00d0app styles\n\n\nIf you want your \u00d0app to nicely fit later into Mist and have follow the official look use the \ndapp-styles css css/less framework\n.\n\n\nNote that they are under heavy development and the class names and elements may change.\n\n\nTo add it simple add the following packages to your \u00d0app:\n\n\n$ meteor add less\n$ meteor add ethereum:dapp-styles\n\n\n\n\nNow rename you \nmyDapp.css\n to \nmyDapp.less\n and add the following line inside:\n\n\n//\n \nlibs\n\n\n@\nimport\n \n{ethereum:dapp-styles}/dapp-styles.less\n;\n\n\n\n\n\nNow you can use all dapp-styles classes and also overwrite all variables of the framework. You can find them \nin the repo\n. Overwrite them by copying them to your \nmyDapp.less\n file and set different values.\n\n\nUsing ethereum packages\n\n\nTo make your life as a \u00d0app developer easier we provide some packages that help you build \u00d0apps faster.\n\n\nIf you add the recommended packages above you should have the \nethereum:tools\n, \nethereum:accounts\n and \nethereum:blocks\n packages available.\n\n\nThese 3 packages give you the \nEthTools\n, \nEthAccounts\n and \nEthblocks\n objects, which give you formatter functions,  a collection with the accounts from \nweb3.eth.accounts\n (with auto updated balance) and a collection of the last 50 blocks.\n\n\nMost of these functions are reactive so they should make building interfaces a breeze.\n\n\nExample usage\n\n\nIf you look into you \nmyDapp.html\n you will find the \nhello\n template.\nJust add a helper called \n{{currentBlock}}\n some where between the \ntemplate name=\"hello\"\n..\n/template\n tags.\n\n\nNow open the \nmyDapp.js\n and add after the \ncounter() {..}\n the \ncurrentBlock\n helper:\n\nTemplate\n.\nelements\n.\nhelpers\n({\n\n    \ncounter\n()\n \n{\n\n      \n...\n\n    \n},\n\n    \ncurrentBlock\n()\n \n{\n\n        \nreturn\n \nEthBlocks\n.\nlatest\n.\nnumber\n;\n\n    \n}\n\n  \n});\n\n\n\n\nThen initialize EthBlocks by adding \nEthBlocks.init();\n after \nthis.counter = new ReactiveVar(0);\n\n\nIf you now check your \u00d0app in the browser you should see the latest block number, which will increase once you mine.\n\n\nFor more examples please checkout the packages readmes and the \ndemo\n (\nsource\n) for more.\n\n\n\u00d0app code structure\n\n\nThis tutorial won't go into building apps with Meteor. For this please refer to the \nMeteor's tutorials\n, \nA list of good resources\n, \nEventMinded\n (payed tutorials) or books like \nBuilding Single-page Web Apps with Meteor\n or \nDiscover Meteor\n.\n\n\nTODO\nShort:\n- put ethereum related stuff into \nclient/lib/ethereum/somefile.js\n\n- use \nmyCollection.observe({added: func, changed: func, removed: func})\n to communicate to ethereum, keep ethereum logic out of your app as much as possible. This way you just write and read from your reactive collections and the observe functions will handle the rest (e.g. sendTransactions)\n- Filters etc will add logs etc to your collections. So you keep all the callback mess out of your app logic.\n\n\nFor an example see the \nEthereum-Wallet\n.\n\n\nBundle your \u00d0app\n\n\nTo bundle your \u00d0app into a local standalone file use \nmeteor-build-client\n:\n\n\n$ npm install -g meteor-build-client\n$ \ncd\n myDapp\n$ meteor-build-client ../build --path \n\n\n\n\n\nThis will put your \u00d0apps static files into the build folder, above your \nmyDapp\n folder.\n\n\nThe last option \n--path\n will make the linking of all files relative, allowing you to start the app by simply clicking the \nbuild/index.html\n.\n\n\nBe aware that when running your app on the \nfile://\n protocol, you won't be able to use client side routing, due to web security. Later in mist you will be able to use client side routing, as dapps are served over the \neth://\n protocol.\n\n\nIn the future you will be able to simply upload your \u00d0app on swarm.", 
            "title": "\u4f7f\u7528Meteor"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#isnt-meteor-a-full-stack-framework-how-does-that-fit-into-app-development", 
            "text": "True, Meteor is a full stack framework and its main improvement is realtime web applications, but Meteor is also the first framework (i know of), which fully embraced  s ingle  p age  a pp (SPA) development and provided all necessary tools.  5 reasons why Meteor is a perfect fit:   Its purely written in JS and has all the tools a SPA needs (Templating engine, Model, on-the-fly compiling, bundling)  You get a development environment, which has live reload, CSS injection and support for many pre-compilers (LESS, Coffeescript, etc) out of the box  You can get all frontend code as single  index.html  with one  js  and  css  file plus your assets, using  meteor-build-client . You can then host it everywhere or simple run the  index.html  itself or distribute it later on  swarm .  It embraces full reactivity, which make building consistent interface much easier (similar to angular.js  $scope  or binding)  It has a great model called Minimongo, which gives you a mongoDB like interface for a reactive in-memory database, which can also be  auto-persisted to localstorage  or  indexedDB", 
            "title": "Isn't Meteor a full stack framework, how does that fit into \u00d0app development"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#do-i-need-to-host-my-app-on-a-server", 
            "text": "No, using  meteor-build-client  you can get all the static assets of your \u00d0app to run without a server, though if you use a router like  iron-  or  flow-router , you need to use hash ( index.html#!/mypath ) routes instead of clean HTML5 pushstate routes.", 
            "title": "Do I need to host my \u00d0app on a server?"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#create-your-app", 
            "text": "Install Meteor if don't have already:  $ curl https://install.meteor.com/  |  sh  Then create an app: $ meteor create myDapp\n$  cd  myDapp  Next add the web3 package: $ meteor add ethereum:web3  I recommend also to add the following packages:   ethereum:dapp-styles  - The LESS/CSS framework which gives your dapp a nice Mist-consistent look.  ethereum:tools  - This package gives you the  EthTools  object with a set of formatting an conversion functions and template helpers for ether.  ethereum:elements  - A set of interface elements specifically made for ethereum.  ethereum:accounts  - Gives you the reactive  EthAccounts  collection with all current available ethereum accounts, where balances will be automatically updated.  ethereum:blocks  - Gives you the reactive  EthBlocks  collection with the latest 50 blocks. To get the lastest block use  EthBlocks.latest  (It will also have the latest default gasPrice)  frozeman:template-var  - Gives you the  TemplateVar  object, that allows you to set reactive variables, which are template instance specific. See the  readme  for more.  frozeman:persistent-minimongo2  - Allows you to auto persist your minimongo collection in local storage", 
            "title": "Create your \u00d0app"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#start-your-app", 
            "text": "", 
            "title": "Start your \u00d0app"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#a-short-excursion-into-meteors-folder-structure", 
            "text": "Meteor doesn't force you to have a specific folder structure, though some folders have specific meaning and will be treated differently when bundling/running your application.  Folders with specific treatment\n-  client  - files in a folder called  client  will only be loaded by the client part of your app and as we are building a \u00d0app, that's where most of our files go.\n-  lib  - files in folders called  lib  will load before other files in the same folder. This is an ideal place your init files, libraries, or ethereum specific files.\n-  public  - a folder called  public  contains assets meteor will make available on the root of your webserver (or later bundled \u00d0app)\n- There are a few more specific folders like  server ,  tests ,  packages , etc. If you want to get to know them take a look at the  Meteor docs  So to build a \u00d0app we ideally create the following folder structure in our  myDapp  folder:  - myDapp\n   - client\n      - lib\n      - myDapp.html\n      - myDapp.js\n      - myDapp.css\n   - public  Note  The community provides also Meteor \u00d0app Boilerplates like this one from Nick Dodson: https://github.com/SilentCicero/meteor-dapp-boilerplate", 
            "title": "A short excursion into Meteors folder structure"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#connect-your-app", 
            "text": "To connect our dapp we need to start  geth  with the right CORS headers in another terminal:  $ geth --rpc --rpccorsdomain  http://localhost:3000   We also need to set the provider. Ideally we create a file in our lib folder called  init.js  and add the following line:  if ( typeof   web3   ===   undefined ) \n     web3   =   new   Web3 ( new   Web3 . providers . HttpProvider ( http://localhost:8545 ));", 
            "title": "Connect your \u00d0app"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#run-your-app", 
            "text": "Now we can run our \u00d0app by simply running:  $ meteor  If we go to  http://localhost:3000 , we should see a website appear and if we open the browser console we can use the web3 object to query the geth node:    web3 . eth . accounts  [ 0xfff2b43a7433ddf50bb82227ed519cd6b142d382 ]", 
            "title": "Run your \u00d0app"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#add-app-styles", 
            "text": "If you want your \u00d0app to nicely fit later into Mist and have follow the official look use the  dapp-styles css css/less framework .  Note that they are under heavy development and the class names and elements may change.  To add it simple add the following packages to your \u00d0app:  $ meteor add less\n$ meteor add ethereum:dapp-styles  Now rename you  myDapp.css  to  myDapp.less  and add the following line inside:  //   libs  @ import   {ethereum:dapp-styles}/dapp-styles.less ;   Now you can use all dapp-styles classes and also overwrite all variables of the framework. You can find them  in the repo . Overwrite them by copying them to your  myDapp.less  file and set different values.", 
            "title": "Add \u00d0app styles"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#using-ethereum-packages", 
            "text": "To make your life as a \u00d0app developer easier we provide some packages that help you build \u00d0apps faster.  If you add the recommended packages above you should have the  ethereum:tools ,  ethereum:accounts  and  ethereum:blocks  packages available.  These 3 packages give you the  EthTools ,  EthAccounts  and  Ethblocks  objects, which give you formatter functions,  a collection with the accounts from  web3.eth.accounts  (with auto updated balance) and a collection of the last 50 blocks.  Most of these functions are reactive so they should make building interfaces a breeze.", 
            "title": "Using ethereum packages"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#example-usage", 
            "text": "If you look into you  myDapp.html  you will find the  hello  template.\nJust add a helper called  {{currentBlock}}  some where between the  template name=\"hello\" .. /template  tags.  Now open the  myDapp.js  and add after the  counter() {..}  the  currentBlock  helper: Template . elements . helpers ({ \n     counter ()   { \n       ... \n     }, \n     currentBlock ()   { \n         return   EthBlocks . latest . number ; \n     } \n   });   Then initialize EthBlocks by adding  EthBlocks.init();  after  this.counter = new ReactiveVar(0);  If you now check your \u00d0app in the browser you should see the latest block number, which will increase once you mine.  For more examples please checkout the packages readmes and the  demo  ( source ) for more.", 
            "title": "Example usage"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#app-code-structure", 
            "text": "This tutorial won't go into building apps with Meteor. For this please refer to the  Meteor's tutorials ,  A list of good resources ,  EventMinded  (payed tutorials) or books like  Building Single-page Web Apps with Meteor  or  Discover Meteor .  TODO\nShort:\n- put ethereum related stuff into  client/lib/ethereum/somefile.js \n- use  myCollection.observe({added: func, changed: func, removed: func})  to communicate to ethereum, keep ethereum logic out of your app as much as possible. This way you just write and read from your reactive collections and the observe functions will handle the rest (e.g. sendTransactions)\n- Filters etc will add logs etc to your collections. So you keep all the callback mess out of your app logic.  For an example see the  Ethereum-Wallet .", 
            "title": "\u00d0app code structure"
        }, 
        {
            "location": "/Dapps/Using-Meteor/#bundle-your-app", 
            "text": "To bundle your \u00d0app into a local standalone file use  meteor-build-client :  $ npm install -g meteor-build-client\n$  cd  myDapp\n$ meteor-build-client ../build --path    This will put your \u00d0apps static files into the build folder, above your  myDapp  folder.  The last option  --path  will make the linking of all files relative, allowing you to start the app by simply clicking the  build/index.html .  Be aware that when running your app on the  file://  protocol, you won't be able to use client side routing, due to web security. Later in mist you will be able to use client side routing, as dapps are served over the  eth://  protocol.  In the future you will be able to simply upload your \u00d0app on swarm.", 
            "title": "Bundle your \u00d0app"
        }, 
        {
            "location": "/Dapps/Tutorial/", 
            "text": "The purpose of this page is to serve as an introduction to the basics of Ethereum that you will need to understand from a development standpoint, in order to produce contracts and decentralized applications. For a general introduction to Ethereum, see \nthe white paper\n, and for a full technical spec see the \nyellow\n papers, although those are not prerequisites for this page; that is to say, this page is meant as an alternative introduction to Ethereum specifically targeted towards application developers.\n\n\nIntroduction\n\n\nEthereum is a platform that is intended to allow people to easily write decentralized applications (\u0110apps) using blockchain technology. A decentralized application is an application which serves some specific purpose to its users, but which has the important property that the application itself does not depend on any specific party existing. Rather than serving as a front-end for selling or providing a specific party's services, a \u0110app is a tool for people and organizations on different sides of an interaction used to come together without any centralized intermediary.\n\n\nEven necessary \"intermediary\" functions that are typically the domain of centralized providers, such as filtering, identity management, escrow and dispute resolution, are either handled directly by the network or left open for anyone to participate, using tools like internal token systems and reputation systems to ensure that users get access to high-quality services. Early examples of \u0110apps include BitTorrent for file sharing and Bitcoin for currency. Ethereum takes the primary developments used by BitTorrent and Bitcoin, the peer to peer network and the blockchain, and generalizes them in order to allow developers to use these technologies for any purpose.\n\n\nThe Ethereum blockchain can be alternately described as a blockchain with a built-in programming language, or as a consensus-based globally executed virtual machine. The part of the protocol that actually handles internal state and computation is referred to as the Ethereum Virtual Machine (EVM). From a practical standpoint, the EVM can be thought of as a large decentralized computer containing millions of objects, called \"accounts\", which have the ability to maintain an internal database, execute code and talk to each other.\n\n\nThere are two types of accounts:\n\n\n\n\nExternally owned account (EOAs)\n: an account controlled by a private key, and if you own the private key associated with the EOA you have the ability to send ether and messages from it.\n\n\nContract\n: an account that has its own code, and is controlled by code.\n\n\n\n\nBy default, the Ethereum execution environment is lifeless; nothing happens and the state of every account remains the same. However, any user can trigger an action by sending a transaction from an externally owned account, setting Ethereum's wheels in motion. If the destination of the transaction is another EOA, then the transaction may transfer some ether but otherwise does nothing. However, if the destination is a contract, then the contract in turn activates, and automatically runs its code.\n\n\nThe code has the ability to read/write to its own internal storage (a database mapping 32-byte keys to 32-byte values), read the storage of the received message, and send messages to other contracts, triggering their execution in turn. Once execution stops, and all sub-executions triggered by a message sent by a contract stop (this all happens in a deterministic and synchronous order, ie. a sub-call completes fully before the parent call goes any further), the execution environment halts once again, until woken by the next transaction.\n\n\nContracts generally serve four purposes:\n\n\n\n\n\n\nMaintain a data store representing something which is useful to either other contracts or to the outside world; one example of this is a contract that simulates a currency, and another is a contract that records membership in a particular organization.\n\n\n\n\n\n\nServe as a sort of externally owned account with a more complicated access policy; this is called a \"forwarding contract\" and typically involves simply resending incoming messages to some desired destination only if certain conditions are met; for example, one can have a forwarding contract that waits until two out of a given three private keys have confirmed a particular message before resending it (ie. multisig). More complex forwarding contracts have different conditions based on the nature of the message sent; the simplest use case for this functionality is a withdrawal limit that is overrideable via some more complicated access procedure.\n\n\n\n\n\n\nManage an ongoing contract or relationship between multiple users. Examples of this include a financial contract, an escrow with some particular set of mediators, or some kind of insurance. One can also have an open contract that one party leaves open for any other party to engage with at any time; one example of this is a contract that automatically pays a bounty to whoever submits a valid solution to some mathematical problem, or proves that it is providing some computational resource.\n\n\n\n\n\n\nProvide functions to other contracts; essentially serving as a software library.\n\n\n\n\n\n\nContracts interact with each other through an activity that is alternately called either \"calling\" or \"sending messages\". A \"message\" is an object containing some quantity of ether (a special internal currency used in Ethereum with the primary purpose of paying transaction fees), a byte-array of data of any size, the addresses of a sender and a recipient. When a contract receives a message it has the option of returning some data, which the original sender of the message can then immediately use. In this way, sending a message is exactly like calling a function.\n\n\nBecause contracts can play such different roles, we expect that contracts will be interacting with each other. As an example, consider a situation where Alice and Bob are betting 100 GavCoin that the temperature in San Francisco will not exceed 35\u00baC at any point in the next year. However, Alice is very security-conscious, and as her primary account uses a forwarding contract which only sends messages with the approval of two out of three private keys. Bob is paranoid about quantum cryptography, so he uses a forwarding contract which passes along only messages that have been signed with \nLamport signatures\n alongside traditional ECDSA (but because he's old fashioned, he prefers to use a version of Lamport sigs based on SHA256, which is not supported in Ethereum directly).\n\n\nThe betting contract itself needs to fetch data about the San Francisco weather from some contract, and it also needs to talk to the GavCoin contract when it wants to actually send the GavCoin to either Alice or Bob (or, more precisely, Alice or Bob's forwarding contract). We can show the relationships between the accounts thus:\n\n\n\n\nWhen Bob wants to finalize the bet, the following steps happen:\n\n\n\n\nA transaction is sent, triggering a message from Bob's EOA to Bob's forwarding contract.\n\n\nBob's forwarding contract sends the hash of the message and the Lamport signature to a contract which functions as a Lamport signature verification library.\n\n\nThe Lamport signature verification library sees that Bob wants a SHA256-based Lamport sig, so it calls the SHA256 library many times as needed to verify the signature.\n\n\nOnce the Lamport signature verification library returns 1, signifying that the signature has been verified, it sends a message to the contract representing the bet.\n\n\nThe bet contract checks the contract providing the San Francisco temperature to see what the temperature is.\n\n\nThe bet contract sees that the response to the messages shows that the temperature is above 35\u00baC, so it sends a message to the GavCoin contract to move the GavCoin from its account to Bob's forwarding contract.\n\n\n\n\nNote that the GavCoin is all \"stored\" as entries in the GavCoin contract's database; the word \"account\" in the context of step 6 simply means that there is a data entry in the GavCoin contract storage with a key for the bet contract's address and a value for its balance. After receiving this message, the GavCoin contract decreases this value by some amount and increases the value in the entry corresponding to Bob's forwarding contract's address. We can see these steps in the following diagram:\n\n\n\n\nState Machine\n\n\nComputation in the EVM is done using a stack-based bytecode language that is like a cross between Bitcoin Script, traditional assembly and Lisp (the Lisp part being due to the recursive message-sending functionality). A program in EVM is a sequence of opcodes, like this:\n\n\nPUSH1 0 CALLDATALOAD SLOAD NOT PUSH1 9 JUMPI STOP JUMPDEST PUSH1 32 CALLDATALOAD PUSH1 0 CALLDATALOAD SSTORE\n\n\n\n\n\nThe purpose of this particular contract is to serve as a name registry; anyone can send a message containing 64 bytes of data, 32 for the key and 32 for the value. The contract checks if the key has already been registered in storage, and if it has not been then the contract registers the value at that key.\n\n\nDuring execution, an infinitely expandable byte-array called \"memory\", the \"program counter\" pointing to the current instruction, and a stack of 32-byte values is maintained. At the start of execution, memory and stack are empty and the PC is zero. Now, let us suppose the contract with this code is being accessed for the first time, and a message is sent in with 123 wei (10\n18\n wei = 1 ether) and 64 bytes of data where the first 32 bytes encode the number 54 and the second 32 bytes encode the number 2020202020.\n\n\nThus, the state at the start is:\n\n\nPC\n:\n \n0\n \nSTACK\n:\n \n[]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nThe instruction at position 0 is PUSH1, which pushes a one-byte value onto the stack and jumps two steps in the code. Thus, we have:\n\n\nPC\n:\n \n2\n \nSTACK\n:\n \n[\n0\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nThe instruction at position 2 is CALLDATALOAD, which pops one value from the stack, loads the 32 bytes of message data starting from that index, and pushes that on to the stack. Recall that the first 32 bytes here encode 54.\n\n\nPC\n:\n \n3\n \nSTACK\n:\n \n[\n54\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nSLOAD pops one from the stack and checks if there is a value in storage for the key popped from the stack. If so, it pushes the value into the stack at the current index. Since the contract is used for the first time, the storage is empty and no value is found for the popped key. Therefore, SLOAD pushes zero to the stack.\n\n\nPC\n:\n \n4\n \nSTACK\n:\n \n[\n0\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nNOT pops one value and pushes 1 if the value is zero, else 0\n\n\nPC\n:\n \n5\n \nSTACK\n:\n \n[\n1\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nNext, we PUSH1 9.\n\n\nPC\n:\n \n7\n \nSTACK\n:\n \n[\n1\n,\n \n9\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nThe JUMPI instruction pops 2 values and jumps to the instruction designated by the first only if the second is nonzero. Here, the second is nonzero, so we jump. If the value in storage index 54 had not been zero, then the second value from top on the stack would have been 0 (due to NOT), so we would not have jumped, and we would have advanced to the STOP instruction which would have led to us stopping execution.\n\n\nPC\n:\n \n9\n \nSTACK\n:\n \n[]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nHere, we PUSH1 32.\n\n\nPC\n:\n \n11\n \nSTACK\n:\n \n[\n32\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nNow, we CALLDATALOAD again, popping 32 and pushing the bytes in message data starting from byte 32 until byte 63.\n\n\nPC\n:\n \n13\n \nSTACK\n:\n \n[\n2020202020\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nNext, we PUSH1 0.\n\n\nPC\n:\n \n14\n \nSTACK\n:\n \n[\n2020202020\n,\n \n0\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nNow, we load message data bytes 0-31 again (loading message data is just as cheap as loading memory, so we don't bother to save it in memory)\n\n\nPC\n:\n \n16\n \nSTACK\n:\n \n[\n2020202020\n,\n \n54\n]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{}\n\n\n\n\n\n\nFinally, we SSTORE to save the value 2020202020 in storage at index 54.\n\n\nPC\n:\n \n17\n \nSTACK\n:\n \n[]\n \nMEM\n:\n \n[],\n \nSTORAGE\n:\n \n{\n54\n:\n \n2020202020\n}\n\n\n\n\n\n\nAt index 17, there is no instruction, so we stop. If there was anything left in the stack or memory, it would be deleted, but the storage will stay and be available next time someone sends a message. Thus, if the sender of this message sends the same message again (or perhaps someone else tries to reregister 54 to 3030303030), the next time the \nJUMPI\n at position 7 would not process, and execution would STOP early at position 8.\n\n\nFortunately, you do not have to program in low-level assembly; a high-level language exists, especially designed for writing contracts, known as \nSolidity\n exists to make it much easier for you to write contracts (there are several others, too, including \nLLL\n, \nSerpent\n and \nMutan\n, which you may find easier to learn or use depending on your experience). Any code you write in these languages gets compiled into EVM, and to create the contracts you send the transaction containing the EVM bytecode.\n\n\nThere are two types of transactions: a sending transaction and a contract creating transaction. A sending transaction is a standard transaction, containing a receiving address, an ether amount, a data bytearray and some other parameters, and a signature from the private key associated with the sender account. A contract creating transaction looks like a standard transaction, except the receiving address is blank. When a contract creating transaction makes its way into the blockchain, the data bytearray in the transaction is interpreted as EVM code, and the value returned by that EVM execution is taken to be the code of the new contract; hence, you can have a transaction do certain things during initialization. The address of the new contract is deterministically calculated based on the sending address and the number of times that the sending account has made a transaction before (this value, called the account nonce, is also kept for unrelated security reasons). Thus, the full code that you need to put onto the blockchain to produce the above name registry is as follows:\n\n\nPUSH1 16 DUP PUSH1 12 PUSH1 0 CODECOPY PUSH1 0 RETURN STOP PUSH1 0 CALLDATALOAD SLOAD NOT PUSH1 9 JUMPI STOP PUSH1 32 CALLDATALOAD PUSH1 0 CALLDATALOAD SSTORE\n\n\n\n\n\nThe key opcodes are CODECOPY, copying the 16 bytes of code starting from byte 12 into memory starting at index 0, and RETURN, returning memory bytes 0-16, ie. code bytes 12-28 (feel free to \"run\" the execution manually on paper to verify that those parts of the code and memory actually get copied and returned). Code bytes 12-28 are, of course, the actual code as we saw above.\n\n\nGas\n\n\nOne important aspect of the way the EVM works is that every single operation that is executed inside the EVM is actually simultaneously executed by every full node. This is a necessary component of the Ethereum 1.0 consensus model, and has the benefit that any contract on the EVM can call any other contract at almost zero cost, but also has the drawback that computational steps on the EVM are very expensive. Roughly, a good heuristic to use is that you will not be able to do anything on the EVM that you cannot do on a smartphone from 1999. Acceptable uses of the EVM include running business logic (\"if this then that\") and verifying signatures and other cryptographic objects; at the upper limit of this are applications that verify parts of other blockchains (eg. a decentralized ether-to-bitcoin exchange); unacceptable uses include using the EVM as a file storage, email or text messaging system, anything to do with graphical interfaces, and applications best suited for cloud computing like genetic algorithms, graph analysis or machine learning.\n\n\nIn order to prevent deliberate attacks and abuse, the Ethereum protocol charges a fee per computational step. The fee is market-based, though mandatory in practice; a floating limit on the number of operations that can be contained in a block forces even miners who can afford to include transactions at close to no cost to charge a fee commensurate with the cost of the transaction to the entire network; see \nthe whitepaper section on fees\n for more details on the economic underpinnings of our fee and block operation limit system.\n\n\nThe way the fee works is as follows. Every transaction must contain, alongside its other data, a \nGASPRICE\n and \nSTARTGAS\n value. \nSTARTGAS\n is the amount of \"gas\" that the transaction assigns itself, and \nGASPRICE\n is the fee that the transaction pays per unit of gas; thus, when a transaction is sent, the first thing that is done during evaluation is subtracting \nSTARTGAS * GASPRICE\n wei plus the transaction's value from the sending account balance. \nGASPRICE\n is set by the transaction sender, but miners will likely refuse to process transactions whose \nGASPRICE\n is too low.\n\n\nGas can be roughly thought of as a counter of computational steps, and is something that exists during transaction execution but not outside of it. When transaction execution starts, the gas remaining is set to \nSTARTGAS - 21000 - 68 * TXDATALEN\n where \nTXDATALEN\n is the number of bytes in transaction data (note: zero bytes are charged only 4 gas due to the greater compressibility of long strings of zero bytes). Every computational step, a certain amount (usually 1, sometimes more depending on the operation) of gas is subtracted from the total. If gas goes down to zero, then all execution reverts, but the transaction is still valid and the sender still has to pay for gas. If transaction execution finishes with \nN \n= 0\n gas remaining, then the sending account is refunded with \nN * GASPRICE\n wei.\n\n\nDuring contract execution, when a contract sends a message, that message call itself comes with a gas limit, and the sub-execution works the same way (namely, it can either run out of gas and revert or execute successfully and return a value). If sub-execution runs out of gas, the parent execution continues; thus, it is perfectly \"safe\" for a contract to call another contract if you set a gas limit on the sub-execution. If sub-execution has some gas remaining, then that gas is returned to the parent execution to continue using.\n\n\nVirtual machine opcodes\n\n\nA complete listing of the opcodes in the EVM can be found in the \nyellow paper\n. Note that high-level languages will often have their own wrappers for these opcodes, sometimes with very different interfaces.\n\n\nBasics of the Ethereum Blockchain\n\n\nThe Ethereum blockchain (or \"ledger\") is the decentralized, massively replicated database in which the current state of all accounts is stored. The blockchain uses a database called a \nPatricia tree\n (or \"trie\") to store all accounts; this is essentially a specialized kind of Merkle tree that acts as a generic key/value store. Like a standard Merkle tree, a Patricia tree has a \"root hash\" that can be used to refer to the entire tree, and the contents of the tree cannot be modified without changing the root hash. For each account, the tree stores a 4-tuple containing \n[account_nonce, ether_balance, code_hash, storage_root]\n, where \naccount_nonce\n is the number of transactions sent from the account (kept to prevent replay attacks), \nether_balance\n is the balance of the account, \ncode_hash\n the hash of the code if the account is a contract and \"\" otherwise, and \nstorage_root\n is the root of yet another Patricia tree which stores the storage data.\n\n\n\n\nEvery minute, a miner produces a new block (the concept of mining in Ethereum is exactly the same as in Bitcoin; see any Bitcoin tutorial for more info on this), and that block contains a list of transactions that happened since the last block and the root hash of the Patricia tree representing the new state (\"state tree\") after applying those transactions and giving the miner an ether reward for creating the block.\n\n\nBecause of the way the Patricia tree works, if few changes are made then most parts of the tree will be exactly the same as in the last block; hence, there is no need to store data twice as nodes in the new tree will simply be able to point back to the same memory address that stores the nodes of the old tree in places where the new tree and the old tree are exactly the same. If a thousand pieces of data are changed between block \nN\n and block \nN + 1\n, even if the total size of the tree is many gigabytes, the amount of new data that needs to be stored for block \nN + 1\n is at most a few hundred kilobytes and often substantially less (especially if multiple changes happen inside the same contract). Every block contains the hash of the previous block (this is what makes the block set a \"chain\") as well as ancillary data like the block number, timestamp, address of the miner and gas limit.\n\n\nGraphical Interfaces (\nOUTDATED API\n)\n\n\nA contract by itself is a powerful thing, but it is not a complete \u0110app. A \u0110app, rather, is defined as a combination of a contract and a graphical interface for using that contract (note: this is only true for now; future versions of Ethereum will include whisper, a protocol for allowing nodes in a \u0110app to send direct peer-to-peer messages to each other without the blockchain). Right now, the interface is implemented as an HTML/CSS/JS webpage, with a special Javascript API in the form of the \neth\n object for working with the Ethereum blockchain. The key parts of the Javascript API are as follows:\n\n\n\n\neth.transact(from, ethervalue, to, data, gaslimit, gasprice)\n - sends a transaction to the desired address from the desired address (note: \nfrom\n must be a private key and \nto\n must be an address in hex form) with the desired parameters\n\n\n(string).pad(n)\n - converts a number, encoded as a string, to binary form \nn\n bytes long\n\n\neth.gasPrice\n - returns the current gas price\n\n\neth.secretToAddress(key)\n - converts a private key into an address\n\n\neth.storageAt(acct, index)\n - returns the desired account's storage entry at the desired index\n\n\neth.key\n - the user's private key\n\n\neth.watch(acct, index, f)\n - calls \nf\n when the given storage entry of the given account changes\n\n\n\n\nYou do not need any special source file or library to use the \neth\n object; however, your \u0110app will only work when opened in an Ethereum client, not a regular web browser. For an example of the Javascript API being used in practice, see \nthe source code of this webpage\n.\n\n\nFine Points To Keep Track Of\n\n\nSee \nhttps://github.com/ethereum/wiki/wiki/Subtleties", 
            "title": "\u5f00\u53d1\u6307\u5357"
        }, 
        {
            "location": "/Dapps/Tutorial/#introduction", 
            "text": "Ethereum is a platform that is intended to allow people to easily write decentralized applications (\u0110apps) using blockchain technology. A decentralized application is an application which serves some specific purpose to its users, but which has the important property that the application itself does not depend on any specific party existing. Rather than serving as a front-end for selling or providing a specific party's services, a \u0110app is a tool for people and organizations on different sides of an interaction used to come together without any centralized intermediary.  Even necessary \"intermediary\" functions that are typically the domain of centralized providers, such as filtering, identity management, escrow and dispute resolution, are either handled directly by the network or left open for anyone to participate, using tools like internal token systems and reputation systems to ensure that users get access to high-quality services. Early examples of \u0110apps include BitTorrent for file sharing and Bitcoin for currency. Ethereum takes the primary developments used by BitTorrent and Bitcoin, the peer to peer network and the blockchain, and generalizes them in order to allow developers to use these technologies for any purpose.  The Ethereum blockchain can be alternately described as a blockchain with a built-in programming language, or as a consensus-based globally executed virtual machine. The part of the protocol that actually handles internal state and computation is referred to as the Ethereum Virtual Machine (EVM). From a practical standpoint, the EVM can be thought of as a large decentralized computer containing millions of objects, called \"accounts\", which have the ability to maintain an internal database, execute code and talk to each other.  There are two types of accounts:   Externally owned account (EOAs) : an account controlled by a private key, and if you own the private key associated with the EOA you have the ability to send ether and messages from it.  Contract : an account that has its own code, and is controlled by code.   By default, the Ethereum execution environment is lifeless; nothing happens and the state of every account remains the same. However, any user can trigger an action by sending a transaction from an externally owned account, setting Ethereum's wheels in motion. If the destination of the transaction is another EOA, then the transaction may transfer some ether but otherwise does nothing. However, if the destination is a contract, then the contract in turn activates, and automatically runs its code.  The code has the ability to read/write to its own internal storage (a database mapping 32-byte keys to 32-byte values), read the storage of the received message, and send messages to other contracts, triggering their execution in turn. Once execution stops, and all sub-executions triggered by a message sent by a contract stop (this all happens in a deterministic and synchronous order, ie. a sub-call completes fully before the parent call goes any further), the execution environment halts once again, until woken by the next transaction.  Contracts generally serve four purposes:    Maintain a data store representing something which is useful to either other contracts or to the outside world; one example of this is a contract that simulates a currency, and another is a contract that records membership in a particular organization.    Serve as a sort of externally owned account with a more complicated access policy; this is called a \"forwarding contract\" and typically involves simply resending incoming messages to some desired destination only if certain conditions are met; for example, one can have a forwarding contract that waits until two out of a given three private keys have confirmed a particular message before resending it (ie. multisig). More complex forwarding contracts have different conditions based on the nature of the message sent; the simplest use case for this functionality is a withdrawal limit that is overrideable via some more complicated access procedure.    Manage an ongoing contract or relationship between multiple users. Examples of this include a financial contract, an escrow with some particular set of mediators, or some kind of insurance. One can also have an open contract that one party leaves open for any other party to engage with at any time; one example of this is a contract that automatically pays a bounty to whoever submits a valid solution to some mathematical problem, or proves that it is providing some computational resource.    Provide functions to other contracts; essentially serving as a software library.    Contracts interact with each other through an activity that is alternately called either \"calling\" or \"sending messages\". A \"message\" is an object containing some quantity of ether (a special internal currency used in Ethereum with the primary purpose of paying transaction fees), a byte-array of data of any size, the addresses of a sender and a recipient. When a contract receives a message it has the option of returning some data, which the original sender of the message can then immediately use. In this way, sending a message is exactly like calling a function.  Because contracts can play such different roles, we expect that contracts will be interacting with each other. As an example, consider a situation where Alice and Bob are betting 100 GavCoin that the temperature in San Francisco will not exceed 35\u00baC at any point in the next year. However, Alice is very security-conscious, and as her primary account uses a forwarding contract which only sends messages with the approval of two out of three private keys. Bob is paranoid about quantum cryptography, so he uses a forwarding contract which passes along only messages that have been signed with  Lamport signatures  alongside traditional ECDSA (but because he's old fashioned, he prefers to use a version of Lamport sigs based on SHA256, which is not supported in Ethereum directly).  The betting contract itself needs to fetch data about the San Francisco weather from some contract, and it also needs to talk to the GavCoin contract when it wants to actually send the GavCoin to either Alice or Bob (or, more precisely, Alice or Bob's forwarding contract). We can show the relationships between the accounts thus:   When Bob wants to finalize the bet, the following steps happen:   A transaction is sent, triggering a message from Bob's EOA to Bob's forwarding contract.  Bob's forwarding contract sends the hash of the message and the Lamport signature to a contract which functions as a Lamport signature verification library.  The Lamport signature verification library sees that Bob wants a SHA256-based Lamport sig, so it calls the SHA256 library many times as needed to verify the signature.  Once the Lamport signature verification library returns 1, signifying that the signature has been verified, it sends a message to the contract representing the bet.  The bet contract checks the contract providing the San Francisco temperature to see what the temperature is.  The bet contract sees that the response to the messages shows that the temperature is above 35\u00baC, so it sends a message to the GavCoin contract to move the GavCoin from its account to Bob's forwarding contract.   Note that the GavCoin is all \"stored\" as entries in the GavCoin contract's database; the word \"account\" in the context of step 6 simply means that there is a data entry in the GavCoin contract storage with a key for the bet contract's address and a value for its balance. After receiving this message, the GavCoin contract decreases this value by some amount and increases the value in the entry corresponding to Bob's forwarding contract's address. We can see these steps in the following diagram:", 
            "title": "Introduction"
        }, 
        {
            "location": "/Dapps/Tutorial/#state-machine", 
            "text": "Computation in the EVM is done using a stack-based bytecode language that is like a cross between Bitcoin Script, traditional assembly and Lisp (the Lisp part being due to the recursive message-sending functionality). A program in EVM is a sequence of opcodes, like this:  PUSH1 0 CALLDATALOAD SLOAD NOT PUSH1 9 JUMPI STOP JUMPDEST PUSH1 32 CALLDATALOAD PUSH1 0 CALLDATALOAD SSTORE  The purpose of this particular contract is to serve as a name registry; anyone can send a message containing 64 bytes of data, 32 for the key and 32 for the value. The contract checks if the key has already been registered in storage, and if it has not been then the contract registers the value at that key.  During execution, an infinitely expandable byte-array called \"memory\", the \"program counter\" pointing to the current instruction, and a stack of 32-byte values is maintained. At the start of execution, memory and stack are empty and the PC is zero. Now, let us suppose the contract with this code is being accessed for the first time, and a message is sent in with 123 wei (10 18  wei = 1 ether) and 64 bytes of data where the first 32 bytes encode the number 54 and the second 32 bytes encode the number 2020202020.  Thus, the state at the start is:  PC :   0   STACK :   []   MEM :   [],   STORAGE :   {}   The instruction at position 0 is PUSH1, which pushes a one-byte value onto the stack and jumps two steps in the code. Thus, we have:  PC :   2   STACK :   [ 0 ]   MEM :   [],   STORAGE :   {}   The instruction at position 2 is CALLDATALOAD, which pops one value from the stack, loads the 32 bytes of message data starting from that index, and pushes that on to the stack. Recall that the first 32 bytes here encode 54.  PC :   3   STACK :   [ 54 ]   MEM :   [],   STORAGE :   {}   SLOAD pops one from the stack and checks if there is a value in storage for the key popped from the stack. If so, it pushes the value into the stack at the current index. Since the contract is used for the first time, the storage is empty and no value is found for the popped key. Therefore, SLOAD pushes zero to the stack.  PC :   4   STACK :   [ 0 ]   MEM :   [],   STORAGE :   {}   NOT pops one value and pushes 1 if the value is zero, else 0  PC :   5   STACK :   [ 1 ]   MEM :   [],   STORAGE :   {}   Next, we PUSH1 9.  PC :   7   STACK :   [ 1 ,   9 ]   MEM :   [],   STORAGE :   {}   The JUMPI instruction pops 2 values and jumps to the instruction designated by the first only if the second is nonzero. Here, the second is nonzero, so we jump. If the value in storage index 54 had not been zero, then the second value from top on the stack would have been 0 (due to NOT), so we would not have jumped, and we would have advanced to the STOP instruction which would have led to us stopping execution.  PC :   9   STACK :   []   MEM :   [],   STORAGE :   {}   Here, we PUSH1 32.  PC :   11   STACK :   [ 32 ]   MEM :   [],   STORAGE :   {}   Now, we CALLDATALOAD again, popping 32 and pushing the bytes in message data starting from byte 32 until byte 63.  PC :   13   STACK :   [ 2020202020 ]   MEM :   [],   STORAGE :   {}   Next, we PUSH1 0.  PC :   14   STACK :   [ 2020202020 ,   0 ]   MEM :   [],   STORAGE :   {}   Now, we load message data bytes 0-31 again (loading message data is just as cheap as loading memory, so we don't bother to save it in memory)  PC :   16   STACK :   [ 2020202020 ,   54 ]   MEM :   [],   STORAGE :   {}   Finally, we SSTORE to save the value 2020202020 in storage at index 54.  PC :   17   STACK :   []   MEM :   [],   STORAGE :   { 54 :   2020202020 }   At index 17, there is no instruction, so we stop. If there was anything left in the stack or memory, it would be deleted, but the storage will stay and be available next time someone sends a message. Thus, if the sender of this message sends the same message again (or perhaps someone else tries to reregister 54 to 3030303030), the next time the  JUMPI  at position 7 would not process, and execution would STOP early at position 8.  Fortunately, you do not have to program in low-level assembly; a high-level language exists, especially designed for writing contracts, known as  Solidity  exists to make it much easier for you to write contracts (there are several others, too, including  LLL ,  Serpent  and  Mutan , which you may find easier to learn or use depending on your experience). Any code you write in these languages gets compiled into EVM, and to create the contracts you send the transaction containing the EVM bytecode.  There are two types of transactions: a sending transaction and a contract creating transaction. A sending transaction is a standard transaction, containing a receiving address, an ether amount, a data bytearray and some other parameters, and a signature from the private key associated with the sender account. A contract creating transaction looks like a standard transaction, except the receiving address is blank. When a contract creating transaction makes its way into the blockchain, the data bytearray in the transaction is interpreted as EVM code, and the value returned by that EVM execution is taken to be the code of the new contract; hence, you can have a transaction do certain things during initialization. The address of the new contract is deterministically calculated based on the sending address and the number of times that the sending account has made a transaction before (this value, called the account nonce, is also kept for unrelated security reasons). Thus, the full code that you need to put onto the blockchain to produce the above name registry is as follows:  PUSH1 16 DUP PUSH1 12 PUSH1 0 CODECOPY PUSH1 0 RETURN STOP PUSH1 0 CALLDATALOAD SLOAD NOT PUSH1 9 JUMPI STOP PUSH1 32 CALLDATALOAD PUSH1 0 CALLDATALOAD SSTORE  The key opcodes are CODECOPY, copying the 16 bytes of code starting from byte 12 into memory starting at index 0, and RETURN, returning memory bytes 0-16, ie. code bytes 12-28 (feel free to \"run\" the execution manually on paper to verify that those parts of the code and memory actually get copied and returned). Code bytes 12-28 are, of course, the actual code as we saw above.", 
            "title": "State Machine"
        }, 
        {
            "location": "/Dapps/Tutorial/#gas", 
            "text": "One important aspect of the way the EVM works is that every single operation that is executed inside the EVM is actually simultaneously executed by every full node. This is a necessary component of the Ethereum 1.0 consensus model, and has the benefit that any contract on the EVM can call any other contract at almost zero cost, but also has the drawback that computational steps on the EVM are very expensive. Roughly, a good heuristic to use is that you will not be able to do anything on the EVM that you cannot do on a smartphone from 1999. Acceptable uses of the EVM include running business logic (\"if this then that\") and verifying signatures and other cryptographic objects; at the upper limit of this are applications that verify parts of other blockchains (eg. a decentralized ether-to-bitcoin exchange); unacceptable uses include using the EVM as a file storage, email or text messaging system, anything to do with graphical interfaces, and applications best suited for cloud computing like genetic algorithms, graph analysis or machine learning.  In order to prevent deliberate attacks and abuse, the Ethereum protocol charges a fee per computational step. The fee is market-based, though mandatory in practice; a floating limit on the number of operations that can be contained in a block forces even miners who can afford to include transactions at close to no cost to charge a fee commensurate with the cost of the transaction to the entire network; see  the whitepaper section on fees  for more details on the economic underpinnings of our fee and block operation limit system.  The way the fee works is as follows. Every transaction must contain, alongside its other data, a  GASPRICE  and  STARTGAS  value.  STARTGAS  is the amount of \"gas\" that the transaction assigns itself, and  GASPRICE  is the fee that the transaction pays per unit of gas; thus, when a transaction is sent, the first thing that is done during evaluation is subtracting  STARTGAS * GASPRICE  wei plus the transaction's value from the sending account balance.  GASPRICE  is set by the transaction sender, but miners will likely refuse to process transactions whose  GASPRICE  is too low.  Gas can be roughly thought of as a counter of computational steps, and is something that exists during transaction execution but not outside of it. When transaction execution starts, the gas remaining is set to  STARTGAS - 21000 - 68 * TXDATALEN  where  TXDATALEN  is the number of bytes in transaction data (note: zero bytes are charged only 4 gas due to the greater compressibility of long strings of zero bytes). Every computational step, a certain amount (usually 1, sometimes more depending on the operation) of gas is subtracted from the total. If gas goes down to zero, then all execution reverts, but the transaction is still valid and the sender still has to pay for gas. If transaction execution finishes with  N  = 0  gas remaining, then the sending account is refunded with  N * GASPRICE  wei.  During contract execution, when a contract sends a message, that message call itself comes with a gas limit, and the sub-execution works the same way (namely, it can either run out of gas and revert or execute successfully and return a value). If sub-execution runs out of gas, the parent execution continues; thus, it is perfectly \"safe\" for a contract to call another contract if you set a gas limit on the sub-execution. If sub-execution has some gas remaining, then that gas is returned to the parent execution to continue using.", 
            "title": "Gas"
        }, 
        {
            "location": "/Dapps/Tutorial/#virtual-machine-opcodes", 
            "text": "A complete listing of the opcodes in the EVM can be found in the  yellow paper . Note that high-level languages will often have their own wrappers for these opcodes, sometimes with very different interfaces.", 
            "title": "Virtual machine opcodes"
        }, 
        {
            "location": "/Dapps/Tutorial/#basics-of-the-ethereum-blockchain", 
            "text": "The Ethereum blockchain (or \"ledger\") is the decentralized, massively replicated database in which the current state of all accounts is stored. The blockchain uses a database called a  Patricia tree  (or \"trie\") to store all accounts; this is essentially a specialized kind of Merkle tree that acts as a generic key/value store. Like a standard Merkle tree, a Patricia tree has a \"root hash\" that can be used to refer to the entire tree, and the contents of the tree cannot be modified without changing the root hash. For each account, the tree stores a 4-tuple containing  [account_nonce, ether_balance, code_hash, storage_root] , where  account_nonce  is the number of transactions sent from the account (kept to prevent replay attacks),  ether_balance  is the balance of the account,  code_hash  the hash of the code if the account is a contract and \"\" otherwise, and  storage_root  is the root of yet another Patricia tree which stores the storage data.   Every minute, a miner produces a new block (the concept of mining in Ethereum is exactly the same as in Bitcoin; see any Bitcoin tutorial for more info on this), and that block contains a list of transactions that happened since the last block and the root hash of the Patricia tree representing the new state (\"state tree\") after applying those transactions and giving the miner an ether reward for creating the block.  Because of the way the Patricia tree works, if few changes are made then most parts of the tree will be exactly the same as in the last block; hence, there is no need to store data twice as nodes in the new tree will simply be able to point back to the same memory address that stores the nodes of the old tree in places where the new tree and the old tree are exactly the same. If a thousand pieces of data are changed between block  N  and block  N + 1 , even if the total size of the tree is many gigabytes, the amount of new data that needs to be stored for block  N + 1  is at most a few hundred kilobytes and often substantially less (especially if multiple changes happen inside the same contract). Every block contains the hash of the previous block (this is what makes the block set a \"chain\") as well as ancillary data like the block number, timestamp, address of the miner and gas limit.", 
            "title": "Basics of the Ethereum Blockchain"
        }, 
        {
            "location": "/Dapps/Tutorial/#graphical-interfaces-outdated-api", 
            "text": "A contract by itself is a powerful thing, but it is not a complete \u0110app. A \u0110app, rather, is defined as a combination of a contract and a graphical interface for using that contract (note: this is only true for now; future versions of Ethereum will include whisper, a protocol for allowing nodes in a \u0110app to send direct peer-to-peer messages to each other without the blockchain). Right now, the interface is implemented as an HTML/CSS/JS webpage, with a special Javascript API in the form of the  eth  object for working with the Ethereum blockchain. The key parts of the Javascript API are as follows:   eth.transact(from, ethervalue, to, data, gaslimit, gasprice)  - sends a transaction to the desired address from the desired address (note:  from  must be a private key and  to  must be an address in hex form) with the desired parameters  (string).pad(n)  - converts a number, encoded as a string, to binary form  n  bytes long  eth.gasPrice  - returns the current gas price  eth.secretToAddress(key)  - converts a private key into an address  eth.storageAt(acct, index)  - returns the desired account's storage entry at the desired index  eth.key  - the user's private key  eth.watch(acct, index, f)  - calls  f  when the given storage entry of the given account changes   You do not need any special source file or library to use the  eth  object; however, your \u0110app will only work when opened in an Ethereum client, not a regular web browser. For an example of the Javascript API being used in practice, see  the source code of this webpage .", 
            "title": "Graphical Interfaces (OUTDATED API)"
        }, 
        {
            "location": "/Dapps/Tutorial/#fine-points-to-keep-track-of", 
            "text": "See  https://github.com/ethereum/wiki/wiki/Subtleties", 
            "title": "Fine Points To Keep Track Of"
        }, 
        {
            "location": "/Dapps/Mix-IDE/", 
            "text": "Mix has been discontinued. Please use https://remix.ethereum.org", 
            "title": "Mix \u6307\u5357"
        }, 
        {
            "location": "/Dapps/Mix-Features/", 
            "text": "OUTDATED\n \nThis document can contain outdated information.\n\n\nBlock Mining\n\n\nHit \nFile\n-\nNew Project\n.\n\n\nType contract:\n\n\ncontract\n \nTest\n \n{\n\n\n}\n\n\n\n\n\nHit \nFile\n-\nSave\n.\n\n\nHit \nDeploy\n-\nDeploy 'Default'\n to deploy contract.\n\n\nThen for index.html:\n\n\nhtml\n\n\nhead\n\n\nscript\n\n\nvar\n \nweb3\n \n=\n \nparent\n.\nweb3\n;\n\n\nvar\n \ntheContract\n \n=\n \nparent\n.\ncontract\n;\n\n\n/\nscript\n\n\n/\nhead\n\n\nbody\n\n    number: \nspan\n \nid\n=\nn\n/\nspan\n\n\nscript\n\n    \nfunction\n \nupdate\n()\n \n{\n\n        \ndocument\n.\ngetElementById\n(\nn\n).\ninnerHTML\n \n=\n \nweb3\n.\neth\n.\nblockNumber\n;\n\n    \n}\n\n    \nweb3\n.\neth\n.\nfilter\n(\nlatest\n,\n \nupdate\n);\n\n\n/\nscript\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\nHit \nFile\n-\nSave\n.\n\n\nIn the HTML view, you'll see:\n\n\nnumber\n:\n \n1\n\n\n\n\n\nHit \nDeploy\n-\nMine\n.\n\n\nThe HTML view will update to:\n\n\nnumber\n:\n \n2\n\n\n\n\n\nParameters in Contract Constructor\n\n\nWrite a Contract containing parameters in the constructor:\n\n\ncontract\n \nTest\n \n{\n\n       \nuint\n \nmem\n;\n\n       \nTest\n(\nuint\n \n_a\n,\n \nuint\n \n_b\n)\n \n{\n \nmem\n \n=\n \n_a\n;\n \n}\n\n       \nget\n()\n \nreturns\n \n(\nuint\n)\n\n       \n{\n\n         \nreturn\n \nmem\n;\n\n       \n}\n\n\n}\n\n\n\n\n\nPress \nF7\n =\n \nEdit State\n\nThe transaction named 'Constructor' should appear in the transaction lists.\n\n\nPress \nEdit\n (on \nConstructor\n)\nThis modal dialog should allow users to fill in input parameters (_a and _b).\n\n\nPress \n+\n to add a new transaction. Select the function \nget\n and save.\n\n\nPress \nF5\n (or run the current editing state if this is not the default state).\n\n\nVerify that the return value of \nget\n is displayed and is this is the good one =\n in the transaction log (column \nreturned\n).\n\n\nDeploy to Network\n\n\nThis feature allows users to deploy the current project as a Dapp in the main blockchain.\nThis will deploy contracts and register front end resources.\n\n\nThe deployment process includes two steps:\n - \nThe Deployment of contracts\n:\nThis step will deploy contracts in the main blockchain and package front end resources of the current project. After this operation the package (package.dapp) will be available inside the deployment directory.\n\n\n\n\nThe Registration of front end resources\n:\nTo render the Dapp, the Ethereum browser (Mist or AlethZero) needs to access this package. This step will register the URL where the resources are stored.\n\n\n\n\nTo Deploy your Dapp, Please follow these instructions:\n\n\nClick on \nDeploy\n, \nDeploy to Network\n.\nThis modal dialog displays two parts, We will focus on the first part (Deployment) for now:\n\n\nThe Deployment of contracts\n\n - 4 Buttons: \nHelp\n to access to the WikiPage, \nOpen Package Folder\n to open the deployment directory (this button is only enable is the package is built), \nCopy Base64 conversion to ClipBoard\n to copy the Base64 value of the built package (this button is only enable is the package is built), \nExit\n to close this modal dialog.\n - \nRoot Registrar address\n is the address of the root registrar contract (used to link the Dapp with resources.\n - \nAccount used to deploy\n allows users to select the Ethereum account to use to deploy.\n - \nAmount of gas to use..\n is the amount of gas that the deployment process will use to deploy contracts.\n - \nEthereum Application URL\n is the address that users should use in Mist (or AlethZero) to access to the Dapp. in italic, you can check the formatted Dapp URL (which will be used by the Ethereum browser)\n(ex: eth/user1/app1).\n - \nWeb Application Resources URL\n is the URL where the front resources (html/js/...) will be stored.\n - 1 button to start the deployment process (The checkbox \nDeploy Contract(s)\n is disabled and checked if this is the first time the contract is deployed. If not you can choose to repackage the resources without redeploying the contract by unchecking this option).\n\n\nClick on \nDeploy contract(s) and Package resources files\n (last button) and the deployment is executed.\nThen many options/actions will be enabled:\n - \nOpen Package Folder\n, \nCopy Base64 conversion to ClipBoard\n, \nDeploy Contract(s)\n\n - All inputs associated with the second step.\n\n\nHost your web application\n\n\nThere are many places where to host front end resources, you just need to find a web server. One other way (and very easy way) could be to use the pastebin.com service:\n - Follow the first deployment step to deploy contract(s).\n - The \nCopy Base64 conversion to ClipBoard\n icon will be enable (on top of the modal dialog), click on this icon to copy the Base64 content into the clipboard.\n - Go to pastebin.com and paste the content into the \nNew Paste\n input. Then click on \nSubmit'.\n - Go through the Captcha.\n - Copy the address targeted by the link\nRaw\n(on the top of the page).\n - Use this address in the\nWeb Application Resources URL` field.\n\n\nRegistration of front end resources\n\n - \nURL Hint contract address\n is the address of the contract which is used to store the URL where the resources are.\n - \nWeb Application Resources URL\n is the URL from where the Ethereum browser will retrieve resources.\n\n\nClick on \nRegister hosted Web Application\n and Mix will register the front end resources on the Ethereum network.\n\n\nUsers can now use  Mist or AlethZero to access to the Dapp, using the Ethereum URL (ex: eth/user1/app1).\n\n\nAccount Management\n\n\nWhen a new state is created, it is possible to add new accounts which can be used to send transaction.\nIt is not possible to delete an account if this one is used by a transaction.\n\n\nBy default, one account is created, this account will be used to deploy standards contract like \nConfig\n and \nNameReg\n but can also be used in other transactions.\n\n\nFor each created account users have to specify a balance. When users start to debugging, the state will\nbe initialized with all the configured accounts/balances.\n\n\nWhen a transaction is edited, users can select which account to set as the sender.\n\n\nLogs Window\n\n\nClicking on the header status pane will open a pane which displays all logs generated by Mix.\nThere are 3 log levels: info, warning, error.\nThose logs comes from different part of Mix:\n - \nJavaScript\n displays logs coming from the Web preview, it shows error messages generated by the JavaScript engine and messages generated by the command \nconsole.log('...')\n.\n - \nRun\n displays logs coming from the execution of transactions.\n - \nState\n displays logs coming from directly from the state (State alteration, New block added).\n - \nCompilation\n displays logs generated by an error when Mix is trying to compile contracts.\n\n\nOn the header are several actions:\n - Clear the content of this window.\n - Copy the content to the Clipboard.\n - Select which log type to display (4 buttons).\n - Use the text input to filter displayed logs.\n\n\nAuto-completion for solidity source\n\n\nAuto-completion in Mix is based on the code mirror plugins show-hint.js and anyword-hint.js (Not semantic)\nIt displays:\n  - Solidity token (currency, keywords, stdContract, Time, Types).\n  - Contract Name.\n  - Functions Name.\n  - Words that are in the nearby code.\n\n\nError messages\n\n\nWhen running a bunch of transactions, several error might happen.\nOne of the common error is that the current account does not have enough ether to execute a transaction.\nUsers should be aware of that and the status panel should display the amount of gas needed, and the current amount of ether that the user has given for this transaction.\nOther important error messages will be displayed here.\n\n\nHighlight secondary error locations\n\n\nIf the current compilation error has secondary errors locations Mix shows those secondary errors.\nIn each secondary errors Mix shows where (document) the primary error is.", 
            "title": "Mix \u7279\u8272"
        }, 
        {
            "location": "/Dapps/Mix-Features/#block-mining", 
            "text": "Hit  File - New Project .  Type contract:  contract   Test   {  }   Hit  File - Save .  Hit  Deploy - Deploy 'Default'  to deploy contract.  Then for index.html:  html  head  script  var   web3   =   parent . web3 ;  var   theContract   =   parent . contract ;  / script  / head  body \n    number:  span   id = n / span  script \n     function   update ()   { \n         document . getElementById ( n ). innerHTML   =   web3 . eth . blockNumber ; \n     } \n     web3 . eth . filter ( latest ,   update );  / script  / body  / html   Hit  File - Save .  In the HTML view, you'll see:  number :   1   Hit  Deploy - Mine .  The HTML view will update to:  number :   2", 
            "title": "Block Mining"
        }, 
        {
            "location": "/Dapps/Mix-Features/#parameters-in-contract-constructor", 
            "text": "Write a Contract containing parameters in the constructor:  contract   Test   { \n        uint   mem ; \n        Test ( uint   _a ,   uint   _b )   {   mem   =   _a ;   } \n        get ()   returns   ( uint ) \n        { \n          return   mem ; \n        }  }   Press  F7  =   Edit State \nThe transaction named 'Constructor' should appear in the transaction lists.  Press  Edit  (on  Constructor )\nThis modal dialog should allow users to fill in input parameters (_a and _b).  Press  +  to add a new transaction. Select the function  get  and save.  Press  F5  (or run the current editing state if this is not the default state).  Verify that the return value of  get  is displayed and is this is the good one =  in the transaction log (column  returned ).", 
            "title": "Parameters in Contract Constructor"
        }, 
        {
            "location": "/Dapps/Mix-Features/#deploy-to-network", 
            "text": "This feature allows users to deploy the current project as a Dapp in the main blockchain.\nThis will deploy contracts and register front end resources.  The deployment process includes two steps:\n -  The Deployment of contracts :\nThis step will deploy contracts in the main blockchain and package front end resources of the current project. After this operation the package (package.dapp) will be available inside the deployment directory.   The Registration of front end resources :\nTo render the Dapp, the Ethereum browser (Mist or AlethZero) needs to access this package. This step will register the URL where the resources are stored.   To Deploy your Dapp, Please follow these instructions:  Click on  Deploy ,  Deploy to Network .\nThis modal dialog displays two parts, We will focus on the first part (Deployment) for now:  The Deployment of contracts \n - 4 Buttons:  Help  to access to the WikiPage,  Open Package Folder  to open the deployment directory (this button is only enable is the package is built),  Copy Base64 conversion to ClipBoard  to copy the Base64 value of the built package (this button is only enable is the package is built),  Exit  to close this modal dialog.\n -  Root Registrar address  is the address of the root registrar contract (used to link the Dapp with resources.\n -  Account used to deploy  allows users to select the Ethereum account to use to deploy.\n -  Amount of gas to use..  is the amount of gas that the deployment process will use to deploy contracts.\n -  Ethereum Application URL  is the address that users should use in Mist (or AlethZero) to access to the Dapp. in italic, you can check the formatted Dapp URL (which will be used by the Ethereum browser)\n(ex: eth/user1/app1).\n -  Web Application Resources URL  is the URL where the front resources (html/js/...) will be stored.\n - 1 button to start the deployment process (The checkbox  Deploy Contract(s)  is disabled and checked if this is the first time the contract is deployed. If not you can choose to repackage the resources without redeploying the contract by unchecking this option).  Click on  Deploy contract(s) and Package resources files  (last button) and the deployment is executed.\nThen many options/actions will be enabled:\n -  Open Package Folder ,  Copy Base64 conversion to ClipBoard ,  Deploy Contract(s) \n - All inputs associated with the second step.  Host your web application  There are many places where to host front end resources, you just need to find a web server. One other way (and very easy way) could be to use the pastebin.com service:\n - Follow the first deployment step to deploy contract(s).\n - The  Copy Base64 conversion to ClipBoard  icon will be enable (on top of the modal dialog), click on this icon to copy the Base64 content into the clipboard.\n - Go to pastebin.com and paste the content into the  New Paste  input. Then click on  Submit'.\n - Go through the Captcha.\n - Copy the address targeted by the link Raw (on the top of the page).\n - Use this address in the Web Application Resources URL` field.  Registration of front end resources \n -  URL Hint contract address  is the address of the contract which is used to store the URL where the resources are.\n -  Web Application Resources URL  is the URL from where the Ethereum browser will retrieve resources.  Click on  Register hosted Web Application  and Mix will register the front end resources on the Ethereum network.  Users can now use  Mist or AlethZero to access to the Dapp, using the Ethereum URL (ex: eth/user1/app1).", 
            "title": "Deploy to Network"
        }, 
        {
            "location": "/Dapps/Mix-Features/#account-management", 
            "text": "When a new state is created, it is possible to add new accounts which can be used to send transaction.\nIt is not possible to delete an account if this one is used by a transaction.  By default, one account is created, this account will be used to deploy standards contract like  Config  and  NameReg  but can also be used in other transactions.  For each created account users have to specify a balance. When users start to debugging, the state will\nbe initialized with all the configured accounts/balances.  When a transaction is edited, users can select which account to set as the sender.", 
            "title": "Account Management"
        }, 
        {
            "location": "/Dapps/Mix-Features/#logs-window", 
            "text": "Clicking on the header status pane will open a pane which displays all logs generated by Mix.\nThere are 3 log levels: info, warning, error.\nThose logs comes from different part of Mix:\n -  JavaScript  displays logs coming from the Web preview, it shows error messages generated by the JavaScript engine and messages generated by the command  console.log('...') .\n -  Run  displays logs coming from the execution of transactions.\n -  State  displays logs coming from directly from the state (State alteration, New block added).\n -  Compilation  displays logs generated by an error when Mix is trying to compile contracts.  On the header are several actions:\n - Clear the content of this window.\n - Copy the content to the Clipboard.\n - Select which log type to display (4 buttons).\n - Use the text input to filter displayed logs.", 
            "title": "Logs Window"
        }, 
        {
            "location": "/Dapps/Mix-Features/#auto-completion-for-solidity-source", 
            "text": "Auto-completion in Mix is based on the code mirror plugins show-hint.js and anyword-hint.js (Not semantic)\nIt displays:\n  - Solidity token (currency, keywords, stdContract, Time, Types).\n  - Contract Name.\n  - Functions Name.\n  - Words that are in the nearby code.", 
            "title": "Auto-completion for solidity source"
        }, 
        {
            "location": "/Dapps/Mix-Features/#error-messages", 
            "text": "When running a bunch of transactions, several error might happen.\nOne of the common error is that the current account does not have enough ether to execute a transaction.\nUsers should be aware of that and the status panel should display the amount of gas needed, and the current amount of ether that the user has given for this transaction.\nOther important error messages will be displayed here.", 
            "title": "Error messages"
        }, 
        {
            "location": "/Dapps/Mix-Features/#highlight-secondary-error-locations", 
            "text": "If the current compilation error has secondary errors locations Mix shows those secondary errors.\nIn each secondary errors Mix shows where (document) the primary error is.", 
            "title": "Highlight secondary error locations"
        }, 
        {
            "location": "/Dapps/viper/", 
            "text": "Viper\n\n\nvyper", 
            "title": "Viper"
        }, 
        {
            "location": "/Dapps/viper/#viper", 
            "text": "vyper", 
            "title": "Viper"
        }, 
        {
            "location": "/Dapps/Serpent/", 
            "text": "Serpent is one of the high-level programming languages used to write Ethereum contracts. The language, as suggested by its name, is designed to be very similar to Python; it is intended to be maximally clean and simple, combining many of the efficiency benefits of a low-level language with ease-of-use in programming style, and at the same time adding special domain-specific features for contract programming. The latest version of the Serpent compiler, available \non github\n, is written in C++, allowing it to be easily included in any client.\n\n\nThis tutorial assumes basic knowledge of how Ethereum works, including the concept of blocks, transactions, contracts and messages and the fact that contracts take a byte array as input and provide a byte array as output. If you do not, then go \nhere\n for a basic tutorial.\n\n\nThis documentation is not complete and these examples may further help:\n\n\nhttps://github.com/AugurProject/augur-core/tree/master/tests/serpent_tests\n\n\nhttps://github.com/ethereum/serpent/tree/develop/examples\n\n\nhttps://github.com/AugurProject/augur-core/tree/master/src\n\n\nhttps://github.com/ethereum/dapp-bin\n\n\nDifferences Between Serpent and Python\n\n\nThe important differences between Serpent and Python are:\n\n\n\n\nPython numbers have potentially unlimited size, Serpent numbers wrap around 2\n256\n. For example, in Serpent the expression \n3^(2^254)\n suprisingly evaluates to 1, even though in reality the actual integer is too large to be recorded in its entirety within the universe.\n\n\nSerpent has no decimals.\n\n\nSerpent has no list comprehensions (expressions like \n[x**2 for x in my_list]\n), dictionaries or most other advanced features\n\n\nSerpent has no concept of first-class functions. Contracts do have functions, and can call their own functions, but variables (except storage) do not persist across calls.\n\n\nSerpent has a concept of persistent storage variables (see below)\n\n\nSerpent has an \nextern\n statement used to call functions from other contracts (see below)\n\n\n\n\nInstallation\n\n\nIn order to install the Serpent python library and executable do:\n\n\n$ git clone https://github.com/ethereum/serpent.git\n$ \ncd\n serpent\n$ git checkout develop\n$ make \n sudo make install\n$ python setup.py install\n\n\n\n\n\nYou can install pyethereum itself as well:\n\n\n$ git clone https://github.com/ethereum/pyethereum.git\n$ \ncd\n pyethereum\n$ git checkout develop\n$ pip install -r requirements.txt\n$ python setup.py install\n\n\n\n\n\nTutorial\n\n\nNow, let's write our first contract. Paste the following into a file called \nmul2.se\n:\n\n\ndef double(x):\n    return(x * 2)\n\n\n\n\n\nThis contract is a simple two lines of code, and defines a function. Functions can be called either by transactions or by other contracts, and are the way that Serpent contracts provide an \"interface\" to other contracts and to transactions; for example, a contract defining a currency might have functions \nsend(to, value)\n and \ncheck_balance(address)\n.\n\n\nAdditionally, the Pyethereum testing environment that we will be using simply assumes that data input and output are in this format.\n\n\nNow, let's try actually compiling the code. Type:\n\n\n$ serpent compile mul2.se\n604380600b600039604e567c01000000000000000000000000000000000000000000000000000000006000350463eee9720681141560415760043560405260026040510260605260206060f35b505b6000f3\n\n\n\n\nAnd there we go, that's the hexadecimal form of the code that you can put into transactions. Or, if you want to see opcodes:\n\n\n$ serpent pretty_compile mul2.se\n\n[\nPUSH1, \n67\n, DUP1, PUSH1, \n11\n, PUSH1, \n0\n, CODECOPY, PUSH1, \n78\n, JUMP, PUSH29, \n1\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, PUSH1, \n0\n, CALLDATALOAD, DIV, PUSH4, \n238\n, \n233\n, \n114\n, \n6\n, DUP2, EQ, ISZERO, PUSH1, \n65\n, JUMPI, PUSH1, \n4\n, CALLDATALOAD, PUSH1, \n64\n, MSTORE, PUSH1, \n2\n, PUSH1, \n64\n, MLOAD, MUL, PUSH1, \n96\n, MSTORE, PUSH1, \n32\n, PUSH1, \n96\n, RETURN, JUMPDEST, POP, JUMPDEST, PUSH1, \n0\n, RETURN\n]\n\n\n\n\n\n\nAlternatively, you can compile to LLL to get an intermediate representation:\n\n\n$ serpent compile_to_lll mul2.se\n\n(\nreturn\n \n0\n\n  \n(\nlll\n    \n(\nwith \n__funid\n\n\n      (div (calldataload 0)\n\n\n        26959946667150639794667015087019630673637144422540572481103610249216\n\n\n      )\n\n\n      (unless (iszero (eq (get \n__funid\n)\n \n4008276486\n))\n\n        \n(\nseq\n          \n(\nset\n \nx (calldataload 4))\n\n\n          (seq\n\n\n            (set \n_temp_521 \n(\nmul \n(\nget \nx) 2))\n\n\n            (return (ref \n_temp_521\n)\n \n32\n)\n\n          \n)\n\n        \n)\n\n      \n)\n\n    \n)\n\n    \n0\n\n  \n)\n\n\n)\n\n\n\n\n\nThis shows you the machinery that is going on inside. As with most contracts, the outermost layer of code exists only to copy the data of the inner code during initialization and return it, since the code returned during initialization is the code that will be executed every time the contract is called; in the EVM you can see this with the \nCODECOPY\n opcode, and in LLL this corresponds to the \nlll\n meta-operation. Inside of the LLL, we have a wrapper whose purpose it is to grab the first four bytes of the contract data, (that's the \n(div (calldataload 0) 26959946667150639794667015087019630673637144422540572481103610249216)\n; we grab four bytes by grabbing the first 32 bytes and dividing it by 2^224) to get the function ID that is being called, and then inside of that we have a series of functions (in this case only one function) that checks the function ID provided against all function IDs supported by the contract. If the function ID is 4008276486, then it sets a variable \n'x\n to the message data bytes 4-35 (that's \n(calldataload 4)\n), sets a temporary variable to equal to \n2 * x\n, and returns the 32 byte memory slice that contains that variable.\n\n\nThe function ID is calculated by computing a hash based on the function name and arguments and taking the first four bytes. In this case we have a function named \ndouble\n with a single integer as an argument; on the command line we can do:\n\n\n$ serpent get_prefix double i\n\n4008276486\n\n\n\n\n\n\nNote that you can have multiple functions with the same name, if they take different combinations of inputs. For instance, a hypothetical function double that takes three integers as input (and, say, returns an array consisting of 2x each one) would have a different prefix:\n\n\n$ serpent get_prefix double iii\n\n1142360101\n\n\n\n\n\n\nThe letter \ni\n is meant for integers, and for fixed-length (up to 32 byte) strings (which are treated the same as integers in Serpent and EVM). Use the letter \ns\n for variable-length string arguments, and \na\n for arrays; more on these later.\n\n\nNow, what if you want to actually run the contract? That is where \npyethereum\n comes in. Open up a Python console in the same directory, and run:\n\n\n \nfrom\n \nethereum.tools\n \nimport\n \ntester\n \nas\n \nt\n\n\n \nc\n \n=\n \nt\n.\nChain\n()\n\n\n \nx\n \n=\n \nc\n.\ncontract\n(\nmul2.se\n,\n \nlanguage\n=\nserpent\n)\n\n\n \nx\n.\ndouble\n(\n42\n)\n\n\n84\n\n\n\n\n\n\nThe second line initializes a new state (ie. a genesis block). The third line creates a new contract, and creates an object in Python which represents it. You can use \nx.address\n to access this contract's address. The fourth line calls the contract with argument 42, and we see 84 predictably come out.\n\n\nExample: Name Registry\n\n\nHaving a multiply-by-two function on the blockchain is kind of boring. So let's do something marginally more interesting: a name registry. The main function will be a \nregister(key, value)\n operation which checks if a given key was already taken, and if is unoccupied then register it with the desired value and return 1; if the key is already occupied return 0. We will also add a second function to check the value associated with a particular key. Let's try it out:\n\n\ndef register(key, value):\n    # Key not yet claimed\n    if not self.storage[key]:\n        self.storage[key] = value\n        return(1)\n    else:\n        return(0)  # Key already claimed\n\ndef ask(key):\n    return(self.storage[key])\n\n\n\n\n\nHere, we see a few parts in action. First, we have the \nkey\n and \nvalue\n variables that the function takes as arguments. The second line is a comment; it does not get compiled and only serves to remind you what the code does. Then, we have a standard if/else clause, which checks if \nself.storage[key]\n is zero (ie. unclaimed), and if it is then it sets \nself.storage[key] = value\n and returns 1. Otherwise, it returns zero. \nself.storage\n is also a pseudo-array, acting like an array but without any particular memory location.\n\n\nNow, paste the code into \nnamecoin.se\n, if you wish try compiling it to LLL, opcodes or EVM, and let's try it out in the pyethereum tester environment:\n\n\n \nfrom\n \nethereum.tools\n \nimport\n \ntester\n \nas\n \nt\n\n\n \nc\n \n=\n \nt\n.\nChain\n()\n\n\n \nx\n \n=\n \nc\n.\ncontract\n(\nnamecoin.se\n,\n \nlanguage\n=\nserpent\n)\n\n\n \nx\n.\nregister\n(\n0x67656f726765\n,\n \n45\n)\n\n\n1\n\n\n \nx\n.\nregister\n(\n0x67656f726765\n,\n \n20\n)\n\n\n0\n\n\n \nx\n.\nregister\n(\n0x6861727279\n,\n \n65\n)\n\n\n1\n\n\n \nx\n.\nask\n(\n0x6861727279\n)\n\n\n65\n\n\n\n\n\n\nIncluding files, and calling other contracts\n\n\nOnce your projects become larger, you will not want to put everything into the same file; things become particularly inconvenient when one piece of code needs to create a contract. Fortunately, the process for splitting code into multiple files is quite simple. Make the following two files:\n\n\nmul2.se:\n\n\ndef double(x):\n    return(x * 2)\n\n\n\n\n\nreturnten.se:\n\n\nextern mul2.se: [double:[int256]:int256]\n\nMUL2 = create(\nmul2.se\n)\ndef returnten():\n    return(MUL2.double(5))\n\n\n\n\n\nAnd open Python:\n\n\n \nfrom\n \nethereum.tools\n \nimport\n \ntester\n \nas\n \nt\n\n\n \nc\n \n=\n \nt\n.\nChain\n()\n\n\n \nx\n \n=\n \nc\n.\ncontract\n(\nreturnten.se\n,\n \nlanguage\n=\nserpent\n)\n\n\n \nx\n.\nreturnten\n()\n\n\n10\n\n\n\n\n\n\nNote that here we introduced several new features. Particularly:\n\n\n\n\nThe \ncreate\n command to create a contract using code from another file\n\n\nThe \nextern\n keyword to declare a class of contract for which we know the names of the functions\n\n\nThe interface for calling other contracts\n\n\n\n\ncreate\n is self-explanatory; it creates a contract and returns the address to the contract.\n\n\nThe way \nextern\n works is that you declare a class of contract, in this case \nmul2\n, and then list in an array the names of the functions, in this case just \ndouble\n. To generate \nextern mul2.se: [double:[int256]:int256]\n use\n\n\n$ serpent mk_signature mul2.se\n\n\n\n\n\nFrom there, given any variable containing an address, you can do \nx.double(arg1)\n to call the address stored by that variable. The arguments are the values provided to the function. If you provide too few arguments, the rest are filled to zero, and if you provide too many the extra ones are ignored. Function calling also has some other optional arguments:\n\n\n\n\ngas=12414\n - call the function with 12414 gas instead of the default (all gas)\n\n\nvalue=10^19\n - send 10^19 wei (10 ether) along with the message\n\n\ndata=x\n, \ndatasz=5\n - call the function with 5 values from the array \nx\n; note that this replaces other function arguments. \ndata\n without \ndatasz\n is illegal\n\n\noutsz=7\n - by default, Serpent processes the output of a function by taking the first 32 bytes and returning it as a value. However, if \noutsz\n is used as here, the function will instead return an array containing 7 values; if you type \ny = x.fun(arg1, outsz=7)\n then you will be able to access the output via \ny[0]\n, \ny[1]\n, etc.\n\n\n\n\nAnother similar operation to \ncreate\n is \ninset('filename')\n, which simply puts code into a particular place without adding a separate contract.\n\n\nreturnten.se\n\n\ninset(\nmul2.se\n)\n\ndef returnten():\n    return(self.double(5))\n\n\n\n\n\nStorage data structures\n\n\nIn more complicated contracts, you will often want to store data structures in storage to represent certain objects. For example, you might have a decentralized exchange contract that stores the balances of users in multiple currencies, as well as open bid and ask orders where each order has a price and a quantity. For this, Serpent has a built-in mechanism for defining your own structures. For example, in such a decentralized exchange contract you might see:\n\n\ndata user_balances[][]\ndata orders[](buys[](user, price, quantity), sells[](user, price, quantity))\n\n\n\n\n\nThen, you might do something like:\n\n\ndef fill_buy_order(currency, order_id):\n    # Available amount buyer is willing to buy\n    q = self.orders[currency].buys[order_id].quantity\n    # My balance in the currency\n    bal = self.user_balances[msg.sender][currency]\n    # The buyer\n    buyer = self.orders[currency].buys[order_id].user\n    if q \n 0:\n        # The amount we can actually trade\n        amount = min(q, bal)\n        # Trade the currency against the base currency\n        self.user_balances[msg.sender][currency] -= amount\n        self.user_balances[buyer][currency] += amount\n        self.user_balances[msg.sender][0] += amount * self.orders[currency].buys[order_id].price\n        self.user_balances[buyer][0] -= amount * self.orders[currency].buys[order_id].price\n        # Reduce the remaining quantity on the order\n        self.orders[currency].buys[order_id].quantity -= amount\n\n\n\n\n\nNotice how we define the data structures at the top, and then use them throughout the contract. These data structure gets and sets are converted into storage accesses in the background, so the data structures are persistent.\n\n\nThe language for doing data structures is simple. First, we can do simple variables:\n\n\ndata blah\n\nx = self.blah\nself.blah = x + 1\n\n\n\n\n\nThen, we can do arrays, both finite and infinite:\n\n\ndata blah[1243]\ndata blaz[]\n\nx = self.blah[505]\ny = self.blaz[3**160]\nself.blah[125] = x + y\n\n\n\n\n\nNote that finite arrays are always preferred, because it will cost less gas to calculate the storage index associated with a finite array index lookup. And we can do tuples, where each element of the tuple is itself a valid data structure:\n\n\ndata body(head(eyes[2], nose, mouth), arms[2], legs[2])\n\nx = self.body.head.nose\ny = self.body.arms[1]\n\n\n\n\n\nAnd we can do arrays of tuples:\n\n\ndata bodies[100](head(eyes[2], nose, mouth), arms[2](fingers[5], elbow), legs[2])\n\nx = self.bodies[45].head.eyes[1]\ny = self.bodies[x].arms[1].fingers[3]\n\n\n\n\n\nNote that the following is unfortunately not legal:\n\n\ndata body(head(eyes[2], nose, mouth), arms[2], legs[2])\n\nx = self.body.head\ny = x.eyes[0]\n\n\n\n\n\nAccesses have to descend fully in a single statement. To see how this could be used in a simpler example, let's go back to our name registry, and upgrade it so that when a user registers a key they become the owner of that key, and the owner of a key has the ability to (1) transfer ownership, and (2) change the value. We'll remove the return values here for simplicity.\n\n\ndata registry[](owner, value)\n\ndef register(key):\n    # Key not yet claimed\n    if not self.registry[key].owner:\n        self.registry[key].owner = msg.sender\n\ndef transfer_ownership(key, new_owner):\n    if self.registry[key].owner == msg.sender:\n        self.registry[key].owner = new_owner\n\ndef set_value(key, new_value):\n    if self.registry[key].owner == msg.sender:\n        self.registry[key].value = new_value\n\ndef ask(key):\n    return([self.registry[key].owner, self.registry[key].value], items=2)\n\n\n\n\n\nNote that in the last ask command, the function returns an array of 2 values. If you wanted to call the registry, you would have needed to do something like \no = registry.ask(key, outsz=2)\n and you could have then used \no[0]\n and \no[1]\n to recover the owner and value.\n\n\nSimple arrays in memory\n\n\nThe syntax for arrays in memory are different: they can only be finite and cannot have tuples or more complicated structures.\n\n\nExample:\n\n\ndef bitwise_or(x, y):\n    blah = array(1243)\n    blah[567] = x\n    blah[568] = y\n    blah[569] = blah[567] | blah[568]\n    return(blah[569])\n\n\n\n\n\nThere are also two functions for dealing with arrays:\n\n\nlen(x)\n\n\n\n\n\nReturns the length of array x.\n\n\nslice(x, items=start, items=end)\n\n\n\n\n\nTakes a slice of x starting with position start and ending with position end (note that we require \nend \n= start\n; otherwise the result will almost certainly result in an error)\n\n\nArrays and Functions\n\n\nFunctions can also take arrays as arguments, and return arrays.\n\n\ndef compose(inputs:arr):\n    return(inputs[0] + inputs[1] * 10 + inputs[2] * 100)\n\ndef decompose(x):\n    return([x % 10, (x % 100) / 10, x / 100]:arr)\n\n\n\n\n\nPutting the \n:arr\n after a function argument means it is an array, and putting it inside a return statement returns the value as an array (just doing \nreturn([x,y,z])\n would return the integer which is the memory location of the array).\n\n\nIf a contract calls one of its functions, then it will autodetect which arguments should be arrays and parse them accordingly, so this works fine:\n\n\ndef compose(inputs:arr, radix):\n    return(inputs[0] + inputs[1] * radix + inputs[1] * radix ** 2)\n\ndef main():\n    return self.compose([1,2,3,4,5], 100)\n\n\n\n\n\nHowever, if a contract wants to call another contract that takes arrays as arguments, then you will need to put a \"signature\" into the extern declaration:\n\n\nextern composer: [compose:[int256[],int256]:int256, main:[]:int256]\n\n\n\n\n\nIf you want to determine the signature to use from a given file, you can do:\n\n\n serpent mk_signature compose_test.se\nextern compose_test: [compose:[int256[],int256]:int256, main:[]:int256]\n\n\n\n\n\nStrings\n\n\nThere are two types of strings in Serpent: short strings, eg. \n\"george\"\n, and long strings, eg. \ntext(\"afjqwhruqwhurhqkwrhguqwhrkuqwrkqwhwhrugquwrguwegtwetwet\")\n. Short strings, given simply in quotes as above, are treated as numbers; long strings, surrounded by the \ntext\n keyword as above, are treated as array-like objects; you can do \ngetch(str, index)\n and \nsetch(str, index)\n to manipulate characters in strings (doing \nstr[0]\n will treat the string as an array and try to fetch the first 32 characters as a number).\n\n\nTo use strings as function arguments or outputs, use the \nstr\n tag, much like you would use \narr\n for arrays. \nlen(s)\n gives you the length of a string, and \nslice\n works for strings the same way as for arrays too.\n\n\nHere is an example of returning/retrieving a string:\n\ndata str\n\ndef t2():\n    self.str = text(\n01\n)\n    log(data=self.str)\n    return(self.str, chars=2)\n\ndef runThis():\n    s = self.t2(outsz=2)\n    log(data=s)\n\n\n\nMacros\n\n\nWARNING: Relatively new/untested feature, here be ~~dragons~~ serpents\n\n\nMacros allow you to create rewrite rules which provide additional expressivity to the language. For example, suppose that you wanted to create a command that would compute the median of three values. You could simply do:\n\n\nmacro median($a, $b, $c):\n    min(min(max($a, $b), max($a, $c)), max($b, $c))\n\n\n\n\n\nThen, if you wanted to use it somewhere in your code, you just do:\n\n\nx = median(5, 9, 7)\n\n\n\n\n\nOr to take the max of an array:\n\n\nmacro maxarray($a:$asz):\n    $m = 0\n    $i = 0\n    while i \n $asz:\n        $m = max($m, $a[i])\n        $i += 1\n    $m\n\nx = maxarray([1, 9, 5, 6, 2, 4]:6)\n\n\n\n\n\nFor a highly contrived example of just how powerful macros can be, see https://github.com/ethereum/serpent/blob/poc7/examples/peano.se\n\n\nNote that macros are not functions; they are copied into code every time they are used. Hence, if you have a long macro, you may instead want to make the macro call an actual function. Additionally, note that the dollar signs on variables are important; if you omit a dollar sign in the pattern $a then the macro will only match a variable actually called a. You can also create dollar sign variables that are in the substitution pattern, but not the search pattern; this will generate a variable with a random prefix each instance of the macro. You can also create new variables without a dollar sign inside a substitution pattern, but then the same variable will be shared across all instances of the pattern and with uses of that variable outside the pattern.\n\n\nTypes\n\n\nWARNING: Relatively new/untested feature, here be ~~dragons~~ serpents\n\n\nAn excellent compliment to macros is Serpent's ghetto type system, which can be combined with macros to produce quite interesting results. Let us simply show this with an example:\n\n\ntype float: [a, b, c]\n\nmacro float($x) + float($y):\n    float($x + $y)\n\nmacro float($x) - float($y):\n    float($x - $y)\n\nmacro float($x) * float($y):\n    float($x * $y / 2^32)\n\nmacro float($x) / float($y):\n    float($x * 2^32 / $y)\n\nmacro unfloat($x):\n    $x / 2^32\n\nmacro floatfy($x):\n    float($x * 2^32)\n\nmacro float($x) = float($y):\n    $x = $y\n\nmacro with(float($x), float($y), $z):\n    with($x, $y, $z)\n\na = floatfy(25)\nb = a / floatfy(2)\nc = b * b\nreturn(unfloat(c))\n\n\n\n\n\nThis returns 156, the integer portion of 12.5^2. A purely integer-based version of this code would have simply returned 144. An interesting use case would be rewriting the \nelliptic curve signature pubkey recovery code\n using types in order to make the code neater by making all additions and multiplications implicitly modulo P, or using \nlong integer types\n to do RSA and other large-value-based cryptography in EVM code.\n\n\nMiscellaneous\n\n\nThe three other useful features in the tester environment are:\n\n\n\n\nBlock access - you can dig around \ns.block\n to see block data (eg. \ns.block.number\n, \ns.block.get_balance(addr)\n, \ns.block.get_storage_data(addr, index)\n)\n\n\nSnapshots - you can do \nx = s.snapshot()\n and \ns.revert(x)\n\n\nAdvancing blocks - you can do \ns.mine(100)\n and 100 blocks magically pass by with a 60-second interval between blocks. \ns.mine(100, addr)\n mines into a particular address.\n\n\nFull block data dump - type \ns.block.to_dict()\n\n\n\n\nSerpent also gives you access to many \"special variables\"; the full list is:\n\n\n\n\ntx.origin\n - the sender of the transaction\n\n\ntx.gasprice\n - gas price of the transaction\n\n\nmsg.gas\n - estimated gas by sender\n\n\nmsg.sender\n - the sender of the message\n\n\nmsg.value\n - the number of wei (smallest units of ether) sent with the message\n\n\nself\n - the contract's own address\n\n\nself.balance\n - the contract's balance\n\n\nx.balance\n (for any x) - that account's balance\n\n\nblock.coinbase\n - current block miner's address\n\n\nblock.timestamp\n - current block timestamp\n\n\nblock.prevhash\n - previous block hash\n\n\nblock.difficulty\n - current block difficulty\n\n\nblock.number\n - current block number\n\n\nblock.gaslimit\n - current block gaslimit\n\n\n\n\nSerpent recognises the following \"special functions\":\n\n\n\n\ndef init():\n - executed upon contract creation, accepts no parameters\n\n\ndef shared():\n - executed before running \ninit\n and user functions\n\n\ndef any():\n - executed before any user functions\n\n\n\n\nThere are also special commands for a few crypto operations; particularly:\n\n\n\n\naddr = ecrecover(h, v, r, s)\n - determines the address that produced the elliptic curve signature \nv, r, s\n of the hash \nh\n\n\nx = sha256(a, items=4)\n - returns the sha256 hash of the 128 bytes consisting of the 4-item array starting from \na\n\n\nx = ripemd160(a, items=4)\n - same as above but for ripemd160\n\n\nTo hash an arbitrary number of bytes, use chars syntax.  Example: \nx = sha256([0xf1fc122bc7f5d74df2b9441a42a1469500000000000000000000000000000000], chars=16)\n - returns the sha256 of the first 16 bytes.  Note: padding with trailing zeroes, otherwise the first 16 bytes will be zeroes, and the sha256 of it will be computed instead of the desired.\n\n\nyou can also use sha3 instead of sha256, e.g. \nsha3(a, items=4)\n\n\n\n\nTips\n\n\n\n\n\n\nIf a function is not returning the result you expect, double-check that all variables are correct: there is no error/warning when using an undeclared variable.\n\n\n\n\n\n\nInvalid argument count or LLL function\n usually means you just called foo() instead of \nself.foo()\n.\n\n\n\n\n\n\nSometimes you may be intending to use unsigned operators. eg div() and lt() instead of '/' and '\n'.\n\n\n\n\n\n\nTo upgrade Serpent, you may need to do \npip uninstall ethereum-serpent\n and \npython setup.py install\n. (Avoid \npip install ethereum-serpent\n since it will get from PyPI which is probably old.) (Also avoid using the master branch, which is probably even older than the PyPI version; use the develop branch instead.)\n\n\n\n\n\n\nWhen calling abi_contract(), if you get this type of error \nException: Error (file \"main\", line 1, char 5): Invalid object member (ie. a foo.bar not mapped to anything)\n make sure you are specifying correct path to the file you are compiling.\n\n\n\n\n\n\nIf you get a core dump when calling \nabi_contract()\n, check that you do not have functions with the same name.\n\n\n\n\n\n\nUse macro for constants, example:\n\nmacro CONSTANT: 99\n\n\n\n\n\n\n\nBe careful that if your flow requires going through a number of contracts, that someone can't just directly short-circuit and call one of your latter contracts with data they've manipulated elsewhere. Example: If you have contract C which gives someone ether, but relies on computation from Contract A-\nB-\nC, that someone can't just call B or C to give themselves ether.\n\n\n\n\n\n\nOther\n\n\nhttp://mc2-umd.github.io/ethereumlab/docs/serpent_tutorial.pdf - some outdated but can generally be helpful", 
            "title": "Serpent"
        }, 
        {
            "location": "/Dapps/Serpent/#differences-between-serpent-and-python", 
            "text": "The important differences between Serpent and Python are:   Python numbers have potentially unlimited size, Serpent numbers wrap around 2 256 . For example, in Serpent the expression  3^(2^254)  suprisingly evaluates to 1, even though in reality the actual integer is too large to be recorded in its entirety within the universe.  Serpent has no decimals.  Serpent has no list comprehensions (expressions like  [x**2 for x in my_list] ), dictionaries or most other advanced features  Serpent has no concept of first-class functions. Contracts do have functions, and can call their own functions, but variables (except storage) do not persist across calls.  Serpent has a concept of persistent storage variables (see below)  Serpent has an  extern  statement used to call functions from other contracts (see below)", 
            "title": "Differences Between Serpent and Python"
        }, 
        {
            "location": "/Dapps/Serpent/#installation", 
            "text": "In order to install the Serpent python library and executable do:  $ git clone https://github.com/ethereum/serpent.git\n$  cd  serpent\n$ git checkout develop\n$ make   sudo make install\n$ python setup.py install  You can install pyethereum itself as well:  $ git clone https://github.com/ethereum/pyethereum.git\n$  cd  pyethereum\n$ git checkout develop\n$ pip install -r requirements.txt\n$ python setup.py install", 
            "title": "Installation"
        }, 
        {
            "location": "/Dapps/Serpent/#tutorial", 
            "text": "Now, let's write our first contract. Paste the following into a file called  mul2.se :  def double(x):\n    return(x * 2)  This contract is a simple two lines of code, and defines a function. Functions can be called either by transactions or by other contracts, and are the way that Serpent contracts provide an \"interface\" to other contracts and to transactions; for example, a contract defining a currency might have functions  send(to, value)  and  check_balance(address) .  Additionally, the Pyethereum testing environment that we will be using simply assumes that data input and output are in this format.  Now, let's try actually compiling the code. Type:  $ serpent compile mul2.se\n604380600b600039604e567c01000000000000000000000000000000000000000000000000000000006000350463eee9720681141560415760043560405260026040510260605260206060f35b505b6000f3  And there we go, that's the hexadecimal form of the code that you can put into transactions. Or, if you want to see opcodes:  $ serpent pretty_compile mul2.se [ PUSH1,  67 , DUP1, PUSH1,  11 , PUSH1,  0 , CODECOPY, PUSH1,  78 , JUMP, PUSH29,  1 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , PUSH1,  0 , CALLDATALOAD, DIV, PUSH4,  238 ,  233 ,  114 ,  6 , DUP2, EQ, ISZERO, PUSH1,  65 , JUMPI, PUSH1,  4 , CALLDATALOAD, PUSH1,  64 , MSTORE, PUSH1,  2 , PUSH1,  64 , MLOAD, MUL, PUSH1,  96 , MSTORE, PUSH1,  32 , PUSH1,  96 , RETURN, JUMPDEST, POP, JUMPDEST, PUSH1,  0 , RETURN ]   Alternatively, you can compile to LLL to get an intermediate representation:  $ serpent compile_to_lll mul2.se ( return   0 \n   ( lll\n     ( with  __funid        (div (calldataload 0)          26959946667150639794667015087019630673637144422540572481103610249216        )        (unless (iszero (eq (get  __funid )   4008276486 )) \n         ( seq\n           ( set   x (calldataload 4))            (seq              (set  _temp_521  ( mul  ( get  x) 2))              (return (ref  _temp_521 )   32 ) \n           ) \n         ) \n       ) \n     ) \n     0 \n   )  )   This shows you the machinery that is going on inside. As with most contracts, the outermost layer of code exists only to copy the data of the inner code during initialization and return it, since the code returned during initialization is the code that will be executed every time the contract is called; in the EVM you can see this with the  CODECOPY  opcode, and in LLL this corresponds to the  lll  meta-operation. Inside of the LLL, we have a wrapper whose purpose it is to grab the first four bytes of the contract data, (that's the  (div (calldataload 0) 26959946667150639794667015087019630673637144422540572481103610249216) ; we grab four bytes by grabbing the first 32 bytes and dividing it by 2^224) to get the function ID that is being called, and then inside of that we have a series of functions (in this case only one function) that checks the function ID provided against all function IDs supported by the contract. If the function ID is 4008276486, then it sets a variable  'x  to the message data bytes 4-35 (that's  (calldataload 4) ), sets a temporary variable to equal to  2 * x , and returns the 32 byte memory slice that contains that variable.  The function ID is calculated by computing a hash based on the function name and arguments and taking the first four bytes. In this case we have a function named  double  with a single integer as an argument; on the command line we can do:  $ serpent get_prefix double i 4008276486   Note that you can have multiple functions with the same name, if they take different combinations of inputs. For instance, a hypothetical function double that takes three integers as input (and, say, returns an array consisting of 2x each one) would have a different prefix:  $ serpent get_prefix double iii 1142360101   The letter  i  is meant for integers, and for fixed-length (up to 32 byte) strings (which are treated the same as integers in Serpent and EVM). Use the letter  s  for variable-length string arguments, and  a  for arrays; more on these later.  Now, what if you want to actually run the contract? That is where  pyethereum  comes in. Open up a Python console in the same directory, and run:    from   ethereum.tools   import   tester   as   t    c   =   t . Chain ()    x   =   c . contract ( mul2.se ,   language = serpent )    x . double ( 42 )  84   The second line initializes a new state (ie. a genesis block). The third line creates a new contract, and creates an object in Python which represents it. You can use  x.address  to access this contract's address. The fourth line calls the contract with argument 42, and we see 84 predictably come out.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/Dapps/Serpent/#example-name-registry", 
            "text": "Having a multiply-by-two function on the blockchain is kind of boring. So let's do something marginally more interesting: a name registry. The main function will be a  register(key, value)  operation which checks if a given key was already taken, and if is unoccupied then register it with the desired value and return 1; if the key is already occupied return 0. We will also add a second function to check the value associated with a particular key. Let's try it out:  def register(key, value):\n    # Key not yet claimed\n    if not self.storage[key]:\n        self.storage[key] = value\n        return(1)\n    else:\n        return(0)  # Key already claimed\n\ndef ask(key):\n    return(self.storage[key])  Here, we see a few parts in action. First, we have the  key  and  value  variables that the function takes as arguments. The second line is a comment; it does not get compiled and only serves to remind you what the code does. Then, we have a standard if/else clause, which checks if  self.storage[key]  is zero (ie. unclaimed), and if it is then it sets  self.storage[key] = value  and returns 1. Otherwise, it returns zero.  self.storage  is also a pseudo-array, acting like an array but without any particular memory location.  Now, paste the code into  namecoin.se , if you wish try compiling it to LLL, opcodes or EVM, and let's try it out in the pyethereum tester environment:    from   ethereum.tools   import   tester   as   t    c   =   t . Chain ()    x   =   c . contract ( namecoin.se ,   language = serpent )    x . register ( 0x67656f726765 ,   45 )  1    x . register ( 0x67656f726765 ,   20 )  0    x . register ( 0x6861727279 ,   65 )  1    x . ask ( 0x6861727279 )  65", 
            "title": "Example: Name Registry"
        }, 
        {
            "location": "/Dapps/Serpent/#including-files-and-calling-other-contracts", 
            "text": "Once your projects become larger, you will not want to put everything into the same file; things become particularly inconvenient when one piece of code needs to create a contract. Fortunately, the process for splitting code into multiple files is quite simple. Make the following two files:  mul2.se:  def double(x):\n    return(x * 2)  returnten.se:  extern mul2.se: [double:[int256]:int256]\n\nMUL2 = create( mul2.se )\ndef returnten():\n    return(MUL2.double(5))  And open Python:    from   ethereum.tools   import   tester   as   t    c   =   t . Chain ()    x   =   c . contract ( returnten.se ,   language = serpent )    x . returnten ()  10   Note that here we introduced several new features. Particularly:   The  create  command to create a contract using code from another file  The  extern  keyword to declare a class of contract for which we know the names of the functions  The interface for calling other contracts   create  is self-explanatory; it creates a contract and returns the address to the contract.  The way  extern  works is that you declare a class of contract, in this case  mul2 , and then list in an array the names of the functions, in this case just  double . To generate  extern mul2.se: [double:[int256]:int256]  use  $ serpent mk_signature mul2.se  From there, given any variable containing an address, you can do  x.double(arg1)  to call the address stored by that variable. The arguments are the values provided to the function. If you provide too few arguments, the rest are filled to zero, and if you provide too many the extra ones are ignored. Function calling also has some other optional arguments:   gas=12414  - call the function with 12414 gas instead of the default (all gas)  value=10^19  - send 10^19 wei (10 ether) along with the message  data=x ,  datasz=5  - call the function with 5 values from the array  x ; note that this replaces other function arguments.  data  without  datasz  is illegal  outsz=7  - by default, Serpent processes the output of a function by taking the first 32 bytes and returning it as a value. However, if  outsz  is used as here, the function will instead return an array containing 7 values; if you type  y = x.fun(arg1, outsz=7)  then you will be able to access the output via  y[0] ,  y[1] , etc.   Another similar operation to  create  is  inset('filename') , which simply puts code into a particular place without adding a separate contract.  returnten.se  inset( mul2.se )\n\ndef returnten():\n    return(self.double(5))", 
            "title": "Including files, and calling other contracts"
        }, 
        {
            "location": "/Dapps/Serpent/#storage-data-structures", 
            "text": "In more complicated contracts, you will often want to store data structures in storage to represent certain objects. For example, you might have a decentralized exchange contract that stores the balances of users in multiple currencies, as well as open bid and ask orders where each order has a price and a quantity. For this, Serpent has a built-in mechanism for defining your own structures. For example, in such a decentralized exchange contract you might see:  data user_balances[][]\ndata orders[](buys[](user, price, quantity), sells[](user, price, quantity))  Then, you might do something like:  def fill_buy_order(currency, order_id):\n    # Available amount buyer is willing to buy\n    q = self.orders[currency].buys[order_id].quantity\n    # My balance in the currency\n    bal = self.user_balances[msg.sender][currency]\n    # The buyer\n    buyer = self.orders[currency].buys[order_id].user\n    if q   0:\n        # The amount we can actually trade\n        amount = min(q, bal)\n        # Trade the currency against the base currency\n        self.user_balances[msg.sender][currency] -= amount\n        self.user_balances[buyer][currency] += amount\n        self.user_balances[msg.sender][0] += amount * self.orders[currency].buys[order_id].price\n        self.user_balances[buyer][0] -= amount * self.orders[currency].buys[order_id].price\n        # Reduce the remaining quantity on the order\n        self.orders[currency].buys[order_id].quantity -= amount  Notice how we define the data structures at the top, and then use them throughout the contract. These data structure gets and sets are converted into storage accesses in the background, so the data structures are persistent.  The language for doing data structures is simple. First, we can do simple variables:  data blah\n\nx = self.blah\nself.blah = x + 1  Then, we can do arrays, both finite and infinite:  data blah[1243]\ndata blaz[]\n\nx = self.blah[505]\ny = self.blaz[3**160]\nself.blah[125] = x + y  Note that finite arrays are always preferred, because it will cost less gas to calculate the storage index associated with a finite array index lookup. And we can do tuples, where each element of the tuple is itself a valid data structure:  data body(head(eyes[2], nose, mouth), arms[2], legs[2])\n\nx = self.body.head.nose\ny = self.body.arms[1]  And we can do arrays of tuples:  data bodies[100](head(eyes[2], nose, mouth), arms[2](fingers[5], elbow), legs[2])\n\nx = self.bodies[45].head.eyes[1]\ny = self.bodies[x].arms[1].fingers[3]  Note that the following is unfortunately not legal:  data body(head(eyes[2], nose, mouth), arms[2], legs[2])\n\nx = self.body.head\ny = x.eyes[0]  Accesses have to descend fully in a single statement. To see how this could be used in a simpler example, let's go back to our name registry, and upgrade it so that when a user registers a key they become the owner of that key, and the owner of a key has the ability to (1) transfer ownership, and (2) change the value. We'll remove the return values here for simplicity.  data registry[](owner, value)\n\ndef register(key):\n    # Key not yet claimed\n    if not self.registry[key].owner:\n        self.registry[key].owner = msg.sender\n\ndef transfer_ownership(key, new_owner):\n    if self.registry[key].owner == msg.sender:\n        self.registry[key].owner = new_owner\n\ndef set_value(key, new_value):\n    if self.registry[key].owner == msg.sender:\n        self.registry[key].value = new_value\n\ndef ask(key):\n    return([self.registry[key].owner, self.registry[key].value], items=2)  Note that in the last ask command, the function returns an array of 2 values. If you wanted to call the registry, you would have needed to do something like  o = registry.ask(key, outsz=2)  and you could have then used  o[0]  and  o[1]  to recover the owner and value.", 
            "title": "Storage data structures"
        }, 
        {
            "location": "/Dapps/Serpent/#simple-arrays-in-memory", 
            "text": "The syntax for arrays in memory are different: they can only be finite and cannot have tuples or more complicated structures.  Example:  def bitwise_or(x, y):\n    blah = array(1243)\n    blah[567] = x\n    blah[568] = y\n    blah[569] = blah[567] | blah[568]\n    return(blah[569])  There are also two functions for dealing with arrays:  len(x)  Returns the length of array x.  slice(x, items=start, items=end)  Takes a slice of x starting with position start and ending with position end (note that we require  end  = start ; otherwise the result will almost certainly result in an error)", 
            "title": "Simple arrays in memory"
        }, 
        {
            "location": "/Dapps/Serpent/#arrays-and-functions", 
            "text": "Functions can also take arrays as arguments, and return arrays.  def compose(inputs:arr):\n    return(inputs[0] + inputs[1] * 10 + inputs[2] * 100)\n\ndef decompose(x):\n    return([x % 10, (x % 100) / 10, x / 100]:arr)  Putting the  :arr  after a function argument means it is an array, and putting it inside a return statement returns the value as an array (just doing  return([x,y,z])  would return the integer which is the memory location of the array).  If a contract calls one of its functions, then it will autodetect which arguments should be arrays and parse them accordingly, so this works fine:  def compose(inputs:arr, radix):\n    return(inputs[0] + inputs[1] * radix + inputs[1] * radix ** 2)\n\ndef main():\n    return self.compose([1,2,3,4,5], 100)  However, if a contract wants to call another contract that takes arrays as arguments, then you will need to put a \"signature\" into the extern declaration:  extern composer: [compose:[int256[],int256]:int256, main:[]:int256]  If you want to determine the signature to use from a given file, you can do:   serpent mk_signature compose_test.se\nextern compose_test: [compose:[int256[],int256]:int256, main:[]:int256]", 
            "title": "Arrays and Functions"
        }, 
        {
            "location": "/Dapps/Serpent/#strings", 
            "text": "There are two types of strings in Serpent: short strings, eg.  \"george\" , and long strings, eg.  text(\"afjqwhruqwhurhqkwrhguqwhrkuqwrkqwhwhrugquwrguwegtwetwet\") . Short strings, given simply in quotes as above, are treated as numbers; long strings, surrounded by the  text  keyword as above, are treated as array-like objects; you can do  getch(str, index)  and  setch(str, index)  to manipulate characters in strings (doing  str[0]  will treat the string as an array and try to fetch the first 32 characters as a number).  To use strings as function arguments or outputs, use the  str  tag, much like you would use  arr  for arrays.  len(s)  gives you the length of a string, and  slice  works for strings the same way as for arrays too.  Here is an example of returning/retrieving a string: data str\n\ndef t2():\n    self.str = text( 01 )\n    log(data=self.str)\n    return(self.str, chars=2)\n\ndef runThis():\n    s = self.t2(outsz=2)\n    log(data=s)", 
            "title": "Strings"
        }, 
        {
            "location": "/Dapps/Serpent/#macros", 
            "text": "WARNING: Relatively new/untested feature, here be ~~dragons~~ serpents  Macros allow you to create rewrite rules which provide additional expressivity to the language. For example, suppose that you wanted to create a command that would compute the median of three values. You could simply do:  macro median($a, $b, $c):\n    min(min(max($a, $b), max($a, $c)), max($b, $c))  Then, if you wanted to use it somewhere in your code, you just do:  x = median(5, 9, 7)  Or to take the max of an array:  macro maxarray($a:$asz):\n    $m = 0\n    $i = 0\n    while i   $asz:\n        $m = max($m, $a[i])\n        $i += 1\n    $m\n\nx = maxarray([1, 9, 5, 6, 2, 4]:6)  For a highly contrived example of just how powerful macros can be, see https://github.com/ethereum/serpent/blob/poc7/examples/peano.se  Note that macros are not functions; they are copied into code every time they are used. Hence, if you have a long macro, you may instead want to make the macro call an actual function. Additionally, note that the dollar signs on variables are important; if you omit a dollar sign in the pattern $a then the macro will only match a variable actually called a. You can also create dollar sign variables that are in the substitution pattern, but not the search pattern; this will generate a variable with a random prefix each instance of the macro. You can also create new variables without a dollar sign inside a substitution pattern, but then the same variable will be shared across all instances of the pattern and with uses of that variable outside the pattern.", 
            "title": "Macros"
        }, 
        {
            "location": "/Dapps/Serpent/#types", 
            "text": "WARNING: Relatively new/untested feature, here be ~~dragons~~ serpents  An excellent compliment to macros is Serpent's ghetto type system, which can be combined with macros to produce quite interesting results. Let us simply show this with an example:  type float: [a, b, c]\n\nmacro float($x) + float($y):\n    float($x + $y)\n\nmacro float($x) - float($y):\n    float($x - $y)\n\nmacro float($x) * float($y):\n    float($x * $y / 2^32)\n\nmacro float($x) / float($y):\n    float($x * 2^32 / $y)\n\nmacro unfloat($x):\n    $x / 2^32\n\nmacro floatfy($x):\n    float($x * 2^32)\n\nmacro float($x) = float($y):\n    $x = $y\n\nmacro with(float($x), float($y), $z):\n    with($x, $y, $z)\n\na = floatfy(25)\nb = a / floatfy(2)\nc = b * b\nreturn(unfloat(c))  This returns 156, the integer portion of 12.5^2. A purely integer-based version of this code would have simply returned 144. An interesting use case would be rewriting the  elliptic curve signature pubkey recovery code  using types in order to make the code neater by making all additions and multiplications implicitly modulo P, or using  long integer types  to do RSA and other large-value-based cryptography in EVM code.", 
            "title": "Types"
        }, 
        {
            "location": "/Dapps/Serpent/#miscellaneous", 
            "text": "The three other useful features in the tester environment are:   Block access - you can dig around  s.block  to see block data (eg.  s.block.number ,  s.block.get_balance(addr) ,  s.block.get_storage_data(addr, index) )  Snapshots - you can do  x = s.snapshot()  and  s.revert(x)  Advancing blocks - you can do  s.mine(100)  and 100 blocks magically pass by with a 60-second interval between blocks.  s.mine(100, addr)  mines into a particular address.  Full block data dump - type  s.block.to_dict()   Serpent also gives you access to many \"special variables\"; the full list is:   tx.origin  - the sender of the transaction  tx.gasprice  - gas price of the transaction  msg.gas  - estimated gas by sender  msg.sender  - the sender of the message  msg.value  - the number of wei (smallest units of ether) sent with the message  self  - the contract's own address  self.balance  - the contract's balance  x.balance  (for any x) - that account's balance  block.coinbase  - current block miner's address  block.timestamp  - current block timestamp  block.prevhash  - previous block hash  block.difficulty  - current block difficulty  block.number  - current block number  block.gaslimit  - current block gaslimit   Serpent recognises the following \"special functions\":   def init():  - executed upon contract creation, accepts no parameters  def shared():  - executed before running  init  and user functions  def any():  - executed before any user functions   There are also special commands for a few crypto operations; particularly:   addr = ecrecover(h, v, r, s)  - determines the address that produced the elliptic curve signature  v, r, s  of the hash  h  x = sha256(a, items=4)  - returns the sha256 hash of the 128 bytes consisting of the 4-item array starting from  a  x = ripemd160(a, items=4)  - same as above but for ripemd160  To hash an arbitrary number of bytes, use chars syntax.  Example:  x = sha256([0xf1fc122bc7f5d74df2b9441a42a1469500000000000000000000000000000000], chars=16)  - returns the sha256 of the first 16 bytes.  Note: padding with trailing zeroes, otherwise the first 16 bytes will be zeroes, and the sha256 of it will be computed instead of the desired.  you can also use sha3 instead of sha256, e.g.  sha3(a, items=4)", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/Dapps/Serpent/#tips", 
            "text": "If a function is not returning the result you expect, double-check that all variables are correct: there is no error/warning when using an undeclared variable.    Invalid argument count or LLL function  usually means you just called foo() instead of  self.foo() .    Sometimes you may be intending to use unsigned operators. eg div() and lt() instead of '/' and ' '.    To upgrade Serpent, you may need to do  pip uninstall ethereum-serpent  and  python setup.py install . (Avoid  pip install ethereum-serpent  since it will get from PyPI which is probably old.) (Also avoid using the master branch, which is probably even older than the PyPI version; use the develop branch instead.)    When calling abi_contract(), if you get this type of error  Exception: Error (file \"main\", line 1, char 5): Invalid object member (ie. a foo.bar not mapped to anything)  make sure you are specifying correct path to the file you are compiling.    If you get a core dump when calling  abi_contract() , check that you do not have functions with the same name.    Use macro for constants, example: macro CONSTANT: 99    Be careful that if your flow requires going through a number of contracts, that someone can't just directly short-circuit and call one of your latter contracts with data they've manipulated elsewhere. Example: If you have contract C which gives someone ether, but relies on computation from Contract A- B- C, that someone can't just call B or C to give themselves ether.", 
            "title": "Tips"
        }, 
        {
            "location": "/Dapps/Serpent/#other", 
            "text": "http://mc2-umd.github.io/ethereumlab/docs/serpent_tutorial.pdf - some outdated but can generally be helpful", 
            "title": "Other"
        }, 
        {
            "location": "/Dapps/LLL/", 
            "text": "cpp-ethereum was once a dead repository. All relevant wiki pages are moved to [webthree-umbrella wiki(https://github.com/ethereum/webthree-umbrella/wiki)]", 
            "title": "LLL"
        }, 
        {
            "location": "/Dapps/mutan/", 
            "text": "Mutan\n\n\nmutan", 
            "title": "Mutan"
        }, 
        {
            "location": "/Dapps/mutan/#mutan", 
            "text": "mutan", 
            "title": "Mutan"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/", 
            "text": "\u94fe\u89c4\u8303\u683c\u5f0f\n\n\nThis is a format to describe any Ethereum-like chain. It is derived from the \ngenesis.json\n format but includes parameters to change and configure the consensus algorithm, to specify infrastructure information, to specify boot nodes and to specify any built-in contracts together with their cost.\n\n\n\u683c\u5f0f\n\n\nIt is JSON, with the top level being an object with six keys:\n\n\n\n\nname\n: A string value specifying the chain name. e.g. \"Frontier/Homestead\", \"Morden\", \"Olympic\".\n\n\nforkName\n: An optional string value specifying a sub-identifier, in case two different chains have equivalent genesis blocks.\n\n\nengine\n: A enum value specifying the consensus engine. e.g. \"Ethash\", \"Null\".\n\n\nparams\n: An object specifying various attributes of the consensus engine, allowing configuration.\n\n\ngenesis\n: An object specifying the header of the genesis block.\n\n\nnodes\n: An array of strings, each one a node address in enode format.\n\n\naccounts\n: An object specifying accounts of the genesis block. This includes builtin contracts and premines.\n\n\n\n\n\u5b50\u683c\u5f0f: \u5f15\u64ce\n\n\nThere are two valid engines, \nEthash\n and \nNull\n.\n\n\n\n\nNull\n: Nonoperative engine.\n\n\nEthash\n: Sealing engine used by ethereum.\n\n\nparams\n: Engine specific params.\n\n\nminimumDifficulty\n: Integer specifying the minimum difficulty a block may have.\n\n\ngasLimitBoundDivisor\n: Integer specifying the according value in the Yellow Paper.\n\n\ndifficultyBoundDivisor\n: Integer specifying the according value in the Yellow Paper.\n\n\ndurationLimit\n: Integer specifying the boundary point at which difficulty is increased.\n\n\nblockReward\n: Integer specifying the reward given for authoring a block.\n\n\nregistrar\n: \n0x\n-prefixed, 40-nibble datum of the address of the registrar contract on this chain.\n\n\n\n\n\n\n\n\n\u5b50\u683c\u5f0f: \u53c2\u6570\n\n\nDifferent consensus engines may allow different keys in the \nparams\n object, however there exist a few common to all:\n\n\n\n\naccountStartNonce\n: Integer specifying what nonce all newly created accounts should have.\n\n\nfrontierCompatibilityModeLimit\n: Integer specifying the number of the block that Frontier-compatibility mode finishes and Homestead mode begins.\n\n\nmaximumExtraDataSize\n: Integer specifying the maximum size in bytes of the extra_data field of the header.\n\n\nminGasLimit\n: Integer specifying the minimum amount of gas a block may be limited at.\n\n\nnetworkID\n: Integer specifying the index of this chain on the network.\n\n\n\n\nNote: all integers are \n0x\n-prefixed, hex-encoded strings.\n\n\n\u5b50\u683c\u5f0f: genesis\n\n\nThe keys in genesis specify the according fields in the chain's genesis block. All are hex-encoded, \n0x\n prefixed. The fields required are:\n\n\n\n\nseal\n\n\ndifficulty\n\n\nauthor\n\n\ntimestamp\n\n\nparentHash\n\n\nextraData\n\n\ngasLimit\n\n\n\n\n\u5b50\u683c\u5f0f: \u8d26\u6237\n\n\nThe \naccounts\n object maps from addresses (40-nibble strings without the \n0x\n prefix) to objects, each with a number of allowed keys:\n\n\n\n\nbalance\n: Integer to specify the balance of the account at genesis in wei.\n\n\nnonce\n: Integer to specify the nonce of the account at genesis.\n\n\ncode\n: \n0x\n-prefixed hex specifying the code of the account at genesis.\n\n\nstorage\n: Object mapping hex-encoded integers for the account's storage at genesis.\n\n\nbuiltin\n: Alternative to \ncode\n, used to specify that the account's code is natively implemented. Value is an object with further fields:\n\n\n\"name\": The name of the builtin code to execute as a string. e.g. \n\"identity\"\n, \n\"ecrecover\"\n.\n\n\n\"pricing\": Enum to specify the cost of calling this contract.\n\n\n\"linear\": Specify a linear cost to calling this contract. Value is an object with two fields: \nbase\n which is the basic cost in Wei and is always paid; and \nword\n which is the cost per word of input, rounded up.\n\n\n\n\n\n\n\n\n\u793a\u4f8b\n\n\nThis is the Morden ECS JSON file\n\n\n{\n\n    \nname\n:\n \nMorden\n,\n\n    \nengine\n:\n \n{\n\n        \nEthash\n:\n \n{\n\n            \nparams\n:\n \n{\n\n                \ntieBreakingGas\n:\n \nfalse\n,\n\n                \ngasLimitBoundDivisor\n:\n \n0x0400\n,\n\n                \nminimumDifficulty\n:\n \n0x020000\n,\n\n                \ndifficultyBoundDivisor\n:\n \n0x0800\n,\n\n                \ndurationLimit\n:\n \n0x0d\n,\n\n                \nblockReward\n:\n \n0x4563918244F40000\n,\n\n                \nregistrar\n \n:\n \n0xc6d9d2cd449a754c494264e1809c50e34d64562b\n\n            \n}\n\n        \n}\n\n    \n},\n\n    \nparams\n:\n \n{\n\n        \naccountStartNonce\n:\n \n0x0100000\n,\n\n        \nfrontierCompatibilityModeLimit\n:\n \n0x789b0\n,\n\n        \nmaximumExtraDataSize\n:\n \n0x20\n,\n\n        \ntieBreakingGas\n:\n \nfalse\n,\n\n        \nminGasLimit\n:\n \n0x1388\n,\n\n        \nnetworkID\n \n:\n \n0x2\n\n    \n},\n\n    \ngenesis\n:\n \n{\n\n        \nseal\n:\n \n{\n\n            \nethereum\n:\n \n{\n\n                \nnonce\n:\n \n0x0000000000000042\n,\n\n                \nmixHash\n:\n \n0x0000000000000000000000000000000000000000000000000000000000000000\n\n            \n}\n\n        \n},\n\n        \ndifficulty\n:\n \n0x20000\n,\n\n        \nauthor\n:\n \n0x0000000000000000000000000000000000000000\n,\n\n        \ntimestamp\n:\n \n0x00\n,\n\n        \nparentHash\n:\n \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n\n        \nextraData\n:\n \n0x\n,\n\n        \ngasLimit\n:\n \n0x2fefd8\n\n    \n},\n\n    \nnodes\n:\n \n[\n\n        \nenode://b1217cbaa440e35ed471157123fe468e19e8b5ad5bedb4b1fdbcbdab6fb2f5ed3e95dd9c24a22a79fdb2352204cea207df27d92bfd21bfd41545e8b16f637499@104.44.138.37:30303\n\n    \n],\n\n    \naccounts\n:\n \n{\n\n        \n0000000000000000000000000000000000000001\n:\n \n{\n \nbalance\n:\n \n1\n,\n \nnonce\n:\n \n1048576\n,\n \nbuiltin\n:\n \n{\n \nname\n:\n \necrecover\n,\n \npricing\n:\n \n{\n \nlinear\n:\n \n{\n \nbase\n:\n \n3000\n,\n \nword\n:\n \n0\n \n}\n \n}\n \n}\n \n},\n\n        \n0000000000000000000000000000000000000002\n:\n \n{\n \nbalance\n:\n \n1\n,\n \nnonce\n:\n \n1048576\n,\n \nbuiltin\n:\n \n{\n \nname\n:\n \nsha256\n,\n \npricing\n:\n \n{\n \nlinear\n:\n \n{\n \nbase\n:\n \n60\n,\n \nword\n:\n \n12\n \n}\n \n}\n \n}\n \n},\n\n        \n0000000000000000000000000000000000000003\n:\n \n{\n \nbalance\n:\n \n1\n,\n \nnonce\n:\n \n1048576\n,\n \nbuiltin\n:\n \n{\n \nname\n:\n \nripemd160\n,\n \npricing\n:\n \n{\n \nlinear\n:\n \n{\n \nbase\n:\n \n600\n,\n \nword\n:\n \n120\n \n}\n \n}\n \n}\n \n},\n\n        \n0000000000000000000000000000000000000004\n:\n \n{\n \nbalance\n:\n \n1\n,\n \nnonce\n:\n \n1048576\n,\n \nbuiltin\n:\n \n{\n \nname\n:\n \nidentity\n,\n \npricing\n:\n \n{\n \nlinear\n:\n \n{\n \nbase\n:\n \n15\n,\n \nword\n:\n \n3\n \n}\n \n}\n \n}\n \n},\n\n        \n102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c\n:\n \n{\n \nbalance\n:\n \n1606938044258990275541962092341162602522202993782792835301376\n,\n \nnonce\n:\n \n1048576\n \n}\n\n    \n}\n\n\n}\n\n\n\nNote: the builtin accounts enable usage of Solidity language.  Running without them included in the chain definition file may result in unexpected behavior.", 
            "title": "\u94fe\u89c4\u683c\u683c\u5f0f"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#_1", 
            "text": "This is a format to describe any Ethereum-like chain. It is derived from the  genesis.json  format but includes parameters to change and configure the consensus algorithm, to specify infrastructure information, to specify boot nodes and to specify any built-in contracts together with their cost.", 
            "title": "\u94fe\u89c4\u8303\u683c\u5f0f"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#_2", 
            "text": "It is JSON, with the top level being an object with six keys:   name : A string value specifying the chain name. e.g. \"Frontier/Homestead\", \"Morden\", \"Olympic\".  forkName : An optional string value specifying a sub-identifier, in case two different chains have equivalent genesis blocks.  engine : A enum value specifying the consensus engine. e.g. \"Ethash\", \"Null\".  params : An object specifying various attributes of the consensus engine, allowing configuration.  genesis : An object specifying the header of the genesis block.  nodes : An array of strings, each one a node address in enode format.  accounts : An object specifying accounts of the genesis block. This includes builtin contracts and premines.", 
            "title": "\u683c\u5f0f"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#_3", 
            "text": "There are two valid engines,  Ethash  and  Null .   Null : Nonoperative engine.  Ethash : Sealing engine used by ethereum.  params : Engine specific params.  minimumDifficulty : Integer specifying the minimum difficulty a block may have.  gasLimitBoundDivisor : Integer specifying the according value in the Yellow Paper.  difficultyBoundDivisor : Integer specifying the according value in the Yellow Paper.  durationLimit : Integer specifying the boundary point at which difficulty is increased.  blockReward : Integer specifying the reward given for authoring a block.  registrar :  0x -prefixed, 40-nibble datum of the address of the registrar contract on this chain.", 
            "title": "\u5b50\u683c\u5f0f: \u5f15\u64ce"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#_4", 
            "text": "Different consensus engines may allow different keys in the  params  object, however there exist a few common to all:   accountStartNonce : Integer specifying what nonce all newly created accounts should have.  frontierCompatibilityModeLimit : Integer specifying the number of the block that Frontier-compatibility mode finishes and Homestead mode begins.  maximumExtraDataSize : Integer specifying the maximum size in bytes of the extra_data field of the header.  minGasLimit : Integer specifying the minimum amount of gas a block may be limited at.  networkID : Integer specifying the index of this chain on the network.   Note: all integers are  0x -prefixed, hex-encoded strings.", 
            "title": "\u5b50\u683c\u5f0f: \u53c2\u6570"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#genesis", 
            "text": "The keys in genesis specify the according fields in the chain's genesis block. All are hex-encoded,  0x  prefixed. The fields required are:   seal  difficulty  author  timestamp  parentHash  extraData  gasLimit", 
            "title": "\u5b50\u683c\u5f0f: genesis"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#_5", 
            "text": "The  accounts  object maps from addresses (40-nibble strings without the  0x  prefix) to objects, each with a number of allowed keys:   balance : Integer to specify the balance of the account at genesis in wei.  nonce : Integer to specify the nonce of the account at genesis.  code :  0x -prefixed hex specifying the code of the account at genesis.  storage : Object mapping hex-encoded integers for the account's storage at genesis.  builtin : Alternative to  code , used to specify that the account's code is natively implemented. Value is an object with further fields:  \"name\": The name of the builtin code to execute as a string. e.g.  \"identity\" ,  \"ecrecover\" .  \"pricing\": Enum to specify the cost of calling this contract.  \"linear\": Specify a linear cost to calling this contract. Value is an object with two fields:  base  which is the basic cost in Wei and is always paid; and  word  which is the cost per word of input, rounded up.", 
            "title": "\u5b50\u683c\u5f0f: \u8d26\u6237"
        }, 
        {
            "location": "/Infrastructure/Chain-Spec-Format/#_6", 
            "text": "This is the Morden ECS JSON file  { \n     name :   Morden , \n     engine :   { \n         Ethash :   { \n             params :   { \n                 tieBreakingGas :   false , \n                 gasLimitBoundDivisor :   0x0400 , \n                 minimumDifficulty :   0x020000 , \n                 difficultyBoundDivisor :   0x0800 , \n                 durationLimit :   0x0d , \n                 blockReward :   0x4563918244F40000 , \n                 registrar   :   0xc6d9d2cd449a754c494264e1809c50e34d64562b \n             } \n         } \n     }, \n     params :   { \n         accountStartNonce :   0x0100000 , \n         frontierCompatibilityModeLimit :   0x789b0 , \n         maximumExtraDataSize :   0x20 , \n         tieBreakingGas :   false , \n         minGasLimit :   0x1388 , \n         networkID   :   0x2 \n     }, \n     genesis :   { \n         seal :   { \n             ethereum :   { \n                 nonce :   0x0000000000000042 , \n                 mixHash :   0x0000000000000000000000000000000000000000000000000000000000000000 \n             } \n         }, \n         difficulty :   0x20000 , \n         author :   0x0000000000000000000000000000000000000000 , \n         timestamp :   0x00 , \n         parentHash :   0x0000000000000000000000000000000000000000000000000000000000000000 , \n         extraData :   0x , \n         gasLimit :   0x2fefd8 \n     }, \n     nodes :   [ \n         enode://b1217cbaa440e35ed471157123fe468e19e8b5ad5bedb4b1fdbcbdab6fb2f5ed3e95dd9c24a22a79fdb2352204cea207df27d92bfd21bfd41545e8b16f637499@104.44.138.37:30303 \n     ], \n     accounts :   { \n         0000000000000000000000000000000000000001 :   {   balance :   1 ,   nonce :   1048576 ,   builtin :   {   name :   ecrecover ,   pricing :   {   linear :   {   base :   3000 ,   word :   0   }   }   }   }, \n         0000000000000000000000000000000000000002 :   {   balance :   1 ,   nonce :   1048576 ,   builtin :   {   name :   sha256 ,   pricing :   {   linear :   {   base :   60 ,   word :   12   }   }   }   }, \n         0000000000000000000000000000000000000003 :   {   balance :   1 ,   nonce :   1048576 ,   builtin :   {   name :   ripemd160 ,   pricing :   {   linear :   {   base :   600 ,   word :   120   }   }   }   }, \n         0000000000000000000000000000000000000004 :   {   balance :   1 ,   nonce :   1048576 ,   builtin :   {   name :   identity ,   pricing :   {   linear :   {   base :   15 ,   word :   3   }   }   }   }, \n         102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c :   {   balance :   1606938044258990275541962092341162602522202993782792835301376 ,   nonce :   1048576   } \n     }  }  \nNote: the builtin accounts enable usage of Solidity language.  Running without them included in the chain definition file may result in unexpected behavior.", 
            "title": "\u793a\u4f8b"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/", 
            "text": "\u4e92\u6362\u5ba2\u6237\u7aef\u5730\u5740\u534f\u8bae\n\n\nTransferring funds between third-party accounts, especially those of exchanges, places considerable burden on the user and is error prone, due to the way in which deposits are identified to the client account. This problem was tackled by the existing banking industry through having a common code known as \nIBAN\n. This code amalgamated the institution and client account along with a error-detection mechanism practically eliminating trivial errors and providing considerable convenience for the user. Unfortunately, this is a heavily regulated and centralised service accessible only to large, well-established institutions. The present protocol, ICAP, may be viewed as a decentralised version of it suitable for any institutions containing funds on the Ethereum system.\n\n\nIBAN\n\n\nFor a good overview of the IBAN system, please see \nWikipedia's IBAN article\n. An IBAN code consists of up to 34 case insensitive alpha-numeric characters. It contains three pieces of information:\n\n\n\n\nThe country code; a top-level identifier for the context of the following (ISO 3166-1 alpha-2);\n\n\nThe error-detection code; uses the \nmod-97-10\n checksumming protocol (ISO/IEC 7064:2003);\n\n\nThe basic bank account number (BBAN); an identifier of the institution, branch and client account, whose composition is dependent on the aforementioned country.\n\n\n\n\nFor the UK, the BBAN is composed of:\n\n\n\n\nInstitution identifier, 4-character alphabetical, e.g. \nMIDL\n (ironically) represents HSBC bank.\n\n\nSort-code (branch identifier within the institution), a 6-digit decimal number, e.g. \n402702\n would be the Lancaster branch of HSBC.\n\n\nAccount number (client identifier within the branch), an 8-digit decimal number.\n\n\n\n\nProposed Design\n\n\nIntroduce a new IBAN country code: \nXE\n, formulated as the Ethereum \nE\n prefixed with the \"extended\" \nX\n, as used in non-jurisdictional currencies (e.g. XRP, XCP).\n\n\nThere will be three BBAN possibilities for this code; \ndirect\n, \nbasic\n and \nindirect\n.\n\n\nDirect\n\n\nThe BBAN for this code when direct will be 30 characters and will comprise one field:\n\n\n\n\nAccount identifier, 30 characters alphanumeric (\n 155-bit). This will be interpreted as a big-endian encoded base-36 integer representing the least significant bits of a 160-bit Ethereum address. As such, these Ethereum addresses will generally begin with a zero byte.\n\n\n\n\ne.g. XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS corresponds to the address \n00c5496aee77c1ba1f0854206a26dda82a81d6d8\n.\n\n\nBasic\n\n\nThe same as the direct encoding, except that the code is 31 characters (making it non-compliant for IBAN) and composes the same, single, field:\n\n\n\n\nAccount identifier, 31 characters alphanumeric (\n 161-bit). This will be interpreted as a big-endian encoded base-36 integer representing a 160-bit Ethereum address.\n\n\n\n\nIndirect\n\n\nThe BBAN for this code when indirect will be 16 characters and will comprise three fields:\n\n\n\n\nAsset identifier, 3-character alphanumeric (\n 16-bit);\n\n\nInstitution identifier, 4-character alphanumeric (\n 21-bit);\n\n\nInstitution client identifier, 9-character alphanumeric (\n 47-bit);\n\n\n\n\nIncluding the four initial characters, this leads to a final client-account address length of 20 characters, of the form:\n\n\nXE81ETHXREGGAVOFYORK\n\n\n\n\nSplit into:\n\n\n\n\nXE\n The country code for Ethereum;\n\n\n81\n The checksum;\n\n\nETH\n The asset identifier within the client account - in this case, \"ETH\" is the only valid asset identifier, since Ethereum's base registry contract supports only this asset;\n\n\nXREG\n The institution code for the account - in this case, Ethereum's base registry contract;\n\n\nGAVOFYORK\n The client identifier within the institution - in this case, a direct payment with no additional data to whatever primary address is associated with the name \"GAVOFYORK\" in Ethereum's base registry contract;\n\n\n\n\nNotes\n\n\nInstitution codes beginning with \nX\n are reserved for system use.\n\n\nOther forms\n\n\nURI\n\n\nGeneral URIs can be formed though the URI scheme name \niban\n, followed by the colon character \n:\n, followed by the 20-character alphanumeric identifier, thus for the example above, we would use:\n\n\niban\n:\nXE81ETHXREGGAVOFYORK\n\n\n\n\n\nQR Code\n\n\nA QR code may be generated directly from the URI using standard QR encodings. For example, the example above \niban:XE81ETHXREGGAVOFYORK\n would have the corresponding QR code:\n\n\n\n\nTransaction Semantics\n\n\nThe mechanism for indirect asset transfer over three routing protocols are specified, all of which are specific to the Ethereum domain (country-code of \nXE\n). One is for currency transfers directly to an included address (\"direct\"), another is for clients with the system address found through a Registry-lookup system of the client-ID, denoted by asset class \nETH\n, whereas the last is for transfers to an intermediary with associated data to specify client, denoted by asset class \nXET\n (the latter two are \"indirect\").\n\n\nDirect\n\n\nIf the IBAN code is 34 characters, it is a direct address; a direct transfer is made to the address which, when base-36 encoded gives exactly the data segment (the last 30 characters) of the IBAN code.\n\n\nIndirect ETH Asset: Simple transfers\n\n\nWithin the ETH asset code of Ethereum's country-code (XE), i.e. as long as the code begins with \nXE**ETH\n (where \n**\n is the valid checksum), then we can define the required transaction to be the deposit address given by a call to the \nregistry contract\n denoted by the institution code. For institutions not beginning with \nX\n, this corresponds to the primary address associated with the \nEthereum standard name\n:\n\n\n[institution code] \n/\n [client identifier]\n\n\nThe \nEthereum standard name\n is simply the normal hierarchical lookup mechanism, as specified in the Ethereum standard interfaces document.\n\n\nWe define a \nregistry contract\n as a contract fulfilling the Registry interface as specified in the Ethereum standard interfaces document.\n\n\nTODO\n: JS code for specifying the transfer.\n\n\nIndirect XET Asset: Institution transfers\n\n\nFor the \nXET\n asset code within the Ethereum country code (i.e. while the code begins XE**XET), then we can derive the transaction that must be made through a lookup to the Ethereum \niban\n registry contract. For a given institution, this contract specifies two values: the deposit call signature hash and the institution's Ethereum address.\n\n\nAt present, only a single such deposit call is defined, which is:\n\n\nfunction\n \ndeposit\n(\nuint64\n \nclientAccount\n)\n\n\n\n\n\nwhose signature hash is \n0x13765838\n. The transaction to transfer the assets should be formed as an ether-laden call to the institution's Ethereum address using the \ndeposit\n method as specified above, with the client account determined through the value of the big-endian, base-36 interpretation of the alpha-numeric \nInstitution client identifier\n, literally using the value of the characters \n0\n to \n9\n, then evaluating 'A' (or 'a') as 10, 'B' (or 'b') as 11 and so forth.\n\n\nTODO\n: JS code for specifying the transfer.", 
            "title": "\u4e92\u6362\u5ba2\u6237\u7aef\u5730\u5740\u534f\u8bae"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#_1", 
            "text": "Transferring funds between third-party accounts, especially those of exchanges, places considerable burden on the user and is error prone, due to the way in which deposits are identified to the client account. This problem was tackled by the existing banking industry through having a common code known as  IBAN . This code amalgamated the institution and client account along with a error-detection mechanism practically eliminating trivial errors and providing considerable convenience for the user. Unfortunately, this is a heavily regulated and centralised service accessible only to large, well-established institutions. The present protocol, ICAP, may be viewed as a decentralised version of it suitable for any institutions containing funds on the Ethereum system.", 
            "title": "\u4e92\u6362\u5ba2\u6237\u7aef\u5730\u5740\u534f\u8bae"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#iban", 
            "text": "For a good overview of the IBAN system, please see  Wikipedia's IBAN article . An IBAN code consists of up to 34 case insensitive alpha-numeric characters. It contains three pieces of information:   The country code; a top-level identifier for the context of the following (ISO 3166-1 alpha-2);  The error-detection code; uses the  mod-97-10  checksumming protocol (ISO/IEC 7064:2003);  The basic bank account number (BBAN); an identifier of the institution, branch and client account, whose composition is dependent on the aforementioned country.   For the UK, the BBAN is composed of:   Institution identifier, 4-character alphabetical, e.g.  MIDL  (ironically) represents HSBC bank.  Sort-code (branch identifier within the institution), a 6-digit decimal number, e.g.  402702  would be the Lancaster branch of HSBC.  Account number (client identifier within the branch), an 8-digit decimal number.", 
            "title": "IBAN"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#proposed-design", 
            "text": "Introduce a new IBAN country code:  XE , formulated as the Ethereum  E  prefixed with the \"extended\"  X , as used in non-jurisdictional currencies (e.g. XRP, XCP).  There will be three BBAN possibilities for this code;  direct ,  basic  and  indirect .", 
            "title": "Proposed Design"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#direct", 
            "text": "The BBAN for this code when direct will be 30 characters and will comprise one field:   Account identifier, 30 characters alphanumeric (  155-bit). This will be interpreted as a big-endian encoded base-36 integer representing the least significant bits of a 160-bit Ethereum address. As such, these Ethereum addresses will generally begin with a zero byte.   e.g. XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS corresponds to the address  00c5496aee77c1ba1f0854206a26dda82a81d6d8 .", 
            "title": "Direct"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#basic", 
            "text": "The same as the direct encoding, except that the code is 31 characters (making it non-compliant for IBAN) and composes the same, single, field:   Account identifier, 31 characters alphanumeric (  161-bit). This will be interpreted as a big-endian encoded base-36 integer representing a 160-bit Ethereum address.", 
            "title": "Basic"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#indirect", 
            "text": "The BBAN for this code when indirect will be 16 characters and will comprise three fields:   Asset identifier, 3-character alphanumeric (  16-bit);  Institution identifier, 4-character alphanumeric (  21-bit);  Institution client identifier, 9-character alphanumeric (  47-bit);   Including the four initial characters, this leads to a final client-account address length of 20 characters, of the form:  XE81ETHXREGGAVOFYORK  Split into:   XE  The country code for Ethereum;  81  The checksum;  ETH  The asset identifier within the client account - in this case, \"ETH\" is the only valid asset identifier, since Ethereum's base registry contract supports only this asset;  XREG  The institution code for the account - in this case, Ethereum's base registry contract;  GAVOFYORK  The client identifier within the institution - in this case, a direct payment with no additional data to whatever primary address is associated with the name \"GAVOFYORK\" in Ethereum's base registry contract;", 
            "title": "Indirect"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#notes", 
            "text": "Institution codes beginning with  X  are reserved for system use.", 
            "title": "Notes"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#other-forms", 
            "text": "", 
            "title": "Other forms"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#uri", 
            "text": "General URIs can be formed though the URI scheme name  iban , followed by the colon character  : , followed by the 20-character alphanumeric identifier, thus for the example above, we would use:  iban : XE81ETHXREGGAVOFYORK", 
            "title": "URI"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#qr-code", 
            "text": "A QR code may be generated directly from the URI using standard QR encodings. For example, the example above  iban:XE81ETHXREGGAVOFYORK  would have the corresponding QR code:", 
            "title": "QR Code"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#transaction-semantics", 
            "text": "The mechanism for indirect asset transfer over three routing protocols are specified, all of which are specific to the Ethereum domain (country-code of  XE ). One is for currency transfers directly to an included address (\"direct\"), another is for clients with the system address found through a Registry-lookup system of the client-ID, denoted by asset class  ETH , whereas the last is for transfers to an intermediary with associated data to specify client, denoted by asset class  XET  (the latter two are \"indirect\").", 
            "title": "Transaction Semantics"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#direct_1", 
            "text": "If the IBAN code is 34 characters, it is a direct address; a direct transfer is made to the address which, when base-36 encoded gives exactly the data segment (the last 30 characters) of the IBAN code.", 
            "title": "Direct"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#indirect-eth-asset-simple-transfers", 
            "text": "Within the ETH asset code of Ethereum's country-code (XE), i.e. as long as the code begins with  XE**ETH  (where  **  is the valid checksum), then we can define the required transaction to be the deposit address given by a call to the  registry contract  denoted by the institution code. For institutions not beginning with  X , this corresponds to the primary address associated with the  Ethereum standard name :  [institution code]  /  [client identifier]  The  Ethereum standard name  is simply the normal hierarchical lookup mechanism, as specified in the Ethereum standard interfaces document.  We define a  registry contract  as a contract fulfilling the Registry interface as specified in the Ethereum standard interfaces document.  TODO : JS code for specifying the transfer.", 
            "title": "Indirect ETH Asset: Simple transfers"
        }, 
        {
            "location": "/Infrastructure/Inter-exchange-Client-Address-Protocol/#indirect-xet-asset-institution-transfers", 
            "text": "For the  XET  asset code within the Ethereum country code (i.e. while the code begins XE**XET), then we can derive the transaction that must be made through a lookup to the Ethereum  iban  registry contract. For a given institution, this contract specifies two values: the deposit call signature hash and the institution's Ethereum address.  At present, only a single such deposit call is defined, which is:  function   deposit ( uint64   clientAccount )   whose signature hash is  0x13765838 . The transaction to transfer the assets should be formed as an ether-laden call to the institution's Ethereum address using the  deposit  method as specified above, with the client account determined through the value of the big-endian, base-36 interpretation of the alpha-numeric  Institution client identifier , literally using the value of the characters  0  to  9 , then evaluating 'A' (or 'a') as 10, 'B' (or 'b') as 11 and so forth.  TODO : JS code for specifying the transfer.", 
            "title": "Indirect XET Asset: Institution transfers"
        }, 
        {
            "location": "/Infrastructure/URL-Hint-Protocol/", 
            "text": "\u7f51\u5740\u63d0\u793a\u534f\u8bae\n\n\nThere exists a root \nRegistry\n contract at address 0x42 (this is the auctioning thing). There exists a contract interface, \nregister\n, which \nRegistry\n implements.\n\n\nEntries in \nregister\n, when looked up (indexed by a string32 name) have several value fields, including \ncontent\n and \nregister\n.\n\n\ncontent\n is the content hash which gets loaded when you enter this name into Mist/AZ.\n\n\nregister\n is the address of a subregistry contract (some contract implementing \nregister\n) which gets queried recursively.\n\n\nExample\n\n\n\n\neth://gavofyork\n results in the main Registry (at 0x42) being queried for the entry \ngavofyork\n. The content field of this entry (a SHA3 hash of a zip file OR manifest) is used to display content (see Content section for more info).\n\n\n\n\nURL Composition\n\n\nAll URLs canonically begin \neth://\n and are a number of components, each separated by a \n/\n. The field \nregister\n is used to do a recursive lookup.\n\n\nSo the components of \ngavofyork/tools/site/contact\n would comprise four components, in order: \ngavofyork\n, \ntools\n, \nsite\n, \ncontact\n.\n\n\nAny periods \n.\n before the left-most slash \n/\n delineate components which are specified in reverse order.\n\n\nSo non-canonical forms of the above address are:\n\n\n\n\ntools.gavofyork/site/contact\n\n\nsite.tools.gavofyork/contact\n\n\ncontact.site.tools.gavofyork\n\n\n\n\nNOTE: any periods after the leftmost \n/\n are treated no differently than other alphanumeric characters.\n\n\nExample\n\n\n\n\neth://gavofyork/site\n results in the main Registry (at 0x42) being queried for the entry \ngavofyork\n. The register field of this entry (an address of a \nregister\n-implementing contract) is then queried for the entry \nsite\n. The \ncontent\n field of this entry is used to display content.\n\n\n\n\nContent\n\n\nNormally Swarm would be used to determine the content from the content hash.\n\n\nFor 1.0, this will not be possible, so we will fall back to using HTTP distribution. To enable this we will include one or many URLHint contracts, which provide hints of URLs that allow downloading of particular content hashes. Find the contract in dapp-bin.\n\n\nThe content downloaded should be treated in many ways (and hashed) to discover what the content is. Possible ways include base 64 encoding, hex encoding and raw, and any content-cropping needed (e.g. a HTML page should have everything up to body tags removed).\n\n\nIt will be up to the dapp/content uploader to keep URLHint entries updated.\n\n\nThe address of the URLHint contract will be specified on an ad-hoc basis and users will be able to enter additional ones into their browser.", 
            "title": "\u7f51\u5740\u63d0\u793a\u534f\u8bae"
        }, 
        {
            "location": "/Infrastructure/URL-Hint-Protocol/#_1", 
            "text": "There exists a root  Registry  contract at address 0x42 (this is the auctioning thing). There exists a contract interface,  register , which  Registry  implements.  Entries in  register , when looked up (indexed by a string32 name) have several value fields, including  content  and  register .  content  is the content hash which gets loaded when you enter this name into Mist/AZ.  register  is the address of a subregistry contract (some contract implementing  register ) which gets queried recursively.", 
            "title": "\u7f51\u5740\u63d0\u793a\u534f\u8bae"
        }, 
        {
            "location": "/Infrastructure/URL-Hint-Protocol/#example", 
            "text": "eth://gavofyork  results in the main Registry (at 0x42) being queried for the entry  gavofyork . The content field of this entry (a SHA3 hash of a zip file OR manifest) is used to display content (see Content section for more info).", 
            "title": "Example"
        }, 
        {
            "location": "/Infrastructure/URL-Hint-Protocol/#url-composition", 
            "text": "All URLs canonically begin  eth://  and are a number of components, each separated by a  / . The field  register  is used to do a recursive lookup.  So the components of  gavofyork/tools/site/contact  would comprise four components, in order:  gavofyork ,  tools ,  site ,  contact .  Any periods  .  before the left-most slash  /  delineate components which are specified in reverse order.  So non-canonical forms of the above address are:   tools.gavofyork/site/contact  site.tools.gavofyork/contact  contact.site.tools.gavofyork   NOTE: any periods after the leftmost  /  are treated no differently than other alphanumeric characters.", 
            "title": "URL Composition"
        }, 
        {
            "location": "/Infrastructure/URL-Hint-Protocol/#example_1", 
            "text": "eth://gavofyork/site  results in the main Registry (at 0x42) being queried for the entry  gavofyork . The register field of this entry (an address of a  register -implementing contract) is then queried for the entry  site . The  content  field of this entry is used to display content.", 
            "title": "Example"
        }, 
        {
            "location": "/Infrastructure/URL-Hint-Protocol/#content", 
            "text": "Normally Swarm would be used to determine the content from the content hash.  For 1.0, this will not be possible, so we will fall back to using HTTP distribution. To enable this we will include one or many URLHint contracts, which provide hints of URLs that allow downloading of particular content hashes. Find the contract in dapp-bin.  The content downloaded should be treated in many ways (and hashed) to discover what the content is. Possible ways include base 64 encoding, hex encoding and raw, and any content-cropping needed (e.g. a HTML page should have everything up to body tags removed).  It will be up to the dapp/content uploader to keep URLHint entries updated.  The address of the URLHint contract will be specified on an ad-hoc basis and users will be able to enter additional ones into their browser.", 
            "title": "Content"
        }, 
        {
            "location": "/Infrastructure/NatSpec-Determination/", 
            "text": "\u7f51\u7edc\u72b6\u6001\n\n\nPublishing and finding the [NatSpec] (https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format) documentation for a contract is an important part of the Ethereum system. There are two pieces to this puzzle: the first is for a given client to be able to determine, given a call to a contract, what a \ntrustworthy\n NatSpec documentation hash for the contract is; the second is to find the actual NatSpec documentation body given its content hash.\n\n\nTrusted Content Determination\n\n\nThe former, trusted content determination, will ultimately be accomplished through a sophisticated reputation system. In the meantime, we (the Ethereum foundation) will maintain our own curated repository of trusted NatSpec documentation hashes in a contract. The contract is trivial, just providing a mapping from contract code hash to NatSpec JSON file hash. It can be found \nhere\n. We, alone, will retain the key updating and adding entries to this contract.\n\n\nThis contract will have a specific address on the PoC-9 \n Frontier testnet, probably referenced from the Ethereum services contract.\n\n\nContent Publishing and Distribution\n\n\nThe latter, content publishing and distribution, will ultimately be accomplished through the \"Swarm\" subsystem or IPFS. Until then, we will piggy back on the existing workaround for content-based publication and distribution; the \nURL Hint\n system.", 
            "title": "\u56fd\u5bb6\u89c4\u5b9a\u7684\u786e\u5b9a"
        }, 
        {
            "location": "/Infrastructure/NatSpec-Determination/#_1", 
            "text": "Publishing and finding the [NatSpec] (https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format) documentation for a contract is an important part of the Ethereum system. There are two pieces to this puzzle: the first is for a given client to be able to determine, given a call to a contract, what a  trustworthy  NatSpec documentation hash for the contract is; the second is to find the actual NatSpec documentation body given its content hash.", 
            "title": "\u7f51\u7edc\u72b6\u6001"
        }, 
        {
            "location": "/Infrastructure/NatSpec-Determination/#trusted-content-determination", 
            "text": "The former, trusted content determination, will ultimately be accomplished through a sophisticated reputation system. In the meantime, we (the Ethereum foundation) will maintain our own curated repository of trusted NatSpec documentation hashes in a contract. The contract is trivial, just providing a mapping from contract code hash to NatSpec JSON file hash. It can be found  here . We, alone, will retain the key updating and adding entries to this contract.  This contract will have a specific address on the PoC-9   Frontier testnet, probably referenced from the Ethereum services contract.", 
            "title": "Trusted Content Determination"
        }, 
        {
            "location": "/Infrastructure/NatSpec-Determination/#content-publishing-and-distribution", 
            "text": "The latter, content publishing and distribution, will ultimately be accomplished through the \"Swarm\" subsystem or IPFS. Until then, we will piggy back on the existing workaround for content-based publication and distribution; the  URL Hint  system.", 
            "title": "Content Publishing and Distribution"
        }, 
        {
            "location": "/Infrastructure/Network-Status/", 
            "text": "\u7f51\u7edc\u72b6\u6001\u76d1\u89c6\n\n\nThe \nEthereum (centralised) network status monitor\n (known sometimes as \"eth-netstats\") is a web-based application to monitor the health of the testnet/mainnet through a group of nodes.\n\n\nListing\n\n\nTo list your node, you must install the client-side information relay, a node module. Instructions given here work on Ubuntu (Mac OS X follow same instructions, but sudo may be unnecessary). Other platforms vary (please make sure that nodejs-legacy is also installed, otherwise some modules might fail).\n\n\nClone the git repo, then install pm2:\n\n\ngit clone https://github.com/cubedro/eth-net-intelligence-api\ncd eth-net-intelligence-api\nnpm install\nsudo npm install -g pm2\n\n\n\n\nThen edit the \napp.json\n file in it to configure for your node:\n\n\n\n\nalter the value to the right of \nLISTENING_PORT\n to the ethereum listening port (default: 30303)\n\n\nalter the value to the right of \nINSTANCE_NAME\n to whatever you wish to name your node;\n\n\nalter the value to the right of \nCONTACT_DETAILS\n if you wish to share your contact details\n\n\nalter the value to the right of \nRPC_PORT\n to the rpc port for your node (by default 8545 for both cpp and go);\n\n\nand alter the value to the right of \nWS_SECRET\n to the secret (you'll have to get this off \nthe official skype channel\n).\n\n\n\n\nethereum (eth or geth) must be running with rpc enabled.\n\ngeth --rpc\n\n\nthe default port (if one is not specified) for rpc under geth is 8545\n\n\nFinally run the process with:\n\n\npm2 start app.json\n\n\n\n\nSeveral commands are available:\n\n\n\n\npm2 list\n to display the process status;\n\n\npm2 logs\n to display logs;\n\n\npm2 gracefulReload node-app\n for a soft reload;\n\n\npm2 stop node-app\n to stop the app;\n\n\npm2 kill\n to kill the daemon.\n\n\n\n\nUpdating\n\n\nIn order to update you have to do the following:\n- \ngit pull\n to pull the latest version\n- \nsudo npm update\n to update the dependencies\n- \npm2 gracefulReload node-app\n to reload the client\n\n\n\n\nAuto-installation on a fresh Ubuntu install\n\n\nFetch and run the build shell. This will install everything you need: latest ethereum - CLI from develop branch (you can choose between eth or geth), node.js, npm \n pm2.\n\n\nbash \n(\ncurl https://raw.githubusercontent.com/cubedro/eth-net-intelligence-api/master/bin/build.sh\n)\n\n\n\n\n\nConfiguration\n\n\nConfigure the app modifying \napp.json\n. Note that you have to modify the backup \napp.json\n (to allow you to set your env vars without being rewritten when updating).\n\n\nenv\n:\n\n    \n{\n\n        \nNODE_ENV\n        \n:\n \nproduction\n,\n \n// tell the client we\nre in production environment\n\n        \nRPC_HOST\n        \n:\n \nlocalhost\n,\n \n// eth JSON-RPC host the default is 8545\n\n        \nRPC_PORT\n        \n:\n \n8545\n,\n \n// eth JSON-RPC port\n\n        \nLISTENING_PORT\n  \n:\n \n30303\n,\n \n// eth listening port (only used for display)\n\n        \nINSTANCE_NAME\n   \n:\n \n,\n \n// whatever you wish to name your node\n\n        \nCONTACT_DETAILS\n \n:\n \n,\n \n// add your contact details here if you wish (email/skype)\n\n        \nWS_SERVER\n       \n:\n \nwss://rpc.ethstats.net\n,\n \n// path to eth-netstats WebSockets api server\n\n        \nWS_SECRET\n       \n:\n \n,\n \n// WebSockets api server secret used for login\n\n    \n}\n\n\n\n\n\nRun\n\n\nRun it using pm2:\n\n\ncd\n ~/bin\npm2 start processes.json\n\n\n\n\nethereum (eth or geth) must be running with rpc enabled.\n\n\ngeth --rpc\n\n\nthe default port (if one is not specified) for rpc under geth is 8545\n\n\nUpdating\n\n\nTo update the API client use the following command:\n\n\n~/bin/www/bin/update.sh\n\n\n\n\nIt will stop the current netstats client processes, automatically detect your ethereum implementation and version, update it to the latest develop build, update netstats client and reload the processes.", 
            "title": "\u7f51\u7edc\u72b6\u6001"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#_1", 
            "text": "The  Ethereum (centralised) network status monitor  (known sometimes as \"eth-netstats\") is a web-based application to monitor the health of the testnet/mainnet through a group of nodes.", 
            "title": "\u7f51\u7edc\u72b6\u6001\u76d1\u89c6"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#listing", 
            "text": "To list your node, you must install the client-side information relay, a node module. Instructions given here work on Ubuntu (Mac OS X follow same instructions, but sudo may be unnecessary). Other platforms vary (please make sure that nodejs-legacy is also installed, otherwise some modules might fail).  Clone the git repo, then install pm2:  git clone https://github.com/cubedro/eth-net-intelligence-api\ncd eth-net-intelligence-api\nnpm install\nsudo npm install -g pm2  Then edit the  app.json  file in it to configure for your node:   alter the value to the right of  LISTENING_PORT  to the ethereum listening port (default: 30303)  alter the value to the right of  INSTANCE_NAME  to whatever you wish to name your node;  alter the value to the right of  CONTACT_DETAILS  if you wish to share your contact details  alter the value to the right of  RPC_PORT  to the rpc port for your node (by default 8545 for both cpp and go);  and alter the value to the right of  WS_SECRET  to the secret (you'll have to get this off  the official skype channel ).   ethereum (eth or geth) must be running with rpc enabled. geth --rpc \nthe default port (if one is not specified) for rpc under geth is 8545  Finally run the process with:  pm2 start app.json  Several commands are available:   pm2 list  to display the process status;  pm2 logs  to display logs;  pm2 gracefulReload node-app  for a soft reload;  pm2 stop node-app  to stop the app;  pm2 kill  to kill the daemon.", 
            "title": "Listing"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#updating", 
            "text": "In order to update you have to do the following:\n-  git pull  to pull the latest version\n-  sudo npm update  to update the dependencies\n-  pm2 gracefulReload node-app  to reload the client", 
            "title": "Updating"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#auto-installation-on-a-fresh-ubuntu-install", 
            "text": "Fetch and run the build shell. This will install everything you need: latest ethereum - CLI from develop branch (you can choose between eth or geth), node.js, npm   pm2.  bash  ( curl https://raw.githubusercontent.com/cubedro/eth-net-intelligence-api/master/bin/build.sh )", 
            "title": "Auto-installation on a fresh Ubuntu install"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#configuration", 
            "text": "Configure the app modifying  app.json . Note that you have to modify the backup  app.json  (to allow you to set your env vars without being rewritten when updating).  env : \n     { \n         NODE_ENV          :   production ,   // tell the client we re in production environment \n         RPC_HOST          :   localhost ,   // eth JSON-RPC host the default is 8545 \n         RPC_PORT          :   8545 ,   // eth JSON-RPC port \n         LISTENING_PORT    :   30303 ,   // eth listening port (only used for display) \n         INSTANCE_NAME     :   ,   // whatever you wish to name your node \n         CONTACT_DETAILS   :   ,   // add your contact details here if you wish (email/skype) \n         WS_SERVER         :   wss://rpc.ethstats.net ,   // path to eth-netstats WebSockets api server \n         WS_SECRET         :   ,   // WebSockets api server secret used for login \n     }", 
            "title": "Configuration"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#run", 
            "text": "Run it using pm2:  cd  ~/bin\npm2 start processes.json  ethereum (eth or geth) must be running with rpc enabled.  geth --rpc \nthe default port (if one is not specified) for rpc under geth is 8545", 
            "title": "Run"
        }, 
        {
            "location": "/Infrastructure/Network-Status/#updating_1", 
            "text": "To update the API client use the following command:  ~/bin/www/bin/update.sh  It will stop the current netstats client processes, automatically detect your ethereum implementation and version, update it to the latest develop build, update netstats client and reload the processes.", 
            "title": "Updating"
        }, 
        {
            "location": "/Infrastructure/Raspberry-Pi-instructions/", 
            "text": "\u8be5\u9875\u5df2\u5220\u9664.\n\n\nFor \neth\n on single-board-computers, head to one of these articles:\n\n\n\n\nInstalling binaries for Linux SBCs\n\n\nBuilding from source\n\n\nLinux ARM cross-builds\n.\n\n\n\n\nOr directly to http://ethembedded.com for instructions spanning multiple Ethereum clients (\neth\n, \ngeth\n and \nparity\n).", 
            "title": "\u6811\u8393\u6d3e"
        }, 
        {
            "location": "/Infrastructure/Raspberry-Pi-instructions/#_1", 
            "text": "For  eth  on single-board-computers, head to one of these articles:   Installing binaries for Linux SBCs  Building from source  Linux ARM cross-builds .   Or directly to http://ethembedded.com for instructions spanning multiple Ethereum clients ( eth ,  geth  and  parity ).", 
            "title": "\u8be5\u9875\u5df2\u5220\u9664."
        }, 
        {
            "location": "/Infrastructure/Exchange-Integration/", 
            "text": "\u4ea4\u6613\u4e00\u4f53\u5316\n\n\nG+17806663986", 
            "title": "\u4ea4\u6613\u4e00\u4f53\u5316"
        }, 
        {
            "location": "/Infrastructure/Exchange-Integration/#_1", 
            "text": "G+17806663986", 
            "title": "\u4ea4\u6613\u4e00\u4f53\u5316"
        }, 
        {
            "location": "/Infrastructure/Mining/", 
            "text": "\u6316\u77ff\n\n\nNotice\n\n\nBecoming a miner is not recommended. Ethereum is going to transition to proof-of-stake, making mining obsolescent. Becoming a miner would involve investing in a mining rig (several GPUs, plus maybe other hardware if needed, like a compatible computer), which is unlikely to get a return on investment before PoS is implemented.\n\n\nIntroduction\n\n\nThe word mining originates in the context of the gold analogy for crypto currencies. Gold or precious metals are scarce, so are digital tokens, and the only way to increase the total volume is through mining it. This is appropriate to the extent that in Ethereum too, the only mode of issuance post launch is via the mining. Unlike these examples however, mining is also the way to secure the network by creating, verifying, publishing and propagating blocks in the blockchain.\n\n\n\n\nMining Ether = Securing the network = verify computation\n\n\n\n\nSo what is mining anyway?\n\n\nEthereum Frontier, like all blockchain technologies uses an incentive-driven model of security. Consensus is based on choosing the block with the highest total difficulty.\nMiners produce blocks which the others check for validity. Among other well-formedness criteria, a block is only valid if it contains \nproof of work\n (PoW) of a given \ndifficulty\n.\nNote that in Ethereum 1.1, this is likely going to be replaced by a \nproof of stake\n model.\n\n\nThe proof of work algorithm used is called \nEthash\n (a modified version of \nDagger-Hashimoto\n) involves finding a nonce input to the algorithm so that the result is below a certain threshold depending on the difficulty. The point in PoW algorithms is that there is no better strategy to find such a nonce than enumerating the possibilities while verification of a solution is trivial and cheap. If outputs have a uniform distribution, then we can guarantee that on average the time needed to find a nonce depends on the difficulty threshold, making it possible to control the time of finding a new block just by manipulating difficulty.\n\n\nThe difficulty dynamically adjusts so that on average one block is produced by the entire network every 12 seconds (ie., 12 s block time). This heartbeat basically punctuates the synchronisation of system state and guarantees that maintaining a fork (to allow double spend) or rewriting history is impossible unless the attacker possesses more than half of the network mining power (so called 51% attack).\n\n\nAny node participating in the network can be a miner and their expected revenue from mining will be directly proportional to their (relative) mining power or \nhashrate\n, ie., number of nonces tried per second normalised by the total hashrate of the network.\n\n\nEthash PoW is memory hard, making it basically ASIC resistant. This means that calculating the PoW requires choosing subsets of a fixed resource dependent on the nonce and block header. This resource (a few gigabyte size data) is called a \nDAG\n. The \nDAG\n is totally different every 30000 blocks (a 100 hour window, called an \nepoch\n) and takes a while to generate. Since the DAG only depends on block height, it can be pregenerated but if its not, the client need to wait the end of this process to produce a block. Until clients actually precache dags ahead of time the network may experience a massive block delay on each epoch transition. Note that the DAG does not need to be generated for verifying the PoW essentially allowing for verification with both low CPU and small memory.\n\n\nAs a special case, when you start up your node from scratch, mining will only start once the DAG is built for the current epoch.\n\n\nMining Rewards\n\n\nNote that mining 'real' Ether will start with the Frontier release. On the Olympics testnet, the \nFrontier pre-release\n, the ether mined have no value (but see \nOlympic rewards\n).\n\n\nThe successful PoW miner of the winning block receives:\n\n A \nstatic block reward\n for the 'winning' block, consisting of exactly 3.0 Ether\n\n All of the gas expended within the block, that is, all the gas consumed by the execution of all the transactions in the block submitted by the winning miner is compensated for by the senders. The gascost incurred is  credited to the miner's account as part of the consensus protocol. Over time, it's expected these will dwarf the static block reward.\n- An extra reward for including Uncles as part of the block, in the form of an extra 1/32 per Uncle included\n\n\nUncles are stale blocks, ie with parent that are ancestors (max 6 blocks back) of the including block.\nValid uncles are rewarded in order to neutralise the effect of network lag on the dispersion of mining rewards, thereby increasing security.\nUncles included in a block formed by the successful PoW miner receive 7/8 of the static block reward = 2.625 ether\nA maximum of 2 uncles allowed per block.\n\n\nEthash DAG\n\n\nEthash uses a \nDAG\n (directed acyclic graph) for the proof of work algorithm, this is generated for each \nepoch\n, i.e every 30000 blocks (100 hours). The DAG takes a long time to generate. If clients only generate it on demand, you may see a long wait at each epoch transition before the first block of the new epoch is found. However, the DAG only depends on block number, so it CAN and SHOULD be calculated in advance to avoid long wait at each epoch transition. \ngeth\n implements automatic DAG generation and maintains two DAGS at a time for smooth epoch transitions. Automatic DAG generation is turned on and off when mining is controlled from the console. It is also turned on by default if \ngeth\n is launched with the \n--mine\n option. Note that clients share a DAG resource, so if you are running multiple instances of any client, make sure automatic dag generation is switched on in at most one client.\n\n\nTo generate the DAG for an arbitrary epoch:\n\n\ngeth makedag \nblock number\n \noutputdir\n\n\n\n\n\nFor instance \ngeth makedag 360000 ~/.ethash\n. Note that ethash uses \n~/.ethash\n (Mac/Linux) or \n~/AppData/Ethash\n  (Windows) for the DAG so that it can shared between clients.\n\n\nThe Algorithm\n\n\nOur algorithm, \nEthash\n (previously known as Dagger-Hashimoto), is based around the provision of a large, transient, randomly generated dataset which forms a DAG (the Dagger-part), and attempting to solve a particular constraint on it, partly determined through a block's header-hash.\n\n\nIt is designed to hash a fast verifiability time within a slow CPU-only environment, yet provide vast speed-ups for mining when provided with a large amount of memory with high-bandwidth. The large memory requirements mean that large-scale miners get comparatively little super-linear benefit. The high bandwidth requirement means that a speed-up from piling on many super-fast processing units sharing the same memory gives little benefit over a single unit.\n\n\nFormal Requirements\n\n\nTODO: Content from formal requirements doc.\n\n\nDesign Decisions Taken\n\n\nTODO: Content from design decisions doc.\n\n\nInfrastructure Overview\n\n\nMining will be accomplished in one of two ways: either on CPU (and possibly the GPU, to be confirmed) with the Mist client or on the GPU though a combination of the Ethereum daemon and \nsgminer\n.\n\n\nAn sgminer module for Ethash is expected to be released at some point during, but not necessarily before the Frontier Genesis.\n\n\nJSON-RPC\n\n\nCommunication between the external mining application and the Ethereum daemon for work provision and submission happens through the JSON-RPC API. Two RPC functions are provided; \neth_getWork\n and \neth_submitWork\n.\n\n\nThese are formally documented on the \nJSON-RPC API\n wiki article.", 
            "title": "\u77ff\u4e1a"
        }, 
        {
            "location": "/Infrastructure/Mining/#_1", 
            "text": "", 
            "title": "\u6316\u77ff"
        }, 
        {
            "location": "/Infrastructure/Mining/#notice", 
            "text": "Becoming a miner is not recommended. Ethereum is going to transition to proof-of-stake, making mining obsolescent. Becoming a miner would involve investing in a mining rig (several GPUs, plus maybe other hardware if needed, like a compatible computer), which is unlikely to get a return on investment before PoS is implemented.", 
            "title": "Notice"
        }, 
        {
            "location": "/Infrastructure/Mining/#introduction", 
            "text": "The word mining originates in the context of the gold analogy for crypto currencies. Gold or precious metals are scarce, so are digital tokens, and the only way to increase the total volume is through mining it. This is appropriate to the extent that in Ethereum too, the only mode of issuance post launch is via the mining. Unlike these examples however, mining is also the way to secure the network by creating, verifying, publishing and propagating blocks in the blockchain.   Mining Ether = Securing the network = verify computation", 
            "title": "Introduction"
        }, 
        {
            "location": "/Infrastructure/Mining/#so-what-is-mining-anyway", 
            "text": "Ethereum Frontier, like all blockchain technologies uses an incentive-driven model of security. Consensus is based on choosing the block with the highest total difficulty.\nMiners produce blocks which the others check for validity. Among other well-formedness criteria, a block is only valid if it contains  proof of work  (PoW) of a given  difficulty .\nNote that in Ethereum 1.1, this is likely going to be replaced by a  proof of stake  model.  The proof of work algorithm used is called  Ethash  (a modified version of  Dagger-Hashimoto ) involves finding a nonce input to the algorithm so that the result is below a certain threshold depending on the difficulty. The point in PoW algorithms is that there is no better strategy to find such a nonce than enumerating the possibilities while verification of a solution is trivial and cheap. If outputs have a uniform distribution, then we can guarantee that on average the time needed to find a nonce depends on the difficulty threshold, making it possible to control the time of finding a new block just by manipulating difficulty.  The difficulty dynamically adjusts so that on average one block is produced by the entire network every 12 seconds (ie., 12 s block time). This heartbeat basically punctuates the synchronisation of system state and guarantees that maintaining a fork (to allow double spend) or rewriting history is impossible unless the attacker possesses more than half of the network mining power (so called 51% attack).  Any node participating in the network can be a miner and their expected revenue from mining will be directly proportional to their (relative) mining power or  hashrate , ie., number of nonces tried per second normalised by the total hashrate of the network.  Ethash PoW is memory hard, making it basically ASIC resistant. This means that calculating the PoW requires choosing subsets of a fixed resource dependent on the nonce and block header. This resource (a few gigabyte size data) is called a  DAG . The  DAG  is totally different every 30000 blocks (a 100 hour window, called an  epoch ) and takes a while to generate. Since the DAG only depends on block height, it can be pregenerated but if its not, the client need to wait the end of this process to produce a block. Until clients actually precache dags ahead of time the network may experience a massive block delay on each epoch transition. Note that the DAG does not need to be generated for verifying the PoW essentially allowing for verification with both low CPU and small memory.  As a special case, when you start up your node from scratch, mining will only start once the DAG is built for the current epoch.", 
            "title": "So what is mining anyway?"
        }, 
        {
            "location": "/Infrastructure/Mining/#mining-rewards", 
            "text": "Note that mining 'real' Ether will start with the Frontier release. On the Olympics testnet, the  Frontier pre-release , the ether mined have no value (but see  Olympic rewards ).  The successful PoW miner of the winning block receives:  A  static block reward  for the 'winning' block, consisting of exactly 3.0 Ether  All of the gas expended within the block, that is, all the gas consumed by the execution of all the transactions in the block submitted by the winning miner is compensated for by the senders. The gascost incurred is  credited to the miner's account as part of the consensus protocol. Over time, it's expected these will dwarf the static block reward.\n- An extra reward for including Uncles as part of the block, in the form of an extra 1/32 per Uncle included  Uncles are stale blocks, ie with parent that are ancestors (max 6 blocks back) of the including block.\nValid uncles are rewarded in order to neutralise the effect of network lag on the dispersion of mining rewards, thereby increasing security.\nUncles included in a block formed by the successful PoW miner receive 7/8 of the static block reward = 2.625 ether\nA maximum of 2 uncles allowed per block.", 
            "title": "Mining Rewards"
        }, 
        {
            "location": "/Infrastructure/Mining/#ethash-dag", 
            "text": "Ethash uses a  DAG  (directed acyclic graph) for the proof of work algorithm, this is generated for each  epoch , i.e every 30000 blocks (100 hours). The DAG takes a long time to generate. If clients only generate it on demand, you may see a long wait at each epoch transition before the first block of the new epoch is found. However, the DAG only depends on block number, so it CAN and SHOULD be calculated in advance to avoid long wait at each epoch transition.  geth  implements automatic DAG generation and maintains two DAGS at a time for smooth epoch transitions. Automatic DAG generation is turned on and off when mining is controlled from the console. It is also turned on by default if  geth  is launched with the  --mine  option. Note that clients share a DAG resource, so if you are running multiple instances of any client, make sure automatic dag generation is switched on in at most one client.  To generate the DAG for an arbitrary epoch:  geth makedag  block number   outputdir   For instance  geth makedag 360000 ~/.ethash . Note that ethash uses  ~/.ethash  (Mac/Linux) or  ~/AppData/Ethash   (Windows) for the DAG so that it can shared between clients.", 
            "title": "Ethash DAG"
        }, 
        {
            "location": "/Infrastructure/Mining/#the-algorithm", 
            "text": "Our algorithm,  Ethash  (previously known as Dagger-Hashimoto), is based around the provision of a large, transient, randomly generated dataset which forms a DAG (the Dagger-part), and attempting to solve a particular constraint on it, partly determined through a block's header-hash.  It is designed to hash a fast verifiability time within a slow CPU-only environment, yet provide vast speed-ups for mining when provided with a large amount of memory with high-bandwidth. The large memory requirements mean that large-scale miners get comparatively little super-linear benefit. The high bandwidth requirement means that a speed-up from piling on many super-fast processing units sharing the same memory gives little benefit over a single unit.", 
            "title": "The Algorithm"
        }, 
        {
            "location": "/Infrastructure/Mining/#formal-requirements", 
            "text": "TODO: Content from formal requirements doc.", 
            "title": "Formal Requirements"
        }, 
        {
            "location": "/Infrastructure/Mining/#design-decisions-taken", 
            "text": "TODO: Content from design decisions doc.", 
            "title": "Design Decisions Taken"
        }, 
        {
            "location": "/Infrastructure/Mining/#infrastructure-overview", 
            "text": "Mining will be accomplished in one of two ways: either on CPU (and possibly the GPU, to be confirmed) with the Mist client or on the GPU though a combination of the Ethereum daemon and  sgminer .  An sgminer module for Ethash is expected to be released at some point during, but not necessarily before the Frontier Genesis.", 
            "title": "Infrastructure Overview"
        }, 
        {
            "location": "/Infrastructure/Mining/#json-rpc", 
            "text": "Communication between the external mining application and the Ethereum daemon for work provision and submission happens through the JSON-RPC API. Two RPC functions are provided;  eth_getWork  and  eth_submitWork .  These are formally documented on the  JSON-RPC API  wiki article.", 
            "title": "JSON-RPC"
        }, 
        {
            "location": "/Infrastructure/Licensing/", 
            "text": "\u8bb8\u53ef\n\n\nOverview\n\n\nThe Ethereum Foundation ensures three principles concerning the funds it uses to develop Ethereum:\n\n\n\n\nit is both open source software and Free software after the definition of the Free Software Foundation (so-called FLOSS);\n\n\nno special treatment is given to any single entity concerning the copyright of the software, the Foundation included;\n\n\nsource-code will not be distributed ahead of binaries.\n\n\n\n\nHowever, this is not where the story ends; there are many different licenses available that conform to these rules. After considerable discussion, both internal and external together with The Ethereum software collection is distributed under several licenses, partly to reflect the different thinking of the minds behind different pieces of software and partly to reflect the need to adapt to real-world issues and opportunities and lay out a strategy to provide the best possible future for the Ethereum community.\n\n\nThe Core\n\n\nThe core of Ethereum includes the consensus engine, the networking code and any supporting libraries. For C++, this includes libethereum, libp2p, libdevcore, libdevcrypto, libethcore, libevm and libevmface.\n\n\nThe core of Ethereum will be released under the most liberal of licenses. This reflects our desire to have Ethereum used in as many diverse environments as possible, even those which, for various reasons can require modifications or augmentations to the software which cannot be released to the public.\n\n\nIn this way, while we have not arrived at a final license, we expect to select one of the MIT license, the MPL license or the LGPL license. If the latter is chosen, it will come with an amendment allowing it to be linked to be statically linked to software for which source code is not available.\n\n\nIn this way, the core of Ethereum, be it C++ or Go, will be available for use in any commercial environment, closed or open source.\n\n\nThe Applications\n\n\nThe applications of Ethereum, including the Solidity compiler (libsolidity, solc), AlethZero and Mix will be distributed under the GNU General Public License. This is to reflect the fact that these pieces of software tend to not, by nature, need to be amalgamated or augmented into a larger, closed-source, whole. There is however, much to be gained through many different members of the Ethereum-community being incentivised to develop on and build out such software.\n\n\nIn this way we hope our initial version of Solidity and Mix lay down the foundation for others to build upon and improve in the true Free/open-source software manner.\n\n\nThe Middleware\n\n\nThe middleware of Ethereum, including the Javascript-based web3.js, the webthree libraries and eth (the command line client) will be distributed under an Affero license, likely the LGPL variant of it. We wish to allow free development of technologies by allowing linking to arbitrary software, but again would like to incentivise feeding of back-end integration work back into the community, especially regarding the interoperability with legacy systems.", 
            "title": "\u8bb8\u53ef"
        }, 
        {
            "location": "/Infrastructure/Licensing/#_1", 
            "text": "", 
            "title": "\u8bb8\u53ef"
        }, 
        {
            "location": "/Infrastructure/Licensing/#overview", 
            "text": "The Ethereum Foundation ensures three principles concerning the funds it uses to develop Ethereum:   it is both open source software and Free software after the definition of the Free Software Foundation (so-called FLOSS);  no special treatment is given to any single entity concerning the copyright of the software, the Foundation included;  source-code will not be distributed ahead of binaries.   However, this is not where the story ends; there are many different licenses available that conform to these rules. After considerable discussion, both internal and external together with The Ethereum software collection is distributed under several licenses, partly to reflect the different thinking of the minds behind different pieces of software and partly to reflect the need to adapt to real-world issues and opportunities and lay out a strategy to provide the best possible future for the Ethereum community.", 
            "title": "Overview"
        }, 
        {
            "location": "/Infrastructure/Licensing/#the-core", 
            "text": "The core of Ethereum includes the consensus engine, the networking code and any supporting libraries. For C++, this includes libethereum, libp2p, libdevcore, libdevcrypto, libethcore, libevm and libevmface.  The core of Ethereum will be released under the most liberal of licenses. This reflects our desire to have Ethereum used in as many diverse environments as possible, even those which, for various reasons can require modifications or augmentations to the software which cannot be released to the public.  In this way, while we have not arrived at a final license, we expect to select one of the MIT license, the MPL license or the LGPL license. If the latter is chosen, it will come with an amendment allowing it to be linked to be statically linked to software for which source code is not available.  In this way, the core of Ethereum, be it C++ or Go, will be available for use in any commercial environment, closed or open source.", 
            "title": "The Core"
        }, 
        {
            "location": "/Infrastructure/Licensing/#the-applications", 
            "text": "The applications of Ethereum, including the Solidity compiler (libsolidity, solc), AlethZero and Mix will be distributed under the GNU General Public License. This is to reflect the fact that these pieces of software tend to not, by nature, need to be amalgamated or augmented into a larger, closed-source, whole. There is however, much to be gained through many different members of the Ethereum-community being incentivised to develop on and build out such software.  In this way we hope our initial version of Solidity and Mix lay down the foundation for others to build upon and improve in the true Free/open-source software manner.", 
            "title": "The Applications"
        }, 
        {
            "location": "/Infrastructure/Licensing/#the-middleware", 
            "text": "The middleware of Ethereum, including the Javascript-based web3.js, the webthree libraries and eth (the command line client) will be distributed under an Affero license, likely the LGPL variant of it. We wish to allow free development of technologies by allowing linking to arbitrary software, but again would like to incentivise feeding of back-end integration work back into the community, especially regarding the interoperability with legacy systems.", 
            "title": "The Middleware"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/", 
            "text": "\u8054\u76df\u94fe\u53d1\u5c55\n\n\nChoosing a codebase\n\n\nThere are currently 8 implementations of the Ethereum protocol:\n\n\n\n\nGo \nhttp://github.com/ethereum/go-ethereum\n\n\nC++ \nhttp://github.com/ethereum/cpp-ethereum\n\n\nPython \nhttp://github.com/ethereum/pyethereum\n\n\nJavascript \nhttp://github.com/ethereum/ethereumjs-lib\n\n\nJava \nhttps://github.com/ethereum/ethereumj\n\n\nHaskell \nhttps://github.com/jamshidh/ethereumH\n\n\nRust (Parity) \nhttps://github.com/ethcore/parity\n\n\nRuby \nhttps://github.com/janx/ruby-ethereum\n\n\n\n\nThese implementations differ in:\n\n\n\n\nLicense (GPL, LGPL, MIT, Apache)\n\n\nPerformance\n\n\nFeature-completeness\n\n\nModularity\n\n\nEase of modification\n\n\nEase of integration into other systems\n\n\n\n\nFor enterprise use cases, performance is likely to be highly important. There have been some efforts at benchmarking Ethereum clients, see:\n\n\nhttps://github.com/ethereum/wiki/wiki/Benchmarks\n\n\nHowever, a comprehensive set of benchmarks on all clients likely to be performant (C++, Go, Haskell, Java, Parity) would be a very useful task. Regarding licensing, Go is LGPL licensed, C++ is GPL licensed but there is an effort (with outcome still uncertain) to relicense it to Apache, Java is MIT, and Parity is GPL.\n\n\nThe config file\n\n\nThere is an informal standard for a configuration file that Ethereum nodes must support, which describes the network parameters. The goal is to allow nodes to easily connect to test networks, private networks, and in the long term specify alternative networks with different properties, including consensus algorithms, P2P networking protocols, initial state, and protocol rules. The standard is described here:\n\n\nhttps://github.com/ethereum/wiki/wiki/Ethereum-Chain-Spec-Format\n\n\nAn enterprise ethereum version should respect a superset of the standard, so that a node started with the right config settings would act as an Ethereum public chain node (but with more APIs and other features useful for enterprise purposes), but a node started with different settings would participate in a given consortium-chain network using PBFT, or a test network that uses a different virtual machine, or a network that incorporates new scalability features sooner than the public chain, etc.\n\n\nConsensus\n\n\nCurrently, the Ethereum clients support proof of work consensus. There is a desire to modularize the consensus algorithm in such a way that it will be possible to also use proof of stake (Casper), as well as private chain-specific consensus algorithms, with likely initial targets being PBFT and DPOS (essentially a round robin consensus algorithm). The first step is to determine exactly what the \"interface\" for a consensus algorithm \"class\" should look like.\n\n\nA possible sketch of the interface is as follows:\n\n\n\n\nsubmitTransaction(tx)\n: submit a transaction to a participating node. The node will attempt to include it in a block, or vote for it, or perform the equivalent operation in the consensus algorithm.\n\n\nsendMessage(msg, node_id)\n: send a message to another node.\n\n\nbroadcastMessage(msg)\n: broadcast a message.\n\n\ngetMostRecent(conf_level)\n: get the most recent block that satisfies a given confirmation level. In proof of work or DPOS, \nconf_level\n would represent the number of confirmations, so it would return the nth last block in the chain; in PBFT confirmation is binary (ie. final confirmation is instant) so it always returns the most recent confirmed block.\n\n\n\n\nNote that public chain consensus also requires an incentivization model, ie. a way to reward consensus participants who perform well and possibly penalize participants who perform badly. We abstract this by providing two options:\n\n\n\n\nA function \nfinalize\n that gets automatically called after processing every transaction in a block, which makes modifications to the state and may use the block as input.\n\n\nA function \ninitialize\n that gets automatically called before processing every transaction in a block, which makes modifications to the state and may use the block as input.\n\n\n\n\nNote that either \nfinalize\n or \ninitialize\n may simply consist of a call to some standard contract with the block header as data; the Ethereum public chain plans to move to such an approach in the long term. In consortium chains, there is no need to use these functions for incentivization; however, they may be useful for other purposes (eg. to automatically run scheduled operations). Hence, because the utility of these operations is not strictly related to consensus incentivization, they should not be viewed as part of the consensus interface; rather, they should be viewed as transaction processing rules.\n\n\nIn a private chain context, there are several consensus algorithms that make the most sense:\n\n\n\n\nProof of authority\n - essentially, one client with one particular private key makes all of the blocks\n\n\nPBFT\n (or some other traditional byzantine-fault-tolerant consensus algorithm)\n\n\nDPOS\n (or some other chain-based limited-validator consensus algorithm)\n\n\nCasper\n (Ethereum's \nproof of stake\n candidate) with a fixed validator set\n\n\n\n\nPBFT and DPOS (taken purely as a consensus algorithm, not including the ability of some class of token holders to vote on delegates) each have their own advantages and disadvantages. Specifically:\n\n\n\n\nPBFT has academically robust formal proofs for various properties (safety, liveness, etc) under a partially synchronous network model assuming at least 67% of nodes are online and honest\n\n\nPBFT has instant finality - once a transaction is confirmed once, reverts are impossible. DPOS consensus is probabilistic much like proof of work (in fact, slightly worse, as attackers can see if they have the ability to revert short-range forks ahead of time), and so while a notion of \"de-facto finality\" is possible, it takes several minutes to reach\n\n\nDPOS can support an unlimited number of nodes, whereas PBFT becomes very inefficient above about 30 nodes because every node has to send messages to and receive messages from every other node during every round. DPOS does this because each round consists only of one randomly selected validator making a block\n\n\nDPOS is conceptually simpler to understand and implement and intuitively see why it converges\n\n\nIn a synchronous network model, DPOS can survive up to 49% Byzantine faults, higher than the 33% of PBFT; additionally, DPOS can survive even more faults if they consist of nodes going offline rather than trying to attack the network\n\n\n\n\nCasper is intended as a \ncryptoeconomic\n algorithm where anyone can become a validator by depositing money. However, it can be repurposed for permissioned contexts by simply specifying a fixed validator set. This approach is worth exploring once Casper is implemented across major Ethereum clients.\n\n\nProof of authority may be required in some cases where particular safety properties are required and Ethereum's technologies are used more to provide deterministic and verifiable execution and auditing properties rather than decentralization in the traditional sense. Hence, it makes sense to implement all three and give each user the choice of which one to use for any given application.\n\n\nNote\n: there is a common misconception that different algorithms have widely different transaction processing capacities, eg. DPOS can process 100 tx/sec while PBFT can process 1000 tx/sec, etc. Whereas in the case of future sharded blockchains this may be true, in the context of blockchains where every node processes every transaction this is not the case; the same amount of computational effort is required to process each transaction regardless of what consensus algorithm is used, although there may be small differences because some algorithms require recomputing transactions in the case of short-range forks, some can more safely allow transaction processing to be run a larger percentage of the time, etc. Differences in performance between chains are usually almost entirely due to differences in the protocols and the implementations, not the consensus algorithm (with the important exception that public-chain capacities tend to be much lower due to their additional economic restrictions, smaller node sizes and centralization concerns).\n\n\nAbstraction\n\n\nIn Ethereum protocol development, one of the major overriding philosophies is the notion of abstraction: that the protocol itself should be as simple as possible, and as much as possible should be implemented in contract code instead of through hard protocol rules. Targets for abstraction include:\n\n\n\n\nAccount security (see \nhttps://github.com/ethereum/EIPs/issues/86\n)\n\n\nThe transaction state transition function (ie. the rules by which a transaction is processed)\n\n\nEther (ie. make ether into a \nERC 20 token\n just like the others)\n\n\nLogs / events\n\n\n\n\nThe purpose of abstraction is the following:\n\n\n\n\nLower attack surface and lower core code complexity\n\n\nThe ability to more easily hardfork the public chain protocol to different protocol rules, as it can be done simply by swapping out contract code\n\n\nThe ability to more easily swap out different rulesets on a test network or private implementation\n\n\nThe ability to switch between different rules on a per-application or per-user level (eg. some users want their accounts secured by ECDSA, some prefer Lamport for quantum-proofness, and in some private chain use cases industry or national standards require the use of specific forms of cryptography; the goal of EIP 86 is to support all of this)\n\n\n\n\nEES may want to implement some of these abstraction features ahead of schedule.\n\n\nP2P networking\n\n\nEthereum's current P2P network is a Kademlia architecture, and details are described here:\n\n\n\n\nhttps://github.com/ethereum/wiki/wiki/%C3%90%CE%9EVp2p-Wire-Protocol\n\n\nhttps://github.com/ethereum/go-ethereum/wiki/Peer-to-Peer\n\n\n\n\nA private chain may want to either use the same networking code (but with a different network ID set in the config file), or use an alternative type of network; the most likely alternative is a design where every node connects directly to every other node (quite feasible and likely optimal in networks with under ~20 nodes). Additionally there is the choice of customizing the connection that is made at the network or even lower level (eg. should all nodes be in the same subnet? If they are physically close to each other would fiber optic connections be optimal?); many of the details of this are largely outside the scope of the EES codebase, but the codebase should make sure that it works well under many common expected configurations.\n\n\nPrivacy-preserving protocols\n\n\nSee \nhttps://blog.ethereum.org/2016/01/15/privacy-on-the-blockchain/\n for a much more detailed description of the available approaches.\n\n\nAPIs\n\n\nCurrently, the Ethereum codebase supports a basic set of APIs for querying the blockchain, querying contract state, filtering logs, sending transactions, etc. The primary way of making more complex queries (eg. returning the balance of a particular account in a particular token issued on the blockchain, returning the ask price of an offer on a blockchain-based order book, etc) is through the concept of \"virtual transactions\". Essentially, the idea is that a client can pretend to execute a transaction locally, which would call a function of a contract that returns a value. The API would then (possibly synchronously) return the value.\n\n\nHowever, there may be more high-level APIs that are required, particularly around use cases that require not just accessing the current state but also accessing previous state, getting information about transactions, and more advanced forms of blockchain analytics; additionally, there is room for APIs that are compatible with API formats that users are already comfortable with and expect.\n\n\nA particular class of APIs that is likely to be very useful is the ability to make SQL and similar queries to the blockchain. There are a few existing projects in this direction, see:\n\n\n\n\nhttps://www.reddit.com/r/ethereum/comments/4gcsn2/introducing_etherquery_perform_sql_queries/\n\n\nhttps://github.com/jamshidh/ethereum-data-sql\n\n\n\n\nHowever, much more work likely remains in making these systems maximally efficient and broadly applicable to many use cases.\n\n\nUser interfaces\n\n\nUser interfaces in Ethereum are a broad category, including:\n\n\n\n\nThe Mist browser, as well as applications written in HTML/Javascript that can be used either inside of Mist or through a user's regular browser\n\n\nBlock explorers such as \netherchain\n, \netherscan\n and \nether.camp\n. Note that unlike similar tools for many other blockchains, which focus purely on currency balances and transactions, Ethereum block explorers tend to be highly advanced and general, offering views into contract state, functions, internal transactions, etc; for example, here is a ether.camp's view of the DAO:\n\n\nThe geth command line interface (the same as the web3 Javascript API).\n\n\n\n\nEfficiency improvements\n\n\nThe process of verifying a block in Ethereum currently contains the following particularly computationally intensive operations:\n\n\n\n\nVerifying the transaction signatures\n\n\nRunning the EVM instance(s) triggered by transaction execution\n\n\nUpdating the Merkle tree, including computing the new intermediate hashes\n\n\nUpdating the database\n\n\n\n\nSome benchmarks have been made that show that a single ethereum node is capable of around 1000-2000 transactions per second, and a small consortium network is capable of a few hundred transactions per second, given current software. These limits arise due to a combination of (1) bandwidth limitations, and (2) computational limitations.\n\n\nIn a single transaction, we can expect:\n\n\n\n\n1 elliptic curve signature verification (or more precisely, public key recovery)\n\n\n3-10 state updates (minimum 3, corresponding to sender ether deduction, recipient ether increase and miner ether fee payment; state-changing contract calls will have more), corresponding to 3-10 updates to the Merkle tree, requiring ~15-100 rounds of serialization, hashing, etc\n\n\nA corresponding ~15-100 updates to the underlying database\n\n\nIn a contract call, at least one round of VM execution, but possibly more. An informal survey of recent Ethereum transactions showed that among gas-consuming transactions the median gas consumption was ~50,000 gas and the average was ~100,000.\n\n\n\n\nVirtual machine optimization and precompiled contracts\n\n\nThe Ethereum Virtual Machine is a unique architecture that is optimized for the following properties:\n\n\n\n\nSmall attack surface, assumes that all code running inside of it is untrusted\n\n\nSmall code size (eg. the 4 kb of \"boilerplate\" that the default gcc creates for C++ code is acceptable on a single user's hard drive, but completely unacceptable when the code needs to sit on a blockchain; EVM code is often under 100 bytes)\n\n\nFully deterministic (note that due to metering with gas, even timeouts are deterministic; most other smart contract frameworks that try to use existing virtual machines completely fail to accomplish this)\n\n\nVery fast to start a new VM instance up and shut an instance down, as we expect 1-10 EVM instances to be created and destroyed \nper transaction\n. Note that most of these instances may well run less than 100 computational steps; hence, being \"lightweight\" is crucial.\n\n\nReduced complexity - in those cases where users are going to implement an alternative mechanism in contract code regardless (eg. multisig, ring signatures, on-chain tokens), the \"privileged\" in-protocol mechanism only serves to duplicate effort and get in the way, whereas abstraction would allow you to use the alternative mechanism to \nreplace\n the default mechanism.\n\n\nHaving multiple fully compatible implementations (there are ~50000 test cases at \nhttps://github.com/ethereum/tests\n which all 8 VM implementations in the 8 Ethereum clients pass)\n\n\n\n\n\n\nImportant note\n: \"gas\" and \"ether\" are NOT the same thing. Gas is a mechanism that allows computation inside the EVM to be deterministically metered, ie. for contracts to deterministically restrict calls to some fixed number of computational steps. Ether is a way of paying transaction fees, which are expected to be proportional to gas consumption. The Bitcoin analog of ether is BTC, the Bitcoin analog of gas is the number of bytes that a transaction takes up in a block; in Ethereum, measuring bytes alone is not enough as you also need to measure computation, hence the concept of gas. On a private chain, you do not need to use ether to pay for gas; you can come up with alternate rulesets, including for example simply requiring every transaction to have a maximum gas limit of 1 million.\n\n\n\n\nNote that the original EVM was \nnot\n designed for high-performance computation. When the EVM 1.0 spec was created, most ideas for what can be done inside of blockchain scripting were under 50 lines of code, consisting of \"if...then\" logic and basic arithmetic, and in this environment one can make a strong case that even 100x inefficiency in EVM execution will not make a significant difference to total transaction processing times because the bulk of transaction processing load appears in the form of verifying elliptic curve signatures (which requires looping through elliptic curve additions over 1000 times, where each addition itself contains many 256-bit operations).\n\n\nHowever, more recently we have realized that there is a very large demand for high-performance computation in the EVM particularly in order to implement more complex cryptography (eg. ring signatures, partially homomorphic encryption, other kinds of elliptic curves, lamport signatures); hence, we have realized that our current work on the EVM has been insufficient. We currently have two approaches that we are pursuing in parallel toward solving this:\n\n\n\n\nA possible new virtual machine based on WebAssembly (see \nhttps://github.com/ethereum/evm2.0-design\n)\n\n\nEVM improvements\n\n\nPrecompiled contracts\n\n\n\n\nThe WebAssembly plan is to develop a \"trans-compiler\" that takes WebAssembly code and convert it into WebAssembly code that keeps track of its own \"gas consumption\" at every branch point, and automatically stops if the remaining gas goes below zero. WebAssembly was chosen because the design requirements are in many cases similar to Ethereum, eg. users will be running untrusted WebAssembly code in their browsers, code sizes also need to be small as code is downloaded in real time, and there are already multiple implementations and a goal of compatibility between them. However, WebAssembly lacks a notion of gas counting, and the trans-compiler will fix that problem while allowing the use of an unmodified WebAssembly implementation to do the actual execution. It will also ban floating point numbers and other sources of potential nondeterminism. Note that it is not guaranteed that WebAsssembly will become the main public chain VM, but it may make sense to develop it further and make it a candidate for private chain use.\n\n\nThe leading EVM improvement proposal is to add a set of 256 64-bit registers, plus opcodes specialized to dealing with those registers. This allows operations that only require 64-bit precision to be processed with near-native speed. If this proposal is implemented, then it could potentially be merged with the WebAssembly route, by making a two-way compiler between the upgraded EVM and WASM and thus making WASM be one of the implementations of this upgraded EVM.\n\n\nA \"precompiled contract\" is an operation that is implemented in native code, and which can be accessed by calling a contract at a prespecified address. Current precompiles include:\n\n\n\n\nElliptic curve signature public key hash recovery (address \n0x000....0001\n)\n\n\nSHA256 (address \n0x000....0002\n)\n\n\nRIPEMD160 (address \n0x000....0002\n)\n\n\n\n\nIn many industry use cases, there is the goal of either integrating existing libraries for financial computation (eg. \nOpenGamma\n), or different forms of cryptography in order to comply with industry or national standards, or accelerating complex business logic (eg. order books) that is required to run at very high speed. Applications that do so may wish to specify their own precompiles. We recommend that private-chain precompiles take addresses in the range \n0x000....000400\n to \n0x000....0fffff\n (ie. 1024 to 1048575) to avoid collisions with possible future public chain features.\n\n\nDenial-of-service attacks and Security\n\n\nIn September and October 2016 there has been a series of denial-of-service attacks against various Ethereum implementations and the Ethereum protocol. A large portion of them exploited a \"quadratic memory consumption\" vulnerability in the Go implementation, where the client inefficiently copied a potentially large amount of cached state every time a call was made, leading to either very slow processing or an outright halt due to the client running out of memory. Additionally, a large number of attacks arose because opcodes that read the state (eg. EXTCODECOPY, BALANCE, CALL) were incorrectly priced too low, and because a design flaw in the SUICIDE opcode presented a way to very cheaply bloat the state with a large number of empty accounts. These issues were resolved in a hard fork on Oct 17.\n\n\nAs of the time of this writing, the main remaining denial-of-service issue is that the client makes O(log(n)) database reads in order to read a state entry, and when the state is too large to fit into memory (which is the case after the state increased greatly due to previous attacks that are no longer possible) this makes processing state-reading opcodes slow.\n\n\nThere are two ways to resolve this issue. One is to implement a cache that allows state entries to be read in O(1) database reads (likely a single database read in an optimal implementation); this resolves the problem but still leaves a low limit for transaction processing capacity. A single SSD read takes \n100 microseconds\n; hence a leveldb read may take 200-400 microseconds, creating a cap of ~2500 reads per second, or ~500 transactions per second. The requirement for an offline node to be able to synchronize decreases this further. Writes take up to 10x longer due to the need to update the state tree (which adds O(log(n)) overhead), but this can be done in a background process. Hence, storing state in an SSD makes it difficult to process more than ~100 tx/sec effectively.\n\n\nThe other approach is to implement measures to ensure that the total size of the state remains small enough to fit into memory. In a public chain, this entails either charging \"rent\" for accounts (see \nhere\n, \nhere\n, \nhere\n and \nhere\n for proposals); in a consortium chain, this simply entails having a good garbage collection strategy and if needed adding more RAM to validator nodes.\n\n\nThe Merkle Tree\n\n\nThe Merkle tree (also sometimes called \"Merkle Patricia tree\", \"Patricia trie\", \"Merkle Patricia trie\" or \"trie\") is an important part of the Ethereum protocol and provides a large amount of value particularly in the public chain. The function of the tree (see \nhere\n for details, and \nhere\n and \nhere\n for more detailed explanations) is to provide a cryptographically authenticated data structure that stores the entire state (ie. account balances, contract storage, nonces, etc); every 32-byte root hash maps uniquely (assuming cryptographic security of SHA3) to a particular state which may be gigabytes in size.\n\n\nThis allows for the following benefits:\n\n\n\n\nSecure fast syncing\n: new clients joining the network do not need to process every transaction from the genesis block to the present moment in order to download the state. Instead, they can simply download the block headers, verify the proof of work (or potentially proof of stake or signatures from PBFT participants), find a recent finalized block, and from the root hash contained in that block download the entire current state and authenticate it by checking that every hash in the trie matches up.\n\n\nLight client support\n: a client that does not have enough computational power, storage or bandwidth to download and process even the entire current state may simply keep track of block headers and use the consensus algorithm to authenticate block headers, and then download and verify \"branches\" of the Merkle tree just in time when the client needs to get some particular piece of state data.\n\n\nIndependent light verifiability\n: a block creator can come up with a \"proof\", consisting of a block together with the portion of the state data that is accessed or modified during that block, that any client even without any other data can use to verify that the block was created and the transactions were executed correctly.\n\n\n\n\nAlthough no one has yet come up with such a product at the time of this writing, one can imagine a centralized service running its business logic single-node private chain that uses the independent light verifiability feature of the Merkle tree in order to provide its users with very strong auditability and authenticity guarantees. For example, an exchange may commit to providing an API that allows any user to download the Merkle branches corresponding to their account data at any time, and also publish the root hash of its internal state after every operation. If a user sees their balance unexpectedly decreased and wants to be sure that there was no malfeasance, they can use a binary search algorithm to determine after which operation their balance was reduced, and then download a proof-of-execution for that operation and verify that the operation was legitimate. Hence, Merkle trees have benefits in many consortium and private chain applications as well as the public chain.\n\n\nHowever, the Merkle tree also comes with its efficiency cost; hence, in those applications that do not require it, an optimal solution may be to simply get rid of the Merkle tree, and instead store the state in the database directly, so three state changes would correspond to three database operations. That said, it is important not to jump to this conclusion too quickly, as there are several ways to optimize the Merkle tree without removing it entirely. This includes:\n\n\n\n\nAllowing the storage of unlimited-size values in the state, instead of just 32-byte values (see \nEIP 97\n). In cases where a contract very often needs to store many values at the same time (eg. a blockchain-based order book storing buy currency, sell currency, price, quantity, seller), this may improve efficiency by as much as 2x.\n\n\nRemoving the storage of intermediate root hashes after every transaction, instead doing it after every block. This (1) allows for the cache to be used more, so if many transactions in a block modify a single account only a single Merkle tree update needs to be done for that account for the entire block, (2) allows the Merkle tree to be updated using a more efficient algorithm (eg. see in \nthe benchmarks\n the Go client, which has this optimization, needs 28.5 milliseconds instead of 45.7 to update when the number of intermediate root hash calculations is reduced by 40%), (3) allows the Merkle tree to be updated using a more parallelizable algorithm, and (4) potentially opens the door to some heuristic parallel transaction execution optimizations.\n\n\nChanging the serialization algorithm or the trie algorithm (eg. making it a binary trie instead of hexary as it is now)\n\n\nSoftware-level improvements\n\n\n\n\nThe optimal strategy is to pursue three paths (namely, adding an option to instantiate an ethereum chain without a Merkle tree, exploring protocol hardforking options to make the Merkle tree more efficient, and exploring software-level improvements to the code) in parallel.\n\n\nTransaction Parallelizability\n\n\nOne common criticism (see \nhttp://www.multichain.com/blog/2015/11/smart-contracts-slow-blockchains/\n) of the current Ethereum model is that because it is so open-ended in the effects that transactions can have, verifying transactions in parallel is difficult. Once intermediate state root computation is removed, one heuristic strategy that can be employed works as follows:\n\n\n\n\nSelect the next \nk\n transactions, \nt[1] ... t[k]\n, that need to be processed. Process them all in parallel threads on top of the current state (giving each one a separate cache if it reads data that it already wrote), and during execution keep track of the set of addresses that each thread read and the set of addresses that each thread wrote to.\n\n\nLet \n(i, j)\n be the earliest collision (ranked by \nj\n) where (i) \ni \n j\n, (ii) \nt[j]\n read something that transaction \nt[i]\n wrote.\n\n\nApply the state updates from \nt[1] ... t[j-1]\n inclusive. Go back to step 1, starting from \nt[j]\n as the first transaction.\n\n\n\n\nThis may achieve substantial speedups in the general case, but that is not guaranteed; additionally, relying on the scheme may make your application vulnerable to denial-of-service attacks where the attacker sends a large number of deliberately unparallelizable transactions in order to prevent any parallel execution from taking place - in the worst case, performance will be no better than the single-threaded case. The Merkle tree changes detailed above will dditionally allow for the parallelization of Merkle tree calculations, and elliptic curve signature verifications are precomputed in existing clients and can be parallelized already, but this is currently as far as we can go.\n\n\nThe long-term roadmap for Ethereum 2.0 and 3.0 is to implement the concept of \"sharding\", where the state is broken up into many pieces and each piece is stored by a portion of nodes, and transactions affecting different parts of the state are processed by different nodes in parallel. Part of this roadmap is allowing transactions to statically declare an address range within which they are able to make synchronous operations, so that processing these transactions without holding the entire state is actually feasible. Calls going outside the stated address range would return an \nOUT_OF_RANGE\n error, similar to \nOUT_OF_GAS\n errors in effect.\n\n\nPublic blockchain sharding is a complicated technical challenge, as on top of the usual problems involving database sharding there are also cryptoeconomic challenges, as the particular form of distributed computing that a public blockchain is has the unique property that each node does not trust any other node, and so another node simply \nsaying\n that it processed and verified a given set of transactions is not sufficient. However, in the case of private and consortium chains, going this far is not required; instead, it suffices only to implement the part of the sharding roadmap that has to do with transaction parallelizability (ie. transactions specifying address ranges), and then achieve scalability by requiring each node in the network to simply add more CPU cores and more bandwidth.\n\n\nOne challenge with this kind of sharding is that there will be many operations in many applications that need to be cross-shard, ie. have an effect that is dispersed across the state such that a single transaction with a narrow address range cannot cover it. The solution for these cases is an asynchronous programming language, allowing operations to be split up into multiple phases. For example, a coin transfer from shard A to shard B would consist of the following steps:\n\n\n\n\nDestroy X coins on shard A, in a transaction that also specifies the destination shard and address; the consensus mechanism generates a receipt proving that this operation was confirmed.\n\n\nSubmit this receipt into a contract in shard B, which then generates X new coins on shard B. It then saves a record into the storage of shard B stating that the receipt was consumed, preventing it from being used to generate new coins a second time.\n\n\n\n\nSee \nthis presentation\n (\nvideo\n) for more details on how this would be done.\n\n\nAn important higher-level task is to actually create the programming language that would make it easy to implement these kinds of asynchronous cross-shard operations. Note that a lot of this work would simultaneously lay the groundwork for a programming language that compiles down into applications that exist across multiple blockchains.\n\n\nSmart Contract Safety\n\n\nAn important aspect of smart contract programming that touches public and consortium chain smart contracts alike is safety, including both protection against benign developer mistakes, and against malicious exploits included by the author of a contract in order to attempt to cheat users. A compiled list of contract programming mistakes on the public Ethereum blockchain can be found here:\n\n\nhttps://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/\n\n\nAn older paper from security researcher Andrew Miller can be found here:\n\n\nhttps://eprint.iacr.org/2015/460.pdf\n\n\nThe Ethereum wiki doc on safe contract programming techniques can be found here:\n\n\nhttps://github.com/ethereum/wiki/wiki/Safety\n\n\nThe first link also includes possible incremental improvements that can be taken to the EVM as well as Ethereum development environments in order to minimize the risk of such attacks. Additionally, since the DAO incident in June 2016 there has been a number of proposed EIPs in order to facilitate safer contract development: \nEIP 114\n, \n116\n, \n117\n, \n118\n and \n119\n. It is likely not wise for the consortium chain development community to implement safety-focused EIPs ahead of the public chain ecosystem, as we do not want to confuse developers by having one set of safe contract programming practices for the consortium chain ecosystem and one for the public chain ecosystem (except where absolutely unavoidable, eg. on the public chain, game-theoretic issues are much more inescapable).\n\n\nAside from low-level improvements, there are also higher-level tools that can be built in order to improve the safety of the contract programming ecosystem. These fall into two major categories:\n\n\n\n\nNew programming languages (using Solidity, Serpent, LLL or EVM as a compile target)\n\n\nFormal verification, symbolic execution or other static analysis tools for either new programming languages or existing programming languages\n\n\n\n\nNote that one must be careful about how these tools are integrated with the underlying environment; for example, pure functional languages are often cited as a solution to Ethereum contract programming challenges, but if we look at the specific case of the DAO theft we can see that it arose due to a \"re-entrancy\" hack where a contract called an untrusted contract which then called the original contract, and even if you try to implement a purely functional language over the current EVM, you will run into the challenge that if you need to call another contract it is extremely difficult to be sure that the child contract will not make some \"impure\" state-changing operations unless an EVM-level opcode such as \nSTATIC_CALL\n is implemented.\n\n\nIn general, it is not likely that there will be a single magic technology that solves all smart contract safety issues; rather, we will see a combination of incremental approaches including new languages, better analysis tools, better development tools, better standards and best practices and changes to the underlying EVM. Better standards and best practices should be integrated into development tools in order to make them easier for programmers to adapt to; a large part of the value of blockchain technology is in reducing barriers to entry in building high-trust systems, and if the previous barriers to entry are only replaced with a requirement of years of specialized developer education then the potential of the technology is arguably significantly reduced.\n\n\nState channels\n\n\nState channels are a popular short-term scalability, privacy and latency solution for blockchain technologies. Some information on state channels can be found here:\n\n\n\n\nhttp://www.arcturnus.com/ethereum-lightning-network-and-beyond/\n\n\nhttp://www.jeffcoleman.ca/state-channels/\n\n\nhttp://ethereum.stackexchange.com/questions/342/what-are-payment-channels-can-they-be-implemented-on-ethereum/1648\n\n\n\n\nSome implementations include:\n\n\n\n\nhttps://github.com/AnnaIsAWang/LedgerLabsCoops2016\n\n\nhttp://raiden.network\n\n\n\n\nPrivileged Accounts\n\n\nMany consortium chain applications require some node (eg. a regulator) to have special privileges. Possible privileges include:\n\n\n\n\nThe ability to freeze balances\n\n\nThe ability to stop execution of a smart contract\n\n\nThe ability to change the code of a smart contract\n\n\nThe ability to see plaintext state information that is only seen in encrypted form by most participants (eg. balances, contract terms)\n\n\n\n\nIn some cases, these privileges are best implemented in layers on top of the base protocol; for example, in a chain where the issuing of new smart contracts is heavily restricted (or even where there is only one contract for the entire chain), one can implement such features into the code of the contracts themselves. In the case of privacy-preserving solutions, giving regulators the ability to view plaintext state can only be done in layers on top because the privacy-preserving solutions themselves will be built through layers on top.\n\n\nIn other cases, these privileges are best implemented via changes to the underlying protocol. The simplest way to do this is to introduce some new opcodes, eg. \n0xed = SSTORE_EXT\n (set storage of external account), \n0xee = WITHDRAW\n (drain ETH from another account), \n0xef = SET_CODE\n (set code of another account), and give only one address the priviledge of using these opcodes (eg. address 254). Such a \"privileged address\" is a feature that is likely to be implemented in Ethereum in the future as part of the abstraction roadmap (in the public chain, only system-level contracts such as a hypothetical contract that would implement the contract creation function would have access to this priviledged address, so it will not be usable as a \"backdoor\" by any organizations or individuals, but in private and consortium chains it can be dual-purposed as a priviledge mechanism).\n\n\nChanging the Consensus Set\n\n\nOnce a consortium chain is launched, there will inevitably be reasons to change the set of consensus participants after the fact. This includes:\n\n\n\n\nInduction of new members into the consortium\n\n\nRemoval of new members of the consortium\n\n\nChange of the private keys used by one or more members of the consortium\n\n\n\n\nThere are several approaches to handling this:\n\n\n\n\nHave the consensus set be fixed in the config file, and make every consensus set change a hard fork\n\n\nStore the consensus set in a contract, where the contract itself encodes rules for updating the consensus set\n\n\nUse a secure external mechanism to store the consensus set (eg. the Ethereum public blockchain)\n\n\n\n\nA consensus abstraction should be able to cover all three modes if needed. If either (i) the consensus set is stored in an in-chain contract and the consensus algorithm does not provide instant finality (eg. DPOS), or (ii) the consensus set is stored in an external mechanism, then it is prudent to have a delay between when a consensus set change is made and when the change becomes active. The approach currently taken by the Casper proof of stake protocol planned for the public chain is to split blockchain time into 12-hour \"epochs\", and use the validator set defined at the start of the previous epoch (ie. a time which is always between 12 and 24 hours in the past) as the consensus set for the current block.\n\n\nThe reason why you may want to use an external mechanism is to provide greater security assurances for frequently-offline nodes. Specifically, especially if the consensus set is small there is a risk that, over some period of time, a majority of historical keys will be compromised, and if an attacker obtains these keys they will be able to create an alternate chain and trick long-offline nodes that this chain is legitimate. Using an external mechanism to store consensus participants makes it much more difficult for this to happen; though this approach may not be appropriate for all applications and in many cases the consortium itself may be sufficiently large that a 50% historical key compromise is very unlikely.\n\n\nNote that a well-designed setup could even tolerate short-term failures of the external mechanism by using a consensus algorithm that can tolerate small divergences in perceived consensus mechanism; this would also require restricting the rate at which consensus participants could change and having a rule that if the mechanism is unavailable then the most recent available consensus set should be used (though this is highly theoretical).\n\n\nSee also: \nthis article\n, which shows one way that a Byzantine-fault-tolerant consensus algorithm can maintain safety properties during validator transitions.", 
            "title": "\u8054\u76df\u94fe\u53d1\u5c55"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#_1", 
            "text": "", 
            "title": "\u8054\u76df\u94fe\u53d1\u5c55"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#choosing-a-codebase", 
            "text": "There are currently 8 implementations of the Ethereum protocol:   Go  http://github.com/ethereum/go-ethereum  C++  http://github.com/ethereum/cpp-ethereum  Python  http://github.com/ethereum/pyethereum  Javascript  http://github.com/ethereum/ethereumjs-lib  Java  https://github.com/ethereum/ethereumj  Haskell  https://github.com/jamshidh/ethereumH  Rust (Parity)  https://github.com/ethcore/parity  Ruby  https://github.com/janx/ruby-ethereum   These implementations differ in:   License (GPL, LGPL, MIT, Apache)  Performance  Feature-completeness  Modularity  Ease of modification  Ease of integration into other systems   For enterprise use cases, performance is likely to be highly important. There have been some efforts at benchmarking Ethereum clients, see:  https://github.com/ethereum/wiki/wiki/Benchmarks  However, a comprehensive set of benchmarks on all clients likely to be performant (C++, Go, Haskell, Java, Parity) would be a very useful task. Regarding licensing, Go is LGPL licensed, C++ is GPL licensed but there is an effort (with outcome still uncertain) to relicense it to Apache, Java is MIT, and Parity is GPL.", 
            "title": "Choosing a codebase"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#the-config-file", 
            "text": "There is an informal standard for a configuration file that Ethereum nodes must support, which describes the network parameters. The goal is to allow nodes to easily connect to test networks, private networks, and in the long term specify alternative networks with different properties, including consensus algorithms, P2P networking protocols, initial state, and protocol rules. The standard is described here:  https://github.com/ethereum/wiki/wiki/Ethereum-Chain-Spec-Format  An enterprise ethereum version should respect a superset of the standard, so that a node started with the right config settings would act as an Ethereum public chain node (but with more APIs and other features useful for enterprise purposes), but a node started with different settings would participate in a given consortium-chain network using PBFT, or a test network that uses a different virtual machine, or a network that incorporates new scalability features sooner than the public chain, etc.", 
            "title": "The config file"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#consensus", 
            "text": "Currently, the Ethereum clients support proof of work consensus. There is a desire to modularize the consensus algorithm in such a way that it will be possible to also use proof of stake (Casper), as well as private chain-specific consensus algorithms, with likely initial targets being PBFT and DPOS (essentially a round robin consensus algorithm). The first step is to determine exactly what the \"interface\" for a consensus algorithm \"class\" should look like.  A possible sketch of the interface is as follows:   submitTransaction(tx) : submit a transaction to a participating node. The node will attempt to include it in a block, or vote for it, or perform the equivalent operation in the consensus algorithm.  sendMessage(msg, node_id) : send a message to another node.  broadcastMessage(msg) : broadcast a message.  getMostRecent(conf_level) : get the most recent block that satisfies a given confirmation level. In proof of work or DPOS,  conf_level  would represent the number of confirmations, so it would return the nth last block in the chain; in PBFT confirmation is binary (ie. final confirmation is instant) so it always returns the most recent confirmed block.   Note that public chain consensus also requires an incentivization model, ie. a way to reward consensus participants who perform well and possibly penalize participants who perform badly. We abstract this by providing two options:   A function  finalize  that gets automatically called after processing every transaction in a block, which makes modifications to the state and may use the block as input.  A function  initialize  that gets automatically called before processing every transaction in a block, which makes modifications to the state and may use the block as input.   Note that either  finalize  or  initialize  may simply consist of a call to some standard contract with the block header as data; the Ethereum public chain plans to move to such an approach in the long term. In consortium chains, there is no need to use these functions for incentivization; however, they may be useful for other purposes (eg. to automatically run scheduled operations). Hence, because the utility of these operations is not strictly related to consensus incentivization, they should not be viewed as part of the consensus interface; rather, they should be viewed as transaction processing rules.  In a private chain context, there are several consensus algorithms that make the most sense:   Proof of authority  - essentially, one client with one particular private key makes all of the blocks  PBFT  (or some other traditional byzantine-fault-tolerant consensus algorithm)  DPOS  (or some other chain-based limited-validator consensus algorithm)  Casper  (Ethereum's  proof of stake  candidate) with a fixed validator set   PBFT and DPOS (taken purely as a consensus algorithm, not including the ability of some class of token holders to vote on delegates) each have their own advantages and disadvantages. Specifically:   PBFT has academically robust formal proofs for various properties (safety, liveness, etc) under a partially synchronous network model assuming at least 67% of nodes are online and honest  PBFT has instant finality - once a transaction is confirmed once, reverts are impossible. DPOS consensus is probabilistic much like proof of work (in fact, slightly worse, as attackers can see if they have the ability to revert short-range forks ahead of time), and so while a notion of \"de-facto finality\" is possible, it takes several minutes to reach  DPOS can support an unlimited number of nodes, whereas PBFT becomes very inefficient above about 30 nodes because every node has to send messages to and receive messages from every other node during every round. DPOS does this because each round consists only of one randomly selected validator making a block  DPOS is conceptually simpler to understand and implement and intuitively see why it converges  In a synchronous network model, DPOS can survive up to 49% Byzantine faults, higher than the 33% of PBFT; additionally, DPOS can survive even more faults if they consist of nodes going offline rather than trying to attack the network   Casper is intended as a  cryptoeconomic  algorithm where anyone can become a validator by depositing money. However, it can be repurposed for permissioned contexts by simply specifying a fixed validator set. This approach is worth exploring once Casper is implemented across major Ethereum clients.  Proof of authority may be required in some cases where particular safety properties are required and Ethereum's technologies are used more to provide deterministic and verifiable execution and auditing properties rather than decentralization in the traditional sense. Hence, it makes sense to implement all three and give each user the choice of which one to use for any given application.  Note : there is a common misconception that different algorithms have widely different transaction processing capacities, eg. DPOS can process 100 tx/sec while PBFT can process 1000 tx/sec, etc. Whereas in the case of future sharded blockchains this may be true, in the context of blockchains where every node processes every transaction this is not the case; the same amount of computational effort is required to process each transaction regardless of what consensus algorithm is used, although there may be small differences because some algorithms require recomputing transactions in the case of short-range forks, some can more safely allow transaction processing to be run a larger percentage of the time, etc. Differences in performance between chains are usually almost entirely due to differences in the protocols and the implementations, not the consensus algorithm (with the important exception that public-chain capacities tend to be much lower due to their additional economic restrictions, smaller node sizes and centralization concerns).", 
            "title": "Consensus"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#abstraction", 
            "text": "In Ethereum protocol development, one of the major overriding philosophies is the notion of abstraction: that the protocol itself should be as simple as possible, and as much as possible should be implemented in contract code instead of through hard protocol rules. Targets for abstraction include:   Account security (see  https://github.com/ethereum/EIPs/issues/86 )  The transaction state transition function (ie. the rules by which a transaction is processed)  Ether (ie. make ether into a  ERC 20 token  just like the others)  Logs / events   The purpose of abstraction is the following:   Lower attack surface and lower core code complexity  The ability to more easily hardfork the public chain protocol to different protocol rules, as it can be done simply by swapping out contract code  The ability to more easily swap out different rulesets on a test network or private implementation  The ability to switch between different rules on a per-application or per-user level (eg. some users want their accounts secured by ECDSA, some prefer Lamport for quantum-proofness, and in some private chain use cases industry or national standards require the use of specific forms of cryptography; the goal of EIP 86 is to support all of this)   EES may want to implement some of these abstraction features ahead of schedule.", 
            "title": "Abstraction"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#p2p-networking", 
            "text": "Ethereum's current P2P network is a Kademlia architecture, and details are described here:   https://github.com/ethereum/wiki/wiki/%C3%90%CE%9EVp2p-Wire-Protocol  https://github.com/ethereum/go-ethereum/wiki/Peer-to-Peer   A private chain may want to either use the same networking code (but with a different network ID set in the config file), or use an alternative type of network; the most likely alternative is a design where every node connects directly to every other node (quite feasible and likely optimal in networks with under ~20 nodes). Additionally there is the choice of customizing the connection that is made at the network or even lower level (eg. should all nodes be in the same subnet? If they are physically close to each other would fiber optic connections be optimal?); many of the details of this are largely outside the scope of the EES codebase, but the codebase should make sure that it works well under many common expected configurations.", 
            "title": "P2P networking"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#privacy-preserving-protocols", 
            "text": "See  https://blog.ethereum.org/2016/01/15/privacy-on-the-blockchain/  for a much more detailed description of the available approaches.", 
            "title": "Privacy-preserving protocols"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#apis", 
            "text": "Currently, the Ethereum codebase supports a basic set of APIs for querying the blockchain, querying contract state, filtering logs, sending transactions, etc. The primary way of making more complex queries (eg. returning the balance of a particular account in a particular token issued on the blockchain, returning the ask price of an offer on a blockchain-based order book, etc) is through the concept of \"virtual transactions\". Essentially, the idea is that a client can pretend to execute a transaction locally, which would call a function of a contract that returns a value. The API would then (possibly synchronously) return the value.  However, there may be more high-level APIs that are required, particularly around use cases that require not just accessing the current state but also accessing previous state, getting information about transactions, and more advanced forms of blockchain analytics; additionally, there is room for APIs that are compatible with API formats that users are already comfortable with and expect.  A particular class of APIs that is likely to be very useful is the ability to make SQL and similar queries to the blockchain. There are a few existing projects in this direction, see:   https://www.reddit.com/r/ethereum/comments/4gcsn2/introducing_etherquery_perform_sql_queries/  https://github.com/jamshidh/ethereum-data-sql   However, much more work likely remains in making these systems maximally efficient and broadly applicable to many use cases.", 
            "title": "APIs"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#user-interfaces", 
            "text": "User interfaces in Ethereum are a broad category, including:   The Mist browser, as well as applications written in HTML/Javascript that can be used either inside of Mist or through a user's regular browser  Block explorers such as  etherchain ,  etherscan  and  ether.camp . Note that unlike similar tools for many other blockchains, which focus purely on currency balances and transactions, Ethereum block explorers tend to be highly advanced and general, offering views into contract state, functions, internal transactions, etc; for example, here is a ether.camp's view of the DAO:  The geth command line interface (the same as the web3 Javascript API).", 
            "title": "User interfaces"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#efficiency-improvements", 
            "text": "The process of verifying a block in Ethereum currently contains the following particularly computationally intensive operations:   Verifying the transaction signatures  Running the EVM instance(s) triggered by transaction execution  Updating the Merkle tree, including computing the new intermediate hashes  Updating the database   Some benchmarks have been made that show that a single ethereum node is capable of around 1000-2000 transactions per second, and a small consortium network is capable of a few hundred transactions per second, given current software. These limits arise due to a combination of (1) bandwidth limitations, and (2) computational limitations.  In a single transaction, we can expect:   1 elliptic curve signature verification (or more precisely, public key recovery)  3-10 state updates (minimum 3, corresponding to sender ether deduction, recipient ether increase and miner ether fee payment; state-changing contract calls will have more), corresponding to 3-10 updates to the Merkle tree, requiring ~15-100 rounds of serialization, hashing, etc  A corresponding ~15-100 updates to the underlying database  In a contract call, at least one round of VM execution, but possibly more. An informal survey of recent Ethereum transactions showed that among gas-consuming transactions the median gas consumption was ~50,000 gas and the average was ~100,000.", 
            "title": "Efficiency improvements"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#virtual-machine-optimization-and-precompiled-contracts", 
            "text": "The Ethereum Virtual Machine is a unique architecture that is optimized for the following properties:   Small attack surface, assumes that all code running inside of it is untrusted  Small code size (eg. the 4 kb of \"boilerplate\" that the default gcc creates for C++ code is acceptable on a single user's hard drive, but completely unacceptable when the code needs to sit on a blockchain; EVM code is often under 100 bytes)  Fully deterministic (note that due to metering with gas, even timeouts are deterministic; most other smart contract frameworks that try to use existing virtual machines completely fail to accomplish this)  Very fast to start a new VM instance up and shut an instance down, as we expect 1-10 EVM instances to be created and destroyed  per transaction . Note that most of these instances may well run less than 100 computational steps; hence, being \"lightweight\" is crucial.  Reduced complexity - in those cases where users are going to implement an alternative mechanism in contract code regardless (eg. multisig, ring signatures, on-chain tokens), the \"privileged\" in-protocol mechanism only serves to duplicate effort and get in the way, whereas abstraction would allow you to use the alternative mechanism to  replace  the default mechanism.  Having multiple fully compatible implementations (there are ~50000 test cases at  https://github.com/ethereum/tests  which all 8 VM implementations in the 8 Ethereum clients pass)    Important note : \"gas\" and \"ether\" are NOT the same thing. Gas is a mechanism that allows computation inside the EVM to be deterministically metered, ie. for contracts to deterministically restrict calls to some fixed number of computational steps. Ether is a way of paying transaction fees, which are expected to be proportional to gas consumption. The Bitcoin analog of ether is BTC, the Bitcoin analog of gas is the number of bytes that a transaction takes up in a block; in Ethereum, measuring bytes alone is not enough as you also need to measure computation, hence the concept of gas. On a private chain, you do not need to use ether to pay for gas; you can come up with alternate rulesets, including for example simply requiring every transaction to have a maximum gas limit of 1 million.  Note that the original EVM was  not  designed for high-performance computation. When the EVM 1.0 spec was created, most ideas for what can be done inside of blockchain scripting were under 50 lines of code, consisting of \"if...then\" logic and basic arithmetic, and in this environment one can make a strong case that even 100x inefficiency in EVM execution will not make a significant difference to total transaction processing times because the bulk of transaction processing load appears in the form of verifying elliptic curve signatures (which requires looping through elliptic curve additions over 1000 times, where each addition itself contains many 256-bit operations).  However, more recently we have realized that there is a very large demand for high-performance computation in the EVM particularly in order to implement more complex cryptography (eg. ring signatures, partially homomorphic encryption, other kinds of elliptic curves, lamport signatures); hence, we have realized that our current work on the EVM has been insufficient. We currently have two approaches that we are pursuing in parallel toward solving this:   A possible new virtual machine based on WebAssembly (see  https://github.com/ethereum/evm2.0-design )  EVM improvements  Precompiled contracts   The WebAssembly plan is to develop a \"trans-compiler\" that takes WebAssembly code and convert it into WebAssembly code that keeps track of its own \"gas consumption\" at every branch point, and automatically stops if the remaining gas goes below zero. WebAssembly was chosen because the design requirements are in many cases similar to Ethereum, eg. users will be running untrusted WebAssembly code in their browsers, code sizes also need to be small as code is downloaded in real time, and there are already multiple implementations and a goal of compatibility between them. However, WebAssembly lacks a notion of gas counting, and the trans-compiler will fix that problem while allowing the use of an unmodified WebAssembly implementation to do the actual execution. It will also ban floating point numbers and other sources of potential nondeterminism. Note that it is not guaranteed that WebAsssembly will become the main public chain VM, but it may make sense to develop it further and make it a candidate for private chain use.  The leading EVM improvement proposal is to add a set of 256 64-bit registers, plus opcodes specialized to dealing with those registers. This allows operations that only require 64-bit precision to be processed with near-native speed. If this proposal is implemented, then it could potentially be merged with the WebAssembly route, by making a two-way compiler between the upgraded EVM and WASM and thus making WASM be one of the implementations of this upgraded EVM.  A \"precompiled contract\" is an operation that is implemented in native code, and which can be accessed by calling a contract at a prespecified address. Current precompiles include:   Elliptic curve signature public key hash recovery (address  0x000....0001 )  SHA256 (address  0x000....0002 )  RIPEMD160 (address  0x000....0002 )   In many industry use cases, there is the goal of either integrating existing libraries for financial computation (eg.  OpenGamma ), or different forms of cryptography in order to comply with industry or national standards, or accelerating complex business logic (eg. order books) that is required to run at very high speed. Applications that do so may wish to specify their own precompiles. We recommend that private-chain precompiles take addresses in the range  0x000....000400  to  0x000....0fffff  (ie. 1024 to 1048575) to avoid collisions with possible future public chain features.", 
            "title": "Virtual machine optimization and precompiled contracts"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#denial-of-service-attacks-and-security", 
            "text": "In September and October 2016 there has been a series of denial-of-service attacks against various Ethereum implementations and the Ethereum protocol. A large portion of them exploited a \"quadratic memory consumption\" vulnerability in the Go implementation, where the client inefficiently copied a potentially large amount of cached state every time a call was made, leading to either very slow processing or an outright halt due to the client running out of memory. Additionally, a large number of attacks arose because opcodes that read the state (eg. EXTCODECOPY, BALANCE, CALL) were incorrectly priced too low, and because a design flaw in the SUICIDE opcode presented a way to very cheaply bloat the state with a large number of empty accounts. These issues were resolved in a hard fork on Oct 17.  As of the time of this writing, the main remaining denial-of-service issue is that the client makes O(log(n)) database reads in order to read a state entry, and when the state is too large to fit into memory (which is the case after the state increased greatly due to previous attacks that are no longer possible) this makes processing state-reading opcodes slow.  There are two ways to resolve this issue. One is to implement a cache that allows state entries to be read in O(1) database reads (likely a single database read in an optimal implementation); this resolves the problem but still leaves a low limit for transaction processing capacity. A single SSD read takes  100 microseconds ; hence a leveldb read may take 200-400 microseconds, creating a cap of ~2500 reads per second, or ~500 transactions per second. The requirement for an offline node to be able to synchronize decreases this further. Writes take up to 10x longer due to the need to update the state tree (which adds O(log(n)) overhead), but this can be done in a background process. Hence, storing state in an SSD makes it difficult to process more than ~100 tx/sec effectively.  The other approach is to implement measures to ensure that the total size of the state remains small enough to fit into memory. In a public chain, this entails either charging \"rent\" for accounts (see  here ,  here ,  here  and  here  for proposals); in a consortium chain, this simply entails having a good garbage collection strategy and if needed adding more RAM to validator nodes.", 
            "title": "Denial-of-service attacks and Security"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#the-merkle-tree", 
            "text": "The Merkle tree (also sometimes called \"Merkle Patricia tree\", \"Patricia trie\", \"Merkle Patricia trie\" or \"trie\") is an important part of the Ethereum protocol and provides a large amount of value particularly in the public chain. The function of the tree (see  here  for details, and  here  and  here  for more detailed explanations) is to provide a cryptographically authenticated data structure that stores the entire state (ie. account balances, contract storage, nonces, etc); every 32-byte root hash maps uniquely (assuming cryptographic security of SHA3) to a particular state which may be gigabytes in size.  This allows for the following benefits:   Secure fast syncing : new clients joining the network do not need to process every transaction from the genesis block to the present moment in order to download the state. Instead, they can simply download the block headers, verify the proof of work (or potentially proof of stake or signatures from PBFT participants), find a recent finalized block, and from the root hash contained in that block download the entire current state and authenticate it by checking that every hash in the trie matches up.  Light client support : a client that does not have enough computational power, storage or bandwidth to download and process even the entire current state may simply keep track of block headers and use the consensus algorithm to authenticate block headers, and then download and verify \"branches\" of the Merkle tree just in time when the client needs to get some particular piece of state data.  Independent light verifiability : a block creator can come up with a \"proof\", consisting of a block together with the portion of the state data that is accessed or modified during that block, that any client even without any other data can use to verify that the block was created and the transactions were executed correctly.   Although no one has yet come up with such a product at the time of this writing, one can imagine a centralized service running its business logic single-node private chain that uses the independent light verifiability feature of the Merkle tree in order to provide its users with very strong auditability and authenticity guarantees. For example, an exchange may commit to providing an API that allows any user to download the Merkle branches corresponding to their account data at any time, and also publish the root hash of its internal state after every operation. If a user sees their balance unexpectedly decreased and wants to be sure that there was no malfeasance, they can use a binary search algorithm to determine after which operation their balance was reduced, and then download a proof-of-execution for that operation and verify that the operation was legitimate. Hence, Merkle trees have benefits in many consortium and private chain applications as well as the public chain.  However, the Merkle tree also comes with its efficiency cost; hence, in those applications that do not require it, an optimal solution may be to simply get rid of the Merkle tree, and instead store the state in the database directly, so three state changes would correspond to three database operations. That said, it is important not to jump to this conclusion too quickly, as there are several ways to optimize the Merkle tree without removing it entirely. This includes:   Allowing the storage of unlimited-size values in the state, instead of just 32-byte values (see  EIP 97 ). In cases where a contract very often needs to store many values at the same time (eg. a blockchain-based order book storing buy currency, sell currency, price, quantity, seller), this may improve efficiency by as much as 2x.  Removing the storage of intermediate root hashes after every transaction, instead doing it after every block. This (1) allows for the cache to be used more, so if many transactions in a block modify a single account only a single Merkle tree update needs to be done for that account for the entire block, (2) allows the Merkle tree to be updated using a more efficient algorithm (eg. see in  the benchmarks  the Go client, which has this optimization, needs 28.5 milliseconds instead of 45.7 to update when the number of intermediate root hash calculations is reduced by 40%), (3) allows the Merkle tree to be updated using a more parallelizable algorithm, and (4) potentially opens the door to some heuristic parallel transaction execution optimizations.  Changing the serialization algorithm or the trie algorithm (eg. making it a binary trie instead of hexary as it is now)  Software-level improvements   The optimal strategy is to pursue three paths (namely, adding an option to instantiate an ethereum chain without a Merkle tree, exploring protocol hardforking options to make the Merkle tree more efficient, and exploring software-level improvements to the code) in parallel.", 
            "title": "The Merkle Tree"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#transaction-parallelizability", 
            "text": "One common criticism (see  http://www.multichain.com/blog/2015/11/smart-contracts-slow-blockchains/ ) of the current Ethereum model is that because it is so open-ended in the effects that transactions can have, verifying transactions in parallel is difficult. Once intermediate state root computation is removed, one heuristic strategy that can be employed works as follows:   Select the next  k  transactions,  t[1] ... t[k] , that need to be processed. Process them all in parallel threads on top of the current state (giving each one a separate cache if it reads data that it already wrote), and during execution keep track of the set of addresses that each thread read and the set of addresses that each thread wrote to.  Let  (i, j)  be the earliest collision (ranked by  j ) where (i)  i   j , (ii)  t[j]  read something that transaction  t[i]  wrote.  Apply the state updates from  t[1] ... t[j-1]  inclusive. Go back to step 1, starting from  t[j]  as the first transaction.   This may achieve substantial speedups in the general case, but that is not guaranteed; additionally, relying on the scheme may make your application vulnerable to denial-of-service attacks where the attacker sends a large number of deliberately unparallelizable transactions in order to prevent any parallel execution from taking place - in the worst case, performance will be no better than the single-threaded case. The Merkle tree changes detailed above will dditionally allow for the parallelization of Merkle tree calculations, and elliptic curve signature verifications are precomputed in existing clients and can be parallelized already, but this is currently as far as we can go.  The long-term roadmap for Ethereum 2.0 and 3.0 is to implement the concept of \"sharding\", where the state is broken up into many pieces and each piece is stored by a portion of nodes, and transactions affecting different parts of the state are processed by different nodes in parallel. Part of this roadmap is allowing transactions to statically declare an address range within which they are able to make synchronous operations, so that processing these transactions without holding the entire state is actually feasible. Calls going outside the stated address range would return an  OUT_OF_RANGE  error, similar to  OUT_OF_GAS  errors in effect.  Public blockchain sharding is a complicated technical challenge, as on top of the usual problems involving database sharding there are also cryptoeconomic challenges, as the particular form of distributed computing that a public blockchain is has the unique property that each node does not trust any other node, and so another node simply  saying  that it processed and verified a given set of transactions is not sufficient. However, in the case of private and consortium chains, going this far is not required; instead, it suffices only to implement the part of the sharding roadmap that has to do with transaction parallelizability (ie. transactions specifying address ranges), and then achieve scalability by requiring each node in the network to simply add more CPU cores and more bandwidth.  One challenge with this kind of sharding is that there will be many operations in many applications that need to be cross-shard, ie. have an effect that is dispersed across the state such that a single transaction with a narrow address range cannot cover it. The solution for these cases is an asynchronous programming language, allowing operations to be split up into multiple phases. For example, a coin transfer from shard A to shard B would consist of the following steps:   Destroy X coins on shard A, in a transaction that also specifies the destination shard and address; the consensus mechanism generates a receipt proving that this operation was confirmed.  Submit this receipt into a contract in shard B, which then generates X new coins on shard B. It then saves a record into the storage of shard B stating that the receipt was consumed, preventing it from being used to generate new coins a second time.   See  this presentation  ( video ) for more details on how this would be done.  An important higher-level task is to actually create the programming language that would make it easy to implement these kinds of asynchronous cross-shard operations. Note that a lot of this work would simultaneously lay the groundwork for a programming language that compiles down into applications that exist across multiple blockchains.", 
            "title": "Transaction Parallelizability"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#smart-contract-safety", 
            "text": "An important aspect of smart contract programming that touches public and consortium chain smart contracts alike is safety, including both protection against benign developer mistakes, and against malicious exploits included by the author of a contract in order to attempt to cheat users. A compiled list of contract programming mistakes on the public Ethereum blockchain can be found here:  https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/  An older paper from security researcher Andrew Miller can be found here:  https://eprint.iacr.org/2015/460.pdf  The Ethereum wiki doc on safe contract programming techniques can be found here:  https://github.com/ethereum/wiki/wiki/Safety  The first link also includes possible incremental improvements that can be taken to the EVM as well as Ethereum development environments in order to minimize the risk of such attacks. Additionally, since the DAO incident in June 2016 there has been a number of proposed EIPs in order to facilitate safer contract development:  EIP 114 ,  116 ,  117 ,  118  and  119 . It is likely not wise for the consortium chain development community to implement safety-focused EIPs ahead of the public chain ecosystem, as we do not want to confuse developers by having one set of safe contract programming practices for the consortium chain ecosystem and one for the public chain ecosystem (except where absolutely unavoidable, eg. on the public chain, game-theoretic issues are much more inescapable).  Aside from low-level improvements, there are also higher-level tools that can be built in order to improve the safety of the contract programming ecosystem. These fall into two major categories:   New programming languages (using Solidity, Serpent, LLL or EVM as a compile target)  Formal verification, symbolic execution or other static analysis tools for either new programming languages or existing programming languages   Note that one must be careful about how these tools are integrated with the underlying environment; for example, pure functional languages are often cited as a solution to Ethereum contract programming challenges, but if we look at the specific case of the DAO theft we can see that it arose due to a \"re-entrancy\" hack where a contract called an untrusted contract which then called the original contract, and even if you try to implement a purely functional language over the current EVM, you will run into the challenge that if you need to call another contract it is extremely difficult to be sure that the child contract will not make some \"impure\" state-changing operations unless an EVM-level opcode such as  STATIC_CALL  is implemented.  In general, it is not likely that there will be a single magic technology that solves all smart contract safety issues; rather, we will see a combination of incremental approaches including new languages, better analysis tools, better development tools, better standards and best practices and changes to the underlying EVM. Better standards and best practices should be integrated into development tools in order to make them easier for programmers to adapt to; a large part of the value of blockchain technology is in reducing barriers to entry in building high-trust systems, and if the previous barriers to entry are only replaced with a requirement of years of specialized developer education then the potential of the technology is arguably significantly reduced.", 
            "title": "Smart Contract Safety"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#state-channels", 
            "text": "State channels are a popular short-term scalability, privacy and latency solution for blockchain technologies. Some information on state channels can be found here:   http://www.arcturnus.com/ethereum-lightning-network-and-beyond/  http://www.jeffcoleman.ca/state-channels/  http://ethereum.stackexchange.com/questions/342/what-are-payment-channels-can-they-be-implemented-on-ethereum/1648   Some implementations include:   https://github.com/AnnaIsAWang/LedgerLabsCoops2016  http://raiden.network", 
            "title": "State channels"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#privileged-accounts", 
            "text": "Many consortium chain applications require some node (eg. a regulator) to have special privileges. Possible privileges include:   The ability to freeze balances  The ability to stop execution of a smart contract  The ability to change the code of a smart contract  The ability to see plaintext state information that is only seen in encrypted form by most participants (eg. balances, contract terms)   In some cases, these privileges are best implemented in layers on top of the base protocol; for example, in a chain where the issuing of new smart contracts is heavily restricted (or even where there is only one contract for the entire chain), one can implement such features into the code of the contracts themselves. In the case of privacy-preserving solutions, giving regulators the ability to view plaintext state can only be done in layers on top because the privacy-preserving solutions themselves will be built through layers on top.  In other cases, these privileges are best implemented via changes to the underlying protocol. The simplest way to do this is to introduce some new opcodes, eg.  0xed = SSTORE_EXT  (set storage of external account),  0xee = WITHDRAW  (drain ETH from another account),  0xef = SET_CODE  (set code of another account), and give only one address the priviledge of using these opcodes (eg. address 254). Such a \"privileged address\" is a feature that is likely to be implemented in Ethereum in the future as part of the abstraction roadmap (in the public chain, only system-level contracts such as a hypothetical contract that would implement the contract creation function would have access to this priviledged address, so it will not be usable as a \"backdoor\" by any organizations or individuals, but in private and consortium chains it can be dual-purposed as a priviledge mechanism).", 
            "title": "Privileged Accounts"
        }, 
        {
            "location": "/Infrastructure/Consortium-Chain-Development/#changing-the-consensus-set", 
            "text": "Once a consortium chain is launched, there will inevitably be reasons to change the set of consensus participants after the fact. This includes:   Induction of new members into the consortium  Removal of new members of the consortium  Change of the private keys used by one or more members of the consortium   There are several approaches to handling this:   Have the consensus set be fixed in the config file, and make every consensus set change a hard fork  Store the consensus set in a contract, where the contract itself encodes rules for updating the consensus set  Use a secure external mechanism to store the consensus set (eg. the Ethereum public blockchain)   A consensus abstraction should be able to cover all three modes if needed. If either (i) the consensus set is stored in an in-chain contract and the consensus algorithm does not provide instant finality (eg. DPOS), or (ii) the consensus set is stored in an external mechanism, then it is prudent to have a delay between when a consensus set change is made and when the change becomes active. The approach currently taken by the Casper proof of stake protocol planned for the public chain is to split blockchain time into 12-hour \"epochs\", and use the validator set defined at the start of the previous epoch (ie. a time which is always between 12 and 24 hours in the past) as the consensus set for the current block.  The reason why you may want to use an external mechanism is to provide greater security assurances for frequently-offline nodes. Specifically, especially if the consensus set is small there is a risk that, over some period of time, a majority of historical keys will be compromised, and if an attacker obtains these keys they will be able to create an alternate chain and trick long-offline nodes that this chain is legitimate. Using an external mechanism to store consensus participants makes it much more difficult for this to happen; though this approach may not be appropriate for all applications and in many cases the consortium itself may be sufficiently large that a 50% historical key compromise is very unlikely.  Note that a well-designed setup could even tolerate short-term failures of the external mechanism by using a consensus algorithm that can tolerate small divergences in perceived consensus mechanism; this would also require restricting the rate at which consensus participants could change and having a rule that if the mechanism is unavailable then the most recent available consensus set should be used (though this is highly theoretical).  See also:  this article , which shows one way that a Byzantine-fault-tolerant consensus algorithm can maintain safety properties during validator transitions.", 
            "title": "Changing the Consensus Set"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/", 
            "text": "What is Proof of Stake\n\n\nProof of Stake (PoS) is a category of consensus algorithms for public blockchains that depend on a validator's economic stake in the network\n. In proof of work (PoW) based public blockchains (e.g. Bitcoin and the current implementation of Ethereum), the algorithm rewards participants who solve cryptographic puzzles in order to validate transactions and create new blocks (i.e. mining). In PoS-based public blockchains (e.g. Ethereum's upcoming Casper implementation), a set of validators take turns proposing and voting on the next block, and the weight of each validator's vote depends on the size of its deposit (i.e. stake). Significant advantages of PoS include \nsecurity, reduced risk of centralization, and energy efficiency\n.\n\n\nIn general, a proof of stake algorithm looks as follows. The blockchain keeps track of a set of validators, and anyone who holds the blockchain's base cryptocurrency (in Ethereum's case, ether) can become a validator by sending a special type of transaction that \nlocks up their ether into a deposit\n. The process of creating and agreeing to new blocks is then done through a consensus algorithm that all current validators can participate in.\n\n\nThere are many kinds of consensus algorithms, and many ways to assign rewards to validators who participate in the consensus algorithm, so there are many \"flavors\" of proof of stake. From an algorithmic perspective, there are two major types: chain-based proof of stake and \nBFT\n-style proof of stake.\n\n\nIn \nchain-based proof of stake\n, the algorithm pseudo-randomly selects a validator during each time slot (eg. every period of 10 seconds might be a time slot), and assigns that validator the right to create a single block, and this block must point to some previous block (normally the block at the end of the previously longest chain), and so over time most blocks converge into a single constantly growing chain.\n\n\nIn \nBFT-style proof of stake\n, validators are \nrandomly\n assigned the right to \npropose\n blocks, but \nagreeing on which block is canonical\n is done through a multi-round process where every validator sends a \"vote\" for some specific block during each round, and at the end of the process all (honest and online) validators permanently agree on whether or not any given block is part of the chain. Note that blocks may still be \nchained together\n; the key difference is that consensus on a block can come within one block, and does not depend on the length or size of the chain after it.\n\n\nWhat are the benefits of proof of stake as opposed to proof of work?\n\n\nSee \nA Proof of Stake Design Philosophy\n for a more long-form argument.\n\n\nIn short:\n\n\n\n\nNo need to consume large quantities of electricity\n in order to secure a blockchain (eg. it's estimated that both Bitcoin and Ethereum burn over $1 million worth of electricity and hardware costs per day as part of their consensus mechanism).\n\n\nBecause of the lack of high electricity consumption, there is \nnot as much need to issue as many new coins\n in order to motivate participants to keep participating in the network. It may theoretically even be possible to have \nnegative\n net issuance, where a portion of transaction fees is \"burned\" and so the supply goes down over time.\n\n\nProof of stake opens the door to a wider array of techniques that use game-theoretic mechanism design in order to better \ndiscourage centralized cartels\n from forming and, if they do form, from acting in ways that are harmful to the network (eg. like \nselfish mining\n in proof of work).\n\n\nReduced centralization risks\n, as economies of scale are much less of an issue. $10 million of coins will get you exactly 10 times higher returns than $1 million of coins, without any additional disproportionate gains because at the higher level you can afford better mass-production equipment.\n\n\nAbility to use economic penalties to \nmake various forms of 51% attacks vastly more expensive\n to carry out than proof of work - to paraphrase Vlad Zamfir, \"it's as though your ASIC farm burned down if you participated in a 51% attack\".\n\n\n\n\nHow does proof of stake fit into traditional Byzantine fault tolerance research?\n\n\nThere are several fundamental results from Byzantine fault tolerance research that apply to all consensus algorithms, including traditional consensus algorithms like PBFT but also any proof of stake algorithm and, with the appropriate mathematical modeling, proof of work.\n\n\nThe key results include:\n\n\n\n\nCAP theorem\n - \"in the cases that a network partition takes place, you have to choose either consistency or availability, you cannot have both\". The intuitive argument is simple: if the network splits in half, and in one half I send a transaction \"send my 10 coins to A\" and in the other I send a transaction \"send my 10 coins to B\", then either the system is unavailable, as one or both transactions will not be processed, or it becomes inconsistent, as one half of the network will see the first transaction completed and the other half will see the second transaction completed. Note that the CAP theorem has nothing to do with scalability; it applies to sharded and non-sharded systems equally.\n\n\nFLP impossibility\n - in an asynchronous setting (ie. there are no guaranteed bounds on network latency even between correctly functioning nodes), it is not possible to create an algorithm which is guaranteed to reach consensus in any specific finite amount of time if even a single faulty/dishonest node is present. Note that this does NOT rule out \n\"Las Vegas\" algorithms\n that have some probability each round of achieving consensus and thus will achieve consensus within T seconds with probability exponentially approaching 1 as T grows; this is in fact the \"escape hatch\" that many successful consensus algorithms use.\n\n\nBounds on fault tolerance\n - from \nthe DLS paper\n we have: (i) protocols running in a partially synchronous network model (ie. there is a bound on network latency but we do not know ahead of time what it is) can tolerate up to 1/3 arbitrary (ie. \"Byzantine\") faults, (ii) deterministic protocols in an asynchronous model (ie. no bounds on network latency) cannot tolerate faults (although their paper fails to mention that \nrandomized algorithms can\n with up to 1/3 fault tolerance), (iii) protocols in a synchronous model (ie. network latency is guaranteed to be less than a known \nd\n) can, surprisingly, tolerate up to 100% fault tolerance, although there are restrictions on what can happen when more than or equal to 1/2 of nodes are faulty. Note that the \"authenticated Byzantine\" model is the one worth considering, not the \"Byzantine\" one; the \"authenticated\" part essentially means that we can use public key cryptography in our algorithms, which is in modern times very well-researched and very cheap.\n\n\n\n\nProof of work has been \nrigorously analyzed by Andrew Miller and others\n and fits into the picture as an algorithm reliant on a synchronous network model. We can model the network as being made up of a near-infinite number of nodes, with each node representing a very small unit of computing power and having a very small probability of being able to create a block in a given period. In this model, the protocol has 50% fault tolerance assuming zero network latency, ~46% (Ethereum) and ~49.5% (Bitcoin) fault tolerance under actually observed conditions, but goes down to 33% if network latency is equal to the block time, and reduces to zero as network latency approaches infinity.\n\n\nProof of stake consensus fits more directly into the Byzantine fault tolerant consensus mould, as all validators have known identities (stable Ethereum addresses) and the network keeps track of the total size of the validator set. There are two general lines of proof of stake research, one looking at synchronous network models and one looking at partially asynchronous network models. \"Chain-based\" proof of stake algorithms almost always rely on synchronous network models, and their security can be formally proven within these models similarly to how security of \nproof of work algorithms\n can be proven. A line of research connecting traditional Byzantine fault tolerant consensus in partially synchronous networks to proof of stake also exists, but is more complex to explain; it will be covered in more detail in later sections.\n\n\nProof of work algorithms and chain-based proof of stake algorithms choose availability over consistency, but BFT-style consensus algorithms lean more toward consistency; \nTendermint\n chooses consistency explicitly, and Casper uses a hybrid model that prefers availability but provides as much consistency as possible and makes both on-chain applications and clients aware of how strong the consistency guarantee is at any given time.\n\n\nNote that Ittay Eyal and Emin Gun Sirer's \nselfish mining\n discovery, which places 25% and 33% bounds on the incentive compatibility of Bitcoin mining depending on the network model (ie. mining is only incentive compatible if collusions larger than 25% or 33% are impossible) has NOTHING to do with results from traditional consensus algorithm research, which does not touch incentive compatibility.\n\n\nWhat is the \"nothing at stake\" problem and how can it be fixed?\n\n\nIn many early (all chain-based) proof of stake algorithms, including Peercoin, there are only rewards for producing blocks, and no penalties. This has the unfortunate consequence that, in the case that there are multiple competing chains, it is in a validator's incentive to try to make blocks on top of every chain at once, just to be sure:\n\n\n\n\nIn proof of work, doing so would require splitting one's computing power in half, and so would not be lucrative:\n\n\n\n\nThe result is that if all actors are narrowly economically rational, then even if there are no attackers, a blockchain may never reach consensus. If there is an attacker, then the attacker need only overpower altruistic nodes (who would exclusively stake on the original chain), and not rational nodes (who would stake on both the original chain and the attacker's chain), in contrast to proof of work, where the attacker must overpower both altruists and rational nodes (or at least credibly threaten to: see \nP + epsilon attacks\n).\n\n\nSome argue that stakeholders have an incentive to act correctly and only stake on the longest chain in order to \"preserve the value of their investment\", however this ignores that this incentive suffers from \ntragedy of the commons\n problems: each individual stakeholder might only have a 1% chance of being \"pivotal\" (ie. being in a situation where if they participate in an attack then it succeeds and if they do not participate it fails), and so the bribe needed to convince them personally to join an attack would be only 1% of the size of their deposit; hence, the required combined bribe would be only 0.5-1% of the total sum of all deposits. Additionally, this argument implies that any zero-chance-of-failure situation is not a stable equilibrium, as if the chance of failure is zero then everyone has a 0% chance of being pivotal.\n\n\nThis can be solved via two strategies. The first, described in broad terms under the name \"Slasher\" \nhere\n and developed further by Iddo Bentov \nhere\n, involves penalizing validators if they simultaneously create blocks on multiple chains, by means of including proof of misbehavior (ie. two conflicting signed block headers) into the blockchain as a later point in time at which point the malfeasant validator's deposit is deducted appropriately. This changes the incentive structure thus:\n\n\n\n\nNote that for this algorithm to work, the validator set needs to be determined well ahead of time. Otherwise, if a validator has 1% of the stake, then if there are two branches A and B then 0.99% of the time the validator will be eligible to stake only on A and not on B, 0.99% of the time the validator will be eligible to stake on B and not on A, and only 0.01% of the time will the validator will be eligible to stake on both. Hence, the validator can with 99% efficiency probabilistically double-stake: stake on A if possible, stake on B if possible, and only if the choice between both is open stake on the longer chain. This can only be avoided if the validator selection is the same for every block on both branches, which requires the validators to be selected at a time before the fork takes place.\n\n\nThis has its own flaws, including requiring nodes to be frequently online to get a secure view of the blockchain, and opening up medium-range validator collusion risks (ie. situations where, for example, 25 out of 30 consecutive validators get together and agree ahead of time to implement a 51% attack on the previous 19 blocks), but if these risks are deemed acceptable then it works well.\n\n\nThe second strategy is to simply punish validators for creating blocks on the \nwrong\n chain. That is, if there are two competing chains, A and B, then if a validator creates a block on B, they get a reward of +R on B, but the block header can be included into A (in Casper this is called a \"dunkle\") and on A the validator suffers a penalty of -F (possibly F = R). This changes the economic calculation thus:\n\n\n\n\nThe intuition here is that we can replicate the economics of proof of work inside of proof of stake. In proof of work, there is also a penalty for creating a block on the wrong chain, but this penalty is implicit in the external environment: miners have to spend extra electricity and obtain or rent extra hardware. Here, we simply make the penalties explicit. This mechanism has the disadvantage that it imposes slightly more risk on validators (although the effect should be smoothed out over time), but has the advantage that it does not require validators to be known ahead of time.\n\n\nThat shows how chain-based algorithms solve nothing-at-stake. Now how do BFT-style proof of stake algorithms work?\n\n\nBFT-style (partially synchronous) proof of stake algorithms allow validators to \"vote\" on blocks by sending one or more types of signed messages, and specify two kinds of rules:\n\n\n\n\nFinality conditions\n - rules that determine when a given hash can be considered finalized.\n\n\nSlashing conditions\n - rules that determine when a given validator can be deemed beyond reasonable doubt to have misbehaved (eg. voting for multiple conflicting blocks at the same time). If a validator triggers one of these rules, their entire deposit gets deleted.\n\n\n\n\nTo illustrate the different forms that slashing conditions can take, we will give two examples of slashing conditions (hereinafter, \"2/3 of all validators\" is shorthand for \"2/3 of all validators weighted by deposited coins\", and likewise for other fractions and percentages). In these examples, \"PREPARE\" and \"COMMIT\" should be understood as simply referring to two types of messages that validators can send.\n\n\n\n\nIf \nMESSAGES\n contains messages of the form \n[\"COMMIT\", HASH1, view]\n and \n[\"COMMIT\", HASH2, view]\n for the same \nview\n but differing \nHASH1\n and \nHASH2\n signed by the same validator, then that validator is slashed.\n\n\nIf \nMESSAGES\n contains a message of the form \n[\"COMMIT\", HASH, view1]\n, then UNLESS either view1 = -1 or there also exist messages of the form \n[\"PREPARE\", HASH, view1, view2]\n for some specific \nview2\n, where \nview2 \n view1\n, signed by 2/3 of all validators, then the validator that made the COMMIT is slashed.\n\n\n\n\nThere are two important desiderata for a suitable set of slashing conditions to have:\n\n\n\n\nAccountable safety\n - if conflicting \nHASH1\n and \nHASH2\n (ie. \nHASH1\n and \nHASH2\n are different, and neither is a descendant of the other) are finalized, then at least 1/3 of all validators must have violated some slashing condition.\n\n\nPlausible liveness\n - unless at least 1/3 of all validators have violated some slashing condition, there exists a set of messages that 2/3 of validators can produce that finalize some value.\n\n\n\n\nIf we have a set of slashing conditions that satisfies both properties, then we can incentivize participants to send messages, and start benefiting from economic finality.\n\n\nWhat is \"economic finality\" in general?\n\n\nEconomic finality is the idea that once a block is finalized, or more generally once enough messages of certain types have been signed, then the only way that at any point in the future the canonical history will contain a conflicting block is if a large number of people are willing to burn very large amounts of money. If a node sees that this condition has been met for a given block, then they have a very economically strong assurance that that block will always be part of the canonical history that everyone agrees on.\n\n\nThere are two \"flavors\" of economic finality:\n\n\n\n\nA block can be economically finalized if a sufficient number of validators have signed cryptoeconomic claims of the form \"I agree to lose X in all histories where block B is not included\". This gives clients assurance that either (i) B is part of the canonical chain, or (ii) validators lost a large amount of money in order to trick them into thinking that this is the case.\n\n\nA block can be economically finalized if a sufficient number of validators have signed messages expressing support for block B, and there is a mathematical proof that \nif some B' != B is also finalized under the same definition\n then validators lose a large amount of money. If clients see this, and also validate the chain, and validity plus finality is a sufficient condition for precedence in the canonical fork choice rule, then they get an assurance that either (i) B is part of the canonical chain, or (ii) validators lost a large amount of money in making a conflicting chain that was also finalized.\n\n\n\n\nThe two approaches to finality inherit from the two solutions to the nothing at stake problem: finality by penalizing incorrectness, and finality by penalizing equivocation. The main benefit of the first approach is that it is more light-client friendly and is simpler to reason about, and the main benefits of the second approach are that (i) it's easier to see that honest validators will not be punished, and (ii) griefing factors are more favorable to honest validators.\n\n\nCasper follows the second flavor, though it is possible that an on-chain mechanism will be added where validators can voluntarily opt-in to signing finality messages of the first flavor, thereby enabling much more efficient light clients.\n\n\nSo how does this relate to Byzantine fault tolerance theory?\n\n\nTraditional byzantine fault tolerance theory posits similar safety and liveness desiderata, except with some differences. First of all, traditional byzantine fault tolerance theory simply requires that safety is achieved if 2/3 of validators are \nhonest\n. This is a strictly easier model to work in; traditional fault tolerance tries to prove \"if mechanism M has a safety failure, then at least 1/3 of nodes are faulty\", whereas our model tries to prove \"if mechanism M has a safety failure, then at least 1/3 of nodes are faulty, \nand you know which ones, even if you were offline at the time the failure took place\n\". From a liveness perspective, our model is the easier one, as we do not demand a proof that the network \nwill\n come to consensus, we just demand a proof that it does not get \nstuck\n.\n\n\nFortunately, we can show the additional accountability requirement is not a particularly difficult one; in fact, with the right \"protocol armor\", we can convert \nany\n traditional partially synchronous or asynchronous Byzantine fault-tolerant algorithm into an accountable algorithm. The proof of this basically boils down to the fact that faults can be exhaustively categorized into a few classes, and each one of these classes is either accountable (ie. if you commit that type of fault you can get caught, so we can make a slashing condition for it) or indistinguishable from latency (note that even the fault of sending messages too early is indistinguishable from latency, as one can model it by speeding up everyone's clocks and assigning the messages that \nweren't\n sent too early a higher latency).\n\n\nWhat is \"weak subjectivity\"?\n\n\nIt is important to note that the mechanism of using deposits to ensure there is \"something at stake\" does lead to one change in the security model. Suppose that deposits are locked for four months, and can later be withdrawn. Suppose that an attempted 51% attack happens that reverts 10 days worth of transactions. The blocks created by the attackers can simply be imported into the main chain as proof-of-malfeasance (or \"dunkles\") and the validators can be punished. However, suppose that such an attack happens after six months. Then, even though the blocks can certainly be re-imported, by that time the malfeasant validators will be able to withdraw their deposits on the main chain, and so they cannot be punished.\n\n\nTo solve this problem, we introduce a \"revert limit\" - a rule that nodes must simply refuse to revert further back in time than the deposit length (ie. in our example, four months). Note that this rule is different from every other consensus rule in the protocol, in that it means that nodes may come to different conclusions depending on when they saw certain messages. The time that a node saw a given message may be different between different nodes; hence we consider this rule \"subjective\" (alternatively, one well-versed in Byzantine fault tolerance theory may view it as a kind of synchrony assumption).\n\n\nHowever, the \"subjectivity\" here is very weak: in order for a node to get on the \"wrong\" chain, they must receive the original message four months later than they otherwise would have. This is only possible in two cases:\n\n\n\n\nWhen a node connects to the blockchain for the first time.\n\n\nIf a node has been offline for more than four months.\n\n\n\n\nWe can solve (1) by making it the user's responsibility to authenticate the latest state out of band. They can do this by asking their friends, block explorers, businesses that they interact with, etc. for a recent block hash in the chain that they see as the canonical one. In practice, such a block hash may well simply come as part of the software they use to verify the blockchain; an attacker that can corrupt the checkpoint in the software can arguably just as easily corrupt the software itself, and no amount of pure cryptoeconomic verification can solve that problem.\n\n\nNote that all of this is a problem only in the very limited case where a majority of previous stakeholders collude to attack the network and create an alternate chain; most of the time we expect there will only be one canonical chain to choose from.\n\n\nAlso, note that weak subjectivity assumptions exist in proof of work chains as well if the chain does any hard forks. Bitcoin has previously pulled off a hard fork with 2 months lead time through \nbitcoind 0.8.1\n, which fixed a database issue that made certain kinds of large blocks invalid and thereby allowed clients to process blocks that bitcoind 0.7 could not process, and so users had to download a new version of the software with 2 months' notice. This is itself a kind of weak subjectivity assumption, as users had to \"log on\" within that two-month period to download the update to stay on the correct chain.\n\n\nAdditionally, the social authentication can if needed even be automated in several ways. One is to bake it into natural user workflow: a \nBIP 70\n-style payment request could include a recent block hash, and the user's client software would make sure that they are on the same chain as the vendor before approving a payment (or for that matter, any on-chain interaction). The other is to use Jeff Coleman's \nuniversal hash time\n. If UHT is used, then a successful attack chain would need to be generated secretly \nat the same time\n as the legitimate chain was being built, requiring a majority of validators to secretly collude for that long.\n\n\nDoes weak subjectivity mean that a proof of stake chain must be \"anchored\" into a proof of work chain to be secure?\n\n\nIn short, no.\n\n\nElaborate?\n\n\nWeak subjectivity by itself is a rather small addition to the security assumptions in a blockchain in practice, and definitely does not necessitate some proof-of-work-based outside source of truth to supplement it. To see why, consider the kind of situation where weak subjectivity by itself would compromise a blockchain's security. In such a world, powerful corporate or nation state actors would have the ability to somehow convince an entire community that block hash B was the block hash of block XXXYYY when most of them saw at the time and have stored in their own computers that the block hash of block XXXYYY was A, but for some reason such powerful actors \nwould not\n have the ability to trick users into accepting a different location from where they download their client software.\n\n\nFurthermore, the \"anchoring\" that advocates of such a scheme describe is not even all that secure. All anchoring proves is that a given block hash was \nproduced\n at time T' \n T; it does not prove that it was \npublished\n at that time. Hence, a PoS chain anchored into a PoW chain could simply be attacked by a majority coalition that produces both chains in parallel, anchors both, publishes one, and then four months later publishes the other one.\n\n\nOne could get around this by embedding a fully-functional \"light client\" of the PoS chain into the PoW chain, which would reject the double-anchoring, but this would require the PoW chain to be feature-rich enough \nto be able\n to implement such a client - a property which most actually existing proof of work chains do not possess.\n\n\nCan one economically penalize censorship in proof of stake?\n\n\nUnlike reverts, censorship is much more difficult to prove. The blockchain itself cannot directly tell the difference between \"user A tried to send transaction X but it was unfairly censored\", \"user A tried to send transaction X but it never got in because the transaction fee was insufficient\" and \"user A never tried to send transaction X at all\". However, there are a number of techniques that can be used to mitigate censorship issues.\n\n\nThe first is censorship resistance by halting problem. In the weaker version of this scheme, the protocol is designed to be Turing-complete in such a way that a validator cannot even tell whether or not a given transaction will lead to an undesired action without spending a large amount of processing power executing the transaction, and thus opening itself up to denial-of-service attacks. This is what \nprevented the DAO soft fork\n.\n\n\nIn the stronger version of the scheme, transactions can trigger guaranteed effects at some point in the near to mid-term future. Hence, a user could send multiple transactions which interact with each other and with predicted third-party information to lead to some future event, but the validators cannot possibly tell that this is going to happen until the transactions are already included (and economically finalized) and it is far too late to stop them; even if all future transactions are excluded, the event that validators wish to halt would still take place. Note that in this scheme, validators could still try to prevent \nall\n transactions, or perhaps all transactions that do not come packaged with some formal proof that they do not lead to anything undesired, but this would entail forbidding a very wide class of transactions to the point of essentially breaking the entire system, which would cause validators to lose value as the price of the cryptocurrency in which their deposits are denominated would drop.\n\n\nThe second, \ndescribed by Adam Back here\n, is to require transactions to be \ntimelock-encrypted\n. Hence, validators will include the transactions without knowing the contents, and only later could the contents automatically be revealed, by which point once again it would be far too late to un-include the transactions. If validators were sufficiently malicious, however, they could simply only agree to include transactions that come with a cryptographic proof (eg. ZK-SNARK) of what the decrypted version is; this would force users to download new client software, but an adversary could conveniently provide such client software for easy download, and in a game-theoretic model users would have the incentive to play along.\n\n\nPerhaps the best that can be said in a proof-of-stake context is that users could also install a software update that includes a hard fork that deletes the malicious validators and this is not that much harder than installing a software update to make their transactions \"censorship-friendly\". Hence, all in all this scheme is also moderately effective, though it does come at the cost of slowing interaction with the blockchain down (note that the scheme must be mandatory to be effective; otherwise malicious validators could much more easily simply filter encrypted transactions without filtering the quicker unencrypted transactions).\n\n\nA third alternative is to include censorship detection in the fork choice rule. The idea is simple. Nodes watch the network for transactions, and if they see a transaction that has a sufficiently high fee for a sufficient amount of time, then they assign a lower \"score\" to blockchains that do not include this transaction. If all nodes follow this strategy, then eventually a minority chain would automatically coalesce that includes the transactions, and all honest online nodes would follow it. The main weakness of such a scheme is that offline nodes would still follow the majority branch, and if the censorship is temporary and they log back on after the censorship ends then they would end up on a different branch from online nodes. Hence, this scheme should be viewed more as a tool to facilitate automated emergency coordination on a hard fork than something that would play an active role in day-to-day fork choice.\n\n\nHow does validator selection work, and what is stake grinding?\n\n\nIn any chain-based proof of stake algorithm, there is a need for some mechanism which randomly selects which validator out of the currently active validator set can make the next block. For example, if the currently active validator set consists of Alice with 40 ether, Bob with 30 ether, Charlie with 20 ether and David with 10 ether, then you want there to be a 40% chance that Alice will be the next block creator, 30% chance that Bob will be, etc (in practice, you want to randomly select not just one validator, but rather an infinite sequence of validators, so that if Alice doesn't show up there is someone who can replace her after some time, but this doesn't change the fundamental problem). In non-chain-based algorithms randomness is also often needed for different reasons.\n\n\n\"Stake grinding\" is a class of attack where a validator performs some computation or takes some other step to try to bias the randomness in their own favor. For example:\n\n\n\n\nIn \nPeercoin\n, a validator could \"grind\" through many combinations of parameters and find favorable parameters that would increase the probability of their coins generating a valid block.\n\n\nIn one now-defunct implementation, the randomness for block N+1 was dependent on the signature of block N. This allowed a validator to repeatedly produce new signatures until they found one that allowed them to get the next block, thereby seizing control of the system forever.\n\n\nIn NXT, the randomness for block N+1 is dependent on the validator that creates block N. This allows a validator to manipulate the randomness by simply skipping an opportunity to create a block. This carries an opportunity cost equal to the block reward, but sometimes the new random seed would give the validator an above-average number of blocks over the next few dozen blocks. See \nhere\n for a more detailed analysis.\n\n\n\n\n(1) and (2) are easy to solve; the general approach is to require validators to deposit their coins well in advance, and not to use information that can be easily manipulated as source data for the randomness. There are several main strategies for solving problems like (3). The first is to use schemes based on \nsecret sharing\n or \ndeterministic threshold signatures\n and have validators collaboratively generate the random value. These schemes are robust against all manipulation unless a majority of validators collude (in some cases though, depending on the implementation, between 33-50% of validators can interfere in the operation, leading to the protocol having a 67% liveness assumption).\n\n\nThe second is to use cryptoeconomic schemes where validators commit to information (ie. publish \nsha3(x)\n) well in advance, and then must publish \nx\n in the block; \nx\n is then added into the randomness pool. There are two theoretical attack vectors against this:\n\n\n\n\nManipulate \nx\n at commitment time. This is impractical because the randomness result would take many actors' values into account, and if even one of them is honest then the output will be a uniform distribution. A uniform distribution XORed together with arbitrarily many arbitrarily biased distributions still gives a uniform distribution.\n\n\nSelectively avoid publishing blocks. However, this attack costs one block reward of opportunity cost, and because the scheme prevents anyone from seeing any future validators except for the next, it almost never provides more than one block reward worth of revenue. The only exception is the case where, if a validator skips, the next validator in line AND the first child of that validator will both be the same validator; if these situations are a grave concern then we can punish skipping further via an explicit skipping penalty.\n\n\n\n\nThe third is to use \nIddo Bentov's \"majority beacon\"\n, which generates a random number by taking the bit-majority of the previous N random numbers generated through some other beacon (ie. the first bit of the result is 1 if the majority of the first bits in the source numbers is 1 and otherwise it's 0, the second bit of the result is 1 if the majority of the second bits in the source numbers is 1 and otherwise it's 0, etc). This gives a cost-of-exploitation of \n~C * sqrt(N)\n where \nC\n is the cost of exploitation of the underlying beacons. Hence, all in all, many known solutions to stake grinding exist; the problem is more like \ndifferential cryptanalysis\n than \nthe halting problem\n - an annoyance that proof of stake designers eventually understood and now know how to overcome, not a fundamental and inescapable flaw.\n\n\nWhat would the equivalent of a 51% attack against Casper look like?\n\n\nThe most basic form of \"51% attack\" is a simple \nfinality reversion\n: validators that already finalized block A then finalize some competing block A', thereby breaking the blockchain's finality guarantee. In this case, there now exist two incompatible finalized histories, creating a split of the blockchain, that full nodes would be willing to accept, and so it is up to the community to coordinate out of band to focus on one of the branches and ignore the other(s).\n\n\nThis coordination could take place on social media, through private channels between block explorer providers, businesses and exchanges, various online discussion forms, and the like. The principle according to which the decision would be made is \"whichever one was finalized \nfirst\n is the real one\". Another alternative is to rely on \"market consensus\": both branches would be briefly being traded on exchanges for a very short period of time, until network effects rapidly make one branch much more valuable with the others. In this case, the \"first finalized chain wins\" principle would be a Schelling point for what the market would choose. It's very possible that a combination of both approaches will get used in practice.\n\n\nOnce there is consensus on which chain is real, users (ie. validators and light and full node operators) would be able to manually insert the winning block hash into their client software through a special option in the interface, and their nodes would then ignore all other chains. No matter which chain wins, there exists evidence that can immediately be used to destroy at least 1/3 of the validators' deposits.\n\n\nAnother kind of attack is \nliveness denial\n: instead of trying to revert blocks, a cartel of \n=34% of validators could simply refuse to finalize any more blocks. In this case, blocks would never finalize. Casper uses a hybrid chain/BFT-style consensus, and so the blockchain would still grow, but it would have a much lower level of security. If no blocks are finalized for some long period of time (eg. 1 day), then there are several options:\n\n\n\n\nThe protocol can include an automatic feature to rotate the validator set. Blocks under the new validator set would finalize, but clients would get an indication that the new finalized blocks are in some sense suspect, as it's very possible that the old validator set will resume operating and finalize some other blocks. Clients could then manually override this warning once it's clear that the old validator set is not coming back online. There would be a protocol rule that under such an event all old validators that did not try to participate in the consensus process take a large penalty to their deposits.\n\n\nA hard fork is used to add in new validators and delete the attackers' balances.\n\n\n\n\nIn case (2), the fork would once again be coordinated via social consensus and possibly via market consensus (ie. the branch with the old and new validator set briefly both being traded on exchanges). In the latter case, there is a strong argument that the market would want to choose the branch where \"the good guys win\", as such a chain has validators that have demonstrated their goodwill (or at least, their alignment with the interest of the users) and so is a more useful chain for application developers.\n\n\nNote that there is a spectrum of response strategies here between social coordination and in-protocol automation, and it is generally considered desirable to push as far toward automated resolution as possible so as to minimize the risk of simultaneous 51% attacks and attacks on the social layer (and market consensus tools such as exchanges). One can imagine an implementation of (1) where nodes automatically accept a switch to a new validator set if they do not see a new block being committed for a long enough time, which would reduce the need for social coordination but at the cost of requiring those nodes that do not wish to rely on social coordination to remain constantly online. In either case, a solution can be designed where attackers take a large hit to their deposits.\n\n\nA more insidious kind of attack is a \ncensorship attack\n, where \n= 34% of validators refuse to finalize blocks that contain certain kinds of transactions that they do not like, but otherwise the blockchain keeps going and blocks keep getting finalized. This could range from a mild censorship attack which only censors to interfere with a few specific applications (eg. selectively censoring transactions in something like Raiden or the lightning network is a fairly easy way for a cartel to steal money) to an attack that blocks all transactions.\n\n\nThere are two sub-cases. The first is where the attacker has 34-67% of the stake. Here, we can program validators to refuse to finalize or build on blocks that they subjectively believe are clearly censoring transactions, which turns this kind of attack into a more standard liveness attack. The more dangerous case is where the attacker has more than 67% of the stake. Here, the attacker can freely block any transactions they wish to block and refuse to build on any blocks that do contain such transactions.\n\n\nThere are two lines of defense. First, because Ethereum is Turing-complete it is \nnaturally somewhat resistant to censorship\n as censoring transactions that have a certain effect is in some ways similar to solving the halting problem. Because there is a gas limit, it is not literally impossible, though the \"easy\" ways to do it do open up denial-of-service attack vulnerabilities.\n\n\nThis resistance \nis not perfect\n, and there are ways to improve it. The most interesting approach is to add in-protocol features where transactions can automatically schedule future events, as it would be extremely difficult to try to foresee what the result of executing scheduled events and the events resulting from those scheduled events would be ahead of time. Validators could then use obfuscated sequences of scheduled events to deposit their ether, and dilute the attacker to below 33%.\n\n\nSecond, one can introduce the notion of an \"active fork choice rule\", where part of the process for determining whether or not a given chain is valid is trying to interact with it and verifying that it is not trying to censor you. The most effective way to do this would be for nodes to repeatedly send a transaction to schedule depositing their ether and then cancel the deposit at the last moment. If nodes detect censorship, they could then follow through with the deposit, and so temporarily join the validator pool en masse, diluting the attacker to below 33%. If the validator cartel censors their attempts to deposit, then nodes running this \"active fork choice rule\" would not recognize the chain as valid; this would collapse the censorship attack into a liveness denial attack, at which point it can be resolved through the same means as other liveness denial attacks.\n\n\nThat sounds like a lot of reliance on out-of-band social coordination; is that not dangerous?\n\n\nAttacks against Casper are extremely expensive; as we will see below, attacks against Casper cost as much, if not more, than the cost of buying enough mining power in a proof of work chain to permanently 51% attack it over and over again to the point of uselessness. Hence, the recovery techniques described above will only be used in very extreme circumstances; in fact, advocates of proof of work also generally express willingness to use social coordination in similar circumstances by, for example, \nchanging the proof of work algorithm\n. Hence, it is not even clear that the need for social coordination in proof of stake is larger than it is in proof of work.\n\n\nIn reality, we expect the amount of social coordination required to be near-zero, as attackers will realize that it is not in their benefit to burn such large amounts of money to simply take a blockchain offline for one or two days.\n\n\nDoesn't MC =\n MR mean that all consensus algorithms with a given security level are equally efficient (or in other words, equally wasteful)?\n\n\nThis is an argument that many have raised, perhaps best explained by \nPaul Sztorc in this article\n. Essentially, if you create a way for people to earn $100, then people will be willing to spend anywhere up to $99.9 (including the cost of their own labor) in order to get it; marginal cost approaches marginal revenue. Hence, the theory goes, any algorithm with a given block reward will be equally \"wasteful\" in terms of the quantity of socially unproductive activity that is carried out in order to try to get the reward.\n\n\nThere are three flaws with this:\n\n\n\n\nIt's not enough to simply say that marginal cost approaches marginal revenue; one must also posit a plausible mechanism by which someone can actually expend that cost. For example, if tomorrow I announce that every day from then on I will give $100 to a randomly selected one of a given list of ten people (using my laptop's /dev/urandom as randomness), then there is simply no way for anyone to send $99 to try to get at that randomness. Either they are not in the list of ten, in which case they have no chance no matter what they do, or they are in the list of ten, in which case they don't have any reasonable way to manipulate my randomness so they're stuck with getting the expected-value $10 per day.\n\n\nMC =\n MR does NOT imply total cost approaches total revenue. For example, suppose that there is an algorithm which pseudorandomly selects 1000 validators out of some very large set (each validator getting a reward of $1), you have 10% of the stake so on average you get 100, and at a cost of $1 you can force the randomness to reset (and you can repeat this an unlimited number of times). Due to the \ncentral limit theorem\n, the standard deviation of your reward is $10, and based on \nother known results in math\n the expected maximum of N random samples is slightly under \nM + S * sqrt(2 * log(N))\n where \nM\n is the mean and \nS\n is the standard deviation. Hence the reward for making additional trials (ie. increasing N) drops off sharply, eg. with 0 re-trials your expected reward is $100, with one re-trial it's $105.5, with two it's $108.5, with three it's $110.3, with four it's $111.6, with five it's $112.6 and with six it's $113.5. Hence, after five retrials it stops being worth it. As a result, an economically motivated attacker with ten percent of stake will inefficiently spend $5 to get an additional revenue of $13, though the total revenue is $113. If the exploitable mechanisms only expose small opportunities, the economic loss will be small; it is decidedly NOT the case that a single drop of exploitability brings the entire flood of PoW-level economic waste rushing back in. This point will also be very relevant in our below discussion on capital lockup costs.\n\n\nProof of stake can be secured with much lower total rewards than proof of work.\n\n\n\n\nWhat about capital lockup costs?\n\n\nLocking up X ether in a deposit is not free; it entails a sacrifice of optionality for the ether holder. Right now, if I have 1000 ether, I can do whatever I want with it; if I lock it up in a deposit, then it's stuck there for months, and I do not have, for example, the insurance utility of the money being there to pay for sudden unexpected expenses. I also lose some freedom to change my token allocations away from ether within that timeframe; I could simulate selling ether by shorting an amount equivalent to the deposit on an exchange, but this itself carries costs including exchange fees and paying interest. Some might argue: isn't this capital lockup inefficiency really just a highly indirect way of achieving the exact same level of economic inefficiency as exists in proof of work? The answer is no, for both reasons (2) and (3) above.\n\n\nLet us start with (3) first. Consider a model where proof of stake deposits are infinite-term, ASICs last forever, ASIC technology is fixed (ie. no Moore's law) and electricity costs are zero. Let's say the equilibrium interest rate is 5% per annum. In a proof of work blockchain, I can take $1000, convert it into a miner, and the miner will pay me $50 in rewards per year forever. In a proof of stake blockchain, I would buy $1000 of coins, deposit them (ie. losing them forever), and get $50 in rewards per year forever. So far, the situation looks completely symmetrical (technically, even here, in the proof of stake case my destruction of coins isn't fully socially destructive as it makes others' coins worth more, but we can leave that aside for the moment). The cost of a \"Maginot-line\" 51% attack (ie. buying up more hardware than the rest of the network) increases by $1000 in both cases.\n\n\nNow, let's perform the following changes to our model in turn:\n\n\n\n\nMoore's law exists, ASICs depreciate by 50% every 2.772 years (that's a continuously-compounded 25% per annum; picked to make the numbers simpler). If I want to retain the same \"pay once, get money forever\" behavior, I can do so: I would put $1000 into a fund, where $167 would go into an ASIC and the remaining $833 would go into investments at 5% interest; the $41.67 dividends per year would be just enough to keep renewing the ASIC hardware (assuming technological development is fully continuous, once again to make the math simpler). Rewards would go down to $8.33 per year; hence, 83.3% of miners will drop out until the system comes back into equilibrium with me earning $50 per year, and so the Maginot-line cost of an attack on PoW given the same rewards drops by a factor of 6.\n\n\nElectricity plus maintenance makes up 1/3 of mining costs. We estimate the 1/3 from recent mining statistics: one of Bitfury's new data centers consumes \n0.06 joules per gigahash\n, or 60 J/TH or 0.000017 kWh/TH, and if we assume the entire Bitcoin network has similar efficiencies we get 27.9 kWh per second given \n1.67 million TH/s total Bitcoin hashpower\n. Electricity in China costs \n$0.11 per kWh\n, so that's about $3 per second, or $260,000 per day. Bitcoin block rewards plus fees are $600 per BTC * 13 BTC per block * 144 blocks per day = $1.12m per day. Thus electricity itself would make up 23% of costs, and we can back-of-the-envelope estimate maintenance at 10% to give a clean 1/3 ongoing costs, 2/3 fixed costs split. This means that out of your $1000 fund, only $111 would go into the ASIC, $55 would go into paying ongoing costs, and $833 would go into hardware investments; hence the Maginot-line cost of attack is 9x lower than in our original setting.\n\n\nDeposits are temporary, not permanent. Sure, if I voluntarily keep staking forever, then this changes nothing. However, I regain some of the optionality that I had before; I could quit within a medium timeframe (say, 4 months) at any time. This means that I would be willing to put more than $1000 of ether in for the $50 per year gain; perhaps in equilibrium it would be something like $3000. Hence, the cost of the Maginot line attack on PoS \nincreases\n by a factor of three, and so on net PoS gives 27x more security than PoW for the same cost.\n\n\n\n\nThe above included a large amount of simplified modeling, however it serves to show how multiple factors stack up heavily in favor of PoS in such a way that PoS gets \nmore\n bang for its buck in terms of security. The meta-argument for why this \nperhaps suspiciously multifactorial argument\n leans so heavily in favor of PoS is simple: in PoW, we are working directly with the laws of physics. In PoS, we are able to design the protocol in such a way that it has the precise properties that we want - in short, we can \noptimize the laws of physics in our favor\n. The \"hidden trapdoor\" that gives us (3) is the change in the security model, specifically the introduction of weak subjectivity.\n\n\nNow, we can talk about the marginal/total distinction. In the case of capital lockup costs, this is very important. For example, consider a case where you have $100,000 of ether. You probably intend to hold a large portion of it for a long time; hence, locking up even $50,000 of the ether should be nearly free. Locking up $80,000 would be slightly more inconvenient, but $20,000 of breathing room still gives you a large space to maneuver. Locking up $90,000 is more problematic, $99,000 is very problematic, and locking up all $100,000 is absurd, as it means you would not even have a single bit of ether left to pay basic transaction fees. Hence, your marginal costs increase quickly. We can show the difference between this state of affairs and the state of affairs in proof of work as follows:\n\n\n\n\nHence, the \ntotal\n cost of proof of stake is potentially much lower than the marginal cost of depositing 1 more ETH into the system multiplied by the amount of ether currently deposited.\n\n\nNote that this component of the argument unfortunately does not fully translate into reduction of the \"safe level of issuance\". It does help us because it shows that we can get substantial proof of stake participation even if we keep issuance very low; however, it also means that a large portion of the gains will simply be borne by validators as economic surplus.\n\n\nWill exchanges in proof of stake pose a similar centralization risk to pools in proof of work?\n\n\nFrom a centralization perspective, in both \nBitcoin\n and \nEthereum\n it's the case that roughly three pools are needed to coordinate on a 51% attack (4 in Bitcoin, 3 in Ethereum at the time of this writing). In PoS, if we assume 30% participation including all exchanges, then \nthree exchanges\n would be enough to make a 51% attack; if participation goes up to 40% then the required number goes up to eight. However, exchanges will not be able to participate with all of their ether; the reason is that they need to accomodate withdrawals.\n\n\nAdditionally, pooling in PoS is discouraged because it has a much higher trust requirement - a proof of stake pool can pretend to be hacked, destroy its participants' deposits and claim a reward for it. On the other hand, the ability to earn interest on one's coins without oneself running a node, even if trust is required, is something that many may find attractive; all in all, the centralization balance is an empirical question for which the answer is unclear until the system is actually running for a substantial period of time. With sharding, we expect pooling incentives to reduce further, as (i) there is even less concern about variance, and (ii) in a sharded model, transaction verification load is proportional to the amount of capital that one puts in, and so there are no direct infrastructure savings from pooling.\n\n\nA final point is that centralization is less harmful in proof of stake than in proof of work, as there are much cheaper ways to recover from successful 51% attacks; one does not need to switch to a new mining algorithm.\n\n\nCan proof of stake be used in private/consortium chains?\n\n\nGenerally, yes; any proof of stake algorithm can be used as a consensus algorithm in private/consortium chain settings. The only change is that the way the validator set is selected would be different: it would start off as a set of trusted users that everyone agrees on, and then it would be up to the validator set to vote on adding in new validators.", 
            "title": "\u6743\u76ca\u8bc1\u660e"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-is-proof-of-stake", 
            "text": "Proof of Stake (PoS) is a category of consensus algorithms for public blockchains that depend on a validator's economic stake in the network . In proof of work (PoW) based public blockchains (e.g. Bitcoin and the current implementation of Ethereum), the algorithm rewards participants who solve cryptographic puzzles in order to validate transactions and create new blocks (i.e. mining). In PoS-based public blockchains (e.g. Ethereum's upcoming Casper implementation), a set of validators take turns proposing and voting on the next block, and the weight of each validator's vote depends on the size of its deposit (i.e. stake). Significant advantages of PoS include  security, reduced risk of centralization, and energy efficiency .  In general, a proof of stake algorithm looks as follows. The blockchain keeps track of a set of validators, and anyone who holds the blockchain's base cryptocurrency (in Ethereum's case, ether) can become a validator by sending a special type of transaction that  locks up their ether into a deposit . The process of creating and agreeing to new blocks is then done through a consensus algorithm that all current validators can participate in.  There are many kinds of consensus algorithms, and many ways to assign rewards to validators who participate in the consensus algorithm, so there are many \"flavors\" of proof of stake. From an algorithmic perspective, there are two major types: chain-based proof of stake and  BFT -style proof of stake.  In  chain-based proof of stake , the algorithm pseudo-randomly selects a validator during each time slot (eg. every period of 10 seconds might be a time slot), and assigns that validator the right to create a single block, and this block must point to some previous block (normally the block at the end of the previously longest chain), and so over time most blocks converge into a single constantly growing chain.  In  BFT-style proof of stake , validators are  randomly  assigned the right to  propose  blocks, but  agreeing on which block is canonical  is done through a multi-round process where every validator sends a \"vote\" for some specific block during each round, and at the end of the process all (honest and online) validators permanently agree on whether or not any given block is part of the chain. Note that blocks may still be  chained together ; the key difference is that consensus on a block can come within one block, and does not depend on the length or size of the chain after it.", 
            "title": "What is Proof of Stake"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-are-the-benefits-of-proof-of-stake-as-opposed-to-proof-of-work", 
            "text": "See  A Proof of Stake Design Philosophy  for a more long-form argument.  In short:   No need to consume large quantities of electricity  in order to secure a blockchain (eg. it's estimated that both Bitcoin and Ethereum burn over $1 million worth of electricity and hardware costs per day as part of their consensus mechanism).  Because of the lack of high electricity consumption, there is  not as much need to issue as many new coins  in order to motivate participants to keep participating in the network. It may theoretically even be possible to have  negative  net issuance, where a portion of transaction fees is \"burned\" and so the supply goes down over time.  Proof of stake opens the door to a wider array of techniques that use game-theoretic mechanism design in order to better  discourage centralized cartels  from forming and, if they do form, from acting in ways that are harmful to the network (eg. like  selfish mining  in proof of work).  Reduced centralization risks , as economies of scale are much less of an issue. $10 million of coins will get you exactly 10 times higher returns than $1 million of coins, without any additional disproportionate gains because at the higher level you can afford better mass-production equipment.  Ability to use economic penalties to  make various forms of 51% attacks vastly more expensive  to carry out than proof of work - to paraphrase Vlad Zamfir, \"it's as though your ASIC farm burned down if you participated in a 51% attack\".", 
            "title": "What are the benefits of proof of stake as opposed to proof of work?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#how-does-proof-of-stake-fit-into-traditional-byzantine-fault-tolerance-research", 
            "text": "There are several fundamental results from Byzantine fault tolerance research that apply to all consensus algorithms, including traditional consensus algorithms like PBFT but also any proof of stake algorithm and, with the appropriate mathematical modeling, proof of work.  The key results include:   CAP theorem  - \"in the cases that a network partition takes place, you have to choose either consistency or availability, you cannot have both\". The intuitive argument is simple: if the network splits in half, and in one half I send a transaction \"send my 10 coins to A\" and in the other I send a transaction \"send my 10 coins to B\", then either the system is unavailable, as one or both transactions will not be processed, or it becomes inconsistent, as one half of the network will see the first transaction completed and the other half will see the second transaction completed. Note that the CAP theorem has nothing to do with scalability; it applies to sharded and non-sharded systems equally.  FLP impossibility  - in an asynchronous setting (ie. there are no guaranteed bounds on network latency even between correctly functioning nodes), it is not possible to create an algorithm which is guaranteed to reach consensus in any specific finite amount of time if even a single faulty/dishonest node is present. Note that this does NOT rule out  \"Las Vegas\" algorithms  that have some probability each round of achieving consensus and thus will achieve consensus within T seconds with probability exponentially approaching 1 as T grows; this is in fact the \"escape hatch\" that many successful consensus algorithms use.  Bounds on fault tolerance  - from  the DLS paper  we have: (i) protocols running in a partially synchronous network model (ie. there is a bound on network latency but we do not know ahead of time what it is) can tolerate up to 1/3 arbitrary (ie. \"Byzantine\") faults, (ii) deterministic protocols in an asynchronous model (ie. no bounds on network latency) cannot tolerate faults (although their paper fails to mention that  randomized algorithms can  with up to 1/3 fault tolerance), (iii) protocols in a synchronous model (ie. network latency is guaranteed to be less than a known  d ) can, surprisingly, tolerate up to 100% fault tolerance, although there are restrictions on what can happen when more than or equal to 1/2 of nodes are faulty. Note that the \"authenticated Byzantine\" model is the one worth considering, not the \"Byzantine\" one; the \"authenticated\" part essentially means that we can use public key cryptography in our algorithms, which is in modern times very well-researched and very cheap.   Proof of work has been  rigorously analyzed by Andrew Miller and others  and fits into the picture as an algorithm reliant on a synchronous network model. We can model the network as being made up of a near-infinite number of nodes, with each node representing a very small unit of computing power and having a very small probability of being able to create a block in a given period. In this model, the protocol has 50% fault tolerance assuming zero network latency, ~46% (Ethereum) and ~49.5% (Bitcoin) fault tolerance under actually observed conditions, but goes down to 33% if network latency is equal to the block time, and reduces to zero as network latency approaches infinity.  Proof of stake consensus fits more directly into the Byzantine fault tolerant consensus mould, as all validators have known identities (stable Ethereum addresses) and the network keeps track of the total size of the validator set. There are two general lines of proof of stake research, one looking at synchronous network models and one looking at partially asynchronous network models. \"Chain-based\" proof of stake algorithms almost always rely on synchronous network models, and their security can be formally proven within these models similarly to how security of  proof of work algorithms  can be proven. A line of research connecting traditional Byzantine fault tolerant consensus in partially synchronous networks to proof of stake also exists, but is more complex to explain; it will be covered in more detail in later sections.  Proof of work algorithms and chain-based proof of stake algorithms choose availability over consistency, but BFT-style consensus algorithms lean more toward consistency;  Tendermint  chooses consistency explicitly, and Casper uses a hybrid model that prefers availability but provides as much consistency as possible and makes both on-chain applications and clients aware of how strong the consistency guarantee is at any given time.  Note that Ittay Eyal and Emin Gun Sirer's  selfish mining  discovery, which places 25% and 33% bounds on the incentive compatibility of Bitcoin mining depending on the network model (ie. mining is only incentive compatible if collusions larger than 25% or 33% are impossible) has NOTHING to do with results from traditional consensus algorithm research, which does not touch incentive compatibility.", 
            "title": "How does proof of stake fit into traditional Byzantine fault tolerance research?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed", 
            "text": "In many early (all chain-based) proof of stake algorithms, including Peercoin, there are only rewards for producing blocks, and no penalties. This has the unfortunate consequence that, in the case that there are multiple competing chains, it is in a validator's incentive to try to make blocks on top of every chain at once, just to be sure:   In proof of work, doing so would require splitting one's computing power in half, and so would not be lucrative:   The result is that if all actors are narrowly economically rational, then even if there are no attackers, a blockchain may never reach consensus. If there is an attacker, then the attacker need only overpower altruistic nodes (who would exclusively stake on the original chain), and not rational nodes (who would stake on both the original chain and the attacker's chain), in contrast to proof of work, where the attacker must overpower both altruists and rational nodes (or at least credibly threaten to: see  P + epsilon attacks ).  Some argue that stakeholders have an incentive to act correctly and only stake on the longest chain in order to \"preserve the value of their investment\", however this ignores that this incentive suffers from  tragedy of the commons  problems: each individual stakeholder might only have a 1% chance of being \"pivotal\" (ie. being in a situation where if they participate in an attack then it succeeds and if they do not participate it fails), and so the bribe needed to convince them personally to join an attack would be only 1% of the size of their deposit; hence, the required combined bribe would be only 0.5-1% of the total sum of all deposits. Additionally, this argument implies that any zero-chance-of-failure situation is not a stable equilibrium, as if the chance of failure is zero then everyone has a 0% chance of being pivotal.  This can be solved via two strategies. The first, described in broad terms under the name \"Slasher\"  here  and developed further by Iddo Bentov  here , involves penalizing validators if they simultaneously create blocks on multiple chains, by means of including proof of misbehavior (ie. two conflicting signed block headers) into the blockchain as a later point in time at which point the malfeasant validator's deposit is deducted appropriately. This changes the incentive structure thus:   Note that for this algorithm to work, the validator set needs to be determined well ahead of time. Otherwise, if a validator has 1% of the stake, then if there are two branches A and B then 0.99% of the time the validator will be eligible to stake only on A and not on B, 0.99% of the time the validator will be eligible to stake on B and not on A, and only 0.01% of the time will the validator will be eligible to stake on both. Hence, the validator can with 99% efficiency probabilistically double-stake: stake on A if possible, stake on B if possible, and only if the choice between both is open stake on the longer chain. This can only be avoided if the validator selection is the same for every block on both branches, which requires the validators to be selected at a time before the fork takes place.  This has its own flaws, including requiring nodes to be frequently online to get a secure view of the blockchain, and opening up medium-range validator collusion risks (ie. situations where, for example, 25 out of 30 consecutive validators get together and agree ahead of time to implement a 51% attack on the previous 19 blocks), but if these risks are deemed acceptable then it works well.  The second strategy is to simply punish validators for creating blocks on the  wrong  chain. That is, if there are two competing chains, A and B, then if a validator creates a block on B, they get a reward of +R on B, but the block header can be included into A (in Casper this is called a \"dunkle\") and on A the validator suffers a penalty of -F (possibly F = R). This changes the economic calculation thus:   The intuition here is that we can replicate the economics of proof of work inside of proof of stake. In proof of work, there is also a penalty for creating a block on the wrong chain, but this penalty is implicit in the external environment: miners have to spend extra electricity and obtain or rent extra hardware. Here, we simply make the penalties explicit. This mechanism has the disadvantage that it imposes slightly more risk on validators (although the effect should be smoothed out over time), but has the advantage that it does not require validators to be known ahead of time.", 
            "title": "What is the \"nothing at stake\" problem and how can it be fixed?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#that-shows-how-chain-based-algorithms-solve-nothing-at-stake-now-how-do-bft-style-proof-of-stake-algorithms-work", 
            "text": "BFT-style (partially synchronous) proof of stake algorithms allow validators to \"vote\" on blocks by sending one or more types of signed messages, and specify two kinds of rules:   Finality conditions  - rules that determine when a given hash can be considered finalized.  Slashing conditions  - rules that determine when a given validator can be deemed beyond reasonable doubt to have misbehaved (eg. voting for multiple conflicting blocks at the same time). If a validator triggers one of these rules, their entire deposit gets deleted.   To illustrate the different forms that slashing conditions can take, we will give two examples of slashing conditions (hereinafter, \"2/3 of all validators\" is shorthand for \"2/3 of all validators weighted by deposited coins\", and likewise for other fractions and percentages). In these examples, \"PREPARE\" and \"COMMIT\" should be understood as simply referring to two types of messages that validators can send.   If  MESSAGES  contains messages of the form  [\"COMMIT\", HASH1, view]  and  [\"COMMIT\", HASH2, view]  for the same  view  but differing  HASH1  and  HASH2  signed by the same validator, then that validator is slashed.  If  MESSAGES  contains a message of the form  [\"COMMIT\", HASH, view1] , then UNLESS either view1 = -1 or there also exist messages of the form  [\"PREPARE\", HASH, view1, view2]  for some specific  view2 , where  view2   view1 , signed by 2/3 of all validators, then the validator that made the COMMIT is slashed.   There are two important desiderata for a suitable set of slashing conditions to have:   Accountable safety  - if conflicting  HASH1  and  HASH2  (ie.  HASH1  and  HASH2  are different, and neither is a descendant of the other) are finalized, then at least 1/3 of all validators must have violated some slashing condition.  Plausible liveness  - unless at least 1/3 of all validators have violated some slashing condition, there exists a set of messages that 2/3 of validators can produce that finalize some value.   If we have a set of slashing conditions that satisfies both properties, then we can incentivize participants to send messages, and start benefiting from economic finality.", 
            "title": "That shows how chain-based algorithms solve nothing-at-stake. Now how do BFT-style proof of stake algorithms work?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-is-economic-finality-in-general", 
            "text": "Economic finality is the idea that once a block is finalized, or more generally once enough messages of certain types have been signed, then the only way that at any point in the future the canonical history will contain a conflicting block is if a large number of people are willing to burn very large amounts of money. If a node sees that this condition has been met for a given block, then they have a very economically strong assurance that that block will always be part of the canonical history that everyone agrees on.  There are two \"flavors\" of economic finality:   A block can be economically finalized if a sufficient number of validators have signed cryptoeconomic claims of the form \"I agree to lose X in all histories where block B is not included\". This gives clients assurance that either (i) B is part of the canonical chain, or (ii) validators lost a large amount of money in order to trick them into thinking that this is the case.  A block can be economically finalized if a sufficient number of validators have signed messages expressing support for block B, and there is a mathematical proof that  if some B' != B is also finalized under the same definition  then validators lose a large amount of money. If clients see this, and also validate the chain, and validity plus finality is a sufficient condition for precedence in the canonical fork choice rule, then they get an assurance that either (i) B is part of the canonical chain, or (ii) validators lost a large amount of money in making a conflicting chain that was also finalized.   The two approaches to finality inherit from the two solutions to the nothing at stake problem: finality by penalizing incorrectness, and finality by penalizing equivocation. The main benefit of the first approach is that it is more light-client friendly and is simpler to reason about, and the main benefits of the second approach are that (i) it's easier to see that honest validators will not be punished, and (ii) griefing factors are more favorable to honest validators.  Casper follows the second flavor, though it is possible that an on-chain mechanism will be added where validators can voluntarily opt-in to signing finality messages of the first flavor, thereby enabling much more efficient light clients.", 
            "title": "What is \"economic finality\" in general?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#so-how-does-this-relate-to-byzantine-fault-tolerance-theory", 
            "text": "Traditional byzantine fault tolerance theory posits similar safety and liveness desiderata, except with some differences. First of all, traditional byzantine fault tolerance theory simply requires that safety is achieved if 2/3 of validators are  honest . This is a strictly easier model to work in; traditional fault tolerance tries to prove \"if mechanism M has a safety failure, then at least 1/3 of nodes are faulty\", whereas our model tries to prove \"if mechanism M has a safety failure, then at least 1/3 of nodes are faulty,  and you know which ones, even if you were offline at the time the failure took place \". From a liveness perspective, our model is the easier one, as we do not demand a proof that the network  will  come to consensus, we just demand a proof that it does not get  stuck .  Fortunately, we can show the additional accountability requirement is not a particularly difficult one; in fact, with the right \"protocol armor\", we can convert  any  traditional partially synchronous or asynchronous Byzantine fault-tolerant algorithm into an accountable algorithm. The proof of this basically boils down to the fact that faults can be exhaustively categorized into a few classes, and each one of these classes is either accountable (ie. if you commit that type of fault you can get caught, so we can make a slashing condition for it) or indistinguishable from latency (note that even the fault of sending messages too early is indistinguishable from latency, as one can model it by speeding up everyone's clocks and assigning the messages that  weren't  sent too early a higher latency).", 
            "title": "So how does this relate to Byzantine fault tolerance theory?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-is-weak-subjectivity", 
            "text": "It is important to note that the mechanism of using deposits to ensure there is \"something at stake\" does lead to one change in the security model. Suppose that deposits are locked for four months, and can later be withdrawn. Suppose that an attempted 51% attack happens that reverts 10 days worth of transactions. The blocks created by the attackers can simply be imported into the main chain as proof-of-malfeasance (or \"dunkles\") and the validators can be punished. However, suppose that such an attack happens after six months. Then, even though the blocks can certainly be re-imported, by that time the malfeasant validators will be able to withdraw their deposits on the main chain, and so they cannot be punished.  To solve this problem, we introduce a \"revert limit\" - a rule that nodes must simply refuse to revert further back in time than the deposit length (ie. in our example, four months). Note that this rule is different from every other consensus rule in the protocol, in that it means that nodes may come to different conclusions depending on when they saw certain messages. The time that a node saw a given message may be different between different nodes; hence we consider this rule \"subjective\" (alternatively, one well-versed in Byzantine fault tolerance theory may view it as a kind of synchrony assumption).  However, the \"subjectivity\" here is very weak: in order for a node to get on the \"wrong\" chain, they must receive the original message four months later than they otherwise would have. This is only possible in two cases:   When a node connects to the blockchain for the first time.  If a node has been offline for more than four months.   We can solve (1) by making it the user's responsibility to authenticate the latest state out of band. They can do this by asking their friends, block explorers, businesses that they interact with, etc. for a recent block hash in the chain that they see as the canonical one. In practice, such a block hash may well simply come as part of the software they use to verify the blockchain; an attacker that can corrupt the checkpoint in the software can arguably just as easily corrupt the software itself, and no amount of pure cryptoeconomic verification can solve that problem.  Note that all of this is a problem only in the very limited case where a majority of previous stakeholders collude to attack the network and create an alternate chain; most of the time we expect there will only be one canonical chain to choose from.  Also, note that weak subjectivity assumptions exist in proof of work chains as well if the chain does any hard forks. Bitcoin has previously pulled off a hard fork with 2 months lead time through  bitcoind 0.8.1 , which fixed a database issue that made certain kinds of large blocks invalid and thereby allowed clients to process blocks that bitcoind 0.7 could not process, and so users had to download a new version of the software with 2 months' notice. This is itself a kind of weak subjectivity assumption, as users had to \"log on\" within that two-month period to download the update to stay on the correct chain.  Additionally, the social authentication can if needed even be automated in several ways. One is to bake it into natural user workflow: a  BIP 70 -style payment request could include a recent block hash, and the user's client software would make sure that they are on the same chain as the vendor before approving a payment (or for that matter, any on-chain interaction). The other is to use Jeff Coleman's  universal hash time . If UHT is used, then a successful attack chain would need to be generated secretly  at the same time  as the legitimate chain was being built, requiring a majority of validators to secretly collude for that long.", 
            "title": "What is \"weak subjectivity\"?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#does-weak-subjectivity-mean-that-a-proof-of-stake-chain-must-be-anchored-into-a-proof-of-work-chain-to-be-secure", 
            "text": "In short, no.", 
            "title": "Does weak subjectivity mean that a proof of stake chain must be \"anchored\" into a proof of work chain to be secure?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#elaborate", 
            "text": "Weak subjectivity by itself is a rather small addition to the security assumptions in a blockchain in practice, and definitely does not necessitate some proof-of-work-based outside source of truth to supplement it. To see why, consider the kind of situation where weak subjectivity by itself would compromise a blockchain's security. In such a world, powerful corporate or nation state actors would have the ability to somehow convince an entire community that block hash B was the block hash of block XXXYYY when most of them saw at the time and have stored in their own computers that the block hash of block XXXYYY was A, but for some reason such powerful actors  would not  have the ability to trick users into accepting a different location from where they download their client software.  Furthermore, the \"anchoring\" that advocates of such a scheme describe is not even all that secure. All anchoring proves is that a given block hash was  produced  at time T'   T; it does not prove that it was  published  at that time. Hence, a PoS chain anchored into a PoW chain could simply be attacked by a majority coalition that produces both chains in parallel, anchors both, publishes one, and then four months later publishes the other one.  One could get around this by embedding a fully-functional \"light client\" of the PoS chain into the PoW chain, which would reject the double-anchoring, but this would require the PoW chain to be feature-rich enough  to be able  to implement such a client - a property which most actually existing proof of work chains do not possess.", 
            "title": "Elaborate?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#can-one-economically-penalize-censorship-in-proof-of-stake", 
            "text": "Unlike reverts, censorship is much more difficult to prove. The blockchain itself cannot directly tell the difference between \"user A tried to send transaction X but it was unfairly censored\", \"user A tried to send transaction X but it never got in because the transaction fee was insufficient\" and \"user A never tried to send transaction X at all\". However, there are a number of techniques that can be used to mitigate censorship issues.  The first is censorship resistance by halting problem. In the weaker version of this scheme, the protocol is designed to be Turing-complete in such a way that a validator cannot even tell whether or not a given transaction will lead to an undesired action without spending a large amount of processing power executing the transaction, and thus opening itself up to denial-of-service attacks. This is what  prevented the DAO soft fork .  In the stronger version of the scheme, transactions can trigger guaranteed effects at some point in the near to mid-term future. Hence, a user could send multiple transactions which interact with each other and with predicted third-party information to lead to some future event, but the validators cannot possibly tell that this is going to happen until the transactions are already included (and economically finalized) and it is far too late to stop them; even if all future transactions are excluded, the event that validators wish to halt would still take place. Note that in this scheme, validators could still try to prevent  all  transactions, or perhaps all transactions that do not come packaged with some formal proof that they do not lead to anything undesired, but this would entail forbidding a very wide class of transactions to the point of essentially breaking the entire system, which would cause validators to lose value as the price of the cryptocurrency in which their deposits are denominated would drop.  The second,  described by Adam Back here , is to require transactions to be  timelock-encrypted . Hence, validators will include the transactions without knowing the contents, and only later could the contents automatically be revealed, by which point once again it would be far too late to un-include the transactions. If validators were sufficiently malicious, however, they could simply only agree to include transactions that come with a cryptographic proof (eg. ZK-SNARK) of what the decrypted version is; this would force users to download new client software, but an adversary could conveniently provide such client software for easy download, and in a game-theoretic model users would have the incentive to play along.  Perhaps the best that can be said in a proof-of-stake context is that users could also install a software update that includes a hard fork that deletes the malicious validators and this is not that much harder than installing a software update to make their transactions \"censorship-friendly\". Hence, all in all this scheme is also moderately effective, though it does come at the cost of slowing interaction with the blockchain down (note that the scheme must be mandatory to be effective; otherwise malicious validators could much more easily simply filter encrypted transactions without filtering the quicker unencrypted transactions).  A third alternative is to include censorship detection in the fork choice rule. The idea is simple. Nodes watch the network for transactions, and if they see a transaction that has a sufficiently high fee for a sufficient amount of time, then they assign a lower \"score\" to blockchains that do not include this transaction. If all nodes follow this strategy, then eventually a minority chain would automatically coalesce that includes the transactions, and all honest online nodes would follow it. The main weakness of such a scheme is that offline nodes would still follow the majority branch, and if the censorship is temporary and they log back on after the censorship ends then they would end up on a different branch from online nodes. Hence, this scheme should be viewed more as a tool to facilitate automated emergency coordination on a hard fork than something that would play an active role in day-to-day fork choice.", 
            "title": "Can one economically penalize censorship in proof of stake?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#how-does-validator-selection-work-and-what-is-stake-grinding", 
            "text": "In any chain-based proof of stake algorithm, there is a need for some mechanism which randomly selects which validator out of the currently active validator set can make the next block. For example, if the currently active validator set consists of Alice with 40 ether, Bob with 30 ether, Charlie with 20 ether and David with 10 ether, then you want there to be a 40% chance that Alice will be the next block creator, 30% chance that Bob will be, etc (in practice, you want to randomly select not just one validator, but rather an infinite sequence of validators, so that if Alice doesn't show up there is someone who can replace her after some time, but this doesn't change the fundamental problem). In non-chain-based algorithms randomness is also often needed for different reasons.  \"Stake grinding\" is a class of attack where a validator performs some computation or takes some other step to try to bias the randomness in their own favor. For example:   In  Peercoin , a validator could \"grind\" through many combinations of parameters and find favorable parameters that would increase the probability of their coins generating a valid block.  In one now-defunct implementation, the randomness for block N+1 was dependent on the signature of block N. This allowed a validator to repeatedly produce new signatures until they found one that allowed them to get the next block, thereby seizing control of the system forever.  In NXT, the randomness for block N+1 is dependent on the validator that creates block N. This allows a validator to manipulate the randomness by simply skipping an opportunity to create a block. This carries an opportunity cost equal to the block reward, but sometimes the new random seed would give the validator an above-average number of blocks over the next few dozen blocks. See  here  for a more detailed analysis.   (1) and (2) are easy to solve; the general approach is to require validators to deposit their coins well in advance, and not to use information that can be easily manipulated as source data for the randomness. There are several main strategies for solving problems like (3). The first is to use schemes based on  secret sharing  or  deterministic threshold signatures  and have validators collaboratively generate the random value. These schemes are robust against all manipulation unless a majority of validators collude (in some cases though, depending on the implementation, between 33-50% of validators can interfere in the operation, leading to the protocol having a 67% liveness assumption).  The second is to use cryptoeconomic schemes where validators commit to information (ie. publish  sha3(x) ) well in advance, and then must publish  x  in the block;  x  is then added into the randomness pool. There are two theoretical attack vectors against this:   Manipulate  x  at commitment time. This is impractical because the randomness result would take many actors' values into account, and if even one of them is honest then the output will be a uniform distribution. A uniform distribution XORed together with arbitrarily many arbitrarily biased distributions still gives a uniform distribution.  Selectively avoid publishing blocks. However, this attack costs one block reward of opportunity cost, and because the scheme prevents anyone from seeing any future validators except for the next, it almost never provides more than one block reward worth of revenue. The only exception is the case where, if a validator skips, the next validator in line AND the first child of that validator will both be the same validator; if these situations are a grave concern then we can punish skipping further via an explicit skipping penalty.   The third is to use  Iddo Bentov's \"majority beacon\" , which generates a random number by taking the bit-majority of the previous N random numbers generated through some other beacon (ie. the first bit of the result is 1 if the majority of the first bits in the source numbers is 1 and otherwise it's 0, the second bit of the result is 1 if the majority of the second bits in the source numbers is 1 and otherwise it's 0, etc). This gives a cost-of-exploitation of  ~C * sqrt(N)  where  C  is the cost of exploitation of the underlying beacons. Hence, all in all, many known solutions to stake grinding exist; the problem is more like  differential cryptanalysis  than  the halting problem  - an annoyance that proof of stake designers eventually understood and now know how to overcome, not a fundamental and inescapable flaw.", 
            "title": "How does validator selection work, and what is stake grinding?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-would-the-equivalent-of-a-51-attack-against-casper-look-like", 
            "text": "The most basic form of \"51% attack\" is a simple  finality reversion : validators that already finalized block A then finalize some competing block A', thereby breaking the blockchain's finality guarantee. In this case, there now exist two incompatible finalized histories, creating a split of the blockchain, that full nodes would be willing to accept, and so it is up to the community to coordinate out of band to focus on one of the branches and ignore the other(s).  This coordination could take place on social media, through private channels between block explorer providers, businesses and exchanges, various online discussion forms, and the like. The principle according to which the decision would be made is \"whichever one was finalized  first  is the real one\". Another alternative is to rely on \"market consensus\": both branches would be briefly being traded on exchanges for a very short period of time, until network effects rapidly make one branch much more valuable with the others. In this case, the \"first finalized chain wins\" principle would be a Schelling point for what the market would choose. It's very possible that a combination of both approaches will get used in practice.  Once there is consensus on which chain is real, users (ie. validators and light and full node operators) would be able to manually insert the winning block hash into their client software through a special option in the interface, and their nodes would then ignore all other chains. No matter which chain wins, there exists evidence that can immediately be used to destroy at least 1/3 of the validators' deposits.  Another kind of attack is  liveness denial : instead of trying to revert blocks, a cartel of  =34% of validators could simply refuse to finalize any more blocks. In this case, blocks would never finalize. Casper uses a hybrid chain/BFT-style consensus, and so the blockchain would still grow, but it would have a much lower level of security. If no blocks are finalized for some long period of time (eg. 1 day), then there are several options:   The protocol can include an automatic feature to rotate the validator set. Blocks under the new validator set would finalize, but clients would get an indication that the new finalized blocks are in some sense suspect, as it's very possible that the old validator set will resume operating and finalize some other blocks. Clients could then manually override this warning once it's clear that the old validator set is not coming back online. There would be a protocol rule that under such an event all old validators that did not try to participate in the consensus process take a large penalty to their deposits.  A hard fork is used to add in new validators and delete the attackers' balances.   In case (2), the fork would once again be coordinated via social consensus and possibly via market consensus (ie. the branch with the old and new validator set briefly both being traded on exchanges). In the latter case, there is a strong argument that the market would want to choose the branch where \"the good guys win\", as such a chain has validators that have demonstrated their goodwill (or at least, their alignment with the interest of the users) and so is a more useful chain for application developers.  Note that there is a spectrum of response strategies here between social coordination and in-protocol automation, and it is generally considered desirable to push as far toward automated resolution as possible so as to minimize the risk of simultaneous 51% attacks and attacks on the social layer (and market consensus tools such as exchanges). One can imagine an implementation of (1) where nodes automatically accept a switch to a new validator set if they do not see a new block being committed for a long enough time, which would reduce the need for social coordination but at the cost of requiring those nodes that do not wish to rely on social coordination to remain constantly online. In either case, a solution can be designed where attackers take a large hit to their deposits.  A more insidious kind of attack is a  censorship attack , where  = 34% of validators refuse to finalize blocks that contain certain kinds of transactions that they do not like, but otherwise the blockchain keeps going and blocks keep getting finalized. This could range from a mild censorship attack which only censors to interfere with a few specific applications (eg. selectively censoring transactions in something like Raiden or the lightning network is a fairly easy way for a cartel to steal money) to an attack that blocks all transactions.  There are two sub-cases. The first is where the attacker has 34-67% of the stake. Here, we can program validators to refuse to finalize or build on blocks that they subjectively believe are clearly censoring transactions, which turns this kind of attack into a more standard liveness attack. The more dangerous case is where the attacker has more than 67% of the stake. Here, the attacker can freely block any transactions they wish to block and refuse to build on any blocks that do contain such transactions.  There are two lines of defense. First, because Ethereum is Turing-complete it is  naturally somewhat resistant to censorship  as censoring transactions that have a certain effect is in some ways similar to solving the halting problem. Because there is a gas limit, it is not literally impossible, though the \"easy\" ways to do it do open up denial-of-service attack vulnerabilities.  This resistance  is not perfect , and there are ways to improve it. The most interesting approach is to add in-protocol features where transactions can automatically schedule future events, as it would be extremely difficult to try to foresee what the result of executing scheduled events and the events resulting from those scheduled events would be ahead of time. Validators could then use obfuscated sequences of scheduled events to deposit their ether, and dilute the attacker to below 33%.  Second, one can introduce the notion of an \"active fork choice rule\", where part of the process for determining whether or not a given chain is valid is trying to interact with it and verifying that it is not trying to censor you. The most effective way to do this would be for nodes to repeatedly send a transaction to schedule depositing their ether and then cancel the deposit at the last moment. If nodes detect censorship, they could then follow through with the deposit, and so temporarily join the validator pool en masse, diluting the attacker to below 33%. If the validator cartel censors their attempts to deposit, then nodes running this \"active fork choice rule\" would not recognize the chain as valid; this would collapse the censorship attack into a liveness denial attack, at which point it can be resolved through the same means as other liveness denial attacks.", 
            "title": "What would the equivalent of a 51% attack against Casper look like?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#that-sounds-like-a-lot-of-reliance-on-out-of-band-social-coordination-is-that-not-dangerous", 
            "text": "Attacks against Casper are extremely expensive; as we will see below, attacks against Casper cost as much, if not more, than the cost of buying enough mining power in a proof of work chain to permanently 51% attack it over and over again to the point of uselessness. Hence, the recovery techniques described above will only be used in very extreme circumstances; in fact, advocates of proof of work also generally express willingness to use social coordination in similar circumstances by, for example,  changing the proof of work algorithm . Hence, it is not even clear that the need for social coordination in proof of stake is larger than it is in proof of work.  In reality, we expect the amount of social coordination required to be near-zero, as attackers will realize that it is not in their benefit to burn such large amounts of money to simply take a blockchain offline for one or two days.", 
            "title": "That sounds like a lot of reliance on out-of-band social coordination; is that not dangerous?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#doesnt-mc-mr-mean-that-all-consensus-algorithms-with-a-given-security-level-are-equally-efficient-or-in-other-words-equally-wasteful", 
            "text": "This is an argument that many have raised, perhaps best explained by  Paul Sztorc in this article . Essentially, if you create a way for people to earn $100, then people will be willing to spend anywhere up to $99.9 (including the cost of their own labor) in order to get it; marginal cost approaches marginal revenue. Hence, the theory goes, any algorithm with a given block reward will be equally \"wasteful\" in terms of the quantity of socially unproductive activity that is carried out in order to try to get the reward.  There are three flaws with this:   It's not enough to simply say that marginal cost approaches marginal revenue; one must also posit a plausible mechanism by which someone can actually expend that cost. For example, if tomorrow I announce that every day from then on I will give $100 to a randomly selected one of a given list of ten people (using my laptop's /dev/urandom as randomness), then there is simply no way for anyone to send $99 to try to get at that randomness. Either they are not in the list of ten, in which case they have no chance no matter what they do, or they are in the list of ten, in which case they don't have any reasonable way to manipulate my randomness so they're stuck with getting the expected-value $10 per day.  MC =  MR does NOT imply total cost approaches total revenue. For example, suppose that there is an algorithm which pseudorandomly selects 1000 validators out of some very large set (each validator getting a reward of $1), you have 10% of the stake so on average you get 100, and at a cost of $1 you can force the randomness to reset (and you can repeat this an unlimited number of times). Due to the  central limit theorem , the standard deviation of your reward is $10, and based on  other known results in math  the expected maximum of N random samples is slightly under  M + S * sqrt(2 * log(N))  where  M  is the mean and  S  is the standard deviation. Hence the reward for making additional trials (ie. increasing N) drops off sharply, eg. with 0 re-trials your expected reward is $100, with one re-trial it's $105.5, with two it's $108.5, with three it's $110.3, with four it's $111.6, with five it's $112.6 and with six it's $113.5. Hence, after five retrials it stops being worth it. As a result, an economically motivated attacker with ten percent of stake will inefficiently spend $5 to get an additional revenue of $13, though the total revenue is $113. If the exploitable mechanisms only expose small opportunities, the economic loss will be small; it is decidedly NOT the case that a single drop of exploitability brings the entire flood of PoW-level economic waste rushing back in. This point will also be very relevant in our below discussion on capital lockup costs.  Proof of stake can be secured with much lower total rewards than proof of work.", 
            "title": "Doesn't MC =&gt; MR mean that all consensus algorithms with a given security level are equally efficient (or in other words, equally wasteful)?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#what-about-capital-lockup-costs", 
            "text": "Locking up X ether in a deposit is not free; it entails a sacrifice of optionality for the ether holder. Right now, if I have 1000 ether, I can do whatever I want with it; if I lock it up in a deposit, then it's stuck there for months, and I do not have, for example, the insurance utility of the money being there to pay for sudden unexpected expenses. I also lose some freedom to change my token allocations away from ether within that timeframe; I could simulate selling ether by shorting an amount equivalent to the deposit on an exchange, but this itself carries costs including exchange fees and paying interest. Some might argue: isn't this capital lockup inefficiency really just a highly indirect way of achieving the exact same level of economic inefficiency as exists in proof of work? The answer is no, for both reasons (2) and (3) above.  Let us start with (3) first. Consider a model where proof of stake deposits are infinite-term, ASICs last forever, ASIC technology is fixed (ie. no Moore's law) and electricity costs are zero. Let's say the equilibrium interest rate is 5% per annum. In a proof of work blockchain, I can take $1000, convert it into a miner, and the miner will pay me $50 in rewards per year forever. In a proof of stake blockchain, I would buy $1000 of coins, deposit them (ie. losing them forever), and get $50 in rewards per year forever. So far, the situation looks completely symmetrical (technically, even here, in the proof of stake case my destruction of coins isn't fully socially destructive as it makes others' coins worth more, but we can leave that aside for the moment). The cost of a \"Maginot-line\" 51% attack (ie. buying up more hardware than the rest of the network) increases by $1000 in both cases.  Now, let's perform the following changes to our model in turn:   Moore's law exists, ASICs depreciate by 50% every 2.772 years (that's a continuously-compounded 25% per annum; picked to make the numbers simpler). If I want to retain the same \"pay once, get money forever\" behavior, I can do so: I would put $1000 into a fund, where $167 would go into an ASIC and the remaining $833 would go into investments at 5% interest; the $41.67 dividends per year would be just enough to keep renewing the ASIC hardware (assuming technological development is fully continuous, once again to make the math simpler). Rewards would go down to $8.33 per year; hence, 83.3% of miners will drop out until the system comes back into equilibrium with me earning $50 per year, and so the Maginot-line cost of an attack on PoW given the same rewards drops by a factor of 6.  Electricity plus maintenance makes up 1/3 of mining costs. We estimate the 1/3 from recent mining statistics: one of Bitfury's new data centers consumes  0.06 joules per gigahash , or 60 J/TH or 0.000017 kWh/TH, and if we assume the entire Bitcoin network has similar efficiencies we get 27.9 kWh per second given  1.67 million TH/s total Bitcoin hashpower . Electricity in China costs  $0.11 per kWh , so that's about $3 per second, or $260,000 per day. Bitcoin block rewards plus fees are $600 per BTC * 13 BTC per block * 144 blocks per day = $1.12m per day. Thus electricity itself would make up 23% of costs, and we can back-of-the-envelope estimate maintenance at 10% to give a clean 1/3 ongoing costs, 2/3 fixed costs split. This means that out of your $1000 fund, only $111 would go into the ASIC, $55 would go into paying ongoing costs, and $833 would go into hardware investments; hence the Maginot-line cost of attack is 9x lower than in our original setting.  Deposits are temporary, not permanent. Sure, if I voluntarily keep staking forever, then this changes nothing. However, I regain some of the optionality that I had before; I could quit within a medium timeframe (say, 4 months) at any time. This means that I would be willing to put more than $1000 of ether in for the $50 per year gain; perhaps in equilibrium it would be something like $3000. Hence, the cost of the Maginot line attack on PoS  increases  by a factor of three, and so on net PoS gives 27x more security than PoW for the same cost.   The above included a large amount of simplified modeling, however it serves to show how multiple factors stack up heavily in favor of PoS in such a way that PoS gets  more  bang for its buck in terms of security. The meta-argument for why this  perhaps suspiciously multifactorial argument  leans so heavily in favor of PoS is simple: in PoW, we are working directly with the laws of physics. In PoS, we are able to design the protocol in such a way that it has the precise properties that we want - in short, we can  optimize the laws of physics in our favor . The \"hidden trapdoor\" that gives us (3) is the change in the security model, specifically the introduction of weak subjectivity.  Now, we can talk about the marginal/total distinction. In the case of capital lockup costs, this is very important. For example, consider a case where you have $100,000 of ether. You probably intend to hold a large portion of it for a long time; hence, locking up even $50,000 of the ether should be nearly free. Locking up $80,000 would be slightly more inconvenient, but $20,000 of breathing room still gives you a large space to maneuver. Locking up $90,000 is more problematic, $99,000 is very problematic, and locking up all $100,000 is absurd, as it means you would not even have a single bit of ether left to pay basic transaction fees. Hence, your marginal costs increase quickly. We can show the difference between this state of affairs and the state of affairs in proof of work as follows:   Hence, the  total  cost of proof of stake is potentially much lower than the marginal cost of depositing 1 more ETH into the system multiplied by the amount of ether currently deposited.  Note that this component of the argument unfortunately does not fully translate into reduction of the \"safe level of issuance\". It does help us because it shows that we can get substantial proof of stake participation even if we keep issuance very low; however, it also means that a large portion of the gains will simply be borne by validators as economic surplus.", 
            "title": "What about capital lockup costs?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#will-exchanges-in-proof-of-stake-pose-a-similar-centralization-risk-to-pools-in-proof-of-work", 
            "text": "From a centralization perspective, in both  Bitcoin  and  Ethereum  it's the case that roughly three pools are needed to coordinate on a 51% attack (4 in Bitcoin, 3 in Ethereum at the time of this writing). In PoS, if we assume 30% participation including all exchanges, then  three exchanges  would be enough to make a 51% attack; if participation goes up to 40% then the required number goes up to eight. However, exchanges will not be able to participate with all of their ether; the reason is that they need to accomodate withdrawals.  Additionally, pooling in PoS is discouraged because it has a much higher trust requirement - a proof of stake pool can pretend to be hacked, destroy its participants' deposits and claim a reward for it. On the other hand, the ability to earn interest on one's coins without oneself running a node, even if trust is required, is something that many may find attractive; all in all, the centralization balance is an empirical question for which the answer is unclear until the system is actually running for a substantial period of time. With sharding, we expect pooling incentives to reduce further, as (i) there is even less concern about variance, and (ii) in a sharded model, transaction verification load is proportional to the amount of capital that one puts in, and so there are no direct infrastructure savings from pooling.  A final point is that centralization is less harmful in proof of stake than in proof of work, as there are much cheaper ways to recover from successful 51% attacks; one does not need to switch to a new mining algorithm.", 
            "title": "Will exchanges in proof of stake pose a similar centralization risk to pools in proof of work?"
        }, 
        {
            "location": "/Research/Proof-of-Stake-FAQ/#can-proof-of-stake-be-used-in-privateconsortium-chains", 
            "text": "Generally, yes; any proof of stake algorithm can be used as a consensus algorithm in private/consortium chain settings. The only change is that the way the validator set is selected would be different: it would start off as a set of trusted users that everyone agrees on, and then it would be up to the validator set to vote on adding in new validators.", 
            "title": "Can proof of stake be used in private/consortium chains?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/", 
            "text": "\u5206\u7247\u533a\u5757\u94fe\n\n\n\u4ecb\u7ecd\n\n\nCurrently, in all blockchain protocols each node stores all states (account balances, contract code and storage, etc.) and processes all transactions. This provides a large amount of security, but greatly limits scalability: a blockchain cannot process more transactions than a single node can. In large part because of this, Bitcoin is limited to \\~3-7 transactions per second, Ethereum to 7-15, etc. However, this poses a question: are there ways to create a new mechanism, where only small subset of nodes verifies each transaction? As long as there are sufficiently many nodes verifying each transaction that the system is still highly secure, but sufficiently few that the system can process many transactions in parallel, could we not use such a technique to greatly increase a blockchain's throughput?\n\n\nWhat are some trivial but flawed ways of solving the problem?\n\n\nThere are three main categories of \u201ceasy solutions\u201d. The first is to simply give up on scaling individual blockchains, and instead assume that users will be using many different \u201caltcoins\u201d. This greatly increases throughput, but comes at a cost of security: an N-factor increase in throughput using this method necessarily comes with an N-factor decrease in security. Hence, it is arguably non-viable for more than small values of N.\n\n\nThe second is to simply increase the block size limit. This can work and in some situations may well be the correct prescription, as block sizes may well be constrained more by politics than by realistic technical considerations. But regardless of one\u2019s beliefs about any individual case such an approach inevitably has its limits: if one goes too far, then nodes running on consumer hardware will drop out, the network will start to rely exclusively on a very small number of supercomputers running the blockchain, which can lead to great centralization risk.\n\n\nThe third is \u201cmerge mining\u201d, a technique where there are many chains, but all chains share the same mining power (or, in proof of stake systems, stake).\u00a0Currently, Namecoin gets a large portion of its security from the Bitcoin blockchain by doing this. If all miners participate, this theoretically can increase throughput by a factor of N without compromising security. However, this also has the problem that it increases the computational and storage load on each miner by a factor of N, and so in fact this solution is simply a stealthy form of block size increase.\n\n\nEven if this is deemed acceptable, there is still the defect that the chains are not truly \"tied together\"; only a small amount of economic incentive is required to convince the miners to abandon or compromise one specific chain. This possibility is in fact quite real, and there have been \nactual historical incidents\n of merge-mined chains being attacked, as well as developers who have explicitly advocated using merge mining attacks as \na \"governance\" feature\n, destroying chains that are not \"profitable\" to a given coalition.\n\n\nIf only a few miners/mining pools participate in merge-mining each chain, then there is an imminent \nrisk of centralization\n, while the security benefits of merge mining are also greatly reduced.\n\n\nThis sounds like there\u2019s some kind of scalability trilemma at play. What is this trilemma and can we break through it?\n\n\nThe trilemma claims that blockchain systems can only at most have two of the following three properties:\n\n\n\n\nDecentralization\n\u00a0(defined as the system being able to run in a scenario where each participant only has access to O(c) resources, ie. a regular laptop or small VPS)\n\n\nScalability\n\u00a0(defined as being able to process O(n) > O(c) transactions)\n\n\nSecurity\n\u00a0(defined as being secure against attackers with up to O(n) resources)\n\n\n\n\nIn the rest of this document, we\u2019ll continue using \nc\n\u00a0to refer to the size of computational resources (including computation, bandwidth and storage) available to each node, and \nn\n\u00a0to refer to the size of the ecosystem in some abstract sense; we assume that transaction load, state size, and the market cap of a cryptocurrency are all proportional to \nn\n.\n\n\nSome people claim that because of Metcalfe\u2019s law, the market cap of a cryptocurrency should be proportional to n\\^2, and not n. Do they have a point?\n\n\nNo.\n\n\nWhy not?\n\n\nMetcalfe\u2019s law claims that the value of a network is proportional to the square of the number of users (n^2), because if a network has n users then the network has value for each user, but then the value for each individual user is itself proportional to the number of users because if a network has n users that\u2019s n-1 potential connections through the network that each individual user could benefit from.\n\n\nIn practice, \nempirical research suggests\n\u00a0that the value of a network with n users is close to \u201cn^2\u00a0proportionality for small values of n and (n \u00d7 log n) proportionality for large values of n.\u201d This makes sense because for small values, the argument holds true, but once a system gets bigger, two effects slow the growth down. First, growth in practice often happens in communities, and so in a medium-scale network the network often already provides most of the connections that each user cares about. Second, connections are often substitutes from each other, and you could argue that people only derive \\~O(log(k)) value from having k connections \u2013 having 23 brands of deodorant to choose from is nice, but it\u2019s not that much better than having 22 choices, whereas the difference between one choice and zero choices is very significant.\n\n\nFurthermore, even if the value of a cryptocurrency is proportional to O(k * log(k)) with k users, if we accept the above explanation as the reason why this is the case, then that also implies that transaction volume is also O(k * log(k)), as the log(k) value per user theoretically comes from that user exercising log(k) connections through the network, and state size should also in many cases grow with O(k * log(k)) as there are at least some kinds of state that are relationship-specific rather than user-specific. Hence, assuming n = O(k * log(k)) and basing everything off of \nn\n\u00a0(size of the ecosystem) and \nc\n\u00a0(a single node\u2019s computing power) is a perfectly fine model for us to use.\n\n\nWhat are some moderately simple but only partial ways of solving the scalability problem?\n\n\nMany sharding proposals (eg. \nthis early BFT sharding proposal from Loi Luu et al at NUS\n, as well as \nthis Merklix tree\n1\n approach that has been suggested for Bitcoin) attempt to either only shard transaction processing or only shard state, without touching the other\n2\n. These efforts are admirable and may lead to some gains in efficiency, but they run into the fundamental problem that they only solve one of the two bottlenecks. We want to be able to process 10,000+ transactions per second without either forcing every node to be a supercomputer or\u00a0forcing every node to store a terabyte of state data, and this requires a comprehensive solution where the workloads of state storage, transaction processing and even transaction downloading and re-broadcasting are all spread out across nodes.\n\n\nParticularly, note that this requires changes at the P2P level, as a broadcast model is not scalable since it requires every node to download and re-broadcast O(n) data (every transaction that is being sent), whereas our decentralization criterion assumes that every node only has access to O(c) resources of all kinds.\n\n\nWhat about approaches that do not try to \u201cshard\u201d anything?\n\n\nBitcoin-NG\n\u00a0can increase scalability somewhat by means of an alternative blockchain design that makes it much safer for the network if nodes are spending large portions of their CPU time verifying blocks. In simple PoW blockchains, there are high centralization risks and the safety of consensus is weakened if capacity is increased to the point where more than about 5% of nodes\u2019 CPU time is spent verifying blocks; Bitcoin-NG\u2019s design alleviates this problem. However, this can only increase the scalability of transaction capacity by a constant factor of perhaps 5-50x\n3\n,\n4\n, and does not increase the scalability of state. That said, Bitcoin-NG-style approaches are not mutually exclusive with sharding, and the two can certainly be implemented at the same time.\n\n\nChannel-based strategies (lightning network, Raiden, etc) can scale transaction capacity by a constant factor but cannot scale state storage, and also come with their own unique sets of tradeoffs and limitations particularly involving denial-of-service attacks; on-chain scaling via sharding (plus other techniques) and off-chain scaling via channels are arguably both necessary and complementary.\n\n\nThere exist approaches that use advanced cryptography, such as \nMimblewimble\n\u00a0and strategies based on ZK-SNARKs, to solve one specific part of the scaling problem: initial full node synchronization. Instead of verifying the entire history from genesis, nodes could verify a cryptographic proof that the current state legitimately follows from the history. These approaches do solve a legitimate problem, although it is worth noting that one can rely on cryptoeconomics instead of pure cryptography to solve the same problem in a much simpler way - see Ethereum\u2019s current implementations of \nfast syncing\n and \nwarp syncing\n. Neither solution does anything to alleviate state size growth or the limits of online transaction processing.\n\n\nHow does Plasma fit into the trilemma?\n\n\nIn the event of a large attack on Plasma subchains, all users of the Plasma subchains would need to withdraw back to the root chain. If Plasma has O(N) users, then this will require O(N) transactions, and so O(N / C) time to process all of the withdrawals. If withdrawal delays are fixed to some D (ie. the naive implementation), then as soon as N \n C * D, there will not be enough space in the blockchain to process all withdrawals in time, and so the system will be insecure; in this mode, Plasma should be viewed as increasing scalability only by a (possibly large) constant factor. If withdrawal delays are flexible, so they automatically extend if there are many withdrawals being made, then this means that as N increases further and further, the amount of time that an attacker can force everyone's funds to get locked up increases, and so the level of \"security\" of the system decreases further and further in a certain sense, as extended denial of access can be viewed as a security failure, albeit one milder than total loss of access. However, this is a different \ndirection\n of tradeoff from other solutions, and arguably a much milder tradeoff, hence why Plasma subchains are nevertheless a large improvement on the status quo.\n\n\nState size, history, cryptoeconomics, oh my! Define some of these terms before we move further!\n\n\n\n\nState\n: a set of information that represents the \u201ccurrent state\u201d of a system; determining whether or not a transaction is valid, as well as the effect of a transaction, should in the simplest model depend only on state. Examples of state data include the UTXO set in bitcoin, balances + nonces + code + storage in ethereum, and domain name registry entries in Namecoin.\n\n\nHistory\n: an ordered list of all transactions that have taken place since genesis. In a simple model, the present state should be a deterministic function of the genesis state and the history.\n\n\nTransaction\n: an object that goes into the history. In practice, a transaction represents an operation that some user wants to make, and is cryptographically signed.\n\n\nState transition function\n: a function that takes a state, applies a transaction and outputs a new state. The computation involved may involve adding and subtracting balances from accounts specified by the transaction, verifying digital signatures and running contract code.\n\n\nMerkle tree\n: a cryptographic hash tree structure that can store a very large amount of data, where authenticating each individual piece of data only takes O(log(n)) space and time. See \nhere\n\u00a0for details. In Ethereum, the transaction set of each block, as well as the state, is kept in a Merkle tree, where the roots of the trees are committed to in a block.\n\n\nReceipt\n: an object that represents an effect of a transaction that is not stored in the state, but which is still stored in a Merkle tree and committed to in a block so that its existence can later be efficiently proven even to a node that does not have all of the data. Logs in Ethereum are receipts; in sharded models, receipts are used to facilitate asynchronous cross-shard communication.\n\n\nLight client\n: a way of interacting with a blockchain that only requires a very small amount (we\u2019ll say O(1), though O(log(c)) may also be accurate in some cases) of computational resources, keeping track of only the block headers of the chain by default and acquiring any needed information about transactions, state or receipts by asking for and verifying Merkle proofs of the relevant data on an as-needed basis.\n\n\nState root\n: the root hash of the Merkle tree representing the state\n5\n\n\n\n\n \nThe Ethereum state tree, and how the state root fits into the block structure\n\n\nWhat is the basic idea behind sharding?\n\n\nWe split the state up into K = O(n / c) partitions that we call \u201cshards\u201d. For example, a sharding scheme on Ethereum might put all addresses starting with 0x00 into one shard, all addresses starting with 0x01 into another shard, etc. In the simplest form of sharding, each shard also has its own transaction history, and the effect of transactions in some shard k are limited to the state of shard k. One simple example would be a multi-asset blockchain, where there are K shards and each shard stores the balances and processes the transactions associated with one particular asset. In more advanced forms of sharding, some form of cross-shard communication capability, where transactions on one shard can trigger events on other shards, is also included.\n\n\nWhat might a basic design of a sharded blockchain look like?\n\n\nA simple approach is as follows. There exist nodes called \ncollators\n that accept transactions on shard \nk\n (depending on the protocol, collators either choose which \nk\n or are randomly assigned some \nk\n) and create \ncollations\n. A collation has a \ncollation header\n, a short message of the form \"This is a collation of transactions on shard \nk\n. It expects the previous state root of shard \nk\n to be 0x12bc57, the Merkle root of the transactions in this collation is 0x3f98ea, and the state root after processing these transactions should be 0x5d0cc1. Signed, collators #1, 2, 4, 5, 6, 8, 11, 13 ... 98, 99\".\n\n\nA block must then contain a collation header for each shard. A block is valid if:\n\n\n\n\nThe pre-state root given in each collation matches the current state root of the associated shard\n\n\nAll transactions in all collations are valid\n\n\nThe post-state root given in the collation matches the result of executing the transactions in the collation on top of the given pre-state\n\n\nThe collation is signed by at least two thirds of the collators registered for that shard\n\n\n\n\nNote that there are now several \"levels\" of nodes that can exist in such a system:\n\n\n\n\nSuper-full node\n - processes all transactions in all collations and maintains the full state for all shards.\n\n\nTop-level node\n - processes all top-level blocks, but does not process or try to download the transactions in each collation. Instead, it accepts it on faith that a collation is valid if two thirds of the collators in that shard say that it is valid.\n\n\nSingle-shard node\n - acts as a top-level node, but also processes all transactions and maintains the full state for some specific shard.\n\n\nLight node\n - downloads and verifies the block headers of the top-level blocks only; does not process any collation headers or transactions unless it needs to read some specific entry in the state of some specific shard, in which case it downloads the Merkle branch to the most recent collation header for that shard and from there downloads the Merkle proof of the desired value in the state.\n\n\n\n\nWhat are the challenges here?\n\n\n\n\nCross shard communication\n - the above design supports no cross-shard communication. How do we add cross-shard communication safely?\n\n\nSingle-shard takeover attacks\n - what if an attacker takes over the majority of the collators in one single shard, either to prevent any collations from getting enough signatures or, worse, to submit collations that are invalid?\n\n\nFraud detection\n - if an invalid collation does get made, how can nodes (including light nodes) be reliably informed of this so that they can verify the fraud and reject the collation if it is truly fraudulent?\n\n\nThe data availability problem\n - as a subset of fraud detection, what about the specific case where data is missing from a collation?\n\n\nSuperquadratic sharding\n - in the special case where n \n c^2, in the simple design given above there would be more than O(c) collation headers, and so an ordinary node would not be able to process even just the top-level blocks. Hence, more than two levels of indirection between transactions and top-level block headers are required (ie. we need \"shards of shards\"). What is the simplest and best way to do this?\n\n\n\n\nHowever, the effect of a transaction may depend on \nevents that earlier took place in other shards\n; a canonical example is transfer of money, where money can be moved from shard i to shard j by first creating a \u201cdebit\u201d transaction that destroys coins in shard i, and then creating a \u201ccredit\u201d transaction that creates coins in shard j, pointing to a receipt created by the debit transaction as proof that the credit is legitimate.\n\n\nBut doesn't the CAP theorem mean that fully secure distributed systems are impossible, and so sharding is futile?\n\n\nThe CAP theorem is a result that has to do with \ndistributed consensus\n; a simple statement is: \"in the cases that a network partition takes place, you have to choose either consistency or availability, you cannot have both\". The intuitive argument is simple: if the network splits in half, and in one half I send a transaction \"send my 10 coins to A\" and in the other I send a transaction \"send my 10 coins to B\", then either the system is unavailable, as one or both transactions will not be processed, or it becomes inconsistent, as one half of the network will see the first transaction completed and the other half will see the second transaction completed. Note that the CAP theorem has nothing to do with scalability; it applies to any situation where multiple nodes need to agree on a value, regardless of the amount of data that they are agreeing on. All existing decentralized systems have found some compromise between availability and consistency; sharding does not make anything fundamentally harder in this respect.\n\n\nHow can we facilitate cross-shard communication?\n\n\nThe easiest scenario to satisfy is one where there are very many applications that individually do not have too many users, and which only very occasionally and loosely interact with each other; in this case, applications can live on separate shards and use cross-shard communication via receipts to talk to each other.\n\n\nThis typically involves breaking up each transaction into a \"debit\" and a \"credit\". For example, suppose that we have a transaction where account A on shard M wishes to send 100 coins to account B on shard N. The steps would looks as follows:\n\n\n\n\nSend a transaction on shard M which (i) deducts the balance of A by 100 coins, and (ii) creates a receipt. A receipt is an object which is not saved in the state directly, but where the fact that the receipt was generated can be verified via a Merkle proof.\n\n\nWait for the first transaction to be included (sometimes waiting for finalization is required; this depends on the system).\n\n\nSend a transaction on shard N which includes the Merkle proof of the receipt from (1). This transaction also checks in the state of shard N to make sure that this receipt is \"unspent\"; if it is, then it increases the balance of B by 100 coins, and saves in the state that the receipt is spent.\n\n\nOptionally, the transaction in (3) also saves a receipt, which can then be used to perform further actions on shard M that are contingent on the original operation succeeding.\n\n\n\n\n\n\nIn more complex forms of sharding, transactions may in some cases have effects that spread out across several shards and may also synchronously ask for data from the state of multiple shards.\n\n\nHow can different kinds of applications fit into a sharded blockchain?\n\n\nSome applications require no cross-shard interaction at all; multi-asset blockchains, and blockchains with completely heterogeneous applications that require no interoperability, are the simplest cases. If applications do need to talk to each other, the challenge is much easier if the interaction can be made asynchronous - that is, if the interaction can be done in the form of the application on shard A generating a receipt, a transaction on shard B \u201cconsuming\u201d the receipt and performing some action based on it, and possibly sending a \u201ccallback\u201d to shard A containing some response. Generalizing this pattern is easy, and is not difficult to incorporate into a high-level programming language.\n\n\nHowever, note that the in-protocol mechanisms that would be used for asynchronous cross-shard communication would be different and have weaker functionality compared to the mechanisms that are available for intra-shard communication. Some of the functionality that is currently available in non-scalable blockchains would, in a scalable blockchain, only be available for intra-shard communication.\n7\n.\n\n\nWhat is the train-and-hotel problem?\n\n\nThe following example is courtesy of Andrew Miller. Suppose that a user wants to purchase a train ticket and reserve a hotel, and wants to make sure that the operation is atomic - either both reservations succeed or neither do. If the train ticket and hotel booking applications are on the same shard, this is easy: create a transaction that attempts to make both reservations, and throws an exception and reverts everything unless both reservations succeed. If the two are on different shards, however, this is not so easy; even without cryptoeconomic / decentralization concerns, this is essentially the problem of \natomic database transactions\n.\n\n\nWith asynchronous messages only, the simplest solution is to first reserve the train, then reserve the hotel, then once both reservations succeed confirm both; the reservation mechanism would prevent anyone else from reserving (or at least would ensure that enough spots are open to allow all reservations to be confirmed) for some period of time. However, this means that the mechanism relies on an extra security assumptions: that cross-shard messages from one shard can get included in another shard within some fixed period of time.\n\n\nWith cross-shard synchronous transactions, the problem is easier, but the challenge of creating a sharding solution capable of making cross-shard atomic synchronous transactions is itself decidedly nontrivial.\n\n\nIf an individual application has more than O(c) usage, then that application would need to exist across multiple chains. The feasibility of doing this depends on the specifics of the application itself; some applications (eg. currencies) are easily parallelizable, whereas others (eg. certain kinds of market designs) cannot be parallelized and must be processed serially.\n\n\nThere are properties of sharded blockchains that we know for a fact are impossible to achieve. \nAmdahl\u2019s law\n\u00a0states that in any scenario where applications have any non-parallelizable component, once parallelization is easily available the non-parallelizable component quickly becomes the bottleneck. In a general computation platform like Ethereum, it is easy to come up with examples of non-parallelizable computation: a contract that keeps track of an internal value x and sets x = sha3(x, tx_data) upon receiving a transaction is a simple example. No sharding scheme can give individual applications of this form more than O(c) performance. Hence, it is likely that over time sharded blockchain protocols will get better and better at being able to handle a more and more diverse set of application types and application interactions, but a sharded architecture will always necessarily fall behind a single-shard architecture in at least some ways at scales exceeding O(c).\n\n\nWhat are the security models that we are operating under?\n\n\nThere are several competing models under which the safety of blockchain designs is evaluated:\n\n\n\n\nHonest majority\n (or honest supermajority): we assume that there is some set of validators and up to \u00bd (or \u2153 or \u00bc) of those validators are controlled by an attacker, and the remaining validators honestly follow the protocol\n\n\nUncoordinated majority\n: we assume that all validators are rational in a game-theoretic sense (except the attacker, who is motivated to make the network fail in some way), but no more than some fraction (often between \u00bc and \u00bd) are capable of coordinating their actions.\n\n\nCoordinated choice\n: we assume that all validators are controlled by the same actor, or are fully capable of coordinating on the economically optimal choice between themselves. We can talk about the \ncost to the coalition\n (or profit to the coalition) of achieving some undesirable outcome.\n\n\nBribing attacker model\n: we take the uncoordinated majority model, but instead of making the attacker be one of the participants, the attacker sits outside the protocol, and has the ability to bribe any participants to change their behavior. Attackers are modeled as having a \nbudget\n, which is the maximum that they are willing to pay, and we can talk about their \ncost\n, the amount that they \nend up paying\n to disrupt the protocol equilibrium.\n\n\n\n\nBitcoin proof of work with \nEyal and Sirer\u2019s selfish mining fix\n\u00a0is robust up to \u00bd under the honest majority assumption, and up to \u00bc under the uncoordinated majority assumption. \nSchellingcoin\n is robust up to \u00bd under the honest majority and uncoordinated majority assumptions, has \u03b5 (ie. slightly more than zero) cost of attack in a coordinated choice model, and has a P + \u03b5 budget requirement and \u03b5 cost in a bribing attacker model due to \nP + epsilon attacks\n.\n\n\nHybrid models also exist; for example, even in the coordinated choice and bribing attacker models, it is common to make an \nhonest minority assumption\n that some portion (perhaps 1-15%) of validators will act altruistically regardless of incentives. We can also talk about coalitions consisting of between 50-99% of validators either trying to disrupt the protocol or harm other validators; for example, in proof of work, a 51%-sized coalition can double its revenue by refusing to include blocks from all other miners.\n\n\nThe honest majority model is arguably highly unrealistic and has already been empirically disproven - see Bitcoin's \nSPV mining fork\n\u00a0for a practical example. It proves too much: for example, an honest majority model would imply that honest miners are willing to voluntarily burn their own money if doing so punishes attackers in some way. The uncoordinated majority assumption may be realistic; there is also an intermediate model where the majority of nodes is honest but has a budget, so they shut down if they start to lose too much money.\n\n\nThe bribing attacker model has in some cases been criticized as being unrealistically adversarial, although its proponents argue that if a protocol is designed with the bribing attacker model in mind then it should be able to massively reduce the cost of consensus, as 51% attacks become an event that could be recovered from. We will evaluate sharding in the context of both uncoordinated majority and bribing attacker models.\n\n\nHow can we solve the single-shard takeover attack in an uncoordinated majority model?\n\n\nIn short, random sampling. Each shard is assigned a certain number of collators (eg. 150), and the collators that approve blocks on each shard are taken from the sample for that shard. Samples can be reshuffled either semi-frequently (eg. once every 12 hours) or maximally frequently (ie. there is no real independent sampling process, collators are randomly selected for each shard from a global pool every block).\n\n\nThe result is that even though only a few nodes are verifying and creating blocks on each shard at any given time, the level of security is in fact not much lower, in an honest/uncoordinated majority model, than what it would be if every single node was verifying and creating blocks. The reason is simple statistics: if you assume a \u2154 honest supermajority on the global set, and if the size of the sample is 150, then with 99.999% probability the honest majority condition will be satisfied on the sample. If you assume a \u00be honest supermajority on the global set, then that probability increases to 99.999999998% (see \nhere\n\u00a0for calculation details).\n\n\nHence, at least in the honest / uncoordinated majority setting, we have:\n\n\n\n\nDecentralization\n (each node stores only O(c) data, as it\u2019s a light client in O(c) shards and so stores O(1) * O(c) = O(c) data worth of block headers, as well as O(c) data corresponding to the full state and recent history of one or several shards that it is assigned to at the present time)\n\n\nScalability\n (with O(c) shards, each shard having O(c) capacity, the maximum capacity is n = O(c\\^2))\n\n\nSecurity\n (attackers need to control at least \u2153 of the entire O(n)-sized validator pool in order to stand a chance of taking over the network).\n\n\n\n\nIn the Zamfir model (or alternatively, in the \u201cvery very adaptive adversary\u201d model), things are not so easy, but we will get to this later. Note that because of the imperfections of sampling, the security threshold does decrease from \u00bd to \u2153, but this is still a surprisingly low loss of security for what may be a 100-1000x gain in scalability with no loss of decentralization.\n\n\nHow do you actually do this sampling in proof of work, and in proof of stake?\n\n\nIn proof of stake, it is easy. There already is an \u201cactive validator set\u201d that is kept track of in the state, and one can simply sample from this set directly. Either an in-protocol algorithm runs and chooses 150 validators for each shard, or each validator independently runs an algorithm that uses a common source of randomness to (provably) determine which shard they are at any given time. Note that it is very important that the sampling assignment is \u201ccompulsory\u201d; validators do not have a choice of what shard they go into. If validators could choose, then attackers with small total stake could concentrate their stake onto one shard and attack it, thereby eliminating the system\u2019s security.\n\n\nIn proof of work, it is more difficult, as with \u201cdirect\u201d proof of work schemes one cannot prevent miners from applying their work to a given shard. It may be possible to use \nproof-of-file-access forms\n of proof of work to lock individual miners to individual shards, but it is hard to ensure that miners cannot quickly download or generate data that can be used for other shards and thus circumvent such a mechanism. The best known approach is through a technique invented by Dominic Williams called \u201cpuzzle towers\u201d, where miners first perform proof of work on a common chain, which then inducts them into a proof of stake-style validator pool, and the validator pool is then sampled just as in the proof-of-stake case.\n\n\nOne possible intermediate route might look as follows. Miners can spend a large (O(c)-sized) amount of work to create a new \u201ccryptographic identity\u201d. The precise value of the proof of work solution then chooses which shard they have to make their next block on. They can then spend an O(1)-sized amount of work to create a block on that shard, and the value of that\u00a0proof of work solution determines which shard they can work on next, and so on\n8\n. Note that all of these approaches make proof of work \u201cstateful\u201d in some way; the necessity of this is fundamental.\n\n\nWhat are the tradeoffs in making sampling more or less frequent?\n\n\nSelection frequency affects just how adaptive adversaries can be for the protocol to still be secure against them; for example, if you believe that an adaptive attack (eg. dishonest validators who discover that they are part of the same sample banding together and colluding) can happen in 6 hours but not less, then you would be okay with a sampling time of 4 hours but not 12 hours. This is an argument in favor of making sampling happen as quickly as possible.\n\n\nThe main challenge with sampling taking place every block is that reshuffling carries a very high amount of overhead. Specifically, verifying a block on a shard requires knowing the state of that shard, and so every time validators are reshuffled, validators need to download the entire state for the new shard(s) that they are in. This requires both a strong state size control policy (ie. economically ensuring that the size of the state does not grow too large, whether by deleting old accounts, restricting the rate of creating new accounts or a combination of the two) and a fairly long reshuffling time to work well.\n\n\nCurrently, the Parity client can download and verify a full Ethereum state snapshot via \u201cwarp-sync\u201d in \\~3 minutes; if we increase by 20x to compensate for increased usage (10 tx/sec instead of the current 0.5 tx/sec) (we\u2019ll assume future state size control policies and \u201cdust\u201d accumulated from longer-term usage roughly cancel out) , we get \\~60 minute state sync time, suggesting that sync periods of 12-24 hours but not less are safe.\n\n\nThere are two possible paths to overcoming this challenge.\n\n\nCan we force more of the state to be held user-side so that transactions can be validated without requiring validators to hold all state data?\n\n\nThe techniques here tend to involve requiring users to store state data and provide Merkle proofs along with every transaction that they send. A transaction would be sent along with a Merkle proof-of-correct-execution, and this proof would allow a node that only has the state root to calculate the new state root. This proof-of-correct-execution would consist of the subset of objects in the trie that would need to be traversed to access and verify the state information that the transaction must verify; because Merkle proofs are O(log(n)) sized, the proof for a transaction that accesses a constant number of objects would also be O(log(n)) sized.\n\n\n \nThe subset of objects in a Merkle tree that would need to be provided in a Merkle proof of a transaction that accesses several state objects\n\n\nImplementing this scheme in its pure form has two flaws. First, it introduces O(log(n)) overhead, although one could argue that this O(log(n)) overhead is not as bad as it seems because it ensures that the validator can always simply keep state data in memory and thus it never needs to deal with the overhead of accessing the hard drive\n9\n. Second, it can easily be applied if the addresses that are accessed by a transaction are static, but is more difficult to apply if the addresses in question are dynamic - that is, if the transaction execution has code of the form \nread(f(read(x)))\n where the address\u00a0of some state read depends on the execution result of some other state read. In this case, the address that the transaction sender thinks the transaction will be reading at the time that they send the transaction may well differ from the address that is actually read when the transaction is included in a block, and so the Merkle proof may be insufficient\n10\n.\n\n\nA compromise approach is to allow transaction senders to send a proof that incorporates the most likely possibilities for what data would be accessed; if the proof is sufficient, then the transaction will be accepted, and if the state unexpectedly changes and the proof is insufficient then either the sender must resend or some helper node in the network resends the transaction adding the correct proof. Developers would then be free to make transactions that have dynamic behavior, but the more dynamic the behavior gets the less likely transactions would be to actually get included into blocks.\n\n\nNote that validators\u2019 transaction inclusion strategies under this approach would need to be complicated, as they may spend millions of gas processing a transaction only to realize that the last step accesses some state entry that they do not have. One possible compromise is for validators to have a strategy that accepts only (i) transactions with very low gas costs, eg. \\\n100k, and (ii) transactions that statically specify a set of contracts that they are allowed to access, and contain proofs for the entire state of those contracts. Note that this only applies when transactions are initially broadcasted; once a transaction is included into a block, the order of execution is fixed, and so only the minimal Merkle proof corresponding to the state that actually needs to be accessed can be provided.\n\n\nIf validators are not reshuffled immediately, there is one further opportunity to increase efficiency. We can expect validators to store data from proofs of transactions that have already been processed, so that that data does not need to be sent again; if k transactions are sent within one reshuffling period, then this decreases the average size of a Merkle proof from log(n) to log(n) - log(k).\n\n\nHow is the randomness for random sampling generated?\n\n\nFirst of all, it is important to note that even if random number generation is heavily exploitable, this is not a fatal flaw for the protocol; rather, it simply means that there is a medium to high centralization incentive. The reason is that because the randomness is picking fairly large samples, it is difficult to bias the randomness by more than a certain amount.\n\n\nThe simplest way to show this is through the \nbinomial distribution\n, as described above; if one wishes to avoid a sample of size N being more than 50% corrupted by an attacker, and an attacker has p% of the global stake pool, the chance of the attacker being able to get such a majority during one round is:\n\n\n\n\nHere\u2019s a table for what this probability would look like in practice for various values of N and p:\n\n\n \n    \n N = 50     \n N = 100    \n N = 150    \n N = 250    \n \n \n p = 0.4    \n 0.0978     \n 0.0271     \n 0.0082     \n 0.0009     \n \n \n p = 0.33   \n 0.0108     \n 0.0004     \n 1.83 * 10-5   \n 3.98 * 10-8   \n \n \n p = 0.25   \n 0.0001     \n 6.63 * 10\n-8\n   \n 4.11 * 10\n-11\n  \n 1.81 * 10-17  \n<\n \n \n p = 0.2    \n 2.09 * 10\n-6\n   \n 2.14 * 10\n-11\n  \n 2.50 * 10\n-16\n  \n 3.96 * 10\n-26\n  \n \n\n\n\nHence, for N \n= 150, the chance that any given random seed will lead to a sample favoring the attacker is very small indeed\n11\n,\n12\n.\u00a0What this means from the perspective of security of randomness is that the attacker needs to have a very large amount of freedom in choosing the random values order to break the sampling process outright. Most vulnerabilities in proof-of-stake randomness do not allow the attacker to simply choose a seed; at worst, they give the attacker many chances to select the most favorable seed out of many pseudorandomly generated options. If one is very worried about this, one can simply set N to a greater value, and add a moderately hard key-derivation function to the process of computing the randomness, so that it takes more than 2\n100\n\u00a0computational steps to find a way to bias the randomness sufficiently.\n\n\nNow, let\u2019s look at the risk of attacks being made that try to influence the randomness more marginally, for purposes of profit rather than outright takeover. \u00a0For example, suppose that there is an algorithm which pseudorandomly selects 1000 validators out of some very large set (each validator getting a reward of $1), an attacker has 10% of the stake so the attacker\u2019s average \u201chonest\u201d revenue 100, and at a cost of $1 the attacker can manipulate the randomness to \u201cre-roll the dice\u201d (and the attacker can do this an unlimited number of times).\n\n\nDue to the \ncentral limit theorem\n, the standard deviation of the number of samples, and based \non other known results in math\n\u00a0the expected maximum of N random samples is slightly under M + S * sqrt(2 * log(N)) where M is the mean and S is the standard deviation. Hence the reward for manipulating the randomness and effectively re-rolling the dice (ie. increasing N) drops off sharply, eg. with 0 re-trials your expected reward is $100, with one re-trial it's $105.5, with two it's $108.5, with three it's $110.3, with four it's $111.6, with five it's $112.6 and with six it's $113.5. Hence, after five retrials it stops being worth it. As a result, an economically motivated attacker with ten percent of stake will (socially wastefully) spend $5 to get an additional revenue of $13, for a net surplus of $8.\n\n\nHowever, this kind of logic assumes that one single round of re-rolling the dice is expensive. Many older proof of stake algorithms have a \u201cstake grinding\u201d vulnerability where re-rolling the dice simply means making a computation locally on one\u2019s computer; algorithms with this vulnerability are certainly unacceptable in a sharding context. Newer algorithms (see the \u201cvalidator selection\u201d section in the \nproof of stake FAQ\n) have the property that re-rolling the dice can only be done by voluntarily giving up one\u2019s spot in the block creation process, which entails giving up rewards and fees. The best way to mitigate the impact of marginal economically motivated attacks on sample selection is to find ways to increase this cost. One method to increase the cost by a factor of sqrt(N) from N rounds of voting is the \nmajority-bit method devised by Iddo Bentov\n; the Mauve Paper\u2019s sharding algorithm expects to use this approach.\n\n\nAnother form of random number generation that is not exploitable by minority coalitions is the deterministic threshold signature approach most researched and advocated by Dominic Williams. The strategy here is to use a \ndeterministic threshold signature\n\u00a0to generate the random seed from which samples are selected. Deterministic threshold signatures have the property that the value is guaranteed to be the same regardless of which of a given set of participants provides their data to the algorithm, provided that at least \u2154 of participants do participate honestly. This approach is more obviously not economically exploitable and fully resistant to all forms of stake-grinding, but it has several weaknesses:\n\n\n\n\nIt relies on more complex cryptography\n (specifically, elliptic curves and pairings). Other approaches rely on nothing but the random-oracle assumption for common hash algorithms.\n\n\nIt fails when many validators are offline\n. A desired goal for public blockchains is to be able to survive very large portions of the network simultaneously disappearing, as long as a majority of the remaining nodes is honest; deterministic threshold signature schemes at this point cannot provide this property.\n\n\nIt\u2019s not secure in a Zamfir model\n where more than \u2154 of validators are colluding. The other approaches described in the proof of stake FAQ above still make it expensive to manipulate the randomness, as data from all\u00a0validators is mixed into the seed and making any manipulation requires either universal collusion or excluding other validators outright.\n\n\n\n\nOne might argue that the deterministic threshold signature approach works better in consistency-favoring contexts and other approaches work better in availability-favoring contexts.\n\n\nWhat are the concerns about sharding through random sampling in a bribing attacker or coordinated choice model?\n\n\nIn a bribing attacker or coordinated choice model, the fact that validators are randomly sampled doesn\u2019t matter: whatever the sample is, either the attacker can bribe the great majority of the sample to do as the attacker pleases, or the attacker controls a majority of the sample directly and can direct the sample to perform arbitrary actions at low cost (O(c) cost, to be precise).\n\n\nAt that point, the attacker has the ability to conduct 51% attacks against that sample. The threat is further magnified because there is a risk of cross-shard contagion: if the attacker corrupts the state of a shard, the attacker can then start to send unlimited quantities of funds out to other shards and perform other cross-shard mischief. All in all, security in the bribing attacker or coordinated choice model is not much better than that of simply creating O(c) altcoins.\n\n\nHow can we improve on this?\n\n\nBasically, by comprehensively solving the problem of fraud detection.\n\n\nOne major category of solution to this problem is the use of challenge-response mechanisms. Challenge-response mechanisms generally rely on a principle of escalation: fact X (eg. \"collation #17293 in shard #54 is valid\") is initially accepted as true if at least k validators sign a claim (backed by a deposit) that it is. However, if this happens, there is some challenge period during which 2k validators can sign a claim stating that it is false. If this happens, 4k validators can sign a claim stating that the claim is in fact true, and so forth until one side either gives up or most validators have signed claims, at which point every validator and client themselves checks whether or not X is true. If X is ruled true, everyone who made a claim saying so is rewarded and everyone who made a contradictory claim is penalized, and vice versa.\n\n\nLooking at this mechanism, you can prove that malicious actors lose an amount of money proportional to the number of actors that they forced to look at the given piece of data. Forcing \nall\n users to look at the data requires a large portion of validators to sign a claim which is false, which can be used to penalize all of them, so the cost of forcing all users to look at a piece of data is O(n); this prevents the challenge-response mechanism from being used as a denial-of-service vector.\n\n\nWhat is the data availability problem, and how can we use erasure codes to solve it?\n\n\nSee https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding\n\n\nCan we remove the need to solve data availability with some kind of fancy cryptographic accumulator scheme.\n\n\nNo. Suppose there is a scheme where there exists an object S representing the state (S could possibly be a hash) possibly as well as auxiliary information (\"witnesses\") held by individual users that can prove the presence of existing state objects (eg. S is a Merkle root, the witnesses are the branches, though other constructions like RSA accumulators do exist). There exists an updating protocol where some data is broadcasted, and this data changes S to change the contents of the state, and also possibly changes witnesses.\n\n\nSuppose some user has the witnesses for a set of N objects in the state, and M of the objects are updated. After receiving the update information, the user can check the new status of all N objects, and thereby see which M were updated. Hence, the update information itself encoded at least ~M * log(N) bits of information. Hence, the update information that everyone needs for receive to implement the effect of M transactions must necessarily be of size O(M). \n14\n\n\nSo this means that we can actually create scalable sharded blockchains where the cost of making anything bad happen is proportional to the size of the entire validator set?\n\n\nThere is one trivial attack by which an attacker can always burn O(c) capital to temporarily reduce the quality of a shard: spam it by sending transactions with high transaction fees, forcing legitimate users to outbid you to get in. This attack is unavoidable; you could compensate with flexible gas limits, and you could even try \u201ctransparent sharding\u201d schemes that try to automatically re-allocate nodes to shards based on usage, but if some particular application is non-parallelizable, Amdahl\u2019s law guarantees that there is nothing you can do. The attack that is opened up here (reminder: it only works in the Zamfir model, not honest/uncoordinated majority) is arguably not substantially worse than the transaction spam attack. Hence, we've reached the known limit for the security of a single shard, and there is no value in trying to go further.\n\n\nLet\u2019s walk back a bit. Do we actually need any of this complexity if we have instant shuffling? Doesn\u2019t instant shuffling basically mean that each shard directly pulls validators from the global validator pool so it operates just like a blockchain, and so sharding doesn\u2019t actually introduce any new complexities?\n\n\nKind of. First of all, it\u2019s worth noting that proof of work and simple proof of stake, even without sharding, both have very low security in a bribing attacker model; a block is only truly \u201cfinalized\u201d in the economic sense after O(n) time (as if only a few blocks have passed, then the economic cost of replacing the chain is simply the cost of starting a double-spend from before the block in question). Casper solves this problem by adding its finality mechanism, so that the economic security margin immediately increases to the maximum. In a sharded chain, if we want economic finality then we need to come up with a chain of reasoning for why a validator would be willing to make a very strong claim on a chain based solely on a random sample, when the validator itself is convinced that the bribing attacker and coordinated choice models may be true and so the random sample could potentially be corrupted.\n\n\nYou mentioned transparent sharding. I\u2019m 12 years old and what is this?\n\n\nBasically, we do not expose the concept of \u201cshards\u201d directly to developers, and do not permanently assign state objects to specific shards. Instead, the protocol has an ongoing built-in load-balancing process that shifts objects around between shards. If a shard gets too big or consumes too much gas it can be split in half; if two shards get too small and talk to each other very often they can be combined together; if all shards get too small one shard can be deleted and its contents moved to various other shards, etc.\n\n\nImagine if Donald Trump realized that people travel between New York and London a lot, but there\u2019s an ocean in the way, so he could just take out his scissors, cut out the ocean, glue the US east coast and Western Europe together and put the Atlantic beside the South Pole - it\u2019s kind of like that.\n\n\nWhat are some advantages and disadvantages of this?\n\n\n\n\nDevelopers no longer need to think about shards\n\n\nThere\u2019s the possibility for shards to adjust manually to changes in gas prices, rather than relying on market mechanics to increase gas prices in some shards more than others\n\n\nThere is no longer a notion of reliable co-placement: if two contracts are put into the same shard so that they can interact with each other, shard changes may well end up separating them\n\n\nMore protocol complexity\n\n\n\n\nThe co-placement problem can be mitigated by introducing a notion of \u201csequential domains\u201d, where contracts may specify that they exist in the same sequential domain, in which case synchronous communication between them will always be possible. In this model a shard can be viewed as a set of sequential domains that are validated together, and where sequential domains can be rebalanced between shards if the protocol determines that it is efficient to do so.\n\n\nHow would synchronous cross-shard messages work?\n\n\nThe process becomes much easier if you view the transaction history as being already settled, and are simply trying to calculate the state transition function. There are several approaches; one fairly simple approach can be described as follows:\n\n\n\n\nA transaction may specify a set of shards that it can operate in\n\n\nIn order for the transaction to be effective, it must be included at the same block height in all of these shards.\n\n\nTransactions within a block must be put in order of their hash (this ensures a canonical order of execution)\n\n\n\n\nA client on shard X, if it sees a transaction with shards (X, Y), requests a Merkle proof from shard Y verifying (i) the presence of that transaction on shard Y, and (ii) what the pre-state on shard Y is for those bits of data that the transaction will need to access. It then executes the transaction and commits to the execution result. Note that this process may be highly inefficient if there are many transactions with many different \u201cblock pairings\u201d in each block; for this reason, it may be optimal to simply require blocks to specify sister shards, and then calculation can be done more efficiently at a per-block level. This is the basis for how such a scheme could work; one could imagine more complex designs. However, when making a new design, it\u2019s always important to make sure that low-cost denial of service attacks cannot arbitrarily slow state calculation down.\n\n\nWhat about semi-asynchronous messages?\n\n\nVlad Zamfir created a scheme by which asynchronous messages could still solve the \u201cbook a train and hotel\u201d problem. This works as follows. The state keeps track of all operations that have been recently made, as well as the graph of which operations were triggered by any given operation (including cross-shard operations). If an operation is reverted, then a receipt is created which can then be used to revert any effect of that operation on other shards; those reverts may then trigger their own reverts and so forth. The argument is that if one biases the system so that revert messages can propagate twice as fast as other kinds of messages, then a complex cross-shard transaction that finishes executing in K rounds can be fully reverted in another K rounds.\n\n\nThe overhead that this scheme would introduce has arguably not been sufficiently studied; there may be worst-case scenarios that trigger quadratic execution vulnerabilities. It is clear that if transactions have effects that are more isolated from each other, the overhead of this mechanism is lower; perhaps isolated executions can be incentivized via favorable gas cost rules. All in all, this is one of the more promising research directions for advanced sharding.\n\n\nWhat are guaranteed cross-shard calls?\n\n\nOne of the challenges in sharding is that when a call is made, there is by default no hard protocol-provided guarantee that any asynchronous operations created by that call will be made within any particular timeframe, or even made at all; rather, it is up to some party to send a transaction in the destination shard triggering the receipt. This is okay for many applications, but in some cases it may be problematic for several reasons:\n\n\n\n\nThere may be no single party that is clearly incentivized to trigger a given receipt. If the sending of a transaction benefits many parties, then there could be \ntragedy-of-the-commons effects\n where the parties try to wait longer until someone else sends the transaction (ie. play \"chicken\"), or simply decide that sending the transaction is not worth the transaction fees for them individually.\n\n\nGas prices across shards may be volatile\n, and in some cases performing the first half of an operation compels the user to \u201cfollow through\u201d on it, but the user may have to end up following through at a much higher gas price. This may be exacerbated by DoS attacks and related forms of \ngriefing\n.\n\n\nSome applications rely on there being an upper bound on the \u201clatency\u201d of cross-shard messages (eg. the train-and-hotel example). Lacking hard guarantees, such applications would have to have \ninefficiently large safety margins\n.\n\n\n\n\nOne could try to come up with a system where asynchronous messages made in some shard automatically trigger effects in their destination shard after some number of blocks. However, this requires every client on each shard to actively inspect all other shards in the process of calculating the state transition function, which is arguably a source of inefficiency. The best known compromise approach is this: when a receipt from shard A at height \nheight_a\n\u00a0is included in shard B at height \nheight_b\n, if the difference in block heights exceeds \nMAX_HEIGHT\n, then all validators in shard B that created blocks from \nheight_a + MAX_HEIGHT + 1\n\u00a0to \nheight_b - 1\n\u00a0are penalized, and this penalty increases exponentially. A portion of these penalties is given to the validator that finally includes the block as a reward. This keeps the state transition function simple, while still strongly incentivizing the correct behavior.\n\n\nWait, but what if an attacker sends a cross-shard call from every shard into shard X at the same time? Wouldn\u2019t it be mathematically impossible to include all of these calls in time?\n\n\nCorrect; this is a problem. Here is a proposed solution. In order to make a cross-shard call from shard A to shard B, the caller must pre-purchase \u201ccongealed shard B gas\u201d (this is done via a transaction in shard B, and recorded in shard B). Congealed shard B gas has a fast demurrage rate: once ordered, it loses 1/k of its remaining potency every block. A transaction on shard A can then send the congealed shard B gas along with the receipt that it creates, and it can be used on shard B for free. Shard B blocks allocate extra gas space specifically for these kinds of transactions. Note that because of the demurrage rules, there can be at most GAS_LIMIT * k worth of congealed gas for a given shard available at any time, which can certainly be filled within k blocks (in fact, even faster due to demurrage, but we may need this slack space due to malicious validators). In case too many validators maliciously fail to include receipts, we can make the penalties fairer by exempting validators who fill up the \u201creceipt space\u201d of their blocks with as many receipts as possible, starting with the oldest ones.\n\n\nUnder this pre-purchase mechanism, a user that wants to perform a cross-shard operation would first pre-purchase gas for all shards that the operation would go into, over-purchasing to take into account the demurrage. If the operation would create a receipt that triggers an operation that consumes 100000 gas in shard B, the user would pre-buy 100000 * e (ie. 271818) shard-B congealed gas. If that operation would in turn spend 100000 gas in shard C (ie. two levels of indirection), the user would need to pre-buy 100000 * e\\^2 (ie. 738906) shard-C congealed gas. Notice how once the purchases are confirmed, and the user starts the main operation, the user can be confident that they will be insulated from changes in the gas price market, unless validators voluntarily lose large quantities of money from receipt non-inclusion penalties.\n\n\nCongealed gas? This sounds interesting for not just cross-shard operations, but also reliable intra-shard scheduling\n\n\nIndeed; you could buy congealed shard A gas inside of shard A, and send a guaranteed cross-shard call from shard A to itself. Though note that this scheme would only support scheduling at very short time intervals, and the scheduling would not be exact to the block; it would only be guaranteed to happen within some period of time.\n\n\nDoes guaranteed scheduling, both intra-shard and cross-shard, help against majority collusions trying to censor transactions?\n\n\nYes. If a user fails to get a transaction in because colluding validators are filtering the transaction and not accepting any blocks that include it, then the user could send a series of messages which trigger a chain of guaranteed scheduled messages, the last of which reconstructs the transaction inside of the EVM and executes it. Preventing such circumvention techniques is practically impossible without shutting down the guaranteed scheduling feature outright and greatly restricting the entire protocol, and so malicious validators would not be able to do it easily.\n\n\nCould sharded blockchains do a better job of dealing with network partitions?\n\n\nThe schemes described in this document would offer no improvement over non-sharded blockchains; realistically, every shard would end up with some nodes on both sides of the partition. There have been calls (eg. from \nIPFS\u2019s Juan Benet\n) for building scalable networks with the specific goal that networks can split up into shards as needed and thus continue operating as much as possible under network partition conditions, but there are nontrivial cryptoeconomic challenges in making this work well.\n\n\nOne major challenge is that if we want to have location-based sharding so that geographic network partitions minimally hinder intra-shard cohesion (with the side effect of having very low intra-shard latencies and hence very fast intra-shard block times), then we need to have a way for validators to choose which shards they are participating in. This is dangerous, because it allows for much larger classes of attacks in the honest/uncoordinated majority model, and hence cheaper attacks with higher griefing factors in the Zamfir model. Sharding for geographic partition safety and sharding via random sampling for efficiency are two fundamentally different things.\n\n\nSecond, more thinking would need to go into how applications are organized. A likely model in a sharded blockchain as described above is for each \u201capp\u201d to be on some shard (at least for small-scale apps); however, if we want the apps themselves to be partition-resistant, then it means that all apps would need to be cross-shard to some extent.\n\n\nOne possible route to solving this is to create a platform that offers both kinds of shards - some shards would be higher-security \u201cglobal\u201d shards that are randomly sampled, and other shards would be lower-security \u201clocal\u201d shards that could have properties such as ultra-fast block times and cheaper transaction fees. Very low-security shards could even be used for data-publishing and messaging.\n\n\nWhat are the unique challenges of pushing scaling past n = O(c\\^2)?\n\n\nThere are several considerations. First, the algorithm would need to be converted from a two-layer algorithm to a stackable n-layer algorithm; this is possible, but is complex. Second, n / c (ie. the ratio between the total computation load of the network and the capacity of one node) is a value that happens to be close to two constants: first, if measured in blocks, a timespan of several hours, which is an acceptable \u201cmaximum security confirmation time\u201d, and second, the ratio between rewards and deposits (an early computation suggests a 32 ETH deposit size and a 0.05 ETH block reward for Casper). The latter has the consequence that if rewards and penalties on a shard are escalated to be on the scale of validator deposits, the cost of continuing an attack on a shard will be O(n) in size.\n\n\nGoing above c\\^2 would likely entail further weakening the kinds of security guarantees that a system can provide, and allowing attackers to attack individual shards in certain ways for extended periods of time at medium cost, although it should still be possible to prevent invalid state from being finalized and to prevent finalized state from being reverted unless attackers are willing to pay an O(n) cost. However, the rewards are large - a super-quadratically sharded blockchain could be used as a general-purpose tool for nearly all decentralized applications, and could sustain transaction fees that makes its use virtually free.\n\n\nFootnotes\n\n\n\n\n\n\n\u00a0Merklix tree == Merkle Patricia tree\n\n\n\n\n\n\n\u00a0Later proposals from the NUS group do manage to shard state; they do this via the receipt and state-compacting techniques that I describe in later sections in this document.\n\n\n\n\n\n\n\u00a0There are reasons to be conservative here. Particularly, note that if an attacker comes up with worst-case transactions whose ratio between processing time and block space expenditure (bytes, gas, etc) is much higher than usual, then the system will experience very low performance, and so a safety factor is necessary to account for this possibility. In traditional blockchains, the fact that block processing only takes \\~1-5% of block time has the primary role of protecting against centralization risk but serves double duty of protecting against denial of service risk. In the specific case of Bitcoin, its current worst-case \nknown quadratic execution vulnerability\n\u00a0arguably limits any scaling at present to \\~5-10x, and in the case of Ethereum, while all known vulnerabilities are being or have been removed after the denial-of-service attacks, there is still a risk of further discrepancies particularly on a smaller scale. In Bitcoin NG, the need for the former is removed, but the need for the latter is still there.\n\n\n\n\n\n\n\u00a0A further reason to be cautious is that increased state size corresponds to reduced throughput, as nodes will find it harder and harder to keep state data in RAM and so need more and more disk accesses, and databases, which often have an O(log(n)) access time, will take longer and longer to access. This was an important lesson from the last Ethereum denial-of-service attack, which bloated the state by \\~10 GB by creating empty accounts and thereby indirectly slowed processing down by forcing further state accesses to hit disk instead of RAM.\n\n\n\n\n\n\n\u00a0In sharded blockchains, there may not necessarily be in-lockstep consensus on a single global state, and so the protocol never asks nodes to try to compute a global state root; in fact, in the protocols presented in later sections, each shard has its own state, and for each shard there is a mechanism for committing to the state root for that shard, which represents that shard\u2019s state\n\n\n\n\n\n\n\u00a0#MEGA\n\n\n\n\n\n\n\u00a0If a non-scalable blockchain upgrades into a scalable blockchain, the author\u2019s recommended path is that the old chain\u2019s state should simply become a single shard in the new chain.\n\n\n\n\n\n\n For this to be secure, some further conditions must be satisfied; particularly, the proof of work must be non-outsourceable in order to prevent the attacker from determining which \nother miners' identities\n are available for some given shard and mining on top of those.\n\n\n\n\n\n\n\u00a0Recent Ethereum denial-of-service attacks have proven that hard drive access is a primary bottleneck to blockchain scalability.\n\n\n\n\n\n\n\u00a0You could ask: well why don\u2019t validators fetch Merkle proofs just-in-time? Answer: because doing so is a \\~100-1000ms roundtrip, and executing an entire complex transaction within that time could be prohibitive.\n\n\n\n\n\n\n\u00a0\u00a0One hybrid solution that combines the normal-case efficiency of small samples with the greater robustness of larger samples is a multi-layered sampling scheme: have a consensus between 50 nodes that requires 80% agreement to move forward, and then only if that consensus fails to be reached then fall back to a 250-node sample. N = 50 with an 80% threshold has only a 8.92 * 10-9 failure rate even against attackers with p = 0.4, so this does not harm security at all under an honest or uncoordinated majority model.\n\n\n\n\n\n\n\u00a0The probabilities given are for one single shard; however, the random seed affects O(c) shards and the attacker could potentially take over any one of them. If we want to look at O(c) shards simultaneously, then there are two cases. First, if the grinding process is computationally bounded, then this fact does not change the calculus at all, as even though there are now O(c) chances of success per round, checking success takes O(c) times as much work. Second, if the grinding process is economically bounded, then this indeed calls for somewhat higher safety factors (increasing N by 10-20 should be sufficient) although it\u2019s important to note that the goal of an attacker in a profit-motivated manipulation attack is to increase their participation across all\u00a0shards in any case, and so that is the case that we are already investigating.\n\n\n\n\n\n\n\u00a0See \nEthcore\u2019s Polkadotpaper\n\u00a0for further description of how their \u201cfishermen\u201d concept works.\n\n\n\n\n\n\n Thanks to Justin Drake for pointing me to cryptographic accumulators, as well as \nthis paper\n that gives the argument for the impossibility of sublinear batching. See also this thread: https://ethresear.ch/t/accumulators-scalability-of-utxo-blockchains-and-data-availability/176", 
            "title": "\u5206\u7247\u533a\u5757\u94fe"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#_1", 
            "text": "", 
            "title": "\u5206\u7247\u533a\u5757\u94fe"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#_2", 
            "text": "Currently, in all blockchain protocols each node stores all states (account balances, contract code and storage, etc.) and processes all transactions. This provides a large amount of security, but greatly limits scalability: a blockchain cannot process more transactions than a single node can. In large part because of this, Bitcoin is limited to \\~3-7 transactions per second, Ethereum to 7-15, etc. However, this poses a question: are there ways to create a new mechanism, where only small subset of nodes verifies each transaction? As long as there are sufficiently many nodes verifying each transaction that the system is still highly secure, but sufficiently few that the system can process many transactions in parallel, could we not use such a technique to greatly increase a blockchain's throughput?", 
            "title": "\u4ecb\u7ecd"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-some-trivial-but-flawed-ways-of-solving-the-problem", 
            "text": "There are three main categories of \u201ceasy solutions\u201d. The first is to simply give up on scaling individual blockchains, and instead assume that users will be using many different \u201caltcoins\u201d. This greatly increases throughput, but comes at a cost of security: an N-factor increase in throughput using this method necessarily comes with an N-factor decrease in security. Hence, it is arguably non-viable for more than small values of N.  The second is to simply increase the block size limit. This can work and in some situations may well be the correct prescription, as block sizes may well be constrained more by politics than by realistic technical considerations. But regardless of one\u2019s beliefs about any individual case such an approach inevitably has its limits: if one goes too far, then nodes running on consumer hardware will drop out, the network will start to rely exclusively on a very small number of supercomputers running the blockchain, which can lead to great centralization risk.  The third is \u201cmerge mining\u201d, a technique where there are many chains, but all chains share the same mining power (or, in proof of stake systems, stake).\u00a0Currently, Namecoin gets a large portion of its security from the Bitcoin blockchain by doing this. If all miners participate, this theoretically can increase throughput by a factor of N without compromising security. However, this also has the problem that it increases the computational and storage load on each miner by a factor of N, and so in fact this solution is simply a stealthy form of block size increase.  Even if this is deemed acceptable, there is still the defect that the chains are not truly \"tied together\"; only a small amount of economic incentive is required to convince the miners to abandon or compromise one specific chain. This possibility is in fact quite real, and there have been  actual historical incidents  of merge-mined chains being attacked, as well as developers who have explicitly advocated using merge mining attacks as  a \"governance\" feature , destroying chains that are not \"profitable\" to a given coalition.  If only a few miners/mining pools participate in merge-mining each chain, then there is an imminent  risk of centralization , while the security benefits of merge mining are also greatly reduced.", 
            "title": "What are some trivial but flawed ways of solving the problem?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#this-sounds-like-theres-some-kind-of-scalability-trilemma-at-play-what-is-this-trilemma-and-can-we-break-through-it", 
            "text": "The trilemma claims that blockchain systems can only at most have two of the following three properties:   Decentralization \u00a0(defined as the system being able to run in a scenario where each participant only has access to O(c) resources, ie. a regular laptop or small VPS)  Scalability \u00a0(defined as being able to process O(n) > O(c) transactions)  Security \u00a0(defined as being secure against attackers with up to O(n) resources)   In the rest of this document, we\u2019ll continue using  c \u00a0to refer to the size of computational resources (including computation, bandwidth and storage) available to each node, and  n \u00a0to refer to the size of the ecosystem in some abstract sense; we assume that transaction load, state size, and the market cap of a cryptocurrency are all proportional to  n .", 
            "title": "This sounds like there\u2019s some kind of scalability trilemma at play. What is this trilemma and can we break through it?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#some-people-claim-that-because-of-metcalfes-law-the-market-cap-of-a-cryptocurrency-should-be-proportional-to-n2-and-not-n-do-they-have-a-point", 
            "text": "No.", 
            "title": "Some people claim that because of Metcalfe\u2019s law, the market cap of a cryptocurrency should be proportional to n\\^2, and not n. Do they have a point?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#why-not", 
            "text": "Metcalfe\u2019s law claims that the value of a network is proportional to the square of the number of users (n^2), because if a network has n users then the network has value for each user, but then the value for each individual user is itself proportional to the number of users because if a network has n users that\u2019s n-1 potential connections through the network that each individual user could benefit from.  In practice,  empirical research suggests \u00a0that the value of a network with n users is close to \u201cn^2\u00a0proportionality for small values of n and (n \u00d7 log n) proportionality for large values of n.\u201d This makes sense because for small values, the argument holds true, but once a system gets bigger, two effects slow the growth down. First, growth in practice often happens in communities, and so in a medium-scale network the network often already provides most of the connections that each user cares about. Second, connections are often substitutes from each other, and you could argue that people only derive \\~O(log(k)) value from having k connections \u2013 having 23 brands of deodorant to choose from is nice, but it\u2019s not that much better than having 22 choices, whereas the difference between one choice and zero choices is very significant.  Furthermore, even if the value of a cryptocurrency is proportional to O(k * log(k)) with k users, if we accept the above explanation as the reason why this is the case, then that also implies that transaction volume is also O(k * log(k)), as the log(k) value per user theoretically comes from that user exercising log(k) connections through the network, and state size should also in many cases grow with O(k * log(k)) as there are at least some kinds of state that are relationship-specific rather than user-specific. Hence, assuming n = O(k * log(k)) and basing everything off of  n \u00a0(size of the ecosystem) and  c \u00a0(a single node\u2019s computing power) is a perfectly fine model for us to use.", 
            "title": "Why not?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-some-moderately-simple-but-only-partial-ways-of-solving-the-scalability-problem", 
            "text": "Many sharding proposals (eg.  this early BFT sharding proposal from Loi Luu et al at NUS , as well as  this Merklix tree 1  approach that has been suggested for Bitcoin) attempt to either only shard transaction processing or only shard state, without touching the other 2 . These efforts are admirable and may lead to some gains in efficiency, but they run into the fundamental problem that they only solve one of the two bottlenecks. We want to be able to process 10,000+ transactions per second without either forcing every node to be a supercomputer or\u00a0forcing every node to store a terabyte of state data, and this requires a comprehensive solution where the workloads of state storage, transaction processing and even transaction downloading and re-broadcasting are all spread out across nodes.  Particularly, note that this requires changes at the P2P level, as a broadcast model is not scalable since it requires every node to download and re-broadcast O(n) data (every transaction that is being sent), whereas our decentralization criterion assumes that every node only has access to O(c) resources of all kinds.", 
            "title": "What are some moderately simple but only partial ways of solving the scalability problem?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-about-approaches-that-do-not-try-to-shard-anything", 
            "text": "Bitcoin-NG \u00a0can increase scalability somewhat by means of an alternative blockchain design that makes it much safer for the network if nodes are spending large portions of their CPU time verifying blocks. In simple PoW blockchains, there are high centralization risks and the safety of consensus is weakened if capacity is increased to the point where more than about 5% of nodes\u2019 CPU time is spent verifying blocks; Bitcoin-NG\u2019s design alleviates this problem. However, this can only increase the scalability of transaction capacity by a constant factor of perhaps 5-50x 3 , 4 , and does not increase the scalability of state. That said, Bitcoin-NG-style approaches are not mutually exclusive with sharding, and the two can certainly be implemented at the same time.  Channel-based strategies (lightning network, Raiden, etc) can scale transaction capacity by a constant factor but cannot scale state storage, and also come with their own unique sets of tradeoffs and limitations particularly involving denial-of-service attacks; on-chain scaling via sharding (plus other techniques) and off-chain scaling via channels are arguably both necessary and complementary.  There exist approaches that use advanced cryptography, such as  Mimblewimble \u00a0and strategies based on ZK-SNARKs, to solve one specific part of the scaling problem: initial full node synchronization. Instead of verifying the entire history from genesis, nodes could verify a cryptographic proof that the current state legitimately follows from the history. These approaches do solve a legitimate problem, although it is worth noting that one can rely on cryptoeconomics instead of pure cryptography to solve the same problem in a much simpler way - see Ethereum\u2019s current implementations of  fast syncing  and  warp syncing . Neither solution does anything to alleviate state size growth or the limits of online transaction processing.", 
            "title": "What about approaches that do not try to \u201cshard\u201d anything?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-does-plasma-fit-into-the-trilemma", 
            "text": "In the event of a large attack on Plasma subchains, all users of the Plasma subchains would need to withdraw back to the root chain. If Plasma has O(N) users, then this will require O(N) transactions, and so O(N / C) time to process all of the withdrawals. If withdrawal delays are fixed to some D (ie. the naive implementation), then as soon as N   C * D, there will not be enough space in the blockchain to process all withdrawals in time, and so the system will be insecure; in this mode, Plasma should be viewed as increasing scalability only by a (possibly large) constant factor. If withdrawal delays are flexible, so they automatically extend if there are many withdrawals being made, then this means that as N increases further and further, the amount of time that an attacker can force everyone's funds to get locked up increases, and so the level of \"security\" of the system decreases further and further in a certain sense, as extended denial of access can be viewed as a security failure, albeit one milder than total loss of access. However, this is a different  direction  of tradeoff from other solutions, and arguably a much milder tradeoff, hence why Plasma subchains are nevertheless a large improvement on the status quo.", 
            "title": "How does Plasma fit into the trilemma?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#state-size-history-cryptoeconomics-oh-my-define-some-of-these-terms-before-we-move-further", 
            "text": "State : a set of information that represents the \u201ccurrent state\u201d of a system; determining whether or not a transaction is valid, as well as the effect of a transaction, should in the simplest model depend only on state. Examples of state data include the UTXO set in bitcoin, balances + nonces + code + storage in ethereum, and domain name registry entries in Namecoin.  History : an ordered list of all transactions that have taken place since genesis. In a simple model, the present state should be a deterministic function of the genesis state and the history.  Transaction : an object that goes into the history. In practice, a transaction represents an operation that some user wants to make, and is cryptographically signed.  State transition function : a function that takes a state, applies a transaction and outputs a new state. The computation involved may involve adding and subtracting balances from accounts specified by the transaction, verifying digital signatures and running contract code.  Merkle tree : a cryptographic hash tree structure that can store a very large amount of data, where authenticating each individual piece of data only takes O(log(n)) space and time. See  here \u00a0for details. In Ethereum, the transaction set of each block, as well as the state, is kept in a Merkle tree, where the roots of the trees are committed to in a block.  Receipt : an object that represents an effect of a transaction that is not stored in the state, but which is still stored in a Merkle tree and committed to in a block so that its existence can later be efficiently proven even to a node that does not have all of the data. Logs in Ethereum are receipts; in sharded models, receipts are used to facilitate asynchronous cross-shard communication.  Light client : a way of interacting with a blockchain that only requires a very small amount (we\u2019ll say O(1), though O(log(c)) may also be accurate in some cases) of computational resources, keeping track of only the block headers of the chain by default and acquiring any needed information about transactions, state or receipts by asking for and verifying Merkle proofs of the relevant data on an as-needed basis.  State root : the root hash of the Merkle tree representing the state 5     The Ethereum state tree, and how the state root fits into the block structure", 
            "title": "State size, history, cryptoeconomics, oh my! Define some of these terms before we move further!"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-is-the-basic-idea-behind-sharding", 
            "text": "We split the state up into K = O(n / c) partitions that we call \u201cshards\u201d. For example, a sharding scheme on Ethereum might put all addresses starting with 0x00 into one shard, all addresses starting with 0x01 into another shard, etc. In the simplest form of sharding, each shard also has its own transaction history, and the effect of transactions in some shard k are limited to the state of shard k. One simple example would be a multi-asset blockchain, where there are K shards and each shard stores the balances and processes the transactions associated with one particular asset. In more advanced forms of sharding, some form of cross-shard communication capability, where transactions on one shard can trigger events on other shards, is also included.", 
            "title": "What is the basic idea behind sharding?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-might-a-basic-design-of-a-sharded-blockchain-look-like", 
            "text": "A simple approach is as follows. There exist nodes called  collators  that accept transactions on shard  k  (depending on the protocol, collators either choose which  k  or are randomly assigned some  k ) and create  collations . A collation has a  collation header , a short message of the form \"This is a collation of transactions on shard  k . It expects the previous state root of shard  k  to be 0x12bc57, the Merkle root of the transactions in this collation is 0x3f98ea, and the state root after processing these transactions should be 0x5d0cc1. Signed, collators #1, 2, 4, 5, 6, 8, 11, 13 ... 98, 99\".  A block must then contain a collation header for each shard. A block is valid if:   The pre-state root given in each collation matches the current state root of the associated shard  All transactions in all collations are valid  The post-state root given in the collation matches the result of executing the transactions in the collation on top of the given pre-state  The collation is signed by at least two thirds of the collators registered for that shard   Note that there are now several \"levels\" of nodes that can exist in such a system:   Super-full node  - processes all transactions in all collations and maintains the full state for all shards.  Top-level node  - processes all top-level blocks, but does not process or try to download the transactions in each collation. Instead, it accepts it on faith that a collation is valid if two thirds of the collators in that shard say that it is valid.  Single-shard node  - acts as a top-level node, but also processes all transactions and maintains the full state for some specific shard.  Light node  - downloads and verifies the block headers of the top-level blocks only; does not process any collation headers or transactions unless it needs to read some specific entry in the state of some specific shard, in which case it downloads the Merkle branch to the most recent collation header for that shard and from there downloads the Merkle proof of the desired value in the state.", 
            "title": "What might a basic design of a sharded blockchain look like?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-the-challenges-here", 
            "text": "Cross shard communication  - the above design supports no cross-shard communication. How do we add cross-shard communication safely?  Single-shard takeover attacks  - what if an attacker takes over the majority of the collators in one single shard, either to prevent any collations from getting enough signatures or, worse, to submit collations that are invalid?  Fraud detection  - if an invalid collation does get made, how can nodes (including light nodes) be reliably informed of this so that they can verify the fraud and reject the collation if it is truly fraudulent?  The data availability problem  - as a subset of fraud detection, what about the specific case where data is missing from a collation?  Superquadratic sharding  - in the special case where n   c^2, in the simple design given above there would be more than O(c) collation headers, and so an ordinary node would not be able to process even just the top-level blocks. Hence, more than two levels of indirection between transactions and top-level block headers are required (ie. we need \"shards of shards\"). What is the simplest and best way to do this?   However, the effect of a transaction may depend on  events that earlier took place in other shards ; a canonical example is transfer of money, where money can be moved from shard i to shard j by first creating a \u201cdebit\u201d transaction that destroys coins in shard i, and then creating a \u201ccredit\u201d transaction that creates coins in shard j, pointing to a receipt created by the debit transaction as proof that the credit is legitimate.", 
            "title": "What are the challenges here?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#but-doesnt-the-cap-theorem-mean-that-fully-secure-distributed-systems-are-impossible-and-so-sharding-is-futile", 
            "text": "The CAP theorem is a result that has to do with  distributed consensus ; a simple statement is: \"in the cases that a network partition takes place, you have to choose either consistency or availability, you cannot have both\". The intuitive argument is simple: if the network splits in half, and in one half I send a transaction \"send my 10 coins to A\" and in the other I send a transaction \"send my 10 coins to B\", then either the system is unavailable, as one or both transactions will not be processed, or it becomes inconsistent, as one half of the network will see the first transaction completed and the other half will see the second transaction completed. Note that the CAP theorem has nothing to do with scalability; it applies to any situation where multiple nodes need to agree on a value, regardless of the amount of data that they are agreeing on. All existing decentralized systems have found some compromise between availability and consistency; sharding does not make anything fundamentally harder in this respect.", 
            "title": "But doesn't the CAP theorem mean that fully secure distributed systems are impossible, and so sharding is futile?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-can-we-facilitate-cross-shard-communication", 
            "text": "The easiest scenario to satisfy is one where there are very many applications that individually do not have too many users, and which only very occasionally and loosely interact with each other; in this case, applications can live on separate shards and use cross-shard communication via receipts to talk to each other.  This typically involves breaking up each transaction into a \"debit\" and a \"credit\". For example, suppose that we have a transaction where account A on shard M wishes to send 100 coins to account B on shard N. The steps would looks as follows:   Send a transaction on shard M which (i) deducts the balance of A by 100 coins, and (ii) creates a receipt. A receipt is an object which is not saved in the state directly, but where the fact that the receipt was generated can be verified via a Merkle proof.  Wait for the first transaction to be included (sometimes waiting for finalization is required; this depends on the system).  Send a transaction on shard N which includes the Merkle proof of the receipt from (1). This transaction also checks in the state of shard N to make sure that this receipt is \"unspent\"; if it is, then it increases the balance of B by 100 coins, and saves in the state that the receipt is spent.  Optionally, the transaction in (3) also saves a receipt, which can then be used to perform further actions on shard M that are contingent on the original operation succeeding.    In more complex forms of sharding, transactions may in some cases have effects that spread out across several shards and may also synchronously ask for data from the state of multiple shards.", 
            "title": "How can we facilitate cross-shard communication?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-can-different-kinds-of-applications-fit-into-a-sharded-blockchain", 
            "text": "Some applications require no cross-shard interaction at all; multi-asset blockchains, and blockchains with completely heterogeneous applications that require no interoperability, are the simplest cases. If applications do need to talk to each other, the challenge is much easier if the interaction can be made asynchronous - that is, if the interaction can be done in the form of the application on shard A generating a receipt, a transaction on shard B \u201cconsuming\u201d the receipt and performing some action based on it, and possibly sending a \u201ccallback\u201d to shard A containing some response. Generalizing this pattern is easy, and is not difficult to incorporate into a high-level programming language.  However, note that the in-protocol mechanisms that would be used for asynchronous cross-shard communication would be different and have weaker functionality compared to the mechanisms that are available for intra-shard communication. Some of the functionality that is currently available in non-scalable blockchains would, in a scalable blockchain, only be available for intra-shard communication. 7 .", 
            "title": "How can different kinds of applications fit into a sharded blockchain?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-is-the-train-and-hotel-problem", 
            "text": "The following example is courtesy of Andrew Miller. Suppose that a user wants to purchase a train ticket and reserve a hotel, and wants to make sure that the operation is atomic - either both reservations succeed or neither do. If the train ticket and hotel booking applications are on the same shard, this is easy: create a transaction that attempts to make both reservations, and throws an exception and reverts everything unless both reservations succeed. If the two are on different shards, however, this is not so easy; even without cryptoeconomic / decentralization concerns, this is essentially the problem of  atomic database transactions .  With asynchronous messages only, the simplest solution is to first reserve the train, then reserve the hotel, then once both reservations succeed confirm both; the reservation mechanism would prevent anyone else from reserving (or at least would ensure that enough spots are open to allow all reservations to be confirmed) for some period of time. However, this means that the mechanism relies on an extra security assumptions: that cross-shard messages from one shard can get included in another shard within some fixed period of time.  With cross-shard synchronous transactions, the problem is easier, but the challenge of creating a sharding solution capable of making cross-shard atomic synchronous transactions is itself decidedly nontrivial.  If an individual application has more than O(c) usage, then that application would need to exist across multiple chains. The feasibility of doing this depends on the specifics of the application itself; some applications (eg. currencies) are easily parallelizable, whereas others (eg. certain kinds of market designs) cannot be parallelized and must be processed serially.  There are properties of sharded blockchains that we know for a fact are impossible to achieve.  Amdahl\u2019s law \u00a0states that in any scenario where applications have any non-parallelizable component, once parallelization is easily available the non-parallelizable component quickly becomes the bottleneck. In a general computation platform like Ethereum, it is easy to come up with examples of non-parallelizable computation: a contract that keeps track of an internal value x and sets x = sha3(x, tx_data) upon receiving a transaction is a simple example. No sharding scheme can give individual applications of this form more than O(c) performance. Hence, it is likely that over time sharded blockchain protocols will get better and better at being able to handle a more and more diverse set of application types and application interactions, but a sharded architecture will always necessarily fall behind a single-shard architecture in at least some ways at scales exceeding O(c).", 
            "title": "What is the train-and-hotel problem?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-the-security-models-that-we-are-operating-under", 
            "text": "There are several competing models under which the safety of blockchain designs is evaluated:   Honest majority  (or honest supermajority): we assume that there is some set of validators and up to \u00bd (or \u2153 or \u00bc) of those validators are controlled by an attacker, and the remaining validators honestly follow the protocol  Uncoordinated majority : we assume that all validators are rational in a game-theoretic sense (except the attacker, who is motivated to make the network fail in some way), but no more than some fraction (often between \u00bc and \u00bd) are capable of coordinating their actions.  Coordinated choice : we assume that all validators are controlled by the same actor, or are fully capable of coordinating on the economically optimal choice between themselves. We can talk about the  cost to the coalition  (or profit to the coalition) of achieving some undesirable outcome.  Bribing attacker model : we take the uncoordinated majority model, but instead of making the attacker be one of the participants, the attacker sits outside the protocol, and has the ability to bribe any participants to change their behavior. Attackers are modeled as having a  budget , which is the maximum that they are willing to pay, and we can talk about their  cost , the amount that they  end up paying  to disrupt the protocol equilibrium.   Bitcoin proof of work with  Eyal and Sirer\u2019s selfish mining fix \u00a0is robust up to \u00bd under the honest majority assumption, and up to \u00bc under the uncoordinated majority assumption.  Schellingcoin  is robust up to \u00bd under the honest majority and uncoordinated majority assumptions, has \u03b5 (ie. slightly more than zero) cost of attack in a coordinated choice model, and has a P + \u03b5 budget requirement and \u03b5 cost in a bribing attacker model due to  P + epsilon attacks .  Hybrid models also exist; for example, even in the coordinated choice and bribing attacker models, it is common to make an  honest minority assumption  that some portion (perhaps 1-15%) of validators will act altruistically regardless of incentives. We can also talk about coalitions consisting of between 50-99% of validators either trying to disrupt the protocol or harm other validators; for example, in proof of work, a 51%-sized coalition can double its revenue by refusing to include blocks from all other miners.  The honest majority model is arguably highly unrealistic and has already been empirically disproven - see Bitcoin's  SPV mining fork \u00a0for a practical example. It proves too much: for example, an honest majority model would imply that honest miners are willing to voluntarily burn their own money if doing so punishes attackers in some way. The uncoordinated majority assumption may be realistic; there is also an intermediate model where the majority of nodes is honest but has a budget, so they shut down if they start to lose too much money.  The bribing attacker model has in some cases been criticized as being unrealistically adversarial, although its proponents argue that if a protocol is designed with the bribing attacker model in mind then it should be able to massively reduce the cost of consensus, as 51% attacks become an event that could be recovered from. We will evaluate sharding in the context of both uncoordinated majority and bribing attacker models.", 
            "title": "What are the security models that we are operating under?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-can-we-solve-the-single-shard-takeover-attack-in-an-uncoordinated-majority-model", 
            "text": "In short, random sampling. Each shard is assigned a certain number of collators (eg. 150), and the collators that approve blocks on each shard are taken from the sample for that shard. Samples can be reshuffled either semi-frequently (eg. once every 12 hours) or maximally frequently (ie. there is no real independent sampling process, collators are randomly selected for each shard from a global pool every block).  The result is that even though only a few nodes are verifying and creating blocks on each shard at any given time, the level of security is in fact not much lower, in an honest/uncoordinated majority model, than what it would be if every single node was verifying and creating blocks. The reason is simple statistics: if you assume a \u2154 honest supermajority on the global set, and if the size of the sample is 150, then with 99.999% probability the honest majority condition will be satisfied on the sample. If you assume a \u00be honest supermajority on the global set, then that probability increases to 99.999999998% (see  here \u00a0for calculation details).  Hence, at least in the honest / uncoordinated majority setting, we have:   Decentralization  (each node stores only O(c) data, as it\u2019s a light client in O(c) shards and so stores O(1) * O(c) = O(c) data worth of block headers, as well as O(c) data corresponding to the full state and recent history of one or several shards that it is assigned to at the present time)  Scalability  (with O(c) shards, each shard having O(c) capacity, the maximum capacity is n = O(c\\^2))  Security  (attackers need to control at least \u2153 of the entire O(n)-sized validator pool in order to stand a chance of taking over the network).   In the Zamfir model (or alternatively, in the \u201cvery very adaptive adversary\u201d model), things are not so easy, but we will get to this later. Note that because of the imperfections of sampling, the security threshold does decrease from \u00bd to \u2153, but this is still a surprisingly low loss of security for what may be a 100-1000x gain in scalability with no loss of decentralization.", 
            "title": "How can we solve the single-shard takeover attack in an uncoordinated majority model?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-do-you-actually-do-this-sampling-in-proof-of-work-and-in-proof-of-stake", 
            "text": "In proof of stake, it is easy. There already is an \u201cactive validator set\u201d that is kept track of in the state, and one can simply sample from this set directly. Either an in-protocol algorithm runs and chooses 150 validators for each shard, or each validator independently runs an algorithm that uses a common source of randomness to (provably) determine which shard they are at any given time. Note that it is very important that the sampling assignment is \u201ccompulsory\u201d; validators do not have a choice of what shard they go into. If validators could choose, then attackers with small total stake could concentrate their stake onto one shard and attack it, thereby eliminating the system\u2019s security.  In proof of work, it is more difficult, as with \u201cdirect\u201d proof of work schemes one cannot prevent miners from applying their work to a given shard. It may be possible to use  proof-of-file-access forms  of proof of work to lock individual miners to individual shards, but it is hard to ensure that miners cannot quickly download or generate data that can be used for other shards and thus circumvent such a mechanism. The best known approach is through a technique invented by Dominic Williams called \u201cpuzzle towers\u201d, where miners first perform proof of work on a common chain, which then inducts them into a proof of stake-style validator pool, and the validator pool is then sampled just as in the proof-of-stake case.  One possible intermediate route might look as follows. Miners can spend a large (O(c)-sized) amount of work to create a new \u201ccryptographic identity\u201d. The precise value of the proof of work solution then chooses which shard they have to make their next block on. They can then spend an O(1)-sized amount of work to create a block on that shard, and the value of that\u00a0proof of work solution determines which shard they can work on next, and so on 8 . Note that all of these approaches make proof of work \u201cstateful\u201d in some way; the necessity of this is fundamental.", 
            "title": "How do you actually do this sampling in proof of work, and in proof of stake?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-the-tradeoffs-in-making-sampling-more-or-less-frequent", 
            "text": "Selection frequency affects just how adaptive adversaries can be for the protocol to still be secure against them; for example, if you believe that an adaptive attack (eg. dishonest validators who discover that they are part of the same sample banding together and colluding) can happen in 6 hours but not less, then you would be okay with a sampling time of 4 hours but not 12 hours. This is an argument in favor of making sampling happen as quickly as possible.  The main challenge with sampling taking place every block is that reshuffling carries a very high amount of overhead. Specifically, verifying a block on a shard requires knowing the state of that shard, and so every time validators are reshuffled, validators need to download the entire state for the new shard(s) that they are in. This requires both a strong state size control policy (ie. economically ensuring that the size of the state does not grow too large, whether by deleting old accounts, restricting the rate of creating new accounts or a combination of the two) and a fairly long reshuffling time to work well.  Currently, the Parity client can download and verify a full Ethereum state snapshot via \u201cwarp-sync\u201d in \\~3 minutes; if we increase by 20x to compensate for increased usage (10 tx/sec instead of the current 0.5 tx/sec) (we\u2019ll assume future state size control policies and \u201cdust\u201d accumulated from longer-term usage roughly cancel out) , we get \\~60 minute state sync time, suggesting that sync periods of 12-24 hours but not less are safe.  There are two possible paths to overcoming this challenge.", 
            "title": "What are the tradeoffs in making sampling more or less frequent?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#can-we-force-more-of-the-state-to-be-held-user-side-so-that-transactions-can-be-validated-without-requiring-validators-to-hold-all-state-data", 
            "text": "The techniques here tend to involve requiring users to store state data and provide Merkle proofs along with every transaction that they send. A transaction would be sent along with a Merkle proof-of-correct-execution, and this proof would allow a node that only has the state root to calculate the new state root. This proof-of-correct-execution would consist of the subset of objects in the trie that would need to be traversed to access and verify the state information that the transaction must verify; because Merkle proofs are O(log(n)) sized, the proof for a transaction that accesses a constant number of objects would also be O(log(n)) sized.    The subset of objects in a Merkle tree that would need to be provided in a Merkle proof of a transaction that accesses several state objects  Implementing this scheme in its pure form has two flaws. First, it introduces O(log(n)) overhead, although one could argue that this O(log(n)) overhead is not as bad as it seems because it ensures that the validator can always simply keep state data in memory and thus it never needs to deal with the overhead of accessing the hard drive 9 . Second, it can easily be applied if the addresses that are accessed by a transaction are static, but is more difficult to apply if the addresses in question are dynamic - that is, if the transaction execution has code of the form  read(f(read(x)))  where the address\u00a0of some state read depends on the execution result of some other state read. In this case, the address that the transaction sender thinks the transaction will be reading at the time that they send the transaction may well differ from the address that is actually read when the transaction is included in a block, and so the Merkle proof may be insufficient 10 .  A compromise approach is to allow transaction senders to send a proof that incorporates the most likely possibilities for what data would be accessed; if the proof is sufficient, then the transaction will be accepted, and if the state unexpectedly changes and the proof is insufficient then either the sender must resend or some helper node in the network resends the transaction adding the correct proof. Developers would then be free to make transactions that have dynamic behavior, but the more dynamic the behavior gets the less likely transactions would be to actually get included into blocks.  Note that validators\u2019 transaction inclusion strategies under this approach would need to be complicated, as they may spend millions of gas processing a transaction only to realize that the last step accesses some state entry that they do not have. One possible compromise is for validators to have a strategy that accepts only (i) transactions with very low gas costs, eg. \\ 100k, and (ii) transactions that statically specify a set of contracts that they are allowed to access, and contain proofs for the entire state of those contracts. Note that this only applies when transactions are initially broadcasted; once a transaction is included into a block, the order of execution is fixed, and so only the minimal Merkle proof corresponding to the state that actually needs to be accessed can be provided.  If validators are not reshuffled immediately, there is one further opportunity to increase efficiency. We can expect validators to store data from proofs of transactions that have already been processed, so that that data does not need to be sent again; if k transactions are sent within one reshuffling period, then this decreases the average size of a Merkle proof from log(n) to log(n) - log(k).", 
            "title": "Can we force more of the state to be held user-side so that transactions can be validated without requiring validators to hold all state data?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-is-the-randomness-for-random-sampling-generated", 
            "text": "First of all, it is important to note that even if random number generation is heavily exploitable, this is not a fatal flaw for the protocol; rather, it simply means that there is a medium to high centralization incentive. The reason is that because the randomness is picking fairly large samples, it is difficult to bias the randomness by more than a certain amount.  The simplest way to show this is through the  binomial distribution , as described above; if one wishes to avoid a sample of size N being more than 50% corrupted by an attacker, and an attacker has p% of the global stake pool, the chance of the attacker being able to get such a majority during one round is:   Here\u2019s a table for what this probability would look like in practice for various values of N and p:          N = 50       N = 100      N = 150      N = 250          p = 0.4      0.0978       0.0271       0.0082       0.0009           p = 0.33     0.0108       0.0004       1.83 * 10-5     3.98 * 10-8         p = 0.25     0.0001       6.63 * 10 -8      4.11 * 10 -11     1.81 * 10-17   <      p = 0.2      2.09 * 10 -6      2.14 * 10 -11     2.50 * 10 -16     3.96 * 10 -26       Hence, for N  = 150, the chance that any given random seed will lead to a sample favoring the attacker is very small indeed 11 , 12 .\u00a0What this means from the perspective of security of randomness is that the attacker needs to have a very large amount of freedom in choosing the random values order to break the sampling process outright. Most vulnerabilities in proof-of-stake randomness do not allow the attacker to simply choose a seed; at worst, they give the attacker many chances to select the most favorable seed out of many pseudorandomly generated options. If one is very worried about this, one can simply set N to a greater value, and add a moderately hard key-derivation function to the process of computing the randomness, so that it takes more than 2 100 \u00a0computational steps to find a way to bias the randomness sufficiently.  Now, let\u2019s look at the risk of attacks being made that try to influence the randomness more marginally, for purposes of profit rather than outright takeover. \u00a0For example, suppose that there is an algorithm which pseudorandomly selects 1000 validators out of some very large set (each validator getting a reward of $1), an attacker has 10% of the stake so the attacker\u2019s average \u201chonest\u201d revenue 100, and at a cost of $1 the attacker can manipulate the randomness to \u201cre-roll the dice\u201d (and the attacker can do this an unlimited number of times).  Due to the  central limit theorem , the standard deviation of the number of samples, and based  on other known results in math \u00a0the expected maximum of N random samples is slightly under M + S * sqrt(2 * log(N)) where M is the mean and S is the standard deviation. Hence the reward for manipulating the randomness and effectively re-rolling the dice (ie. increasing N) drops off sharply, eg. with 0 re-trials your expected reward is $100, with one re-trial it's $105.5, with two it's $108.5, with three it's $110.3, with four it's $111.6, with five it's $112.6 and with six it's $113.5. Hence, after five retrials it stops being worth it. As a result, an economically motivated attacker with ten percent of stake will (socially wastefully) spend $5 to get an additional revenue of $13, for a net surplus of $8.  However, this kind of logic assumes that one single round of re-rolling the dice is expensive. Many older proof of stake algorithms have a \u201cstake grinding\u201d vulnerability where re-rolling the dice simply means making a computation locally on one\u2019s computer; algorithms with this vulnerability are certainly unacceptable in a sharding context. Newer algorithms (see the \u201cvalidator selection\u201d section in the  proof of stake FAQ ) have the property that re-rolling the dice can only be done by voluntarily giving up one\u2019s spot in the block creation process, which entails giving up rewards and fees. The best way to mitigate the impact of marginal economically motivated attacks on sample selection is to find ways to increase this cost. One method to increase the cost by a factor of sqrt(N) from N rounds of voting is the  majority-bit method devised by Iddo Bentov ; the Mauve Paper\u2019s sharding algorithm expects to use this approach.  Another form of random number generation that is not exploitable by minority coalitions is the deterministic threshold signature approach most researched and advocated by Dominic Williams. The strategy here is to use a  deterministic threshold signature \u00a0to generate the random seed from which samples are selected. Deterministic threshold signatures have the property that the value is guaranteed to be the same regardless of which of a given set of participants provides their data to the algorithm, provided that at least \u2154 of participants do participate honestly. This approach is more obviously not economically exploitable and fully resistant to all forms of stake-grinding, but it has several weaknesses:   It relies on more complex cryptography  (specifically, elliptic curves and pairings). Other approaches rely on nothing but the random-oracle assumption for common hash algorithms.  It fails when many validators are offline . A desired goal for public blockchains is to be able to survive very large portions of the network simultaneously disappearing, as long as a majority of the remaining nodes is honest; deterministic threshold signature schemes at this point cannot provide this property.  It\u2019s not secure in a Zamfir model  where more than \u2154 of validators are colluding. The other approaches described in the proof of stake FAQ above still make it expensive to manipulate the randomness, as data from all\u00a0validators is mixed into the seed and making any manipulation requires either universal collusion or excluding other validators outright.   One might argue that the deterministic threshold signature approach works better in consistency-favoring contexts and other approaches work better in availability-favoring contexts.", 
            "title": "How is the randomness for random sampling generated?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-the-concerns-about-sharding-through-random-sampling-in-a-bribing-attacker-or-coordinated-choice-model", 
            "text": "In a bribing attacker or coordinated choice model, the fact that validators are randomly sampled doesn\u2019t matter: whatever the sample is, either the attacker can bribe the great majority of the sample to do as the attacker pleases, or the attacker controls a majority of the sample directly and can direct the sample to perform arbitrary actions at low cost (O(c) cost, to be precise).  At that point, the attacker has the ability to conduct 51% attacks against that sample. The threat is further magnified because there is a risk of cross-shard contagion: if the attacker corrupts the state of a shard, the attacker can then start to send unlimited quantities of funds out to other shards and perform other cross-shard mischief. All in all, security in the bribing attacker or coordinated choice model is not much better than that of simply creating O(c) altcoins.", 
            "title": "What are the concerns about sharding through random sampling in a bribing attacker or coordinated choice model?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-can-we-improve-on-this", 
            "text": "Basically, by comprehensively solving the problem of fraud detection.  One major category of solution to this problem is the use of challenge-response mechanisms. Challenge-response mechanisms generally rely on a principle of escalation: fact X (eg. \"collation #17293 in shard #54 is valid\") is initially accepted as true if at least k validators sign a claim (backed by a deposit) that it is. However, if this happens, there is some challenge period during which 2k validators can sign a claim stating that it is false. If this happens, 4k validators can sign a claim stating that the claim is in fact true, and so forth until one side either gives up or most validators have signed claims, at which point every validator and client themselves checks whether or not X is true. If X is ruled true, everyone who made a claim saying so is rewarded and everyone who made a contradictory claim is penalized, and vice versa.  Looking at this mechanism, you can prove that malicious actors lose an amount of money proportional to the number of actors that they forced to look at the given piece of data. Forcing  all  users to look at the data requires a large portion of validators to sign a claim which is false, which can be used to penalize all of them, so the cost of forcing all users to look at a piece of data is O(n); this prevents the challenge-response mechanism from being used as a denial-of-service vector.", 
            "title": "How can we improve on this?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-is-the-data-availability-problem-and-how-can-we-use-erasure-codes-to-solve-it", 
            "text": "See https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding", 
            "title": "What is the data availability problem, and how can we use erasure codes to solve it?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#can-we-remove-the-need-to-solve-data-availability-with-some-kind-of-fancy-cryptographic-accumulator-scheme", 
            "text": "No. Suppose there is a scheme where there exists an object S representing the state (S could possibly be a hash) possibly as well as auxiliary information (\"witnesses\") held by individual users that can prove the presence of existing state objects (eg. S is a Merkle root, the witnesses are the branches, though other constructions like RSA accumulators do exist). There exists an updating protocol where some data is broadcasted, and this data changes S to change the contents of the state, and also possibly changes witnesses.  Suppose some user has the witnesses for a set of N objects in the state, and M of the objects are updated. After receiving the update information, the user can check the new status of all N objects, and thereby see which M were updated. Hence, the update information itself encoded at least ~M * log(N) bits of information. Hence, the update information that everyone needs for receive to implement the effect of M transactions must necessarily be of size O(M).  14", 
            "title": "Can we remove the need to solve data availability with some kind of fancy cryptographic accumulator scheme."
        }, 
        {
            "location": "/Research/Sharding-FAQ/#so-this-means-that-we-can-actually-create-scalable-sharded-blockchains-where-the-cost-of-making-anything-bad-happen-is-proportional-to-the-size-of-the-entire-validator-set", 
            "text": "There is one trivial attack by which an attacker can always burn O(c) capital to temporarily reduce the quality of a shard: spam it by sending transactions with high transaction fees, forcing legitimate users to outbid you to get in. This attack is unavoidable; you could compensate with flexible gas limits, and you could even try \u201ctransparent sharding\u201d schemes that try to automatically re-allocate nodes to shards based on usage, but if some particular application is non-parallelizable, Amdahl\u2019s law guarantees that there is nothing you can do. The attack that is opened up here (reminder: it only works in the Zamfir model, not honest/uncoordinated majority) is arguably not substantially worse than the transaction spam attack. Hence, we've reached the known limit for the security of a single shard, and there is no value in trying to go further.", 
            "title": "So this means that we can actually create scalable sharded blockchains where the cost of making anything bad happen is proportional to the size of the entire validator set?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#lets-walk-back-a-bit-do-we-actually-need-any-of-this-complexity-if-we-have-instant-shuffling-doesnt-instant-shuffling-basically-mean-that-each-shard-directly-pulls-validators-from-the-global-validator-pool-so-it-operates-just-like-a-blockchain-and-so-sharding-doesnt-actually-introduce-any-new-complexities", 
            "text": "Kind of. First of all, it\u2019s worth noting that proof of work and simple proof of stake, even without sharding, both have very low security in a bribing attacker model; a block is only truly \u201cfinalized\u201d in the economic sense after O(n) time (as if only a few blocks have passed, then the economic cost of replacing the chain is simply the cost of starting a double-spend from before the block in question). Casper solves this problem by adding its finality mechanism, so that the economic security margin immediately increases to the maximum. In a sharded chain, if we want economic finality then we need to come up with a chain of reasoning for why a validator would be willing to make a very strong claim on a chain based solely on a random sample, when the validator itself is convinced that the bribing attacker and coordinated choice models may be true and so the random sample could potentially be corrupted.", 
            "title": "Let\u2019s walk back a bit. Do we actually need any of this complexity if we have instant shuffling? Doesn\u2019t instant shuffling basically mean that each shard directly pulls validators from the global validator pool so it operates just like a blockchain, and so sharding doesn\u2019t actually introduce any new complexities?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#you-mentioned-transparent-sharding-im-12-years-old-and-what-is-this", 
            "text": "Basically, we do not expose the concept of \u201cshards\u201d directly to developers, and do not permanently assign state objects to specific shards. Instead, the protocol has an ongoing built-in load-balancing process that shifts objects around between shards. If a shard gets too big or consumes too much gas it can be split in half; if two shards get too small and talk to each other very often they can be combined together; if all shards get too small one shard can be deleted and its contents moved to various other shards, etc.  Imagine if Donald Trump realized that people travel between New York and London a lot, but there\u2019s an ocean in the way, so he could just take out his scissors, cut out the ocean, glue the US east coast and Western Europe together and put the Atlantic beside the South Pole - it\u2019s kind of like that.", 
            "title": "You mentioned transparent sharding. I\u2019m 12 years old and what is this?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-some-advantages-and-disadvantages-of-this", 
            "text": "Developers no longer need to think about shards  There\u2019s the possibility for shards to adjust manually to changes in gas prices, rather than relying on market mechanics to increase gas prices in some shards more than others  There is no longer a notion of reliable co-placement: if two contracts are put into the same shard so that they can interact with each other, shard changes may well end up separating them  More protocol complexity   The co-placement problem can be mitigated by introducing a notion of \u201csequential domains\u201d, where contracts may specify that they exist in the same sequential domain, in which case synchronous communication between them will always be possible. In this model a shard can be viewed as a set of sequential domains that are validated together, and where sequential domains can be rebalanced between shards if the protocol determines that it is efficient to do so.", 
            "title": "What are some advantages and disadvantages of this?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#how-would-synchronous-cross-shard-messages-work", 
            "text": "The process becomes much easier if you view the transaction history as being already settled, and are simply trying to calculate the state transition function. There are several approaches; one fairly simple approach can be described as follows:   A transaction may specify a set of shards that it can operate in  In order for the transaction to be effective, it must be included at the same block height in all of these shards.  Transactions within a block must be put in order of their hash (this ensures a canonical order of execution)   A client on shard X, if it sees a transaction with shards (X, Y), requests a Merkle proof from shard Y verifying (i) the presence of that transaction on shard Y, and (ii) what the pre-state on shard Y is for those bits of data that the transaction will need to access. It then executes the transaction and commits to the execution result. Note that this process may be highly inefficient if there are many transactions with many different \u201cblock pairings\u201d in each block; for this reason, it may be optimal to simply require blocks to specify sister shards, and then calculation can be done more efficiently at a per-block level. This is the basis for how such a scheme could work; one could imagine more complex designs. However, when making a new design, it\u2019s always important to make sure that low-cost denial of service attacks cannot arbitrarily slow state calculation down.", 
            "title": "How would synchronous cross-shard messages work?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-about-semi-asynchronous-messages", 
            "text": "Vlad Zamfir created a scheme by which asynchronous messages could still solve the \u201cbook a train and hotel\u201d problem. This works as follows. The state keeps track of all operations that have been recently made, as well as the graph of which operations were triggered by any given operation (including cross-shard operations). If an operation is reverted, then a receipt is created which can then be used to revert any effect of that operation on other shards; those reverts may then trigger their own reverts and so forth. The argument is that if one biases the system so that revert messages can propagate twice as fast as other kinds of messages, then a complex cross-shard transaction that finishes executing in K rounds can be fully reverted in another K rounds.  The overhead that this scheme would introduce has arguably not been sufficiently studied; there may be worst-case scenarios that trigger quadratic execution vulnerabilities. It is clear that if transactions have effects that are more isolated from each other, the overhead of this mechanism is lower; perhaps isolated executions can be incentivized via favorable gas cost rules. All in all, this is one of the more promising research directions for advanced sharding.", 
            "title": "What about semi-asynchronous messages?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-guaranteed-cross-shard-calls", 
            "text": "One of the challenges in sharding is that when a call is made, there is by default no hard protocol-provided guarantee that any asynchronous operations created by that call will be made within any particular timeframe, or even made at all; rather, it is up to some party to send a transaction in the destination shard triggering the receipt. This is okay for many applications, but in some cases it may be problematic for several reasons:   There may be no single party that is clearly incentivized to trigger a given receipt. If the sending of a transaction benefits many parties, then there could be  tragedy-of-the-commons effects  where the parties try to wait longer until someone else sends the transaction (ie. play \"chicken\"), or simply decide that sending the transaction is not worth the transaction fees for them individually.  Gas prices across shards may be volatile , and in some cases performing the first half of an operation compels the user to \u201cfollow through\u201d on it, but the user may have to end up following through at a much higher gas price. This may be exacerbated by DoS attacks and related forms of  griefing .  Some applications rely on there being an upper bound on the \u201clatency\u201d of cross-shard messages (eg. the train-and-hotel example). Lacking hard guarantees, such applications would have to have  inefficiently large safety margins .   One could try to come up with a system where asynchronous messages made in some shard automatically trigger effects in their destination shard after some number of blocks. However, this requires every client on each shard to actively inspect all other shards in the process of calculating the state transition function, which is arguably a source of inefficiency. The best known compromise approach is this: when a receipt from shard A at height  height_a \u00a0is included in shard B at height  height_b , if the difference in block heights exceeds  MAX_HEIGHT , then all validators in shard B that created blocks from  height_a + MAX_HEIGHT + 1 \u00a0to  height_b - 1 \u00a0are penalized, and this penalty increases exponentially. A portion of these penalties is given to the validator that finally includes the block as a reward. This keeps the state transition function simple, while still strongly incentivizing the correct behavior.", 
            "title": "What are guaranteed cross-shard calls?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#wait-but-what-if-an-attacker-sends-a-cross-shard-call-from-every-shard-into-shard-x-at-the-same-time-wouldnt-it-be-mathematically-impossible-to-include-all-of-these-calls-in-time", 
            "text": "Correct; this is a problem. Here is a proposed solution. In order to make a cross-shard call from shard A to shard B, the caller must pre-purchase \u201ccongealed shard B gas\u201d (this is done via a transaction in shard B, and recorded in shard B). Congealed shard B gas has a fast demurrage rate: once ordered, it loses 1/k of its remaining potency every block. A transaction on shard A can then send the congealed shard B gas along with the receipt that it creates, and it can be used on shard B for free. Shard B blocks allocate extra gas space specifically for these kinds of transactions. Note that because of the demurrage rules, there can be at most GAS_LIMIT * k worth of congealed gas for a given shard available at any time, which can certainly be filled within k blocks (in fact, even faster due to demurrage, but we may need this slack space due to malicious validators). In case too many validators maliciously fail to include receipts, we can make the penalties fairer by exempting validators who fill up the \u201creceipt space\u201d of their blocks with as many receipts as possible, starting with the oldest ones.  Under this pre-purchase mechanism, a user that wants to perform a cross-shard operation would first pre-purchase gas for all shards that the operation would go into, over-purchasing to take into account the demurrage. If the operation would create a receipt that triggers an operation that consumes 100000 gas in shard B, the user would pre-buy 100000 * e (ie. 271818) shard-B congealed gas. If that operation would in turn spend 100000 gas in shard C (ie. two levels of indirection), the user would need to pre-buy 100000 * e\\^2 (ie. 738906) shard-C congealed gas. Notice how once the purchases are confirmed, and the user starts the main operation, the user can be confident that they will be insulated from changes in the gas price market, unless validators voluntarily lose large quantities of money from receipt non-inclusion penalties.", 
            "title": "Wait, but what if an attacker sends a cross-shard call from every shard into shard X at the same time? Wouldn\u2019t it be mathematically impossible to include all of these calls in time?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#congealed-gas-this-sounds-interesting-for-not-just-cross-shard-operations-but-also-reliable-intra-shard-scheduling", 
            "text": "Indeed; you could buy congealed shard A gas inside of shard A, and send a guaranteed cross-shard call from shard A to itself. Though note that this scheme would only support scheduling at very short time intervals, and the scheduling would not be exact to the block; it would only be guaranteed to happen within some period of time.", 
            "title": "Congealed gas? This sounds interesting for not just cross-shard operations, but also reliable intra-shard scheduling"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#does-guaranteed-scheduling-both-intra-shard-and-cross-shard-help-against-majority-collusions-trying-to-censor-transactions", 
            "text": "Yes. If a user fails to get a transaction in because colluding validators are filtering the transaction and not accepting any blocks that include it, then the user could send a series of messages which trigger a chain of guaranteed scheduled messages, the last of which reconstructs the transaction inside of the EVM and executes it. Preventing such circumvention techniques is practically impossible without shutting down the guaranteed scheduling feature outright and greatly restricting the entire protocol, and so malicious validators would not be able to do it easily.", 
            "title": "Does guaranteed scheduling, both intra-shard and cross-shard, help against majority collusions trying to censor transactions?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#could-sharded-blockchains-do-a-better-job-of-dealing-with-network-partitions", 
            "text": "The schemes described in this document would offer no improvement over non-sharded blockchains; realistically, every shard would end up with some nodes on both sides of the partition. There have been calls (eg. from  IPFS\u2019s Juan Benet ) for building scalable networks with the specific goal that networks can split up into shards as needed and thus continue operating as much as possible under network partition conditions, but there are nontrivial cryptoeconomic challenges in making this work well.  One major challenge is that if we want to have location-based sharding so that geographic network partitions minimally hinder intra-shard cohesion (with the side effect of having very low intra-shard latencies and hence very fast intra-shard block times), then we need to have a way for validators to choose which shards they are participating in. This is dangerous, because it allows for much larger classes of attacks in the honest/uncoordinated majority model, and hence cheaper attacks with higher griefing factors in the Zamfir model. Sharding for geographic partition safety and sharding via random sampling for efficiency are two fundamentally different things.  Second, more thinking would need to go into how applications are organized. A likely model in a sharded blockchain as described above is for each \u201capp\u201d to be on some shard (at least for small-scale apps); however, if we want the apps themselves to be partition-resistant, then it means that all apps would need to be cross-shard to some extent.  One possible route to solving this is to create a platform that offers both kinds of shards - some shards would be higher-security \u201cglobal\u201d shards that are randomly sampled, and other shards would be lower-security \u201clocal\u201d shards that could have properties such as ultra-fast block times and cheaper transaction fees. Very low-security shards could even be used for data-publishing and messaging.", 
            "title": "Could sharded blockchains do a better job of dealing with network partitions?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#what-are-the-unique-challenges-of-pushing-scaling-past-n-oc2", 
            "text": "There are several considerations. First, the algorithm would need to be converted from a two-layer algorithm to a stackable n-layer algorithm; this is possible, but is complex. Second, n / c (ie. the ratio between the total computation load of the network and the capacity of one node) is a value that happens to be close to two constants: first, if measured in blocks, a timespan of several hours, which is an acceptable \u201cmaximum security confirmation time\u201d, and second, the ratio between rewards and deposits (an early computation suggests a 32 ETH deposit size and a 0.05 ETH block reward for Casper). The latter has the consequence that if rewards and penalties on a shard are escalated to be on the scale of validator deposits, the cost of continuing an attack on a shard will be O(n) in size.  Going above c\\^2 would likely entail further weakening the kinds of security guarantees that a system can provide, and allowing attackers to attack individual shards in certain ways for extended periods of time at medium cost, although it should still be possible to prevent invalid state from being finalized and to prevent finalized state from being reverted unless attackers are willing to pay an O(n) cost. However, the rewards are large - a super-quadratically sharded blockchain could be used as a general-purpose tool for nearly all decentralized applications, and could sustain transaction fees that makes its use virtually free.", 
            "title": "What are the unique challenges of pushing scaling past n = O(c\\^2)?"
        }, 
        {
            "location": "/Research/Sharding-FAQ/#footnotes", 
            "text": "Merklix tree == Merkle Patricia tree    \u00a0Later proposals from the NUS group do manage to shard state; they do this via the receipt and state-compacting techniques that I describe in later sections in this document.    \u00a0There are reasons to be conservative here. Particularly, note that if an attacker comes up with worst-case transactions whose ratio between processing time and block space expenditure (bytes, gas, etc) is much higher than usual, then the system will experience very low performance, and so a safety factor is necessary to account for this possibility. In traditional blockchains, the fact that block processing only takes \\~1-5% of block time has the primary role of protecting against centralization risk but serves double duty of protecting against denial of service risk. In the specific case of Bitcoin, its current worst-case  known quadratic execution vulnerability \u00a0arguably limits any scaling at present to \\~5-10x, and in the case of Ethereum, while all known vulnerabilities are being or have been removed after the denial-of-service attacks, there is still a risk of further discrepancies particularly on a smaller scale. In Bitcoin NG, the need for the former is removed, but the need for the latter is still there.    \u00a0A further reason to be cautious is that increased state size corresponds to reduced throughput, as nodes will find it harder and harder to keep state data in RAM and so need more and more disk accesses, and databases, which often have an O(log(n)) access time, will take longer and longer to access. This was an important lesson from the last Ethereum denial-of-service attack, which bloated the state by \\~10 GB by creating empty accounts and thereby indirectly slowed processing down by forcing further state accesses to hit disk instead of RAM.    \u00a0In sharded blockchains, there may not necessarily be in-lockstep consensus on a single global state, and so the protocol never asks nodes to try to compute a global state root; in fact, in the protocols presented in later sections, each shard has its own state, and for each shard there is a mechanism for committing to the state root for that shard, which represents that shard\u2019s state    \u00a0#MEGA    \u00a0If a non-scalable blockchain upgrades into a scalable blockchain, the author\u2019s recommended path is that the old chain\u2019s state should simply become a single shard in the new chain.     For this to be secure, some further conditions must be satisfied; particularly, the proof of work must be non-outsourceable in order to prevent the attacker from determining which  other miners' identities  are available for some given shard and mining on top of those.    \u00a0Recent Ethereum denial-of-service attacks have proven that hard drive access is a primary bottleneck to blockchain scalability.    \u00a0You could ask: well why don\u2019t validators fetch Merkle proofs just-in-time? Answer: because doing so is a \\~100-1000ms roundtrip, and executing an entire complex transaction within that time could be prohibitive.    \u00a0\u00a0One hybrid solution that combines the normal-case efficiency of small samples with the greater robustness of larger samples is a multi-layered sampling scheme: have a consensus between 50 nodes that requires 80% agreement to move forward, and then only if that consensus fails to be reached then fall back to a 250-node sample. N = 50 with an 80% threshold has only a 8.92 * 10-9 failure rate even against attackers with p = 0.4, so this does not harm security at all under an honest or uncoordinated majority model.    \u00a0The probabilities given are for one single shard; however, the random seed affects O(c) shards and the attacker could potentially take over any one of them. If we want to look at O(c) shards simultaneously, then there are two cases. First, if the grinding process is computationally bounded, then this fact does not change the calculus at all, as even though there are now O(c) chances of success per round, checking success takes O(c) times as much work. Second, if the grinding process is economically bounded, then this indeed calls for somewhat higher safety factors (increasing N by 10-20 should be sufficient) although it\u2019s important to note that the goal of an attacker in a profit-motivated manipulation attack is to increase their participation across all\u00a0shards in any case, and so that is the case that we are already investigating.    \u00a0See  Ethcore\u2019s Polkadotpaper \u00a0for further description of how their \u201cfishermen\u201d concept works.     Thanks to Justin Drake for pointing me to cryptographic accumulators, as well as  this paper  that gives the argument for the impossibility of sublinear batching. See also this thread: https://ethresear.ch/t/accumulators-scalability-of-utxo-blockchains-and-data-availability/176", 
            "title": "Footnotes"
        }, 
        {
            "location": "/D3VTechnologies/RLP/", 
            "text": "The purpose of RLP (Recursive Length Prefix) is to encode arbitrarily nested arrays of binary data, and RLP is the main encoding method used to serialize objects in Ethereum. The only purpose of RLP is to encode structure; encoding specific  data types (eg. strings, floats) is left up to higher-order protocols; but positive RLP integers must be represented in big endian binary form with no leading zeroes (thus making the integer value zero be equivalent to the empty byte array). Deserialised positive integers with leading zeroes must be treated as invalid. The integer representation of string length must also be encoded this way, as well as integers in the payload. Additional information can be found in the Ethereum yellow paper Appendix B.\n\n\nIf one wishes to use RLP to encode a dictionary, the two suggested canonical forms are to either use \n[[k1,v1],[k2,v2]...]\n with keys in lexicographic order or to use the higher-level \nPatricia Tree\n encoding as Ethereum does.\n\n\nDefinition\n\n\nThe RLP encoding function takes in an item. An item is defined as follows\uff1a\n\n\n\n\nA string (ie. byte array) is an item\n\n\nA list of items is an item\n\n\n\n\nFor example, an empty string is an item, as is the string containing the word \"cat\", a list containing any number of strings, as well as more complex data structures like \n[\"cat\",[\"puppy\",\"cow\"],\"horse\",[[]],\"pig\",[\"\"],\"sheep\"]\n. Note that in the context of the rest of this article, \"string\" will be used as a synonym for \"a certain number of bytes of binary data\"; no special encodings are used and no knowledge about the content of the strings is implied.\n\n\nRLP encoding is defined as follows:\n\n\n\n\nFor a single byte whose value is in the \n[0x00, 0x7f]\n range, that byte is its own RLP encoding.\n\n\nOtherwise, if a string is 0-55 bytes long, the RLP encoding consists of a single byte with value \n0x80\n plus the length of the string followed by the string. The range of the first byte is thus \n[0x80, 0xb7]\n.\n\n\nIf a string is more than 55 bytes long, the RLP encoding consists of a single byte with value \n0xb7\n plus the length in bytes of the length of the string in binary form, followed by the length of the string, followed by the string. For example, a length-1024 string would be encoded as \n\\xb9\\x04\\x00\n followed by the string. The range of the first byte is thus \n[0xb8, 0xbf]\n.\n\n\nIf the total payload of a list (i.e. the combined length of all its items being RLP encoded) is 0-55 bytes long, the RLP encoding consists of a single byte with value \n0xc0\n plus the length of the list followed by the concatenation of the RLP encodings of the items. The range of the first byte is thus \n[0xc0, 0xf7]\n.\n\n\nIf the total payload of a list is more than 55 bytes long, the RLP encoding consists of a single byte with value \n0xf7\n plus the length in bytes of the length of the payload in binary form, followed by the length of the payload, followed by the concatenation of the RLP encodings of the items. The range of the first byte is thus \n[0xf8, 0xff]\n.\n\n\n\n\nIn code, this is:\n\n\ndef\n \nrlp_encode\n(\ninput\n):\n\n    \nif\n \nisinstance\n(\ninput\n,\nstr\n):\n\n        \nif\n \nlen\n(\ninput\n)\n \n==\n \n1\n \nand\n \nord\n(\ninput\n)\n \n \n0x80\n:\n \nreturn\n \ninput\n\n        \nelse\n:\n \nreturn\n \nencode_length\n(\nlen\n(\ninput\n),\n \n0x80\n)\n \n+\n \ninput\n\n    \nelif\n \nisinstance\n(\ninput\n,\nlist\n):\n\n        \noutput\n \n=\n \n\n        \nfor\n \nitem\n \nin\n \ninput\n:\n \noutput\n \n+=\n \nrlp_encode\n(\nitem\n)\n\n        \nreturn\n \nencode_length\n(\nlen\n(\noutput\n),\n \n0xc0\n)\n \n+\n \noutput\n\n\n\ndef\n \nencode_length\n(\nL\n,\noffset\n):\n\n    \nif\n \nL\n \n \n56\n:\n\n         \nreturn\n \nchr\n(\nL\n \n+\n \noffset\n)\n\n    \nelif\n \nL\n \n \n256\n**\n8\n:\n\n         \nBL\n \n=\n \nto_binary\n(\nL\n)\n\n         \nreturn\n \nchr\n(\nlen\n(\nBL\n)\n \n+\n \noffset\n \n+\n \n55\n)\n \n+\n \nBL\n\n    \nelse\n:\n\n         \nraise\n \nException\n(\ninput too long\n)\n\n\n\ndef\n \nto_binary\n(\nx\n):\n\n    \nif\n \nx\n \n==\n \n0\n:\n\n        \nreturn\n \n\n    \nelse\n\n        \nreturn\n \nto_binary\n(\nint\n(\nx\n \n/\n \n256\n))\n \n+\n \nchr\n(\nx\n \n%\n \n256\n)\n\n\n\n\n\nExamples\n\n\nThe string \"dog\" = [ 0x83, 'd', 'o', 'g' ]\n\n\nThe list [ \"cat\", \"dog\" ] = \n[ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]\n\n\nThe empty string ('null') = \n[ 0x80 ]\n\n\nThe empty list = \n[ 0xc0 ]\n\n\nThe encoded integer 0 ('\\x00') = \n[ 0x00 ]\n\n\nThe encoded integer 15 ('\\x0f') = \n[ 0x0f ]\n\n\nThe encoded integer 1024 ('\\x04\\x00') = \n[ 0x82, 0x04, 0x00 ]\n\n\nThe \nset theoretical representation\n of three, \n[ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]\n\n\nThe string \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\" = \n[ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ... , 'e', 'l', 'i', 't' ]\n\n\nRLP decoding\n\n\nAccording to rules and process of RLP encoding, the input of RLP decode shall be regarded as array of binary data, the process is as follows:\n\n\n\n\n\n\nAccording to the first byte(i.e. prefix) of input data, and decoding the data type, the length of the actual data and offset;\n\n\n\n\n\n\nAccording to type and offset of data, decode data correspondingly;\n\n\n\n\n\n\nContinue to decode the rest of the input;\n\n\n\n\n\n\nAmong them, the rules of decoding data types and offset is as follows:\n\n\n\n\n\n\nthe data is a string if the range of the first byte(i.e. prefix) is [0x00, 0x7f], and the string is the first byte itself exactly;\n\n\n\n\n\n\nthe data is a string if the range of the first byte is [0x80, 0xb7], and the string which length is equal to the first byte minus 0x80 follows the first byte;\n\n\n\n\n\n\nthe data is a string if the range of the first byte is [0xb8, 0xbf], and the length of the string which length in bytes is equal to the first byte minus 0xb7 follows the first byte, and the string follows the length of the string;\n\n\n\n\n\n\nthe data is a list if the range of the first byte is [0xc0, 0xf7], and the concatenation of the RLP encodings of all items of the list which the total payload is equal to the first byte minus 0xc0 follows the first byte;\n\n\n\n\n\n\nthe data is a list if the range of the first byte is [0xf8, 0xff], and the total payload of the list which length is equal to the first byte minus 0xf7 follows the first byte, and the concatenation of the RLP encodings of all items of the list follows the total payload of the list;\n\n\n\n\n\n\nIn code, this is:\n\n\ndef\n \nrlp_decode\n(\ninput\n):\n\n    \nif\n \nlen\n(\ninput\n)\n \n==\n \n0\n:\n\n        \nreturn\n\n    \noutput\n \n=\n \n\n    \n(\noffset\n,\n \ndataLen\n,\n \ntype\n)\n \n=\n \ndecode_length\n(\ninput\n)\n\n    \nif\n \ntype\n \nis\n \nstr\n:\n\n        \noutput\n \n=\n \ninstantiate_str\n(\nsubstr\n(\ninput\n,\n \noffset\n,\n \ndataLen\n))\n\n    \nelif\n \ntype\n \nis\n \nlist\n:\n\n        \noutput\n \n=\n \ninstantiate_list\n(\nsubstr\n(\ninput\n,\n \noffset\n,\n \ndataLen\n))\n\n    \noutput\n \n+\n \nrlp_decode\n(\nsubstr\n(\ninput\n,\n \noffset\n \n+\n \ndataLen\n))\n\n    \nreturn\n \noutput\n\n\n\ndef\n \ndecode_length\n(\ninput\n):\n\n    \nlength\n \n=\n \nlen\n(\ninput\n)\n\n    \nif\n \nlength\n \n==\n \n0\n:\n\n        \nraise\n \nException\n(\ninput is null\n)\n\n    \nprefix\n \n=\n \nord\n(\ninput\n[\n0\n])\n\n    \nif\n \nprefix\n \n=\n \n0x7f\n:\n\n        \nreturn\n \n(\n0\n,\n \n1\n,\n \nstr\n)\n\n    \nelif\n \nprefix\n \n=\n \n0xb7\n \nand\n \nlength\n \n \nprefix\n \n-\n \n0x80\n:\n\n        \nstrLen\n \n=\n \nprefix\n \n-\n \n0x80\n\n        \nreturn\n \n(\n1\n,\n \nstrLen\n,\n \nstr\n)\n\n    \nelif\n \nprefix\n \n=\n \n0xbf\n \nand\n \nlength\n \n \nprefix\n \n-\n \n0xb7\n \nand\n \nlength\n \n \nprefix\n \n-\n \n0xb7\n \n+\n \nto_integer\n(\nsubstr\n(\ninput\n,\n \n1\n,\n \nprefix\n \n-\n \n0xb7\n)):\n\n        \nlenOfStrLen\n \n=\n \nprefix\n \n-\n \n0xb7\n\n        \nstrLen\n \n=\n \nto_integer\n(\nsubstr\n(\ninput\n,\n \n1\n,\n \nlenOfStrLen\n))\n\n        \nreturn\n \n(\n1\n \n+\n \nlenOfStrLen\n,\n \nstrLen\n,\n \nstr\n)\n\n    \nelif\n \nprefix\n \n=\n \n0xf7\n \nand\n \nlength\n \n \nprefix\n \n-\n \n0xc0\n:\n\n        \nlistLen\n \n=\n \nprefix\n \n-\n \n0xc0\n;\n\n        \nreturn\n \n(\n1\n,\n \nlistLen\n,\n \nlist\n)\n\n    \nelif\n \nprefix\n \n=\n \n0xff\n \nand\n \nlength\n \n \nprefix\n \n-\n \n0xf7\n \nand\n \nlength\n \n \nprefix\n \n-\n \n0xf7\n \n+\n \nto_integer\n(\nsubstr\n(\ninput\n,\n \n1\n,\n \nprefix\n \n-\n \n0xf7\n)):\n\n        \nlenOfListLen\n \n=\n \nprefix\n \n-\n \n0xf7\n\n        \nlistLen\n \n=\n \nto_integer\n(\nsubstr\n(\ninput\n,\n \n1\n,\n \nlenOfListLen\n))\n\n        \nreturn\n \n(\n1\n \n+\n \nlenOfListLen\n,\n \nlistLen\n,\n \nlist\n)\n\n    \nelse\n:\n\n        \nraise\n \nException\n(\ninput don\nt conform RLP encoding form\n)\n\n\n\ndef\n \nto_integer\n(\nb\n)\n\n    \nlength\n \n=\n \nlen\n(\nb\n)\n\n    \nif\n \nlength\n \n==\n \n0\n:\n\n        \nraise\n \nException\n(\ninput is null\n)\n\n    \nelif\n \nlength\n \n==\n \n1\n:\n\n        \nreturn\n \nord\n(\nb\n[\n0\n])\n\n    \nelse\n:\n\n        \nreturn\n \nord\n(\nsubstr\n(\nb\n,\n \n-\n1\n))\n \n+\n \nto_integer\n(\nsubstr\n(\nb\n,\n \n0\n,\n \n-\n1\n))\n \n*\n \n256", 
            "title": "RLP \u7f16\u7801"
        }, 
        {
            "location": "/D3VTechnologies/RLP/#definition", 
            "text": "The RLP encoding function takes in an item. An item is defined as follows\uff1a   A string (ie. byte array) is an item  A list of items is an item   For example, an empty string is an item, as is the string containing the word \"cat\", a list containing any number of strings, as well as more complex data structures like  [\"cat\",[\"puppy\",\"cow\"],\"horse\",[[]],\"pig\",[\"\"],\"sheep\"] . Note that in the context of the rest of this article, \"string\" will be used as a synonym for \"a certain number of bytes of binary data\"; no special encodings are used and no knowledge about the content of the strings is implied.  RLP encoding is defined as follows:   For a single byte whose value is in the  [0x00, 0x7f]  range, that byte is its own RLP encoding.  Otherwise, if a string is 0-55 bytes long, the RLP encoding consists of a single byte with value  0x80  plus the length of the string followed by the string. The range of the first byte is thus  [0x80, 0xb7] .  If a string is more than 55 bytes long, the RLP encoding consists of a single byte with value  0xb7  plus the length in bytes of the length of the string in binary form, followed by the length of the string, followed by the string. For example, a length-1024 string would be encoded as  \\xb9\\x04\\x00  followed by the string. The range of the first byte is thus  [0xb8, 0xbf] .  If the total payload of a list (i.e. the combined length of all its items being RLP encoded) is 0-55 bytes long, the RLP encoding consists of a single byte with value  0xc0  plus the length of the list followed by the concatenation of the RLP encodings of the items. The range of the first byte is thus  [0xc0, 0xf7] .  If the total payload of a list is more than 55 bytes long, the RLP encoding consists of a single byte with value  0xf7  plus the length in bytes of the length of the payload in binary form, followed by the length of the payload, followed by the concatenation of the RLP encodings of the items. The range of the first byte is thus  [0xf8, 0xff] .   In code, this is:  def   rlp_encode ( input ): \n     if   isinstance ( input , str ): \n         if   len ( input )   ==   1   and   ord ( input )     0x80 :   return   input \n         else :   return   encode_length ( len ( input ),   0x80 )   +   input \n     elif   isinstance ( input , list ): \n         output   =   \n         for   item   in   input :   output   +=   rlp_encode ( item ) \n         return   encode_length ( len ( output ),   0xc0 )   +   output  def   encode_length ( L , offset ): \n     if   L     56 : \n          return   chr ( L   +   offset ) \n     elif   L     256 ** 8 : \n          BL   =   to_binary ( L ) \n          return   chr ( len ( BL )   +   offset   +   55 )   +   BL \n     else : \n          raise   Exception ( input too long )  def   to_binary ( x ): \n     if   x   ==   0 : \n         return   \n     else \n         return   to_binary ( int ( x   /   256 ))   +   chr ( x   %   256 )", 
            "title": "Definition"
        }, 
        {
            "location": "/D3VTechnologies/RLP/#examples", 
            "text": "The string \"dog\" = [ 0x83, 'd', 'o', 'g' ]  The list [ \"cat\", \"dog\" ] =  [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]  The empty string ('null') =  [ 0x80 ]  The empty list =  [ 0xc0 ]  The encoded integer 0 ('\\x00') =  [ 0x00 ]  The encoded integer 15 ('\\x0f') =  [ 0x0f ]  The encoded integer 1024 ('\\x04\\x00') =  [ 0x82, 0x04, 0x00 ]  The  set theoretical representation  of three,  [ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]  The string \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\" =  [ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ... , 'e', 'l', 'i', 't' ]", 
            "title": "Examples"
        }, 
        {
            "location": "/D3VTechnologies/RLP/#rlp-decoding", 
            "text": "According to rules and process of RLP encoding, the input of RLP decode shall be regarded as array of binary data, the process is as follows:    According to the first byte(i.e. prefix) of input data, and decoding the data type, the length of the actual data and offset;    According to type and offset of data, decode data correspondingly;    Continue to decode the rest of the input;    Among them, the rules of decoding data types and offset is as follows:    the data is a string if the range of the first byte(i.e. prefix) is [0x00, 0x7f], and the string is the first byte itself exactly;    the data is a string if the range of the first byte is [0x80, 0xb7], and the string which length is equal to the first byte minus 0x80 follows the first byte;    the data is a string if the range of the first byte is [0xb8, 0xbf], and the length of the string which length in bytes is equal to the first byte minus 0xb7 follows the first byte, and the string follows the length of the string;    the data is a list if the range of the first byte is [0xc0, 0xf7], and the concatenation of the RLP encodings of all items of the list which the total payload is equal to the first byte minus 0xc0 follows the first byte;    the data is a list if the range of the first byte is [0xf8, 0xff], and the total payload of the list which length is equal to the first byte minus 0xf7 follows the first byte, and the concatenation of the RLP encodings of all items of the list follows the total payload of the list;    In code, this is:  def   rlp_decode ( input ): \n     if   len ( input )   ==   0 : \n         return \n     output   =   \n     ( offset ,   dataLen ,   type )   =   decode_length ( input ) \n     if   type   is   str : \n         output   =   instantiate_str ( substr ( input ,   offset ,   dataLen )) \n     elif   type   is   list : \n         output   =   instantiate_list ( substr ( input ,   offset ,   dataLen )) \n     output   +   rlp_decode ( substr ( input ,   offset   +   dataLen )) \n     return   output  def   decode_length ( input ): \n     length   =   len ( input ) \n     if   length   ==   0 : \n         raise   Exception ( input is null ) \n     prefix   =   ord ( input [ 0 ]) \n     if   prefix   =   0x7f : \n         return   ( 0 ,   1 ,   str ) \n     elif   prefix   =   0xb7   and   length     prefix   -   0x80 : \n         strLen   =   prefix   -   0x80 \n         return   ( 1 ,   strLen ,   str ) \n     elif   prefix   =   0xbf   and   length     prefix   -   0xb7   and   length     prefix   -   0xb7   +   to_integer ( substr ( input ,   1 ,   prefix   -   0xb7 )): \n         lenOfStrLen   =   prefix   -   0xb7 \n         strLen   =   to_integer ( substr ( input ,   1 ,   lenOfStrLen )) \n         return   ( 1   +   lenOfStrLen ,   strLen ,   str ) \n     elif   prefix   =   0xf7   and   length     prefix   -   0xc0 : \n         listLen   =   prefix   -   0xc0 ; \n         return   ( 1 ,   listLen ,   list ) \n     elif   prefix   =   0xff   and   length     prefix   -   0xf7   and   length     prefix   -   0xf7   +   to_integer ( substr ( input ,   1 ,   prefix   -   0xf7 )): \n         lenOfListLen   =   prefix   -   0xf7 \n         listLen   =   to_integer ( substr ( input ,   1 ,   lenOfListLen )) \n         return   ( 1   +   lenOfListLen ,   listLen ,   list ) \n     else : \n         raise   Exception ( input don t conform RLP encoding form )  def   to_integer ( b ) \n     length   =   len ( b ) \n     if   length   ==   0 : \n         raise   Exception ( input is null ) \n     elif   length   ==   1 : \n         return   ord ( b [ 0 ]) \n     else : \n         return   ord ( substr ( b ,   - 1 ))   +   to_integer ( substr ( b ,   0 ,   - 1 ))   *   256", 
            "title": "RLP decoding"
        }, 
        {
            "location": "/D3VTechnologies/Node-discovery-protocol/", 
            "text": "In a nutshell:\n\n Aimed at discovering \nRLPx nodes\n to connect to\n\n UDP-based RPC protocol (\nkademlia\n-like)\n* Defines 4 packet types: \nping\n, \npong\n, \nfindnode\n and \nneighbors\n\n\nSee details at either:\n\n \ndevp2p\n repository's \nnode discovery protocol\n page\n\n \ngo-ethereum\n repository's \nnode discovery protocol\n page", 
            "title": "\u8282\u70b9\u53d1\u73b0\u534f\u8bae"
        }, 
        {
            "location": "/D3VTechnologies/Wire-Protocol/", 
            "text": "Peer-to-peer communications between nodes running Ethereum/Whisper/\nc. clients are designed to be governed by a simple wire-protocol making use of existing \u00d0\u039eV technologies and standards such as \nRLP\n wherever practical.\n\n\nThis document is intended to specify this protocol comprehensively.\n\n\nLow-Level\n\n\n\u00d0\u039eVp2p nodes communicate by sending messages using RLPx, an encrypted and authenticated transport protocol. Peers are free to advertise and accept connections on any TCP ports they wish, however, a default port on which the connection may be listened and made will be 30303.\nThough TCP provides a connection-oriented medium, \u00d0\u039eVp2p nodes communicate in terms of packets.\nRLPx provides facilities to send and receive packets. For more information about RLPx, refer to the \nprotocol specification\n.\n\n\n\u00d0\u039eVp2p nodes find peers through the RLPx discovery protocol DHT. Peer connections can also be initiated by supplying\nthe endpoint of a peer to a client-specific RPC API.\n\n\nPayload Contents\n\n\nThere are a number of different types of payload that may be encoded within the RLP. This ''type'' is always determined by the first entry of the RLP, interpreted as an integer.\n\n\n\u00d0\u039eVp2p is designed to support arbitrary sub-protocols (aka \ncapabilities\n) over the basic wire protocol. Each sub-protocol is given as much of the message-ID space as it needs (all such protocols must statically specify how many message IDs they require). On connection and reception of the \nHello\n message, both peers have equivalent information about what subprotocols they share (including versions) and are able to form consensus over the composition of message ID space.\n\n\nMessage IDs are assumed to be compact from ID 0x10 onwards (0x00-0x10 is reserved for \u00d0\u039eVp2p messages) and given to each shared (equal-version, equal name) sub-protocol in alphabetic order. Sub-protocols that are not shared are ignored. If multiple versions are shared of the same (equal name) sub-protocol, the numerically highest wins, others are ignored.\n\n\nP2P\n\n\nHello\n\n\n0x00\n [\np2pVersion\n: \nP\n, \nclientId\n: \nB\n, [[\ncap1\n: \nB_3\n, \ncapVersion1\n: \nP\n], [\ncap2\n: \nB_3\n, \ncapVersion2\n: \nP\n], \n...\n], \nlistenPort\n: \nP\n, \nnodeId\n: \nB_64\n] First packet sent over the connection, and sent once by both sides. No other messages may be sent until a Hello is received.\n\n \np2pVersion\n Specifies the implemented version of the P2P protocol. Now must be 1.\n\n \nclientId\n Specifies the client software identity, as a human-readable string (e.g. \"Ethereum(++)/1.0.0\").\n\n \ncap\n Specifies a peer capability name as a length-3 ASCII string. Current supported capabilities are \neth\n, \nshh\n.\n\n \ncapVersion\n Specifies a peer capability version as a positive integer. Current supported versions are 34 for \neth\n, and 1 for \nshh\n.\n\n \nlistenPort\n specifies the port that the client is listening on (on the interface that the present connection traverses). If 0 it indicates the client is not listening.\n\n \nnodeId\n is the Unique Identity of the node and specifies a 512-bit hash that identifies this node.\n\n\nDisconnect\n\n\n0x01\n [\nreason\n: \nP\n] Inform the peer that a disconnection is imminent; if received, a peer should disconnect immediately. When sending, well-behaved hosts give their peers a fighting chance (read: wait 2 seconds) to disconnect to before disconnecting themselves.\n* \nreason\n is an optional integer specifying one of a number of reasons for disconnect:\n  * \n0x00\n Disconnect requested;\n  * \n0x01\n TCP sub-system error;\n  * \n0x02\n Breach of protocol, e.g. a malformed message, bad RLP, incorrect magic number \nc.;\n  * \n0x03\n Useless peer;\n  * \n0x04\n Too many peers;\n  * \n0x05\n Already connected;\n  * \n0x06\n Incompatible P2P protocol version;\n  * \n0x07\n Null node identity received - this is automatically invalid;\n  * \n0x08\n Client quitting;\n  * \n0x09\n Unexpected identity (i.e. a different identity to a previous connection/what a trusted peer told us).\n  * \n0x0a\n Identity is the same as this node (i.e. connected to itself);\n  * \n0x0b\n Timeout on receiving a message (i.e. nothing received since sending last ping);\n  * \n0x10\n Some other reason specific to a subprotocol.\n\n\nPing\n\n\n0x02\n [] Requests an immediate reply of \nPong\n from the peer.\n\n\nPong\n\n\n0x03\n [] Reply to peer's \nPing\n packet.\n\n\nNotImplemented (was GetPeers)\n\n\n0x04\n\n\nNotImplemented (was Peers)\n\n\n0x05\n\n\nNode identity and reputation\n\n\nThe identity of a \u00d0\u039eVp2p node is a secp256k1 public key.\n\n\nNodes are free to store ratings for given IDs (how useful the node has been in the past) and give preference accordingly. Nodes may also track node IDs (and their provenance) in order to help determine potential man-in-the-middle attacks.\nClients are free to mark down new nodes and use the node ID as a means of determining a node's reputation.\n\n\nSession Management\n\n\nUpon connecting, all clients (i.e. both sides of the connection) must send a \nHello\n message. Upon receiving the \nHello\n message and verifying compatibility of the network and versions, a session is active and any other P2P messages may be sent.\n\n\nAt any time, a Disconnect message may be sent.", 
            "title": "\u00d0\u039eVp2p \u6709\u7ebf\u534f\u8bae"
        }, 
        {
            "location": "/D3VTechnologies/Wire-Protocol/#low-level", 
            "text": "\u00d0\u039eVp2p nodes communicate by sending messages using RLPx, an encrypted and authenticated transport protocol. Peers are free to advertise and accept connections on any TCP ports they wish, however, a default port on which the connection may be listened and made will be 30303.\nThough TCP provides a connection-oriented medium, \u00d0\u039eVp2p nodes communicate in terms of packets.\nRLPx provides facilities to send and receive packets. For more information about RLPx, refer to the  protocol specification .  \u00d0\u039eVp2p nodes find peers through the RLPx discovery protocol DHT. Peer connections can also be initiated by supplying\nthe endpoint of a peer to a client-specific RPC API.", 
            "title": "Low-Level"
        }, 
        {
            "location": "/D3VTechnologies/Wire-Protocol/#payload-contents", 
            "text": "There are a number of different types of payload that may be encoded within the RLP. This ''type'' is always determined by the first entry of the RLP, interpreted as an integer.  \u00d0\u039eVp2p is designed to support arbitrary sub-protocols (aka  capabilities ) over the basic wire protocol. Each sub-protocol is given as much of the message-ID space as it needs (all such protocols must statically specify how many message IDs they require). On connection and reception of the  Hello  message, both peers have equivalent information about what subprotocols they share (including versions) and are able to form consensus over the composition of message ID space.  Message IDs are assumed to be compact from ID 0x10 onwards (0x00-0x10 is reserved for \u00d0\u039eVp2p messages) and given to each shared (equal-version, equal name) sub-protocol in alphabetic order. Sub-protocols that are not shared are ignored. If multiple versions are shared of the same (equal name) sub-protocol, the numerically highest wins, others are ignored.", 
            "title": "Payload Contents"
        }, 
        {
            "location": "/D3VTechnologies/Wire-Protocol/#p2p", 
            "text": "Hello  0x00  [ p2pVersion :  P ,  clientId :  B , [[ cap1 :  B_3 ,  capVersion1 :  P ], [ cap2 :  B_3 ,  capVersion2 :  P ],  ... ],  listenPort :  P ,  nodeId :  B_64 ] First packet sent over the connection, and sent once by both sides. No other messages may be sent until a Hello is received.   p2pVersion  Specifies the implemented version of the P2P protocol. Now must be 1.   clientId  Specifies the client software identity, as a human-readable string (e.g. \"Ethereum(++)/1.0.0\").   cap  Specifies a peer capability name as a length-3 ASCII string. Current supported capabilities are  eth ,  shh .   capVersion  Specifies a peer capability version as a positive integer. Current supported versions are 34 for  eth , and 1 for  shh .   listenPort  specifies the port that the client is listening on (on the interface that the present connection traverses). If 0 it indicates the client is not listening.   nodeId  is the Unique Identity of the node and specifies a 512-bit hash that identifies this node.  Disconnect  0x01  [ reason :  P ] Inform the peer that a disconnection is imminent; if received, a peer should disconnect immediately. When sending, well-behaved hosts give their peers a fighting chance (read: wait 2 seconds) to disconnect to before disconnecting themselves.\n*  reason  is an optional integer specifying one of a number of reasons for disconnect:\n  *  0x00  Disconnect requested;\n  *  0x01  TCP sub-system error;\n  *  0x02  Breach of protocol, e.g. a malformed message, bad RLP, incorrect magic number  c.;\n  *  0x03  Useless peer;\n  *  0x04  Too many peers;\n  *  0x05  Already connected;\n  *  0x06  Incompatible P2P protocol version;\n  *  0x07  Null node identity received - this is automatically invalid;\n  *  0x08  Client quitting;\n  *  0x09  Unexpected identity (i.e. a different identity to a previous connection/what a trusted peer told us).\n  *  0x0a  Identity is the same as this node (i.e. connected to itself);\n  *  0x0b  Timeout on receiving a message (i.e. nothing received since sending last ping);\n  *  0x10  Some other reason specific to a subprotocol.  Ping  0x02  [] Requests an immediate reply of  Pong  from the peer.  Pong  0x03  [] Reply to peer's  Ping  packet.  NotImplemented (was GetPeers)  0x04  NotImplemented (was Peers)  0x05", 
            "title": "P2P"
        }, 
        {
            "location": "/D3VTechnologies/Wire-Protocol/#node-identity-and-reputation", 
            "text": "The identity of a \u00d0\u039eVp2p node is a secp256k1 public key.  Nodes are free to store ratings for given IDs (how useful the node has been in the past) and give preference accordingly. Nodes may also track node IDs (and their provenance) in order to help determine potential man-in-the-middle attacks.\nClients are free to mark down new nodes and use the node ID as a means of determining a node's reputation.", 
            "title": "Node identity and reputation"
        }, 
        {
            "location": "/D3VTechnologies/Wire-Protocol/#session-management", 
            "text": "Upon connecting, all clients (i.e. both sides of the connection) must send a  Hello  message. Upon receiving the  Hello  message and verifying compatibility of the network and versions, a session is active and any other P2P messages may be sent.  At any time, a Disconnect message may be sent.", 
            "title": "Session Management"
        }, 
        {
            "location": "/D3VTechnologies/libp2p-Whitepaper/", 
            "text": "NOTE:\n \nThis is a work-in-progress\n\n\nFor Ethereum to succeed, and for the ultimate goals of Ethereum to be achieved, Ethereum needs to employ a number of secure decentralised data systems. The generalised Turing-complete, extensible-state blockchain is one component in this, but for it to be leveraged to its full potential for building decentralised applications (\u00d0Apps), a suite of additional data systems are necessary. Each decentralised-datasystem solves specific needs; in general it is difficult to predict what data systems will ultimately be required since the decentralised paradigm is not immediately comparable, like-for-like with traditional centralised architected systems.\n\n\nThree types of data systems in particular are required for many current massively multi-user applications (MMAs, aka generally Web-based applications but also mobile phone apps and e.g. MMORPGs). In addition to a transactional database (\"Ethereum\"), a publication and download system would be required in addition to a generalised low-level \"bulletin-board\" system for posting messages.\n\n\nWe can, however, imagine many more such types of decentralised communications systems in the future including, e.g., those for identity-based RTC. Each of these components have a number of shared prerequisites, such as peer-discovery and recording; network well-formedness; transport-level buffering, scheduling and framing; and authentication and security. Any computer scientist worth their salt would instantly scream out \"abstraction opportunity!\".\n\n\nWhat it is\n\n\nlibp2p (aka \u00d0\u039eVp2p) aims to provide a lightweight abstraction layer that provides these low-level algorithms, protocols and services in a transparent framework without predetermining the eventual transmission-use-cases of the protocols.\n\n\nIts specific aims are to provide a language-agnostic API and specification which is:\n- \nUniversal:\n Pairwise addressing (ala Telehash), broadcast (ala Bitcoin), groupwise (some DHT designs \n filesharing) are all reasonable. There may be others. It should provide only the network structure, not dictate usage over it.\n- \nUbiquitous:\n The same peer-set/-network should be able to be used for all protocols.\n- \nSecure:\n Encryption between physical peers is a given. Peer introduction can provide a good level of defence against systematic MitM attacks.\n- \nEfficient:\n Framing and prioritisation to guarantee QoS over each protocol. Multiplexing allows access to limited resources to be easily controlled between p2p protocols. Kademlia-style network well-formedness guarantees a low maximum hope distance to any peer in the network and its group.\n- \nSimple:\n A minimal, developer-driven API gives source-level future-proofing.\n\n\nUltimately, additional secondary features will also be explored:\n- \nDPI security:\n Framing and bandwidth control can be used to control traffic shape.\n- \nTransport-layer Agnostic:\n TCP/IP v4 and v6 are provided with initial protocol specifications. Others should be able to be added on at later dates without altering the API. Mesh networking devices could even ultimately implement this natively.\n\n\nBasic Design\n\n\n\n\nPeers can each be identified by a node-ID.\n\n\nProvides ability \nonly\n to communicate with peers.\n\n\nEverything happens in typed, ordered datagrams.\n\n\nAny number of datagram types can be registered - these are automatically negotiated at the handshake.\n\n\nPeers can be requested via a libp2p physical endpoint.\n\n\nPeers can be rated per-protocol using a local metric.\n\n\nPeer set is dynamic and \"steered\" by libp2p internally, going from ratings.\n\n\nFirst packets are either DH key exchange or, if node known from peer introduction, PKI-encrypted session key, or if node known from previous session, new session key encrypted by old. Retry can be made after failed negotiation using prior knowledge, with the corresponding removal of any trust.\n\n\nPeer-set is made up from multiple sub-protocol slots.\n\n\nEach slot is given over to maximise rating for that particular sub-protocol.\n\n\n\n\nThere is no preordained inter-node message routing system (this is left to a higher-level), and no preordained high-level identity system (again, higher level).", 
            "title": "\u00d0\u039eVp2p \u767d\u76ae\u4e66"
        }, 
        {
            "location": "/D3VTechnologies/libp2p-Whitepaper/#what-it-is", 
            "text": "libp2p (aka \u00d0\u039eVp2p) aims to provide a lightweight abstraction layer that provides these low-level algorithms, protocols and services in a transparent framework without predetermining the eventual transmission-use-cases of the protocols.  Its specific aims are to provide a language-agnostic API and specification which is:\n-  Universal:  Pairwise addressing (ala Telehash), broadcast (ala Bitcoin), groupwise (some DHT designs   filesharing) are all reasonable. There may be others. It should provide only the network structure, not dictate usage over it.\n-  Ubiquitous:  The same peer-set/-network should be able to be used for all protocols.\n-  Secure:  Encryption between physical peers is a given. Peer introduction can provide a good level of defence against systematic MitM attacks.\n-  Efficient:  Framing and prioritisation to guarantee QoS over each protocol. Multiplexing allows access to limited resources to be easily controlled between p2p protocols. Kademlia-style network well-formedness guarantees a low maximum hope distance to any peer in the network and its group.\n-  Simple:  A minimal, developer-driven API gives source-level future-proofing.  Ultimately, additional secondary features will also be explored:\n-  DPI security:  Framing and bandwidth control can be used to control traffic shape.\n-  Transport-layer Agnostic:  TCP/IP v4 and v6 are provided with initial protocol specifications. Others should be able to be added on at later dates without altering the API. Mesh networking devices could even ultimately implement this natively.", 
            "title": "What it is"
        }, 
        {
            "location": "/D3VTechnologies/libp2p-Whitepaper/#basic-design", 
            "text": "Peers can each be identified by a node-ID.  Provides ability  only  to communicate with peers.  Everything happens in typed, ordered datagrams.  Any number of datagram types can be registered - these are automatically negotiated at the handshake.  Peers can be requested via a libp2p physical endpoint.  Peers can be rated per-protocol using a local metric.  Peer set is dynamic and \"steered\" by libp2p internally, going from ratings.  First packets are either DH key exchange or, if node known from peer introduction, PKI-encrypted session key, or if node known from previous session, new session key encrypted by old. Retry can be made after failed negotiation using prior knowledge, with the corresponding removal of any trust.  Peer-set is made up from multiple sub-protocol slots.  Each slot is given over to maximise rating for that particular sub-protocol.   There is no preordained inter-node message routing system (this is left to a higher-level), and no preordained high-level identity system (again, higher level).", 
            "title": "Basic Design"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/", 
            "text": "To make your app work on Ethereum, you can use the web3 object provided by the web3.js library. Under the hood it communicates to a local node through RPC calls. \nweb3\n works with any Ethereum node, which exposes an RPC layer.\n\n\nweb3 contains the eth object - web3.eth (for specifically Ethereum blockchain interactions) and the shh object - web3.shh (for Whisper interaction). Over time we'll introduce other objects for each of the other web3 protocols. Working examples can be found here.\n\n\nvar fs = require(\nfs\n);\nvar recognizer = require(\nethereum-keyfile-recognizer\n);\n\nfs.readFile(\nkeyfile.json\n, (err, data) =\n {\nvar json = JSON.parse(data);\nvar result = recognizer(json);\n/** result\n  *               [ \nweb3\n, 3 ]   web3 (v3) keyfile\n  *  [ \nethersale\n, undefined ]   Ethersale keyfile\n  *                        null     invalid keyfile\n */\n }));\n\n\n\n\n\nThis documents version 3 of the Web3 Secret Storage Definition.\n\n\nDefinition\n\n\nThe actual encoding and decoding of the file remains largely unchanged from version 1, except that the crypto algorithm is no longer fixed to AES-128-CBC (AES-128-CTR is now the minimal requirement). Most of the meanings/algorithm are similar to version 1, except \nmac\n, which is given as the SHA3 (keccak-256) of the concatenation of the last 16 bytes of the derived key together with the full \nciphertext\n.\n\n\nSecret key files are stored directly in \n~/.web3/keystore\n (for Unix-like systems) and \n~/AppData/Web3/keystore\n (for Windows). They may be named anything, but a good convention is \nuuid\n.json\n, where \nuuid\n is the 128-bit UUID given to the secret key (a privacy-preserving proxy for the secret key's address).\n\n\nAll such files have an associated password. To derive a given \n.json\n file's secret key, first derive the file's encryption key; this is done through taking the file's password and passing it through a key derivation function as described by the \nkdf\n key. KDF-dependent static and dynamic parameters to the KDF function are described in \nkdfparams\n key.\n\n\nPBKDF2 must be supported by all minimally-compliant implementations, denoted though:\n\n\n\n\nkdf\n: \npbkdf2\n\n\n\n\nFor PBKDF2, the \nkdfparams\n include:\n\n\n\n\nprf\n: Must be \nhmac-sha256\n (may be extended in the future);\n\n\nc\n: number of iterations;\n\n\nsalt\n: salt passed to PBKDF;\n\n\ndklen\n: length for the derived key. Must be \n= 32.\n\n\n\n\nOnce the file's key has been derived, it should be verified through the derivation of the MAC. The MAC should be calculated as the SHA3 (keccak-256) hash of the byte array formed as the concatenations of the second-leftmost 16 bytes of the derived key with the \nciphertext\n key's contents, i.e.:\n\n\nKECCAK(DK[16..31] ++ \nciphertext\n)\n\n\n\n\n(where \n++\n is the concatenation operator)\n\n\nThis value should be compared to the contents of the \nmac\n key; if they are different, an alternative password should be requested (or the operation cancelled).\n\n\nAfter the file's key has been verified, the cipher text (the \nciphertext\n key in the file) may be decrypted using the symmetric encryption algorithm specified by the \ncipher\n key and parameterised through the \ncipherparams\n key. If the derived key size and the algorithm's key size are mismatched, the zero padded, rightmost bytes of the derived key should be used as the key to the algorithm.\n\n\nAll minimally-compliant implementations must support the AES-128-CTR algorithm, denoted through:\n\n\n\n\ncipher\n: \naes-128-ctr\n\n\n\n\nThis cipher takes the following parameters, given as keys to the \ncipherparams\n key:\n\n\n\n\niv\n: 128-bit initialisation vector for the cipher.\n\n\n\n\nThe key for the cipher is the leftmost 16 bytes of the derived key, i.e. \nDK[0..15]\n\n\nThe creation/encryption of a secret key should be essentially the reverse of these instructions. Make sure the \nuuid\n, \nsalt\n and \niv\n are actually random.\n\n\nIn addition to the \nversion\n field, which should act as a \"hard\" identifier of version, implementations may also use \nminorversion\n to track smaller, non-breaking changes to the format.\n\n\nTest Vectors\n\n\nDetails:\n\n\n\n\nAddress: \n008aeeda4d805471df9b2a5b0f38a0c3bcba786b\n\n\nICAP: \nXE542A5PZHH8PYIZUBEJEO0MFWRAPPIL67\n\n\nUUID: \n3198bc9c-6672-5ab3-d9954942343ae5b6\n\n\nPassword: \ntestpassword\n\n\nSecret: \n7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d\n\n\n\n\nPBKDF2-SHA-256\n\n\nTest vector using AES-128-CTR and PBKDF2-SHA-256:\n\n\nFile contents of \n~/.web3/keystore/3198bc9c-6672-5ab3-d9954942343ae5b6.json\n:\n\n{\n\n    \ncrypto\n \n:\n \n{\n\n        \ncipher\n \n:\n \naes-128-ctr\n,\n\n        \ncipherparams\n \n:\n \n{\n\n            \niv\n \n:\n \n6087dab2f9fdbbfaddc31a909735c1e6\n\n        \n},\n\n        \nciphertext\n \n:\n \n5318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46\n,\n\n        \nkdf\n \n:\n \npbkdf2\n,\n\n        \nkdfparams\n \n:\n \n{\n\n            \nc\n \n:\n \n262144\n,\n\n            \ndklen\n \n:\n \n32\n,\n\n            \nprf\n \n:\n \nhmac-sha256\n,\n\n            \nsalt\n \n:\n \nae3cd4e7013836a3df6bd7241b12db061dbe2c6785853cce422d148a624ce0bd\n\n        \n},\n\n        \nmac\n \n:\n \n517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2\n\n    \n},\n\n    \nid\n \n:\n \n3198bc9c-6672-5ab3-d995-4942343ae5b6\n,\n\n    \nversion\n \n:\n \n3\n\n\n}\n\n\n\n\nIntermediates:\n\n\n\n\nDerived key: \nf06d69cdc7da0faffb1008270bca38f5e31891a3a773950e6d0fea48a7188551\n\n\nMAC Body: \ne31891a3a773950e6d0fea48a71885515318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46\n\n\nMAC \n517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2\n\n\nCipher key: \nf06d69cdc7da0faffb1008270bca38f5\n\n\n\n\nScrypt\n\n\nTest vector using AES-128-CTR and Scrypt:\n\n\n{\n\n    \ncrypto\n \n:\n \n{\n\n        \ncipher\n \n:\n \naes-128-ctr\n,\n\n        \ncipherparams\n \n:\n \n{\n\n            \niv\n \n:\n \n83dbcc02d8ccb40e466191a123791e0e\n\n        \n},\n\n        \nciphertext\n \n:\n \nd172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c\n,\n\n        \nkdf\n \n:\n \nscrypt\n,\n\n        \nkdfparams\n \n:\n \n{\n\n            \ndklen\n \n:\n \n32\n,\n\n            \nn\n \n:\n \n262144\n,\n\n            \nr\n \n:\n \n1\n,\n\n            \np\n \n:\n \n8\n,\n\n            \nsalt\n \n:\n \nab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19\n\n        \n},\n\n        \nmac\n \n:\n \n2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097\n\n    \n},\n\n    \nid\n \n:\n \n3198bc9c-6672-5ab3-d995-4942343ae5b6\n,\n\n    \nversion\n \n:\n \n3\n\n\n}\n\n\n\n\n\nIntermediates:\n\n\n\n\nDerived key: \nfac192ceb5fd772906bea3e118a69e8bbb5cc24229e20d8766fd298291bba6bd\n\n\nMAC Body \nbb5cc24229e20d8766fd298291bba6bdd172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c\n\n\nMAC: \n2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097\n\n\nCipher key: \nfac192ceb5fd772906bea3e118a69e8b\n\n\n\n\nAlterations from Version 1\n\n\nThis version fixes several inconsistencies with the version 1 published \nhere\n. In brief these are:\n\n\n\n\nCapitalisation is unjustified and inconsistent (\nscrypt\n lowercase, \nKdf\n mixed-case, \nMAC\n uppercase).\n\n\nAddress\n unnecessary and compromises privacy.\n\n\nSalt\n is intrinsically a parameter of the key derivation function and deserves to be associated with it, not with the crypto in general.\n\n\nSaltLen\n unnecessary (just derive it from \nSalt\n).\n\n\nThe key derivation function is given, yet the crypto algorithm is hard specified.\n\n\nVersion\n is intrinsically numeric yet is a string (structured versioning would be possible with a string, but can be considered out of scope for a rarely changing configuration file format).\n\n\nKDF and cipher are notionally sibling concepts yet are organised differently.\n\n\nMAC is calculated through a whitespace agnostic piece of data(!)\n\n\n\n\nChanges have been made to the format to give the following file, functionally equivalent to the example given on the previously linked page:\n\n\n{\n\n    \ncrypto\n:\n \n{\n\n        \ncipher\n:\n \naes-128-cbc\n,\n\n        \nciphertext\n:\n \n07533e172414bfa50e99dba4a0ce603f654ebfa1ff46277c3e0c577fdc87f6bb4e4fe16c5a94ce6ce14cfa069821ef9b\n,\n\n        \ncipherparams\n:\n \n{\n\n            \niv\n:\n \n16d67ba0ce5a339ff2f07951253e6ba8\n\n        \n},\n\n        \nkdf\n:\n \nscrypt\n,\n\n        \nkdfparams\n:\n \n{\n\n            \ndklen\n:\n \n32\n,\n\n            \nn\n:\n \n262144\n,\n\n            \np\n:\n \n1\n,\n\n            \nr\n:\n \n8\n,\n\n            \nsalt\n:\n \n06870e5e6a24e183a5c807bd1c43afd86d573f7db303ff4853d135cd0fd3fe91\n\n        \n},\n\n        \nmac\n:\n \n8ccded24da2e99a11d48cda146f9cc8213eb423e2ea0d8427f41c3be414424dd\n,\n\n        \nversion\n:\n \n1\n\n    \n},\n\n    \nid\n:\n \n0498f19a-59db-4d54-ac95-33901b4f1870\n,\n\n    \nversion\n:\n \n2\n\n\n}\n\n\n\n\n\nAlterations from Version 2\n\n\nVersion 2 was an early C++ implementation with a number of bugs. All essentials remain unchanged from it.", 
            "title": "Web3 \u79d8\u5bc6\u5b58\u50a8"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/#definition", 
            "text": "The actual encoding and decoding of the file remains largely unchanged from version 1, except that the crypto algorithm is no longer fixed to AES-128-CBC (AES-128-CTR is now the minimal requirement). Most of the meanings/algorithm are similar to version 1, except  mac , which is given as the SHA3 (keccak-256) of the concatenation of the last 16 bytes of the derived key together with the full  ciphertext .  Secret key files are stored directly in  ~/.web3/keystore  (for Unix-like systems) and  ~/AppData/Web3/keystore  (for Windows). They may be named anything, but a good convention is  uuid .json , where  uuid  is the 128-bit UUID given to the secret key (a privacy-preserving proxy for the secret key's address).  All such files have an associated password. To derive a given  .json  file's secret key, first derive the file's encryption key; this is done through taking the file's password and passing it through a key derivation function as described by the  kdf  key. KDF-dependent static and dynamic parameters to the KDF function are described in  kdfparams  key.  PBKDF2 must be supported by all minimally-compliant implementations, denoted though:   kdf :  pbkdf2   For PBKDF2, the  kdfparams  include:   prf : Must be  hmac-sha256  (may be extended in the future);  c : number of iterations;  salt : salt passed to PBKDF;  dklen : length for the derived key. Must be  = 32.   Once the file's key has been derived, it should be verified through the derivation of the MAC. The MAC should be calculated as the SHA3 (keccak-256) hash of the byte array formed as the concatenations of the second-leftmost 16 bytes of the derived key with the  ciphertext  key's contents, i.e.:  KECCAK(DK[16..31] ++  ciphertext )  (where  ++  is the concatenation operator)  This value should be compared to the contents of the  mac  key; if they are different, an alternative password should be requested (or the operation cancelled).  After the file's key has been verified, the cipher text (the  ciphertext  key in the file) may be decrypted using the symmetric encryption algorithm specified by the  cipher  key and parameterised through the  cipherparams  key. If the derived key size and the algorithm's key size are mismatched, the zero padded, rightmost bytes of the derived key should be used as the key to the algorithm.  All minimally-compliant implementations must support the AES-128-CTR algorithm, denoted through:   cipher :  aes-128-ctr   This cipher takes the following parameters, given as keys to the  cipherparams  key:   iv : 128-bit initialisation vector for the cipher.   The key for the cipher is the leftmost 16 bytes of the derived key, i.e.  DK[0..15]  The creation/encryption of a secret key should be essentially the reverse of these instructions. Make sure the  uuid ,  salt  and  iv  are actually random.  In addition to the  version  field, which should act as a \"hard\" identifier of version, implementations may also use  minorversion  to track smaller, non-breaking changes to the format.", 
            "title": "Definition"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/#test-vectors", 
            "text": "Details:   Address:  008aeeda4d805471df9b2a5b0f38a0c3bcba786b  ICAP:  XE542A5PZHH8PYIZUBEJEO0MFWRAPPIL67  UUID:  3198bc9c-6672-5ab3-d9954942343ae5b6  Password:  testpassword  Secret:  7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d", 
            "title": "Test Vectors"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/#pbkdf2-sha-256", 
            "text": "Test vector using AES-128-CTR and PBKDF2-SHA-256:  File contents of  ~/.web3/keystore/3198bc9c-6672-5ab3-d9954942343ae5b6.json : { \n     crypto   :   { \n         cipher   :   aes-128-ctr , \n         cipherparams   :   { \n             iv   :   6087dab2f9fdbbfaddc31a909735c1e6 \n         }, \n         ciphertext   :   5318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46 , \n         kdf   :   pbkdf2 , \n         kdfparams   :   { \n             c   :   262144 , \n             dklen   :   32 , \n             prf   :   hmac-sha256 , \n             salt   :   ae3cd4e7013836a3df6bd7241b12db061dbe2c6785853cce422d148a624ce0bd \n         }, \n         mac   :   517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2 \n     }, \n     id   :   3198bc9c-6672-5ab3-d995-4942343ae5b6 , \n     version   :   3  }   Intermediates:   Derived key:  f06d69cdc7da0faffb1008270bca38f5e31891a3a773950e6d0fea48a7188551  MAC Body:  e31891a3a773950e6d0fea48a71885515318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46  MAC  517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2  Cipher key:  f06d69cdc7da0faffb1008270bca38f5", 
            "title": "PBKDF2-SHA-256"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/#scrypt", 
            "text": "Test vector using AES-128-CTR and Scrypt:  { \n     crypto   :   { \n         cipher   :   aes-128-ctr , \n         cipherparams   :   { \n             iv   :   83dbcc02d8ccb40e466191a123791e0e \n         }, \n         ciphertext   :   d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c , \n         kdf   :   scrypt , \n         kdfparams   :   { \n             dklen   :   32 , \n             n   :   262144 , \n             r   :   1 , \n             p   :   8 , \n             salt   :   ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19 \n         }, \n         mac   :   2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097 \n     }, \n     id   :   3198bc9c-6672-5ab3-d995-4942343ae5b6 , \n     version   :   3  }   Intermediates:   Derived key:  fac192ceb5fd772906bea3e118a69e8bbb5cc24229e20d8766fd298291bba6bd  MAC Body  bb5cc24229e20d8766fd298291bba6bdd172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c  MAC:  2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097  Cipher key:  fac192ceb5fd772906bea3e118a69e8b", 
            "title": "Scrypt"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/#alterations-from-version-1", 
            "text": "This version fixes several inconsistencies with the version 1 published  here . In brief these are:   Capitalisation is unjustified and inconsistent ( scrypt  lowercase,  Kdf  mixed-case,  MAC  uppercase).  Address  unnecessary and compromises privacy.  Salt  is intrinsically a parameter of the key derivation function and deserves to be associated with it, not with the crypto in general.  SaltLen  unnecessary (just derive it from  Salt ).  The key derivation function is given, yet the crypto algorithm is hard specified.  Version  is intrinsically numeric yet is a string (structured versioning would be possible with a string, but can be considered out of scope for a rarely changing configuration file format).  KDF and cipher are notionally sibling concepts yet are organised differently.  MAC is calculated through a whitespace agnostic piece of data(!)   Changes have been made to the format to give the following file, functionally equivalent to the example given on the previously linked page:  { \n     crypto :   { \n         cipher :   aes-128-cbc , \n         ciphertext :   07533e172414bfa50e99dba4a0ce603f654ebfa1ff46277c3e0c577fdc87f6bb4e4fe16c5a94ce6ce14cfa069821ef9b , \n         cipherparams :   { \n             iv :   16d67ba0ce5a339ff2f07951253e6ba8 \n         }, \n         kdf :   scrypt , \n         kdfparams :   { \n             dklen :   32 , \n             n :   262144 , \n             p :   1 , \n             r :   8 , \n             salt :   06870e5e6a24e183a5c807bd1c43afd86d573f7db303ff4853d135cd0fd3fe91 \n         }, \n         mac :   8ccded24da2e99a11d48cda146f9cc8213eb423e2ea0d8427f41c3be414424dd , \n         version :   1 \n     }, \n     id :   0498f19a-59db-4d54-ac95-33901b4f1870 , \n     version :   2  }", 
            "title": "Alterations from Version 1"
        }, 
        {
            "location": "/D3VTechnologies/Web3-Secret-Storage-Definition/#alterations-from-version-2", 
            "text": "Version 2 was an early C++ implementation with a number of bugs. All essentials remain unchanged from it.", 
            "title": "Alterations from Version 2"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/", 
            "text": "\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u6811\n\n\n\u8bcd\u6811\u89c4\u8303\n\n\n\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811(\u4e5f\u53eb\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u6811) provide a cryptographically authenticated data structure that can be used to store all (key, value) bindings, although for the scope of this paper we are restricting keys and values to strings (to remove this restriction, just use any serialization format for other data types). They are fully deterministic, meaning that a Patricia \u8bcd\u6811 with the same (key,value) bindings is guaranteed to be exactly the same down to the last byte and therefore have the same root hash, provide the holy grail of O(log(n)) efficiency for inserts, lookups and deletes, and are much easier to understand and code than more complex comparison-based alternatives like red-black \u8bcd\u6811s.\n\n\n\u6839\u8bcd\u6811\n\n\nIn a basic radix \u8bcd\u6811, every node looks as follows:\n\n\n[i0, i1 ... in, value]\n\n\n\n\n\nWhere \ni0 ... in\n represent the symbols of the alphabet (often binary or hex), \nvalue\n is the terminal value at the node, and the values in the \ni0 ... in\n slots are either \nNULL\n or pointers to (in our case, hashes of) other nodes. This forms a basic (key, value) store; for example, if you are interested in the value that is currently mapped to \ndog\n in the \u8bcd\u6811, you would first convert \ndog\n into letters of the alphabet (giving \n64 6f 67\n), and then descend down the \u8bcd\u6811 following that path until at the end of the path you read the value. That is, you would first look up the root hash in a flat key/value DB to find the root node of the \u8bcd\u6811 (which is basically an array of keys to other nodes), use the value at index \n6\n as a key (and look it up in the flat key/value DB) to get the node one level down, then pick index \n4\n of that to lookup the next value, then pick index \n6\n of that, and so on, until, once you followed the path: \nroot -\n 6 -\n 4 -\n 6 -\n 15 -\n 6 -\n 7\n, you look up the value of the node that you have and return the result.\n\n\nNote there is a difference between looking something up in the \"\u8bcd\u6811\" vs the underlying flat key/value \"DB\". They both define key/values arrangements, but the underlying DB can do a traditional 1 step lookup of a key, while looking up a key in the \u8bcd\u6811 requires multiple underlying DB lookups to get to the final value as described above. To eliminate ambiguity, let's refer to the latter as a \npath\n.\n\n\nThe update and delete operations for radix \u8bcd\u6811s are simple, and can be defined roughly as follows:\n\n\ndef update(node,path,value):\n    if path == \n:\n        curnode = db.get(node) if node else [ NULL ] * 17\n        newnode = curnode.copy()\n        newnode[-1] = value\n    else:\n        curnode = db.get(node) if node else [ NULL ] * 17\n        newnode = curnode.copy()\n        newindex = update(curnode[path[0]],path[1:],value)\n        newnode[path[0]] = newindex\n    db.put(hash(newnode),newnode)\n    return hash(newnode)\n\ndef delete(node,path):\n    if node is NULL:\n        return NULL\n    else:\n        curnode = db.get(node)\n        newnode = curnode.copy()\n        if path == \n:\n            newnode[-1] = NULL\n        else:\n            newindex = delete(curnode[path[0]],path[1:])\n            newnode[path[0]] = newindex\n\n        if len(filter(x -\n x is not NULL, newnode)) == 0:\n            return NULL\n        else:\n            db.put(hash(newnode),newnode)\n            return hash(newnode)\n\n\n\n\n\nThe \"Merkle\" part of the radix \u8bcd\u6811 arises in the fact that a deterministic cryptographic hash of a node is used as the pointer to the node (for every lookup in the key/value DB \nkey == sha3(rlp(value))\n, rather than some 32-bit or 64-bit memory location as might happen in a more traditional \u8bcd\u6811 implemented in C. This provides a form of cryptographic authentication to the data structure; if the root hash of a given \u8bcd\u6811 is publicly known, then anyone can provide a proof that the \u8bcd\u6811 has a given value at a specific path by providing the nodes going up each step of the way. It is impossible for an attacker to provide a proof of a (path, value) pair that does not exist since the root hash is ultimately based on all hashes below it, so any modification would change the root hash.\n\n\nWhile traversing a path 1 nibble at a time as described above, most nodes contain a 17-element array. 1 index for each possible value held by the next hex character (nibble) in the path, and 1 to hold the final target value in the case that the path has been fully traversed. These 17-element array nodes are called \nbranch\n nodes.\n\n\n\u4e3b\u8981\u89c4\u8303\n\n\n\u7136\u800c, \u6839\u8bcd\u6811\u6709\u4e00\u4e2a\u4e3b\u8981\u9650\u5236: \u4ed6\u4eec\u7684\u6548\u7387\u4f4e\u4e0b. If you want to store just one (path,value) binding where the path is (in the case of the ethereum state \u8bcd\u6811), 64 characters long (number of nibbles in \nbytes32\n), you will need over a kilobyte of extra space to store one level per character, and each lookup or delete will take the full 64 steps. The Patricia \u8bcd\u6811 introduced here solves this issue.\n\n\n\u4f18\u5316\n\n\n\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811s solve the inefficiency issue by adding some extra complexity to the data structure. A node in a \u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811 is one of the following:\n\n\n\n\nNULL\n (represented as the empty string)\n\n\nbranch\n A 17-item node \n[ v0 ... v15, vt ]\n\n\nleaf\n A 2-item node \n[ encodedPath, value ]\n\n\nextension\n A 2-item node \n[ encodedPath, key ]\n\n\n\n\nWith 64 character paths it is inevitable that after traversing the first few layers of the \u8bcd\u6811, you will reach a node where no divergent path exists for at least part of the way down. It would be naive to require such a node to have empty values in every index (one for each of the 16 hex characters) besides the target index (next nibble in the path). Instead we shortcut the descent by setting up a \nextension\n node of the form \n[ encodedPath, key ]\n, where \nencodedPath\n contains the \"partial path\" to skip ahead (using compact encoding described below), and the \nkey\n is for the next db lookup.\n\n\nIn the case of a \nleaf\n node, which can be determined by a flag in the first nibble of \nencodedPath\n, the situation above occurs and also the \"partial path\" to skip ahead completes the full remainder of a path. In this case \nvalue\n is the target value itself.\n\n\nThe optimization above however introduces some ambiguity.\n\n\nWhen traversing paths in nibbles, we may end up with an odd number of nibbles to traverse, but because all data is stored in \nbytes\n format, it is not possible to differentiate between, for instance, the nibble \n1\n, and the nibbles \n01\n (both must be stored as \n01\n). To specify odd length, the partial path is prefixed with a flag.\n\n\n\u89c4\u8303\n\n\n\u5341\u516d\u8fdb\u5236\u5e8f\u5217\u4e0e\u53ef\u9009\u7ec8\u6b62\u7b26\u7684\u7d27\u51d1\u7f16\u7801\n\n\nThe flagging of both \nodd vs. even remaining partial path length\n and \nleaf vs. extension node\n as described above reside in the first nibble of the partial path of any 2-item node. They result in the following:\n\n\nhex char    bits    |    node type partial     path length\n\n\n----------------------------------------------------------\n\n   0        0000    |       extension              even\n   1        0001    |       extension              odd\n   2        0010    |   terminating (leaf)         even\n   3        0011    |   terminating (leaf)         odd\n\n\n\n\n\nFor even remaining path length (\n0\n or \n2\n), another \n0\n \"padding\" nibble will always follow.\n\n\n    \ndef\n \ncompact_encode\n(\nhexarray\n):\n\n        \nterm\n \n=\n \n1\n \nif\n \nhexarray\n[\n-\n1\n]\n \n==\n \n16\n \nelse\n \n0\n\n        \nif\n \nterm\n:\n \nhexarray\n \n=\n \nhexarray\n[:\n-\n1\n]\n\n        \noddlen\n \n=\n \nlen\n(\nhexarray\n)\n \n%\n \n2\n\n        \nflags\n \n=\n \n2\n \n*\n \nterm\n \n+\n \noddlen\n\n        \nif\n \noddlen\n:\n\n            \nhexarray\n \n=\n \n[\nflags\n]\n \n+\n \nhexarray\n\n        \nelse\n:\n\n            \nhexarray\n \n=\n \n[\nflags\n]\n \n+\n \n[\n0\n]\n \n+\n \nhexarray\n\n        \n//\n \nhexarray\n \nnow\n \nhas\n \nan\n \neven\n \nlength\n \nwhose\n \nfirst\n \nnibble\n \nis\n \nthe\n \nflags\n.\n\n        \no\n \n=\n \n\n        \nfor\n \ni\n \nin\n \nrange\n(\n0\n,\nlen\n(\nhexarray\n),\n2\n):\n\n            \no\n \n+=\n \nchr\n(\n16\n \n*\n \nhexarray\n[\ni\n]\n \n+\n \nhexarray\n[\ni\n+\n1\n])\n\n        \nreturn\n \no\n\n\n\n\n\n\u793a\u4f8b:\n\n\n [ 1, 2, 3, 4, 5, ...]\n\n11 23 45\n\n\n [ 0, 1, 2, 3, 4, 5, ...]\n\n00 01 23 45\n\n\n [ 0, f, 1, c, b, 8, 10]\n\n20 0f 1c b8\n\n\n [ f, 1, c, b, 8, 10]\n\n3f 1c b8\n\n\n\n\n\n\nHere is the extended code for getting a node in the \u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811:\n\n\ndef get_helper(node,path):\n    if path == []: return node\n    if node = \n: return \n\n    curnode = rlp.decode(node if len(node) \n 32 else db.get(node))\n    if len(curnode) == 2:\n        (k2, v2) = curnode\n        k2 = compact_decode(k2)\n        if k2 == path[:len(k2)]:\n            return get(v2, path[len(k2):])\n        else:\n            return \n\n    elif len(curnode) == 17:\n        return get_helper(curnode[path[0]],path[1:])\n\ndef get(node,path):\n    path2 = []\n    for i in range(len(path)):\n        path2.push(int(ord(path[i]) / 16))\n        path2.push(ord(path[i]) % 16)\n    path2.push(16)\n    return get_helper(node,path2)\n\n\n\n\n\n\u793a\u4f8b\n\n\nSuppose we want a \u8bcd\u6811 containing four path/value pairs  \n('do', 'verb')\n, \n('dog', 'puppy')\n, \n('doge', 'coin')\n, \n('horse', 'stallion')\n.\n\n\nFirst, we convert both paths and values to \nbytes\n. Below, actual byte representations for \npaths\n are denoted by \n, although \nvalues\n are still shown as strings, denoted by \n''\n, for easier comprehension (they, too, would actually be \nbytes\n):\n\n\n64 6f\n : \nverb\n\n\n64 6f 67\n : \npuppy\n\n\n64 6f 67 65\n : \ncoin\n\n\n68 6f 72 73 65\n : \nstallion\n\n\n\n\n\n\nNow, we build such a \u8bcd\u6811 with the following key/value pairs in the underlying DB:\n\n\nrootHash: [ \n16\n, hashA ]\nhashA:    [ \n, \n, \n, \n, hashB, \n, \n, \n, hashC, \n, \n, \n, \n, \n, \n, \n, \n ]\nhashC:    [ \n20 6f 72 73 65\n, \nstallion\n ]\nhashB:    [ \n00 6f\n, hashD ]\nhashD:    [ \n, \n, \n, \n, \n, \n, hashE, \n, \n, \n, \n, \n, \n, \n, \n, \n, \nverb\n ]\nhashE:    [ \n17\n, hashF ]\nhashF:    [ \n, \n, \n, \n, \n, \n, hashG, \n, \n, \n, \n, \n, \n, \n, \n, \n, \npuppy\n ]\nhashG:    [ \n35\n, \ncoin\n ]\n\n\n\n\n\nWhen one node is referenced inside another node, what is included is \nH(rlp.encode(x))\n, where \nH(x) = sha3(x) if len(x) \n= 32 else x\n and \nrlp.encode\n is the \nRLP\n encoding function.\n\n\nNote that when updating a \u8bcd\u6811, one needs to store the key/value pair \n(sha3(x), x)\n in a persistent lookup table \nif\n the newly-created node has length \n= 32. However, if the node is shorter than that, one does not need to store anything, since the function f(x) = x is reversible.\n\n\n\u4ee5\u592a\u574a\u8bcd\u6811\n\n\n\u4ee5\u592a\u574a\u91cc\u7684\u6240\u6709\u8bcd\u6811\u4f7f\u7528\u4e00\u4e2a\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811.\n\n\n\u5757\u9996\u91cd\u6709\u4e09\u4e2a\u4e2a\u6839\uff0c\u6765\u6e90\u4e8e\u4e09\u4e2a\u8bcd\u6811.\n\n\n\n\nstateRoot\n\n\ntransactionsRoot\n\n\nreceiptsRoot\n\n\n\n\n\u72b6\u6001\u8bcd\u6811\n\n\nThere is one global state \u8bcd\u6811, and it updates over time. In it, a \npath\n is always: \nsha3(ethereumAddress)\n and a \nvalue\n is always: \nrlp(ethereumAccount)\n. More specifically an ethereum \naccount\n is a 4 item array of \n[nonce,balance,storageRoot,codeHash]\n. At this point it's worth noting that this \nstorageRoot\n is the root of another patricia \u8bcd\u6811:\n\n\n\u5b58\u50a8\u8bcd\u6811\n\n\nStorage \u8bcd\u6811 is where \nall\n contract data lives. There is a separate storage \u8bcd\u6811 for each account. A \npath\n in this \u8bcd\u6811 is somewhat complex but they depend on \nthis\n.\n\n\n\u4ea4\u6613\u8bcd\u6811\n\n\nThere is a separate transactions \u8bcd\u6811 for every block. A \npath\n here is: \nrlp(transactionIndex)\n. \ntransactionIndex\n is its index within the block it's mined. The ordering is mostly decided by a miner so this data is unknown until mined. After a block is mined, the transaction \u8bcd\u6811 never updates.\n\n\n\u6536\u5165\u8bcd\u6811\n\n\nEvery block has its own Receipts \u8bcd\u6811. A \npath\n here is: \nrlp(transactionIndex)\n. \ntransactionIndex\n is its index within the block it's mined. Never updates.", 
            "title": "\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_1", 
            "text": "", 
            "title": "\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_2", 
            "text": "\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811(\u4e5f\u53eb\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u6811) provide a cryptographically authenticated data structure that can be used to store all (key, value) bindings, although for the scope of this paper we are restricting keys and values to strings (to remove this restriction, just use any serialization format for other data types). They are fully deterministic, meaning that a Patricia \u8bcd\u6811 with the same (key,value) bindings is guaranteed to be exactly the same down to the last byte and therefore have the same root hash, provide the holy grail of O(log(n)) efficiency for inserts, lookups and deletes, and are much easier to understand and code than more complex comparison-based alternatives like red-black \u8bcd\u6811s.", 
            "title": "\u8bcd\u6811\u89c4\u8303"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_3", 
            "text": "In a basic radix \u8bcd\u6811, every node looks as follows:  [i0, i1 ... in, value]  Where  i0 ... in  represent the symbols of the alphabet (often binary or hex),  value  is the terminal value at the node, and the values in the  i0 ... in  slots are either  NULL  or pointers to (in our case, hashes of) other nodes. This forms a basic (key, value) store; for example, if you are interested in the value that is currently mapped to  dog  in the \u8bcd\u6811, you would first convert  dog  into letters of the alphabet (giving  64 6f 67 ), and then descend down the \u8bcd\u6811 following that path until at the end of the path you read the value. That is, you would first look up the root hash in a flat key/value DB to find the root node of the \u8bcd\u6811 (which is basically an array of keys to other nodes), use the value at index  6  as a key (and look it up in the flat key/value DB) to get the node one level down, then pick index  4  of that to lookup the next value, then pick index  6  of that, and so on, until, once you followed the path:  root -  6 -  4 -  6 -  15 -  6 -  7 , you look up the value of the node that you have and return the result.  Note there is a difference between looking something up in the \"\u8bcd\u6811\" vs the underlying flat key/value \"DB\". They both define key/values arrangements, but the underlying DB can do a traditional 1 step lookup of a key, while looking up a key in the \u8bcd\u6811 requires multiple underlying DB lookups to get to the final value as described above. To eliminate ambiguity, let's refer to the latter as a  path .  The update and delete operations for radix \u8bcd\u6811s are simple, and can be defined roughly as follows:  def update(node,path,value):\n    if path ==  :\n        curnode = db.get(node) if node else [ NULL ] * 17\n        newnode = curnode.copy()\n        newnode[-1] = value\n    else:\n        curnode = db.get(node) if node else [ NULL ] * 17\n        newnode = curnode.copy()\n        newindex = update(curnode[path[0]],path[1:],value)\n        newnode[path[0]] = newindex\n    db.put(hash(newnode),newnode)\n    return hash(newnode)\n\ndef delete(node,path):\n    if node is NULL:\n        return NULL\n    else:\n        curnode = db.get(node)\n        newnode = curnode.copy()\n        if path ==  :\n            newnode[-1] = NULL\n        else:\n            newindex = delete(curnode[path[0]],path[1:])\n            newnode[path[0]] = newindex\n\n        if len(filter(x -  x is not NULL, newnode)) == 0:\n            return NULL\n        else:\n            db.put(hash(newnode),newnode)\n            return hash(newnode)  The \"Merkle\" part of the radix \u8bcd\u6811 arises in the fact that a deterministic cryptographic hash of a node is used as the pointer to the node (for every lookup in the key/value DB  key == sha3(rlp(value)) , rather than some 32-bit or 64-bit memory location as might happen in a more traditional \u8bcd\u6811 implemented in C. This provides a form of cryptographic authentication to the data structure; if the root hash of a given \u8bcd\u6811 is publicly known, then anyone can provide a proof that the \u8bcd\u6811 has a given value at a specific path by providing the nodes going up each step of the way. It is impossible for an attacker to provide a proof of a (path, value) pair that does not exist since the root hash is ultimately based on all hashes below it, so any modification would change the root hash.  While traversing a path 1 nibble at a time as described above, most nodes contain a 17-element array. 1 index for each possible value held by the next hex character (nibble) in the path, and 1 to hold the final target value in the case that the path has been fully traversed. These 17-element array nodes are called  branch  nodes.", 
            "title": "\u6839\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_4", 
            "text": "\u7136\u800c, \u6839\u8bcd\u6811\u6709\u4e00\u4e2a\u4e3b\u8981\u9650\u5236: \u4ed6\u4eec\u7684\u6548\u7387\u4f4e\u4e0b. If you want to store just one (path,value) binding where the path is (in the case of the ethereum state \u8bcd\u6811), 64 characters long (number of nibbles in  bytes32 ), you will need over a kilobyte of extra space to store one level per character, and each lookup or delete will take the full 64 steps. The Patricia \u8bcd\u6811 introduced here solves this issue.", 
            "title": "\u4e3b\u8981\u89c4\u8303"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_5", 
            "text": "\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811s solve the inefficiency issue by adding some extra complexity to the data structure. A node in a \u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811 is one of the following:   NULL  (represented as the empty string)  branch  A 17-item node  [ v0 ... v15, vt ]  leaf  A 2-item node  [ encodedPath, value ]  extension  A 2-item node  [ encodedPath, key ]   With 64 character paths it is inevitable that after traversing the first few layers of the \u8bcd\u6811, you will reach a node where no divergent path exists for at least part of the way down. It would be naive to require such a node to have empty values in every index (one for each of the 16 hex characters) besides the target index (next nibble in the path). Instead we shortcut the descent by setting up a  extension  node of the form  [ encodedPath, key ] , where  encodedPath  contains the \"partial path\" to skip ahead (using compact encoding described below), and the  key  is for the next db lookup.  In the case of a  leaf  node, which can be determined by a flag in the first nibble of  encodedPath , the situation above occurs and also the \"partial path\" to skip ahead completes the full remainder of a path. In this case  value  is the target value itself.  The optimization above however introduces some ambiguity.  When traversing paths in nibbles, we may end up with an odd number of nibbles to traverse, but because all data is stored in  bytes  format, it is not possible to differentiate between, for instance, the nibble  1 , and the nibbles  01  (both must be stored as  01 ). To specify odd length, the partial path is prefixed with a flag.", 
            "title": "\u4f18\u5316"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_6", 
            "text": "\u5341\u516d\u8fdb\u5236\u5e8f\u5217\u4e0e\u53ef\u9009\u7ec8\u6b62\u7b26\u7684\u7d27\u51d1\u7f16\u7801  The flagging of both  odd vs. even remaining partial path length  and  leaf vs. extension node  as described above reside in the first nibble of the partial path of any 2-item node. They result in the following:  hex char    bits    |    node type partial     path length  ---------------------------------------------------------- \n   0        0000    |       extension              even\n   1        0001    |       extension              odd\n   2        0010    |   terminating (leaf)         even\n   3        0011    |   terminating (leaf)         odd  For even remaining path length ( 0  or  2 ), another  0  \"padding\" nibble will always follow.       def   compact_encode ( hexarray ): \n         term   =   1   if   hexarray [ - 1 ]   ==   16   else   0 \n         if   term :   hexarray   =   hexarray [: - 1 ] \n         oddlen   =   len ( hexarray )   %   2 \n         flags   =   2   *   term   +   oddlen \n         if   oddlen : \n             hexarray   =   [ flags ]   +   hexarray \n         else : \n             hexarray   =   [ flags ]   +   [ 0 ]   +   hexarray \n         //   hexarray   now   has   an   even   length   whose   first   nibble   is   the   flags . \n         o   =   \n         for   i   in   range ( 0 , len ( hexarray ), 2 ): \n             o   +=   chr ( 16   *   hexarray [ i ]   +   hexarray [ i + 1 ]) \n         return   o   \u793a\u4f8b:   [ 1, 2, 3, 4, 5, ...] 11 23 45   [ 0, 1, 2, 3, 4, 5, ...] 00 01 23 45   [ 0, f, 1, c, b, 8, 10] 20 0f 1c b8   [ f, 1, c, b, 8, 10] 3f 1c b8   Here is the extended code for getting a node in the \u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811:  def get_helper(node,path):\n    if path == []: return node\n    if node =  : return  \n    curnode = rlp.decode(node if len(node)   32 else db.get(node))\n    if len(curnode) == 2:\n        (k2, v2) = curnode\n        k2 = compact_decode(k2)\n        if k2 == path[:len(k2)]:\n            return get(v2, path[len(k2):])\n        else:\n            return  \n    elif len(curnode) == 17:\n        return get_helper(curnode[path[0]],path[1:])\n\ndef get(node,path):\n    path2 = []\n    for i in range(len(path)):\n        path2.push(int(ord(path[i]) / 16))\n        path2.push(ord(path[i]) % 16)\n    path2.push(16)\n    return get_helper(node,path2)", 
            "title": "\u89c4\u8303"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_7", 
            "text": "Suppose we want a \u8bcd\u6811 containing four path/value pairs   ('do', 'verb') ,  ('dog', 'puppy') ,  ('doge', 'coin') ,  ('horse', 'stallion') .  First, we convert both paths and values to  bytes . Below, actual byte representations for  paths  are denoted by  , although  values  are still shown as strings, denoted by  '' , for easier comprehension (they, too, would actually be  bytes ):  64 6f  :  verb  64 6f 67  :  puppy  64 6f 67 65  :  coin  68 6f 72 73 65  :  stallion   Now, we build such a \u8bcd\u6811 with the following key/value pairs in the underlying DB:  rootHash: [  16 , hashA ]\nhashA:    [  ,  ,  ,  , hashB,  ,  ,  , hashC,  ,  ,  ,  ,  ,  ,  ,   ]\nhashC:    [  20 6f 72 73 65 ,  stallion  ]\nhashB:    [  00 6f , hashD ]\nhashD:    [  ,  ,  ,  ,  ,  , hashE,  ,  ,  ,  ,  ,  ,  ,  ,  ,  verb  ]\nhashE:    [  17 , hashF ]\nhashF:    [  ,  ,  ,  ,  ,  , hashG,  ,  ,  ,  ,  ,  ,  ,  ,  ,  puppy  ]\nhashG:    [  35 ,  coin  ]  When one node is referenced inside another node, what is included is  H(rlp.encode(x)) , where  H(x) = sha3(x) if len(x)  = 32 else x  and  rlp.encode  is the  RLP  encoding function.  Note that when updating a \u8bcd\u6811, one needs to store the key/value pair  (sha3(x), x)  in a persistent lookup table  if  the newly-created node has length  = 32. However, if the node is shorter than that, one does not need to store anything, since the function f(x) = x is reversible.", 
            "title": "\u793a\u4f8b"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_8", 
            "text": "\u4ee5\u592a\u574a\u91cc\u7684\u6240\u6709\u8bcd\u6811\u4f7f\u7528\u4e00\u4e2a\u6885\u514b\u5c14\u5e15\u7279\u91cc\u590f\u8bcd\u6811.  \u5757\u9996\u91cd\u6709\u4e09\u4e2a\u4e2a\u6839\uff0c\u6765\u6e90\u4e8e\u4e09\u4e2a\u8bcd\u6811.   stateRoot  transactionsRoot  receiptsRoot", 
            "title": "\u4ee5\u592a\u574a\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_9", 
            "text": "There is one global state \u8bcd\u6811, and it updates over time. In it, a  path  is always:  sha3(ethereumAddress)  and a  value  is always:  rlp(ethereumAccount) . More specifically an ethereum  account  is a 4 item array of  [nonce,balance,storageRoot,codeHash] . At this point it's worth noting that this  storageRoot  is the root of another patricia \u8bcd\u6811:", 
            "title": "\u72b6\u6001\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_10", 
            "text": "Storage \u8bcd\u6811 is where  all  contract data lives. There is a separate storage \u8bcd\u6811 for each account. A  path  in this \u8bcd\u6811 is somewhat complex but they depend on  this .", 
            "title": "\u5b58\u50a8\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_11", 
            "text": "There is a separate transactions \u8bcd\u6811 for every block. A  path  here is:  rlp(transactionIndex) .  transactionIndex  is its index within the block it's mined. The ordering is mostly decided by a miner so this data is unknown until mined. After a block is mined, the transaction \u8bcd\u6811 never updates.", 
            "title": "\u4ea4\u6613\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Patricia-Tree/#_12", 
            "text": "Every block has its own Receipts \u8bcd\u6811. A  path  here is:  rlp(transactionIndex) .  transactionIndex  is its index within the block it's mined. Never updates.", 
            "title": "\u6536\u5165\u8bcd\u6811"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/", 
            "text": "Peer-to-peer communications between nodes running Ethereum clients run using the underlying \n\u00d0\u039eVp2p Wire Protocol\n.\n\n\nBasic Chain Syncing\n\n\n\n\nTwo peers connect \n say Hello and send their Status message. Status includes the Total Difficulty(TD) \n hash of their best block.\n\n\nThe client with the worst TD asks peer for full chain of just block hashes.\n\n\nChain of hashes is stored in space shared by all peer connections, and used as a \"work pool\".\n\n\nWhile there are hashes in the chain of hashes that we don't have in our chain:\n\n\nAsk for N blocks from our peer using the hashes. Mark them as on their way so we don't get them from another peer.\n\n\n\n\nEthereum Sub-protocol\n\n\nStatus\n\n[\n+0x00\n: \nP\n, \nprotocolVersion\n: \nP\n, \nnetworkId\n: \nP\n, \ntd\n: \nP\n, \nbestHash\n: \nB_32\n, \ngenesisHash\n: \nB_32\n] Inform a peer of its current \nethereum\n state. This message should be sent \nafter\n the initial handshake and \nprior\n to any \nethereum\n related messages.\n\n \nprotocolVersion\n is one of:\n    * \n0x00\n for PoC-1;\n    * \n0x01\n for PoC-2;\n    * \n0x07\n for PoC-3;\n    * \n0x09\n for PoC-4.\n    * \n0x17\n for PoC-5.\n    * \n0x1c\n for PoC-6.\n    * \n61\n for PV61\n    * \n62\n for PV62\n    * \n63\n for PV63\n\n \nnetworkId\n: 0=Olympic (disused), 1=Frontier (mainnet), 2=Morden (disused), 3=Ropsten (testnet), 4=\nRinkeby\n\n\n \ntd\n: Total Difficulty of the best chain. Integer, as found in block header.\n\n \nbestHash\n: The hash of the best (i.e. highest TD) known block.\n* \ngenesisHash\n: The hash of the Genesis block.\n\n\nNewBlockHashes\n\n[\n+0x01\n: \nP\n, \nhash1\n: \nB_32\n, \nhash2\n: \nB_32\n, \n...\n] Specify one or more new blocks which have appeared on the network. The list may contain 256 hashes at most. To be maximally helpful, nodes should inform peers of all blocks that they may not be aware of. Including hashes that the sending peer could reasonably be considered to know (due to the fact they were previously informed of because that node has itself advertised knowledge of the hashes through \nNewBlockHashes\n) is considered Bad Form, and may reduce the reputation of the sending node. Including hashes that the sending node later refuses to honour with a proceeding \nGetBlocks\n message is considered Bad Form, and may reduce the reputation of the sending node.\n\n\nTransactions\n\n[\n+0x02\n: \nP\n, [\nnonce\n: \nP\n, \nreceivingAddress\n: \nB_20\n, \nvalue\n: \nP\n, \n...\n], \n...\n] Specify (a) transaction(s) that the peer should make sure is included on its transaction queue. The items in the list (following the first item \n0x12\n) are transactions in the format described in the main Ethereum specification. Nodes must not resend the same transaction to a peer in the same session. This packet must contain at least one (new) transaction.\n\n\nGetBlockHashes\n\n[\n+0x03\n: \nP\n, \nhash\n : \nB_32\n, \nmaxBlocks\n: \nP\n] Requests a \nBlockHashes\n message of at most \nmaxBlocks\n entries, of block hashes from the blockchain, starting at the parent of block \nhash\n. Does not \nrequire\n the peer to give \nmaxBlocks\n hashes - they could give somewhat fewer.\n\n\nBlockHashes\n\n[\n+0x04\n: \nP\n, \nhash_0\n: \nB_32\n, \nhash_1\n: \nB_32\n, \n...\n] Gives a series of hashes of blocks (each the child of the next). This implies that the blocks are ordered from youngest to oldest.\n\n\nGetBlocks\n\n[\n+0x05\n: \nP\n, \nhash_0\n: \nB_32\n, \nhash_1\n: \nB_32\n, \n...\n] Requests a \nBlocks\n message detailing a number of blocks to be sent, each referred to by a hash. Note: Don't expect that the peer necessarily give you all these blocks in a single message - you might have to re-request them.\n\n\nBlocks\n\n[\n+0x06\n, [\nblockHeader\n, \ntransactionList\n, \nuncleList\n], \n...\n] Specify (a) block(s) as an answer to \nGetBlocks\n. The items in the list (following the message ID) are blocks in the format described in the main Ethereum specification. This may validly contain no blocks if no blocks were able to be returned for the \nGetBlocks\n query.\n\n\nNewBlock\n\n[\n+0x07\n, [\nblockHeader\n, \ntransactionList\n, \nuncleList\n], \ntotalDifficulty\n] Specify a single block that the peer should know about. The composite item in the list (following the message ID) is a block in the format described in the main Ethereum specification.\n- \ntotalDifficulty\n is the total difficulty of the block (aka score).\n\n\nPV61 specific\n\n\nBlockHashesFromNumber\n\n[\n+0x08\n: \nP\n, \nnumber\n: \nP\n, \nmaxBlocks\n: \nP\n]\nRequires peer to reply with a \nBlockHashes\n message. Message should contain block with that of number \nnumber\n on the canonical chain. Should also be followed by subsequent blocks, on the same chain, detailing a number of the first block hash and a total of hashes to be sent. Returned hash list must be ordered by block number in ascending order.\n\n\nNew model syncing (PV62)\n\n\nNewBlockHashes\n\n[\n+0x01\n: \nP\n, [\nhash_0\n: \nB_32\n, \nnumber_0\n: \nP\n], [\nhash_1\n: \nB_32\n, \nnumber_1\n: \nP\n], ...] Specify one or more new blocks which have appeared on the network. To be maximally helpful, nodes should inform peers of all blocks that they may not be aware of. Including hashes that the sending peer could reasonably be considered to know (due to the fact they were previously informed of because that node has itself advertised knowledge of the hashes through \nNewBlockHashes\n) is considered Bad Form, and may reduce the reputation of the sending node. Including hashes that the sending node later refuses to honour with a proceeding \nGetBlockHeaders\n message is considered Bad Form, and may reduce the reputation of the sending node.\n\n\nGetBlockHeaders\n\n[\n+0x03\n: \nP\n, \nblock\n: { \nP\n , \nB_32\n }, \nmaxHeaders\n: \nP\n, \nskip\n: \nP\n, \nreverse\n: \nP\n in { \n0\n , \n1\n } ] Require peer to return a \nBlockHeaders\n message. Reply must contain a number of block headers, of rising number when \nreverse\n is \n0\n, falling when \n1\n, \nskip\n blocks apart, beginning at block \nblock\n (denoted by either number or hash) in the canonical chain, and with at most \nmaxHeaders\n items.\n\n\nBlockHeaders\n\n[\n+0x04\n, \nblockHeader_0\n, \nblockHeader_1\n, \n...\n] Reply to \nGetBlockHeaders\n. The items in the list (following the message ID) are block headers in the format described in the main Ethereum specification, previously asked for in a \nGetBlockHeaders\n message. This may validly contain no block headers if no block headers were able to be returned for the \nGetBlockHeaders\n query.\n\n\nGetBlockBodies\n\n[\n+0x05\n, \nhash_0\n: \nB_32\n, \nhash_1\n: \nB_32\n, \n...\n] Require peer to return a \nBlockBodies\n message. Specify the set of blocks that we're interested in with the hashes.\n\n\nBlockBodies\n\n[\n+0x06\n, [\ntransactions_0\n, \nuncles_0\n] , \n...\n] Reply to \nGetBlockBodies\n. The items in the list (following the message ID) are some of the blocks, minus the header, in the format described in the main Ethereum specification, previously asked for in a \nGetBlockBodies\n message. This may validly contain no items if no blocks were able to be returned for the \nGetBlockBodies\n query.\n\n\nELIMINATED: \nGetBlockHashes\n, \nBlockHashes\n, \nGetBlocks\n, \nBlocks\n, \nBlockHashesFromNumber\n\n\nFast synchronization (PV63)\n\n\nGetNodeData\n\n[\n+0x0d\n, \nhash_0\n: \nB_32\n, \nhash_1\n: \nB_32\n, \n...\n] Require peer to return a \nNodeData\n message. Hint that useful values in it are those which correspond to given hashes.\n\n\nNodeData\n\n[\n+0x0e\n, \nvalue_0\n: \nB\n, \nvalue_1\n: \nB\n, \n...\n] Provide a set of values which correspond to previously asked node data hashes from \nGetNodeData\n. Does not need to contain all; best effort is fine. If it contains none, then has no information for previous \nGetNodeData\n hashes.\n\n\nGetReceipts\n\n[\n+0x0f\n, \nhash_0\n: \nB_32\n, \nhash_1\n: \nB_32\n, \n...\n] Require peer to return a \nReceipts\n message. Hint that useful values in it are those which correspond to blocks of the given hashes.\n\n\nReceipts\n\n[\n+0x10\n, [\nreceipt_0\n, \nreceipt_1\n], \n...\n] Provide a set of receipts which correspond to previously asked in \nGetReceipts\n.\n\n\nSession Management\n\n\nFor the Ethereum sub-protocol, upon an active session, a \nStatus\n message must be sent. Following the reception of the peer's \nStatus\n message, the Ethereum session is active and any other messages may be sent. All transactions should initially be sent with one or more Transactions messages.\n\n\nTransactions messages should also be sent periodically as the node has new transactions to disseminate. A node should never send a transaction back to the peer that it can determine already knows of it (either because it was previously sent or because it was informed from this peer originally).\n\n\nUpcoming changes\n\n\n\n\nLight Client Protocol\n\n\n\n\nChanges (PoC-7)\n\n\n\n\nNewBlock Message\n\n\n\n\nChanged (PoC-6)\n\n\n\n\nParallel Block Downloads", 
            "title": "\u6709\u7ebf\u534f\u8bae"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#basic-chain-syncing", 
            "text": "Two peers connect   say Hello and send their Status message. Status includes the Total Difficulty(TD)   hash of their best block.  The client with the worst TD asks peer for full chain of just block hashes.  Chain of hashes is stored in space shared by all peer connections, and used as a \"work pool\".  While there are hashes in the chain of hashes that we don't have in our chain:  Ask for N blocks from our peer using the hashes. Mark them as on their way so we don't get them from another peer.", 
            "title": "Basic Chain Syncing"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#ethereum-sub-protocol", 
            "text": "Status \n[ +0x00 :  P ,  protocolVersion :  P ,  networkId :  P ,  td :  P ,  bestHash :  B_32 ,  genesisHash :  B_32 ] Inform a peer of its current  ethereum  state. This message should be sent  after  the initial handshake and  prior  to any  ethereum  related messages.   protocolVersion  is one of:\n    *  0x00  for PoC-1;\n    *  0x01  for PoC-2;\n    *  0x07  for PoC-3;\n    *  0x09  for PoC-4.\n    *  0x17  for PoC-5.\n    *  0x1c  for PoC-6.\n    *  61  for PV61\n    *  62  for PV62\n    *  63  for PV63   networkId : 0=Olympic (disused), 1=Frontier (mainnet), 2=Morden (disused), 3=Ropsten (testnet), 4= Rinkeby    td : Total Difficulty of the best chain. Integer, as found in block header.   bestHash : The hash of the best (i.e. highest TD) known block.\n*  genesisHash : The hash of the Genesis block.  NewBlockHashes \n[ +0x01 :  P ,  hash1 :  B_32 ,  hash2 :  B_32 ,  ... ] Specify one or more new blocks which have appeared on the network. The list may contain 256 hashes at most. To be maximally helpful, nodes should inform peers of all blocks that they may not be aware of. Including hashes that the sending peer could reasonably be considered to know (due to the fact they were previously informed of because that node has itself advertised knowledge of the hashes through  NewBlockHashes ) is considered Bad Form, and may reduce the reputation of the sending node. Including hashes that the sending node later refuses to honour with a proceeding  GetBlocks  message is considered Bad Form, and may reduce the reputation of the sending node.  Transactions \n[ +0x02 :  P , [ nonce :  P ,  receivingAddress :  B_20 ,  value :  P ,  ... ],  ... ] Specify (a) transaction(s) that the peer should make sure is included on its transaction queue. The items in the list (following the first item  0x12 ) are transactions in the format described in the main Ethereum specification. Nodes must not resend the same transaction to a peer in the same session. This packet must contain at least one (new) transaction.  GetBlockHashes \n[ +0x03 :  P ,  hash  :  B_32 ,  maxBlocks :  P ] Requests a  BlockHashes  message of at most  maxBlocks  entries, of block hashes from the blockchain, starting at the parent of block  hash . Does not  require  the peer to give  maxBlocks  hashes - they could give somewhat fewer.  BlockHashes \n[ +0x04 :  P ,  hash_0 :  B_32 ,  hash_1 :  B_32 ,  ... ] Gives a series of hashes of blocks (each the child of the next). This implies that the blocks are ordered from youngest to oldest.  GetBlocks \n[ +0x05 :  P ,  hash_0 :  B_32 ,  hash_1 :  B_32 ,  ... ] Requests a  Blocks  message detailing a number of blocks to be sent, each referred to by a hash. Note: Don't expect that the peer necessarily give you all these blocks in a single message - you might have to re-request them.  Blocks \n[ +0x06 , [ blockHeader ,  transactionList ,  uncleList ],  ... ] Specify (a) block(s) as an answer to  GetBlocks . The items in the list (following the message ID) are blocks in the format described in the main Ethereum specification. This may validly contain no blocks if no blocks were able to be returned for the  GetBlocks  query.  NewBlock \n[ +0x07 , [ blockHeader ,  transactionList ,  uncleList ],  totalDifficulty ] Specify a single block that the peer should know about. The composite item in the list (following the message ID) is a block in the format described in the main Ethereum specification.\n-  totalDifficulty  is the total difficulty of the block (aka score).", 
            "title": "Ethereum Sub-protocol"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#pv61-specific", 
            "text": "BlockHashesFromNumber \n[ +0x08 :  P ,  number :  P ,  maxBlocks :  P ]\nRequires peer to reply with a  BlockHashes  message. Message should contain block with that of number  number  on the canonical chain. Should also be followed by subsequent blocks, on the same chain, detailing a number of the first block hash and a total of hashes to be sent. Returned hash list must be ordered by block number in ascending order.", 
            "title": "PV61 specific"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#new-model-syncing-pv62", 
            "text": "NewBlockHashes \n[ +0x01 :  P , [ hash_0 :  B_32 ,  number_0 :  P ], [ hash_1 :  B_32 ,  number_1 :  P ], ...] Specify one or more new blocks which have appeared on the network. To be maximally helpful, nodes should inform peers of all blocks that they may not be aware of. Including hashes that the sending peer could reasonably be considered to know (due to the fact they were previously informed of because that node has itself advertised knowledge of the hashes through  NewBlockHashes ) is considered Bad Form, and may reduce the reputation of the sending node. Including hashes that the sending node later refuses to honour with a proceeding  GetBlockHeaders  message is considered Bad Form, and may reduce the reputation of the sending node.  GetBlockHeaders \n[ +0x03 :  P ,  block : {  P  ,  B_32  },  maxHeaders :  P ,  skip :  P ,  reverse :  P  in {  0  ,  1  } ] Require peer to return a  BlockHeaders  message. Reply must contain a number of block headers, of rising number when  reverse  is  0 , falling when  1 ,  skip  blocks apart, beginning at block  block  (denoted by either number or hash) in the canonical chain, and with at most  maxHeaders  items.  BlockHeaders \n[ +0x04 ,  blockHeader_0 ,  blockHeader_1 ,  ... ] Reply to  GetBlockHeaders . The items in the list (following the message ID) are block headers in the format described in the main Ethereum specification, previously asked for in a  GetBlockHeaders  message. This may validly contain no block headers if no block headers were able to be returned for the  GetBlockHeaders  query.  GetBlockBodies \n[ +0x05 ,  hash_0 :  B_32 ,  hash_1 :  B_32 ,  ... ] Require peer to return a  BlockBodies  message. Specify the set of blocks that we're interested in with the hashes.  BlockBodies \n[ +0x06 , [ transactions_0 ,  uncles_0 ] ,  ... ] Reply to  GetBlockBodies . The items in the list (following the message ID) are some of the blocks, minus the header, in the format described in the main Ethereum specification, previously asked for in a  GetBlockBodies  message. This may validly contain no items if no blocks were able to be returned for the  GetBlockBodies  query.  ELIMINATED:  GetBlockHashes ,  BlockHashes ,  GetBlocks ,  Blocks ,  BlockHashesFromNumber", 
            "title": "New model syncing (PV62)"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#fast-synchronization-pv63", 
            "text": "GetNodeData \n[ +0x0d ,  hash_0 :  B_32 ,  hash_1 :  B_32 ,  ... ] Require peer to return a  NodeData  message. Hint that useful values in it are those which correspond to given hashes.  NodeData \n[ +0x0e ,  value_0 :  B ,  value_1 :  B ,  ... ] Provide a set of values which correspond to previously asked node data hashes from  GetNodeData . Does not need to contain all; best effort is fine. If it contains none, then has no information for previous  GetNodeData  hashes.  GetReceipts \n[ +0x0f ,  hash_0 :  B_32 ,  hash_1 :  B_32 ,  ... ] Require peer to return a  Receipts  message. Hint that useful values in it are those which correspond to blocks of the given hashes.  Receipts \n[ +0x10 , [ receipt_0 ,  receipt_1 ],  ... ] Provide a set of receipts which correspond to previously asked in  GetReceipts .", 
            "title": "Fast synchronization (PV63)"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#session-management", 
            "text": "For the Ethereum sub-protocol, upon an active session, a  Status  message must be sent. Following the reception of the peer's  Status  message, the Ethereum session is active and any other messages may be sent. All transactions should initially be sent with one or more Transactions messages.  Transactions messages should also be sent periodically as the node has new transactions to disseminate. A node should never send a transaction back to the peer that it can determine already knows of it (either because it was previously sent or because it was informed from this peer originally).", 
            "title": "Session Management"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#upcoming-changes", 
            "text": "Light Client Protocol", 
            "title": "Upcoming changes"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#changes-poc-7", 
            "text": "NewBlock Message", 
            "title": "Changes (PoC-7)"
        }, 
        {
            "location": "/Technologies/Ethereum-Wire-Protocol/#changed-poc-6", 
            "text": "Parallel Block Downloads", 
            "title": "Changed (PoC-6)"
        }, 
        {
            "location": "/Technologies/Light-client-protocol/", 
            "text": "\u8f7b\u5ba2\u6237\u7aef\u534f\u8bae\n\n\nNote: The light client protocol is under development. See the following links for current state of the protocol specification.\n\n\n\n\nhttps://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29\n\n\nhttps://github.com/zsfelfoldi/go-ethereum/wiki/Client-Side-Flow-Control-model-for-the-LES-protocol\n\n\n\n\n\n\n\u524d\u8a00\n\n\nThe purpose of the light client protocol is to allow users in low-capacity environments (embedded smart property environments, smartphones, browser extensions, some desktops, etc) to maintain a high-security assurance about the current state of some particular part of the Ethereum state or verify the execution of a transaction. Although full security is only possible for a full node, the light client protocol allows light nodes processing about 1KB of data per 2 minutes to receive data from the network about the parts of the state that are of concern to them, and be sure that the data is correct  provided that the majority of miners are correctly following the protocol, and perhaps even only provided that at least one honest verifying full node exists.\n\n\n\u80cc\u666f: \u5e15\u7279\u91cc\u590f\u6885\u514b\u5c14\u6811\n\n\nAll substantial quantities of data in Ethereum are stored in a data structure known as the \nPatricia Merkle tree\n, a tree structure where each node in the tree is the hash of its children. Each set of key/value pairs maps to a unique root hash, and only a small subset of nodes is needed to prove that a particular key/value combination is in the tree corresponding to a particular root hash.\n\n\nThe size complexity of a Merkle proof scales linearly with the height of a tree; because each child in a tree has a particular number of children (in our case, up to 17), this means that the size complexity of a Merkle proof is logarithmic in the quantity of data stored. This means that, even if the entire state tree is a few gigabytes in size, if a node receives a state root from a trusted source that node has the ability to know with full certainty the validity of any information with the tree by only downloading a few kilobytes of data in a proof.\n\n\nAn SPV proof of a node in a Patricia tree simply consists of the complete subset of tree nodes that were processed in order to access it (or, more specifically, the tree nodes that needed to be looked up in a reverse-hash-lookup database). In a simple implementation of a Patricia tree, retrieving the value associated with a particular key requires descending the hash tree, constantly looking up nodes in the database by their hashes, until you eventually reach the final leaf node; a simple algorithm for producing an SPV proof is to simply run this naive algorithm, and record all of the database lookups that were made. SPV verification consists of running the naive lookup algorithm but pointing it to a custom database populated only with the nodes in the SPV proof; if there is a \"node not found\" error, then the proof is invalid.\n\n\n\u539f\u5219\n\n\nIn Ethereum, a light client can be viewed as a client that downloads block headers by default, and verifies only a small portion of what needs to be verified, using a distributed hash table as a database for trie nodes in place of its local hard drive. For a \"partially light client\", which processes everything but is constrained by hard drive space and so stores almost nothing, swapping out a database read with a DHT get request is by itself sufficient to meet the requirements. Indeed, all \"full clients\" except for archive nodes (intended to be run by businesses, block explorers, etc) will eventually be set up as \"partially light clients\" with respect to all history older than a few thousand blocks. However, what we are also interested in supporting is \nfully\n light clients, which never even process most transactions. Formally, we can say that \nall\n measures of a full light client are bounded by a sublinear function of the number of transactions in a block - in most cases, the protocols below work for a bound of O(log(n)), though one particular mechanism works only for ~O(sqrt(n)).\n\n\nSome use cases for a fully light client, and how the light client meets those use cases, include:\n\n\n\n\nA light client wants to know the state of an account (nonce, balance, code or storage index) at a particular time. The light client can simply recursively download trie nodes from the state root until it gets to the desired value.\n\n\nA light client wants to check that a transaction was confirmed. The light client can simply ask the network for the index and block number of that transaction, and recursively download transaction trie nodes to check for availability.\n\n\nLight clients want to collectively validate a block. Each light client \nC[i]\n chooses one transaction index \ni\n with transaction \nT[i]\n (with corresponding receipt \nR[i]\n) and does the following:\n\n\nInitiate the state with state root \nR[i-1].medstate\n and \nR[i-1].gas_used\n (if \ni = 0\n use the parent endstate and 0 \ngas_used\n)\n\n\nProcess transaction \nT[i]\n\n\nCheck that the resulting state root is \nR[i].medstate\n and the gas_used is \nR[i].gas_used\n\n\nCheck that the set of logs and bloom produced matches \nR[i].logs\n and \nR[i].logbloom\n\n\nChecks that the bloom is a subset of the block header-level bloom (this detects block header-level blooms with false negatives); then pick a few random indices of the block header-level bloom where that bloom contains a 1 and ask other nodes for a transaction-level bloom that contains a 1 at that index, rejecting the block if no response is given (this detects block header-level blooms with false positives)\n\n\n\n\n\n\nLight clients want to \"watch\" for events that are logged. The protocol here is the following:\n\n\nA light client gets all block headers, checks for block headers that contain bloom filters that match one of a desired list of addresses or topics that the light client is interested in\n\n\nUpon finding a potentially matching block header, the light client downloads all transaction receipts, checks them for transactions whose bloom filters match\n\n\nUpon finding a potentially matching transaction, the light client checks its actual log RLP, and sees if it actually matches\n\n\n\n\n\n\n\n\nThe first three light client protocols require a logarithmic amount of data access and computation; the fourth requires ~O(sqrt(N)) since bloom filters are only a two-level structure, although this can be improved to O(log(N)) if the light client is willing to rely on multiple providers to point to \"interesting\" transaction indices and decommission providers if they are revealed to have missed a transaction. The first protocol is useful to simply check up on state, and the second in consumer-merchant scenarios to check that a transaction was validated. The third protocol allows Ethereum light clients to collectively validate blocks with a very low degree of trust. In Bitcoin, for example, a miner can create a block that gives the miner an excessive amount of transaction fees, and there would be no way for light nodes to detect this themselves, or upon seeing an honest full node detect it verify a proof of invalidity. In Ethereum, if a block is invalid, it must contain an invalid state transition at some index, and so a light client that happens to be verifying that index can see that something is wrong, either because the proof step does not check out, or because data is unavailable, and that client can then raise the alarm.\n\n\nThe fourth protocol is useful in cases where a dapp wants to keep track of some kind of events that need to be efficiently verifiable, but which do not need to be part of the permanent state; an example is a decentralized exchange logging trades or a wallet logging transactions (note that the light client protocol will need to be augmented with header-level coinbase and uncle checks for this to work fully with mining accounts). In Bitcoin terminology, \nLOG\n can be viewed as a pure \"proof of publication\" opcode.", 
            "title": "\u8f7b\u7aef\u534f\u8bae"
        }, 
        {
            "location": "/Technologies/Light-client-protocol/#_1", 
            "text": "Note: The light client protocol is under development. See the following links for current state of the protocol specification.   https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29  https://github.com/zsfelfoldi/go-ethereum/wiki/Client-Side-Flow-Control-model-for-the-LES-protocol", 
            "title": "\u8f7b\u5ba2\u6237\u7aef\u534f\u8bae"
        }, 
        {
            "location": "/Technologies/Light-client-protocol/#_2", 
            "text": "The purpose of the light client protocol is to allow users in low-capacity environments (embedded smart property environments, smartphones, browser extensions, some desktops, etc) to maintain a high-security assurance about the current state of some particular part of the Ethereum state or verify the execution of a transaction. Although full security is only possible for a full node, the light client protocol allows light nodes processing about 1KB of data per 2 minutes to receive data from the network about the parts of the state that are of concern to them, and be sure that the data is correct  provided that the majority of miners are correctly following the protocol, and perhaps even only provided that at least one honest verifying full node exists.", 
            "title": "\u524d\u8a00"
        }, 
        {
            "location": "/Technologies/Light-client-protocol/#_3", 
            "text": "All substantial quantities of data in Ethereum are stored in a data structure known as the  Patricia Merkle tree , a tree structure where each node in the tree is the hash of its children. Each set of key/value pairs maps to a unique root hash, and only a small subset of nodes is needed to prove that a particular key/value combination is in the tree corresponding to a particular root hash.  The size complexity of a Merkle proof scales linearly with the height of a tree; because each child in a tree has a particular number of children (in our case, up to 17), this means that the size complexity of a Merkle proof is logarithmic in the quantity of data stored. This means that, even if the entire state tree is a few gigabytes in size, if a node receives a state root from a trusted source that node has the ability to know with full certainty the validity of any information with the tree by only downloading a few kilobytes of data in a proof.  An SPV proof of a node in a Patricia tree simply consists of the complete subset of tree nodes that were processed in order to access it (or, more specifically, the tree nodes that needed to be looked up in a reverse-hash-lookup database). In a simple implementation of a Patricia tree, retrieving the value associated with a particular key requires descending the hash tree, constantly looking up nodes in the database by their hashes, until you eventually reach the final leaf node; a simple algorithm for producing an SPV proof is to simply run this naive algorithm, and record all of the database lookups that were made. SPV verification consists of running the naive lookup algorithm but pointing it to a custom database populated only with the nodes in the SPV proof; if there is a \"node not found\" error, then the proof is invalid.", 
            "title": "\u80cc\u666f: \u5e15\u7279\u91cc\u590f\u6885\u514b\u5c14\u6811"
        }, 
        {
            "location": "/Technologies/Light-client-protocol/#_4", 
            "text": "In Ethereum, a light client can be viewed as a client that downloads block headers by default, and verifies only a small portion of what needs to be verified, using a distributed hash table as a database for trie nodes in place of its local hard drive. For a \"partially light client\", which processes everything but is constrained by hard drive space and so stores almost nothing, swapping out a database read with a DHT get request is by itself sufficient to meet the requirements. Indeed, all \"full clients\" except for archive nodes (intended to be run by businesses, block explorers, etc) will eventually be set up as \"partially light clients\" with respect to all history older than a few thousand blocks. However, what we are also interested in supporting is  fully  light clients, which never even process most transactions. Formally, we can say that  all  measures of a full light client are bounded by a sublinear function of the number of transactions in a block - in most cases, the protocols below work for a bound of O(log(n)), though one particular mechanism works only for ~O(sqrt(n)).  Some use cases for a fully light client, and how the light client meets those use cases, include:   A light client wants to know the state of an account (nonce, balance, code or storage index) at a particular time. The light client can simply recursively download trie nodes from the state root until it gets to the desired value.  A light client wants to check that a transaction was confirmed. The light client can simply ask the network for the index and block number of that transaction, and recursively download transaction trie nodes to check for availability.  Light clients want to collectively validate a block. Each light client  C[i]  chooses one transaction index  i  with transaction  T[i]  (with corresponding receipt  R[i] ) and does the following:  Initiate the state with state root  R[i-1].medstate  and  R[i-1].gas_used  (if  i = 0  use the parent endstate and 0  gas_used )  Process transaction  T[i]  Check that the resulting state root is  R[i].medstate  and the gas_used is  R[i].gas_used  Check that the set of logs and bloom produced matches  R[i].logs  and  R[i].logbloom  Checks that the bloom is a subset of the block header-level bloom (this detects block header-level blooms with false negatives); then pick a few random indices of the block header-level bloom where that bloom contains a 1 and ask other nodes for a transaction-level bloom that contains a 1 at that index, rejecting the block if no response is given (this detects block header-level blooms with false positives)    Light clients want to \"watch\" for events that are logged. The protocol here is the following:  A light client gets all block headers, checks for block headers that contain bloom filters that match one of a desired list of addresses or topics that the light client is interested in  Upon finding a potentially matching block header, the light client downloads all transaction receipts, checks them for transactions whose bloom filters match  Upon finding a potentially matching transaction, the light client checks its actual log RLP, and sees if it actually matches     The first three light client protocols require a logarithmic amount of data access and computation; the fourth requires ~O(sqrt(N)) since bloom filters are only a two-level structure, although this can be improved to O(log(N)) if the light client is willing to rely on multiple providers to point to \"interesting\" transaction indices and decommission providers if they are revealed to have missed a transaction. The first protocol is useful to simply check up on state, and the second in consumer-merchant scenarios to check that a transaction was validated. The third protocol allows Ethereum light clients to collectively validate blocks with a very low degree of trust. In Bitcoin, for example, a miner can create a block that gives the miner an excessive amount of transaction fees, and there would be no way for light nodes to detect this themselves, or upon seeing an honest full node detect it verify a proof of invalidity. In Ethereum, if a block is invalid, it must contain an invalid state transition at some index, and so a light client that happens to be verifying that index can see that something is wrong, either because the proof step does not check out, or because data is unavailable, and that client can then raise the alarm.  The fourth protocol is useful in cases where a dapp wants to keep track of some kind of events that need to be efficiently verifiable, but which do not need to be part of the permanent state; an example is a decentralized exchange logging trades or a wallet logging transactions (note that the light client protocol will need to be augmented with header-level coinbase and uncle checks for this to work fully with mining accounts). In Bitcoin terminology,  LOG  can be viewed as a pure \"proof of publication\" opcode.", 
            "title": "\u539f\u5219"
        }, 
        {
            "location": "/Technologies/Subtleties/", 
            "text": "\u7384\u673a\n\n\n\u5185\u5b58\n\n\n\n\nStorage is a key/value store where keys and values are both 32 bytes\n\n\nValues on the stack are 32 bytes\n\n\nMemory is a byte-array. Memory starts off zero-size, but can be expanded in 32-byte chunks by simply accessing or storing memory at indices greater than its current size.\n\n\nThe fee for expanding memory is determined via a subtract-the-integrals method. Specifically, \nTOTALFEE(SZ) = SZ * 3 + floor(SZ**2 / 512)\n is the total fee for expanding the memory to \nSZ\n 32-byte chunks (note: partially filled chunks are counted, so 33 bytes = 2 chunks), and if a particular operation expands memory from size \nx\n to \ny\n, the additional gas cost is \nTOTALFEE(y) - TOTALFEE(x)\n\n\nIf an operation writes a slice of data zero bytes wide to memory, even if the start index of the slice exceeds the current memory size, memory is NOT expanded.\n\n\n\n\n\u968f\u673a\u6570\n\n\n\n\nIf an externally-owned account sends a transaction, its nonce is incremented before execution\n\n\nIf an externally-owned account creates a contract, its nonce is incremented before execution. The contract's nonce starts at 1 and not 0\n\n\nIf a contract sends a message, no nonce increments happen\n\n\nIf a contract creates a contract, the following steps happen in the following order:\n\n\nThe new (\"inner\") contract's address is calculated as \nsha3(rlp.encode([outer_contract_address, outer_contract_nonce]))\n\n\nThe \"outer\" contract's nonce is incremented by 1\n\n\nThe inner contract's nonce is set to 1\n\n\nThe inner contract's code and storage are emptied\n\n\nA call is made with the code being the init code (that's the memory slice provided by the CREATE opcode)\n\n\nIf the call returns an exception, all is reverted except for the outer contract's nonce increment\n\n\nIf the call returns 24000 or more bytes, this is considered an exception\n\n\nIf the call returns x \n 24000 bytes, the outer call is charged x * 200 gas. If there is not enough gas then this is also considered an exception; if there is, then the creation succeeds and the inner contract's code is set to the return data of the call.\n\n\n\n\n\n\n\n\n\u5f02\u5e38\u60c5\u51b5\n\n\n\n\nThe following count as exceptions:\n\n\nExecution running out of gas\n\n\nAn operation trying to take more slots off the stack than are available on the stack, or put more than 1024 items onto the stack\n\n\nJumping to a bad jump destination\n\n\nAn invalid opcode (note: the code of an account is assumed to be followed by an infinite tail of STOP instructions, so the program counter \"walking off\" the end of the code is not an invalid opcode exception. However, jumping outside the code is an exception, because STOP is not a valid jump destination)\n\n\nThe REVERT opcode at 0xfd (starting from Metropolis; pre-Metropolis 0xfd is simply an invalid opcode)\n\n\n\n\n\n\nIf a transaction triggers an exception, then:\n\n\nThe value transfer from sender to recipient still sometimes takes place\n\n\nThe fee transfer from sender to miner still takes place\n\n\nThe entire \nSTARTGAS\n is added to \ngas_used\n unless the exception is the result of a \nREVERT\n opcode\n\n\nAll other execution during the exception-causing message call (or contract creation) is reverted\n\n\nWhen a transaction contains multiple message calls and contract creations, only some of them might be reverted.\n\n\n\n\n\n\nIf a contract-producing transaction triggers an exception, then:\n\n\nThe fee transfer from sender to miner still takes place\n\n\nThe endowment is subtracted from the sender's account\n\n\nThe account that would have been created gets created anyway, keeps its original endowment, but has the empty string as its code\n\n\nThe entire \nSTARTGAS\n is added to \ngas_used\n unless the exception is the result of a \nREVERT\n opcode\n\n\nAll other execution is reverted\n\n\n\n\n\n\nIf a \nCALL\n operation's sub-execution triggers an exception, then:\n\n\nEther value is still sent\n\n\nAll gas is consumed unless the exception is the result of a \nREVERT\n opcode\n\n\n0\n is appended onto the stack\n\n\nAll other execution is reverted\n\n\n\n\n\n\nIf a \nCREATE\n operation's sub-execution triggers an exception, then:\n\n\nEther value is lost\n\n\nAll gas is consumed unless the exception is the result of a \nREVERT\n opcode\n\n\nAll other execution is reverted\n\n\nThe current implementations add \n0\n onto the stack, but it does not matter, since with 0 gas remaining the parent execution will instaquit anyway\n\n\n\n\n\n\nIf a contract tries to \nCALL\n or \nCREATE\n a contract with insufficient balance, the sub-execution and transfer do not occur at all, no gas gets consumed, and 0 is added to the stack.\n\n\nA \nCALL\n or \nCREATE\n can consume at most 63/64 of the gas remaining at the time the \nCALL\n is made; if a \nCALL\n asks for more than this prescribed maximum, then the inner call will only have the prescribed maximum gas regardless of how much gas was asked for.\n\n\n\n\n\u7b97\u6cd5\n\n\n\n\nAll arithmetic is modulo 2\n256\n. For division, modulo and comparison, both signed and unsigned operators exist (eg. \n(0 - 27) / 3\n returns -9 if \nSDIV\n is used, but \n38597363079105398474523661669562635951089994888546854679819194669304376546636\n if \nDIV\n is used.\n\n\nTruncation and modulo operations with negative operators in the \nSDIV\n/\nSMOD\n case are handled as in Python (eg. , )\n\n\nDIV\n, \nSDIV\n, \nMOD\n and \nSMOD\n with dividend (second argument) equal to 0 push 0 to the stack.\n\n\n\n\n\u5176\u4ed6\u64cd\u4f5c\n\n\n\n\nThe \nCREATE\n opcode takes three values: value (ie. initial amount of ether), memory start and memory length, and pushes onto the stack the address of the new contract. \nCREATE\n gives the initializing sub-execution all the gas that you have (and if gas remains then it gets refunded back to the parent execution)\n\n\nThe \nCALL\n opcode takes seven values: gas, recipient, ether value, memory location of start of input data, length of input data, memory location to put start of output data, length of output data. It puts onto the stack either 1 for success (ie. did not run out of gas) or 0 for failure.\n\n\nWhen a contract calls \nSELFDESTRUCT\n, its ether is immediately sent to the desired address, but the contract continues existing until the end of transaction execution. Note that this leads to the interesting effect that, unlike Bitcoin where funds can be locked away forever but never destroyed, if a contract either SELFDESTRUCTs into itself or receives ether in the context of the same transaction execution after it has SELFDESTRUCTed that ether is actually destroyed.\n\n\nIf contract A calls contract B calls contract A, then the inner execution of A will have its own, fresh, memory, stack and PC, but it will modify and read the same balance and storage.\n\n\nIf contract initialization returns an empty array, then no contract will be created. This allows you to \"abuse\" contract initialization as an atomic multi-operation, which might be useful in some protocols where you want to do multiple things but you don't want some of them to be able to process without others.\n\n\nJUMP\n and \nJUMPI\n instructions are only allowed to jump onto destinations that are (1) occupied by a \nJUMPDEST\n opcode, and (2) are not inside \nPUSH\n data. Note that properly processing these conditions requires preprocessing the code; a particularly pathological use case is \nPUSH2 JUMPDEST PUSH1 PUSH2 JUMPDEST PUSH1 PUSH2 JUMPDEST PUSH1 ...\n, as this code has all \nJUMPDEST\ns invalid but an alternative piece of code equivalent to this but only with the leading \nPUSH2\n replaced with another op (eg. \nBALANCE\n) will have all \nJUMPDESTS\ns valid.\n\n\nCALL\n has a multi-part gas cost:\n\n\n700 base\n\n\n9000 additional if the value is nonzero\n\n\n25000 additional if the destination account does not yet exist (note: there is a difference between zero-balance and nonexistent!)\n\n\n\n\n\n\nCALLCODE\n operates similarly to call, except without the potential for a 25000 gas surcharge.\n\n\nThe child message of a nonzero-value \nCALL\n operation (NOT the top-level message arising from a transaction!) gains an additional 2300 gas on top of the gas supplied by the calling account; this stipend can be considered to be paid out of the 9000 mandatory additional fee for nonzero-value calls. This ensures that a call recipient will always have enough gas to log that it received funds.", 
            "title": "\u7384\u673a"
        }, 
        {
            "location": "/Technologies/Subtleties/#_1", 
            "text": "", 
            "title": "\u7384\u673a"
        }, 
        {
            "location": "/Technologies/Subtleties/#_2", 
            "text": "Storage is a key/value store where keys and values are both 32 bytes  Values on the stack are 32 bytes  Memory is a byte-array. Memory starts off zero-size, but can be expanded in 32-byte chunks by simply accessing or storing memory at indices greater than its current size.  The fee for expanding memory is determined via a subtract-the-integrals method. Specifically,  TOTALFEE(SZ) = SZ * 3 + floor(SZ**2 / 512)  is the total fee for expanding the memory to  SZ  32-byte chunks (note: partially filled chunks are counted, so 33 bytes = 2 chunks), and if a particular operation expands memory from size  x  to  y , the additional gas cost is  TOTALFEE(y) - TOTALFEE(x)  If an operation writes a slice of data zero bytes wide to memory, even if the start index of the slice exceeds the current memory size, memory is NOT expanded.", 
            "title": "\u5185\u5b58"
        }, 
        {
            "location": "/Technologies/Subtleties/#_3", 
            "text": "If an externally-owned account sends a transaction, its nonce is incremented before execution  If an externally-owned account creates a contract, its nonce is incremented before execution. The contract's nonce starts at 1 and not 0  If a contract sends a message, no nonce increments happen  If a contract creates a contract, the following steps happen in the following order:  The new (\"inner\") contract's address is calculated as  sha3(rlp.encode([outer_contract_address, outer_contract_nonce]))  The \"outer\" contract's nonce is incremented by 1  The inner contract's nonce is set to 1  The inner contract's code and storage are emptied  A call is made with the code being the init code (that's the memory slice provided by the CREATE opcode)  If the call returns an exception, all is reverted except for the outer contract's nonce increment  If the call returns 24000 or more bytes, this is considered an exception  If the call returns x   24000 bytes, the outer call is charged x * 200 gas. If there is not enough gas then this is also considered an exception; if there is, then the creation succeeds and the inner contract's code is set to the return data of the call.", 
            "title": "\u968f\u673a\u6570"
        }, 
        {
            "location": "/Technologies/Subtleties/#_4", 
            "text": "The following count as exceptions:  Execution running out of gas  An operation trying to take more slots off the stack than are available on the stack, or put more than 1024 items onto the stack  Jumping to a bad jump destination  An invalid opcode (note: the code of an account is assumed to be followed by an infinite tail of STOP instructions, so the program counter \"walking off\" the end of the code is not an invalid opcode exception. However, jumping outside the code is an exception, because STOP is not a valid jump destination)  The REVERT opcode at 0xfd (starting from Metropolis; pre-Metropolis 0xfd is simply an invalid opcode)    If a transaction triggers an exception, then:  The value transfer from sender to recipient still sometimes takes place  The fee transfer from sender to miner still takes place  The entire  STARTGAS  is added to  gas_used  unless the exception is the result of a  REVERT  opcode  All other execution during the exception-causing message call (or contract creation) is reverted  When a transaction contains multiple message calls and contract creations, only some of them might be reverted.    If a contract-producing transaction triggers an exception, then:  The fee transfer from sender to miner still takes place  The endowment is subtracted from the sender's account  The account that would have been created gets created anyway, keeps its original endowment, but has the empty string as its code  The entire  STARTGAS  is added to  gas_used  unless the exception is the result of a  REVERT  opcode  All other execution is reverted    If a  CALL  operation's sub-execution triggers an exception, then:  Ether value is still sent  All gas is consumed unless the exception is the result of a  REVERT  opcode  0  is appended onto the stack  All other execution is reverted    If a  CREATE  operation's sub-execution triggers an exception, then:  Ether value is lost  All gas is consumed unless the exception is the result of a  REVERT  opcode  All other execution is reverted  The current implementations add  0  onto the stack, but it does not matter, since with 0 gas remaining the parent execution will instaquit anyway    If a contract tries to  CALL  or  CREATE  a contract with insufficient balance, the sub-execution and transfer do not occur at all, no gas gets consumed, and 0 is added to the stack.  A  CALL  or  CREATE  can consume at most 63/64 of the gas remaining at the time the  CALL  is made; if a  CALL  asks for more than this prescribed maximum, then the inner call will only have the prescribed maximum gas regardless of how much gas was asked for.", 
            "title": "\u5f02\u5e38\u60c5\u51b5"
        }, 
        {
            "location": "/Technologies/Subtleties/#_5", 
            "text": "All arithmetic is modulo 2 256 . For division, modulo and comparison, both signed and unsigned operators exist (eg.  (0 - 27) / 3  returns -9 if  SDIV  is used, but  38597363079105398474523661669562635951089994888546854679819194669304376546636  if  DIV  is used.  Truncation and modulo operations with negative operators in the  SDIV / SMOD  case are handled as in Python (eg. , )  DIV ,  SDIV ,  MOD  and  SMOD  with dividend (second argument) equal to 0 push 0 to the stack.", 
            "title": "\u7b97\u6cd5"
        }, 
        {
            "location": "/Technologies/Subtleties/#_6", 
            "text": "The  CREATE  opcode takes three values: value (ie. initial amount of ether), memory start and memory length, and pushes onto the stack the address of the new contract.  CREATE  gives the initializing sub-execution all the gas that you have (and if gas remains then it gets refunded back to the parent execution)  The  CALL  opcode takes seven values: gas, recipient, ether value, memory location of start of input data, length of input data, memory location to put start of output data, length of output data. It puts onto the stack either 1 for success (ie. did not run out of gas) or 0 for failure.  When a contract calls  SELFDESTRUCT , its ether is immediately sent to the desired address, but the contract continues existing until the end of transaction execution. Note that this leads to the interesting effect that, unlike Bitcoin where funds can be locked away forever but never destroyed, if a contract either SELFDESTRUCTs into itself or receives ether in the context of the same transaction execution after it has SELFDESTRUCTed that ether is actually destroyed.  If contract A calls contract B calls contract A, then the inner execution of A will have its own, fresh, memory, stack and PC, but it will modify and read the same balance and storage.  If contract initialization returns an empty array, then no contract will be created. This allows you to \"abuse\" contract initialization as an atomic multi-operation, which might be useful in some protocols where you want to do multiple things but you don't want some of them to be able to process without others.  JUMP  and  JUMPI  instructions are only allowed to jump onto destinations that are (1) occupied by a  JUMPDEST  opcode, and (2) are not inside  PUSH  data. Note that properly processing these conditions requires preprocessing the code; a particularly pathological use case is  PUSH2 JUMPDEST PUSH1 PUSH2 JUMPDEST PUSH1 PUSH2 JUMPDEST PUSH1 ... , as this code has all  JUMPDEST s invalid but an alternative piece of code equivalent to this but only with the leading  PUSH2  replaced with another op (eg.  BALANCE ) will have all  JUMPDESTS s valid.  CALL  has a multi-part gas cost:  700 base  9000 additional if the value is nonzero  25000 additional if the destination account does not yet exist (note: there is a difference between zero-balance and nonexistent!)    CALLCODE  operates similarly to call, except without the potential for a 25000 gas surcharge.  The child message of a nonzero-value  CALL  operation (NOT the top-level message arising from a transaction!) gains an additional 2300 gas on top of the gas supplied by the calling account; this stipend can be considered to be paid out of the 9000 mandatory additional fee for nonzero-value calls. This ensures that a call recipient will always have enough gas to log that it received funds.", 
            "title": "\u5176\u4ed6\u64cd\u4f5c"
        }, 
        {
            "location": "/Technologies/Solidity/", 
            "text": "\u56fa\u8bed\u8a00\n\n\nsolidity", 
            "title": "\u56fa\u8bed\u8a00"
        }, 
        {
            "location": "/Technologies/Solidity/#_1", 
            "text": "solidity", 
            "title": "\u56fa\u8bed\u8a00"
        }, 
        {
            "location": "/Technologies/Ethereum-Natural-Specification-Format/", 
            "text": "Solidity contracts can have a special form of comments that form the basis of the Ethereum Natural Specification Format. For a usage example please check \nhere\n.\n\n\nDocumentation Example\n\n\nDocumentation is inserted above the function following the doxygen notation of either one or multiple lines starting with \n///\n or a multiline comment starting with \n/**\n and ending with \n*/\n.\n\n\nAs an example consider the documentation of the following function:\n\n\n  /// @notice Send `(valueInmGAV / 1000).fixed(0,3)` GAV from the account of\n  /// `message.caller.address()`, to an account accessible only by `to.address()`\n  /// @dev This should be the documentation of the function for the developer docs\n  /// @param to The address of the recipient of the GavCoin\n  /// @param valueInmGAV The GavCoin value to send\n  function send(address to, uint256 valueInmGAV) {\n    if (balances[msg.sender] \n= valueInmGAV) {\n      balances[to] += valueInmGAV;\n      balances[msg.sender] -= valueInmGAV;\n    }\n\n\n\n\nThere are a few things to note about the above example.\n- Natspec format uses doxygen tags with some special meaning. These are:\n    + @title: This is a title that should describe the contract and go above the contract definition\n    + @author: The name of the author of the contract. Should also go above the contract definition.\n    + @notice: Represents user documentation. This is the text that will appear to the user to notify him\n      of what the function he is about to execute is doing\n    + @dev: Represents developer documentation. This is documentation that would only be visible to the\n      developer.\n    + @param: Documents a parameter just like in doxygen. Has to be followed by the parameter name.\n    + @return: Documents the return type of a contract's function.\n\n\n\n\n\n\nIf any of the above are missing they are simply considered as blank and it's not illegal to omit any of them\n\n\n\n\n\n\n(valueInmGAV / 1000).fixed(0,3)\n A dynamic expression. This should be a valid Javascript/Paperscript expression, which when evaluated in an EVM Javascript environment initialised with various system values (such as parameters).\n\n\n\n\n\n\nDocumentation Output\n\n\nWhen parsed, documentation such as the one from the above example will produce 2 different json files. One is meant to be consumed by the user as a notice when a function is executed and the other to be used by the developer.\n\n\nLet us see a more full contract example.\n\n\n/// @title This is the contract title.\n/// @author Homer Simpson\ncontract GavCoin\n{\n  /// @notice Send `(valueInmGAV / 1000).fixed(0,3)` GAV from the account of\n  /// `message.caller.address()`, to an account accessible only by `to.address()\n  /// @dev This should be the documentation of the function for the developer docs\n  /// @param to The address of the recipient of the GavCoin\n  /// @param valueInmGav The GavCoin value to send\n  function send(address to, uint256 valueInmGAV) {\n    if (balances[msg.sender] \n= valueInmGAV) {\n      balances[to] += valueInmGAV;\n      balances[msg.sender] -= valueInmGAV;\n    }\n  }\n\n  /// @notice `(balanceInmGAV / 1000).fixed(0,3)` GAV is the total funds available to `who.address()`.\n  /// @param who The address of the person whose balance we check\n  /// @return The balance of the user provided as argument\n  function balance(address who) constant returns (uint256 balanceInmGAV) {\n    balanceInmGAV = balances[who];\n  }\n\n  mapping (address =\n uint256) balances;\n}\n\n\n\n\nUser Documentation\n\n\nThe above documentation will produce the following user documentation json file as output:\n\n\n{\n  \nsource\n: \n...\n,\n  \nlanguage\n: \nSolidity\n,\n  \nlanguageVersion\n: 1,\n  \nmethods\n: {\n    \nsend(address,uint256)\n: { \nnotice\n: \nSend `(valueInmGAV / 1000).fixed(0,3)` GAV from the account of `message.caller.address()`, to an account accessible only by `to.address()`.\n },\n    \nbalance(address)\n: { \nnotice\n: \n`(balanceInmGAV / 1000).fixed(0,3)` GAV is the total funds available to `who.address()`.\n }\n  },\n  \ninvariants\n: [\n    { \nnotice\n: \nThe sum total amount of GAV in the system is 1 million.\n }\n  ],\n  \nconstruction\n: [\n    { \nnotice\n: \nEndows `message.caller.address()` with 1m GAV.\n }\n  ]\n}\n\n\n\n\nNote that the key by which to find the methods is the function's canonical signature as defined in the \nContract ABI\n and not simply the function's name.\n\n\nDeveloper Documentation\n\n\nApart from the user documentation file, a developer documentation json file should also be produced and should look like this:\n\n\n{\n  \nauthor\n: \nHomer Simpson\n,\n  \ntitle\n: \nThis is the contract title.\n,\n  \nmethods\n: {\n    \nsend(uint256)\n: {\n      \ndetails\n: \nThis should be the documentation of the function for the developer docs\n\n    },\n    \nbalance\n: {\n      \ndetails\n: \n\n    }\n  },\n  \ninvariants\n: [\n     { \ndetails\n: \nThis is the invariant development documentation\n}\n  ],\n  \nconstruction\n: {\n     \ndetails\n: \n\n  }\n}\n\n\n\n\nExample usage\n\n\nThere is a detailed example of using the Natspec feature with the cpp client \nhere\n.", 
            "title": "NatSpec\u683c\u5f0f"
        }, 
        {
            "location": "/Technologies/Ethereum-Natural-Specification-Format/#documentation-example", 
            "text": "Documentation is inserted above the function following the doxygen notation of either one or multiple lines starting with  ///  or a multiline comment starting with  /**  and ending with  */ .  As an example consider the documentation of the following function:    /// @notice Send `(valueInmGAV / 1000).fixed(0,3)` GAV from the account of\n  /// `message.caller.address()`, to an account accessible only by `to.address()`\n  /// @dev This should be the documentation of the function for the developer docs\n  /// @param to The address of the recipient of the GavCoin\n  /// @param valueInmGAV The GavCoin value to send\n  function send(address to, uint256 valueInmGAV) {\n    if (balances[msg.sender]  = valueInmGAV) {\n      balances[to] += valueInmGAV;\n      balances[msg.sender] -= valueInmGAV;\n    }  There are a few things to note about the above example.\n- Natspec format uses doxygen tags with some special meaning. These are:\n    + @title: This is a title that should describe the contract and go above the contract definition\n    + @author: The name of the author of the contract. Should also go above the contract definition.\n    + @notice: Represents user documentation. This is the text that will appear to the user to notify him\n      of what the function he is about to execute is doing\n    + @dev: Represents developer documentation. This is documentation that would only be visible to the\n      developer.\n    + @param: Documents a parameter just like in doxygen. Has to be followed by the parameter name.\n    + @return: Documents the return type of a contract's function.    If any of the above are missing they are simply considered as blank and it's not illegal to omit any of them    (valueInmGAV / 1000).fixed(0,3)  A dynamic expression. This should be a valid Javascript/Paperscript expression, which when evaluated in an EVM Javascript environment initialised with various system values (such as parameters).", 
            "title": "Documentation Example"
        }, 
        {
            "location": "/Technologies/Ethereum-Natural-Specification-Format/#documentation-output", 
            "text": "When parsed, documentation such as the one from the above example will produce 2 different json files. One is meant to be consumed by the user as a notice when a function is executed and the other to be used by the developer.  Let us see a more full contract example.  /// @title This is the contract title.\n/// @author Homer Simpson\ncontract GavCoin\n{\n  /// @notice Send `(valueInmGAV / 1000).fixed(0,3)` GAV from the account of\n  /// `message.caller.address()`, to an account accessible only by `to.address()\n  /// @dev This should be the documentation of the function for the developer docs\n  /// @param to The address of the recipient of the GavCoin\n  /// @param valueInmGav The GavCoin value to send\n  function send(address to, uint256 valueInmGAV) {\n    if (balances[msg.sender]  = valueInmGAV) {\n      balances[to] += valueInmGAV;\n      balances[msg.sender] -= valueInmGAV;\n    }\n  }\n\n  /// @notice `(balanceInmGAV / 1000).fixed(0,3)` GAV is the total funds available to `who.address()`.\n  /// @param who The address of the person whose balance we check\n  /// @return The balance of the user provided as argument\n  function balance(address who) constant returns (uint256 balanceInmGAV) {\n    balanceInmGAV = balances[who];\n  }\n\n  mapping (address =  uint256) balances;\n}", 
            "title": "Documentation Output"
        }, 
        {
            "location": "/Technologies/Ethereum-Natural-Specification-Format/#user-documentation", 
            "text": "The above documentation will produce the following user documentation json file as output:  {\n   source :  ... ,\n   language :  Solidity ,\n   languageVersion : 1,\n   methods : {\n     send(address,uint256) : {  notice :  Send `(valueInmGAV / 1000).fixed(0,3)` GAV from the account of `message.caller.address()`, to an account accessible only by `to.address()`.  },\n     balance(address) : {  notice :  `(balanceInmGAV / 1000).fixed(0,3)` GAV is the total funds available to `who.address()`.  }\n  },\n   invariants : [\n    {  notice :  The sum total amount of GAV in the system is 1 million.  }\n  ],\n   construction : [\n    {  notice :  Endows `message.caller.address()` with 1m GAV.  }\n  ]\n}  Note that the key by which to find the methods is the function's canonical signature as defined in the  Contract ABI  and not simply the function's name.", 
            "title": "User Documentation"
        }, 
        {
            "location": "/Technologies/Ethereum-Natural-Specification-Format/#developer-documentation", 
            "text": "Apart from the user documentation file, a developer documentation json file should also be produced and should look like this:  {\n   author :  Homer Simpson ,\n   title :  This is the contract title. ,\n   methods : {\n     send(uint256) : {\n       details :  This should be the documentation of the function for the developer docs \n    },\n     balance : {\n       details :  \n    }\n  },\n   invariants : [\n     {  details :  This is the invariant development documentation }\n  ],\n   construction : {\n      details :  \n  }\n}", 
            "title": "Developer Documentation"
        }, 
        {
            "location": "/Technologies/Ethereum-Natural-Specification-Format/#example-usage", 
            "text": "There is a detailed example of using the Natspec feature with the cpp client  here .", 
            "title": "Example usage"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/", 
            "text": "This specification is now maintained as part of the \nSolidity documentation\n.\n\n\nFunctions\n\n\nBasic design\n\n\nWe assume the Application Binary Interface (ABI) is strongly typed, known at compilation time and static. No introspection mechanism will be provided. We assert that all contracts will have the interface definitions of any contracts they call available at compile-time.\n\n\nThis specification does not address contracts whose interface is dynamic or otherwise known only at run-time. Should these cases become important they can be adequately handled as facilities built within the Ethereum ecosystem.\n\n\nFunction Selector\n\n\nThe first four bytes of the call data for a function call specifies the function to be called. It is the\nfirst (left, high-order in big-endian) four bytes of the Keccak (SHA-3) hash of the signature of the function. The signature is defined as the canonical expression of the basic prototype, i.e.\nthe function name with the parenthesised list of parameter types. Parameter types are split by a single comma - no spaces are used.\n\n\nArgument Encoding\n\n\nStarting from the fifth byte, the encoded arguments follow. This encoding is also used in other places, e.g. the return values and also event arguments are encoded in the same way, without the four bytes specifying the function.\n\n\nTypes\n\n\nThe following elementary types exist:\n- \nuint\nM\n: unsigned integer type of \nM\n bits, \n0 \n M \n= 256\n, \nM % 8 == 0\n. e.g. \nuint32\n, \nuint8\n, \nuint256\n.\n- \nint\nM\n: two's complement signed integer type of \nM\n bits, \n0 \n M \n= 256\n, \nM % 8 == 0\n.\n- \naddress\n: equivalent to \nuint160\n, except for the assumed interpretation and language typing.\n- \nuint\n, \nint\n: synonyms for \nuint256\n, \nint256\n respectively (not to be used for computing the function selector).\n- \nbool\n: equivalent to \nuint8\n restricted to the values 0 and 1\n- \nfixed\nM\nx\nN\n: signed fixed-point decimal number of \nM\n bits, \n0 \n M \n= 256\n, \nM % 8 ==0\n, and \n0 \n N \n= 80\n, which denotes the value \nv\n as \nv / (10 ** N)\n.\n- \nufixed\nM\nx\nN\n: unsigned variant of \nfixed\nM\nx\nN\n.\n- \nfixed\n, \nufixed\n: synonyms for \nfixed128x19\n, \nufixed128x19\n respectively (not to be used for computing the function selector).\n- \nbytes\nM\n: binary type of \nM\n bytes, \n0 \n M \n= 32\n.\n- \nfunction\n: equivalent to \nbytes24\n: an address, followed by a function selector\n\n\nThe following (fixed-size) array type exists:\n- \ntype\n[M]\n: a fixed-length array of the given fixed-length type.\n\n\nThe following non-fixed-size types exist:\n- \nbytes\n: dynamic sized byte sequence.\n- \nstring\n: dynamic sized unicode string assumed to be UTF-8 encoded.\n- \ntype\n[]\n: a variable-length array of the given fixed-length type.\n\n\nFormal Specification of the Encoding\n\n\nThis specification is now maintained as part of the \nSolidity documentation\n.\n\n\nWe will now formally specify the encoding, such that it will have the following\nproperties, which are especially useful if some arguments are nested arrays:\n\n\nProperties:\n\n\n\n\n\n\nThe number of reads necessary to access a value is at most the depth of the\nvalue inside the argument array structure, i.e. four reads are needed to\nretrieve \na_i[k][l][r]\n. In a previous version of the ABI, the number of reads scaled\nlinearly with the total number of dynamic parameters in the worst case.\n\n\n\n\n\n\nThe data of a variable or array element is not interleaved with other data\nand it is relocatable, i.e. it only uses relative \"addresses\"\n\n\n\n\n\n\nWe distinguish static and dynamic types. Static types are encoded in-place and dynamic types are encoded at a separately allocated location after the current block.\n\n\nDefinition:\n The following types are called \"dynamic\":\n\n \nbytes\n\n\n \nstring\n\n\n \nT[]\n for any \nT\n\n\n \nT[k]\n for any dynamic \nT\n and any \nk \n 0\n\n\nAll other types are called \"static\".\n\n\nDefinition:\n \nlen(a)\n is the number of bytes in a binary string \na\n.\nThe type of \nlen(a)\n is assumed to be \nuint256\n.\n\n\nWe define \nenc\n, the actual encoding, as a mapping of values of the ABI types to binary strings such\nthat \nlen(enc(X))\n depends on the value of \nX\n if and only if the type of \nX\n\nis dynamic.\n\n\nDefinition:\n For any ABI value \nX\n, we recursively define \nenc(X)\n, depending\non the type of \nX\n being\n\n\n\n\nT[k]\n for any \nT\n and \nk\n:\n\n\n\n\nenc(X) = head(X[0]) ... head(X[k-1]) tail(X[0]) ... tail(X[k-1])\n\n\nwhere \nhead\n and \ntail\n are defined for \nX[i]\n being of a static type as\n    \nhead(X[i]) = enc(X[i])\n and \ntail(X[i]) = \"\"\n (the empty string)\n  and as\n    \nhead(X[i]) = enc(len(head(X[0]) ... head(X[k-1]) tail(X[0]) ... tail(X[i-1])))\n\n    \ntail(X[i]) = enc(X[i])\n\n  otherwise.\n\n\nNote that in the dynamic case, \nhead(X[i])\n is well-defined since the lengths of\n  the head parts only depend on the types and not the values. Its value is the offset\n  of the beginning of \ntail(X[i])\n relative to the start of \nenc(X)\n.\n\n\n\n\nT[]\n where \nX\n has \nk\n elements (\nk\n is assumed to be of type \nuint256\n):\n\n\n\n\nenc(X) = enc(k) enc([X[1], ..., X[k]])\n\n\ni.e. it is encoded as if it were an array of static size \nk\n, prefixed with\n  the number of elements.\n\n\n\n\nbytes\n, of length \nk\n (which is assumed to be of type \nuint256\n):\n\n\n\n\nenc(X) = enc(k) pad_right(X)\n, i.e. the number of bytes is encoded as a\n    \nuint256\n followed by the actual value of \nX\n as a byte sequence, followed by\n    the minimum number of zero-bytes such that \nlen(enc(X))\n is a multiple of 32.\n\n\n\n\nstring\n:\n\n\n\n\nenc(X) = enc(enc_utf8(X))\n, i.e. \nX\n is utf-8 encoded and this value is interpreted as of \nbytes\n type and encoded further. Note that the length used in this subsequent encoding is the number of bytes of the utf-8 encoded string, not its number of characters.\n\n\n\n\nuint\nM\n: \nenc(X)\n is the big-endian encoding of \nX\n, padded on the higher-order (left) side with zero-bytes such that the length is a multiple of 32 bytes.\n\n\naddress\n: as in the \nuint160\n case\n\n\nint\nM\n: \nenc(X)\n is the big-endian two's complement encoding of \nX\n, padded on the higher-order (left) side with \n0xff\n for negative \nX\n and with zero bytes for positive \nX\n such that the length is a multiple of 32 bytes.\n\n\nbool\n: as in the \nuint8\n case, where \n1\n is used for \ntrue\n and \n0\n for \nfalse\n\n\nfixed\nM\nx\nN\n: \nenc(X)\n is \nenc(X * 2**N)\n where \nX * 2**N\n is interpreted as a \nint256\n.\n\n\nfixed\n: as in the \nfixed128x19\n case\n\n\nufixed\nM\nx\nN\n: \nenc(X)\n is \nenc(X * 2**N)\n where \nX * 2**N\n is interpreted as a \nuint256\n.\n\n\nufixed\n: as in the \nufixed128x19\n case\n\n\nbytes\nM\n: \nenc(X)\n is the sequence of bytes in \nX\n padded with zero-bytes to a length of 32.\n\n\n\n\nNote that for any \nX\n, \nlen(enc(X))\n is a multiple of 32.\n\n\nFunction Selector and Argument Encoding\n\n\nAll in all, a call to the function \nf\n with parameters \na_1, ..., a_n\n is encoded as\n\n\nfunction_selector(f) enc([a_1, ..., a_n])\n\n\nand the return values \nv_1, ..., v_k\n of \nf\n are encoded as\n\n\nenc([v_1, ..., v_k])\n\n\nwhere the types of \n[a_1, ..., a_n]\n and \n[v_1, ..., v_k]\n are assumed to be\nfixed-size arrays of length \nn\n and \nk\n, respectively. Note that strictly,\n\n[a_1, ..., a_n]\n can be an \"array\" with elements of different types, but the\nencoding is still well-defined as the assumed common type \nT\n (above) is not\nactually used.\n\n\nExamples\n\n\nThis specification is now maintained as part of the \nSolidity documentation\n.\n\n\nGiven the contract:\n\n\ncontract\n \nFoo\n \n{\n\n  \nfunction\n \nbar\n(\nfixed\n[\n2\n]\n \nxy\n)\n \n{}\n\n  \nfunction\n \nbaz\n(\nuint32\n \nx\n,\n \nbool\n \ny\n)\n \nreturns\n \n(\nbool\n \nr\n)\n \n{\n \nr\n \n=\n \nx\n \n \n32\n \n||\n \ny\n;\n \n}\n\n  \nfunction\n \nsam\n(\nbytes\n \nname\n,\n \nbool\n \nz\n,\n \nuint\n[]\n \ndata\n)\n \n{}\n\n\n}\n\n\n\n\n\nThus for our \nFoo\n example if we wanted to call \nbaz\n with the parameters \n69\n and \ntrue\n, we would pass 68 bytes total, which can be broken down into:\n\n\n\n\n0xcdcd77c0\n: the Method ID. This is derived as the first 4 bytes of the Keccak hash of the ASCII form of the signature \nbaz(uint32,bool)\n.\n\n\n0x0000000000000000000000000000000000000000000000000000000000000045\n: the first parameter, a uint32 value \n69\n padded to 32 bytes\n\n\n0x0000000000000000000000000000000000000000000000000000000000000001\n: the second parameter - boolean \ntrue\n, padded to 32 bytes\n\n\n\n\nIn total:\n\n0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001\n\n\nIt returns a single \nbool\n. If, for example, it were to return \nfalse\n, its output would be the single byte array \n0x0000000000000000000000000000000000000000000000000000000000000000\n, a single bool.\n\n\nIf we wanted to call \nbar\n with the argument \n[2.125, 8.5]\n, we would pass 68 bytes total, broken down into:\n- \n0xab55044d\n: the Method ID. This is derived from the signature \nbar(fixed128x19[2])\n. Note that \nfixed\n is replaced with its canonical representation \nfixed128x19\n.\n- \n0x0000000000000000000000000000000220000000000000000000000000000000\n: the first part of the first parameter, a fixed128x19 value \n2.125\n.\n- \n0x0000000000000000000000000000000880000000000000000000000000000000\n: the second part of the first parameter, a fixed128x19 value \n8.5\n.\n\n\nIn total:\n\n0xab55044d00000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000\n\n\n\nIf we wanted to call \nsam\n with the arguments \n\"dave\"\n, \ntrue\n and \n[1,2,3]\n, we would pass 292 bytes total, broken down into:\n- \n0xa5643bf2\n: the Method ID. This is derived from the signature \nsam(bytes,bool,uint256[])\n. Note that \nuint\n is replaced with its canonical representation \nuint256\n.\n- \n0x0000000000000000000000000000000000000000000000000000000000000060\n: the location of the data part of the first parameter (dynamic type), measured in bytes from the start of the arguments block. In this case, \n0x60\n.\n- \n0x0000000000000000000000000000000000000000000000000000000000000001\n: the second parameter: boolean true.\n- \n0x00000000000000000000000000000000000000000000000000000000000000a0\n: the location of the data part of the third parameter (dynamic type), measured in bytes. In this case, \n0xa0\n.\n- \n0x0000000000000000000000000000000000000000000000000000000000000004\n: the data part of the first argument, it starts with the length of the byte array in elements, in this case, 4.\n- \n0x6461766500000000000000000000000000000000000000000000000000000000\n: the contents of the first argument: the UTF-8 (equal to ASCII in this case) encoding of \n\"dave\"\n, padded on the right to 32 bytes.\n- \n0x0000000000000000000000000000000000000000000000000000000000000003\n: the data part of the third argument, it starts with the length of the array in elements, in this case, 3.\n- \n0x0000000000000000000000000000000000000000000000000000000000000001\n: the first entry of the third parameter.\n- \n0x0000000000000000000000000000000000000000000000000000000000000002\n: the second entry of the third parameter.\n- \n0x0000000000000000000000000000000000000000000000000000000000000003\n: the third entry of the third parameter.\n\n\nIn total:\n\n0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003\n\n\n\nUse of Dynamic Types\n\n\nThis specification is now maintained as part of the \nSolidity documentation\n.\n\n\nA call to a function with the signature \nf(uint,uint32[],bytes10,bytes)\n with values \n(0x123, [0x456, 0x789], \"1234567890\", \"Hello, world!\")\n is encoded in the following way:\n\n\nWe take the first four bytes of \nsha3(\"f(uint256,uint32[],bytes10,bytes)\")\n, i.e. \n0x8be65246\n.\nThen we encode the head parts of all four arguments. For the static types \nuint256\n and \nbytes10\n, these are directly the values we want to pass, whereas for the dynamic types \nuint32[]\n and \nbytes\n, we use the offset in bytes to the start of their data area, measured from the start of the value encoding (i.e. not counting the first four bytes containing the hash of the function signature). These are:\n\n\n\n\n0x0000000000000000000000000000000000000000000000000000000000000123\n (\n0x123\n padded to 32 bytes)\n\n\n0x0000000000000000000000000000000000000000000000000000000000000080\n (offset to start of data part of second parameter, 4*32 bytes, exactly the size of the head part)\n\n\n0x3132333435363738393000000000000000000000000000000000000000000000\n (\n\"1234567890\"\n padded to 32 bytes on the right)\n\n\n0x00000000000000000000000000000000000000000000000000000000000000e0\n (offset to start of data part of fourth parameter = offset to start of data part of first dynamic parameter + size of data part of first dynamic parameter = 4*32 + 3*32 (see below))\n\n\n\n\nAfter this, the data part of the first dynamic argument, \n[0x456, 0x789]\n follows:\n\n\n\n\n0x0000000000000000000000000000000000000000000000000000000000000002\n (number of elements of the array, 2)\n\n\n0x0000000000000000000000000000000000000000000000000000000000000456\n (first element)\n\n\n0x0000000000000000000000000000000000000000000000000000000000000789\n (second element)\n\n\n\n\nFinally, we encode the data part of the second dynamic argument, \n\"Hello, world!\"\n:\n\n\n\n\n0x000000000000000000000000000000000000000000000000000000000000000d\n (number of elements (bytes in this case): 13)\n\n\n0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000\n (\n\"Hello, world!\"\n padded to 32 bytes on the right)\n\n\n\n\nAll together, the encoding is (newline after function selector and each 32-bytes for clarity):\n\n\n0x8be65246\n0000000000000000000000000000000000000000000000000000000000000123\n0000000000000000000000000000000000000000000000000000000000000080\n3132333435363738393000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000e0\n0000000000000000000000000000000000000000000000000000000000000002\n0000000000000000000000000000000000000000000000000000000000000456\n0000000000000000000000000000000000000000000000000000000000000789\n000000000000000000000000000000000000000000000000000000000000000d\n48656c6c6f2c20776f726c642100000000000000000000000000000000000000\n\n\n\n\nEvents\n\n\nThis specification is now maintained as part of the \nSolidity documentation\n.\n\n\nEvents are an abstraction of the Ethereum logging/event-watching protocol. Log entries provide the contract's address, a series of up to four topics and some arbitrary length binary data. Events leverage the existing function ABI in order to interpret this (together with an interface spec) as a properly typed structure.\n\n\nGiven an event name and series of event parameters, we split them into two sub-series: those which are indexed and those which are not. Those which are indexed, which may number up to 3, are used alongside the Keccak hash of the event signature to form the topics of the log entry. Those which are not indexed form the byte array of the event.\n\n\nIn effect, a log entry using this ABI is described as:\n\n\n\n\naddress\n: the address of the contract (intrinsically provided by Ethereum);\n\n\ntopics[0]\n: \nkeccak(EVENT_NAME+\"(\"+EVENT_ARGS.map(canonical_type_of).join(\",\")+\")\")\n (\ncanonical_type_of\n is a function that simply returns the canonical type of a given argument, e.g. for \nuint indexed foo\n, it would return \nuint256\n). If the event is declared as \nanonymous\n the \ntopics[0]\n is not generated;\n\n\ntopics[n]\n: \nEVENT_INDEXED_ARGS[n - 1]\n (\nEVENT_INDEXED_ARGS\n is the series of \nEVENT_ARGS\n that are indexed);\n\n\ndata\n: \nabi_serialise(EVENT_NON_INDEXED_ARGS)\n (\nEVENT_NON_INDEXED_ARGS\n is the series of \nEVENT_ARGS\n that are not indexed, \nabi_serialise\n is the ABI serialisation function used for returning a series of typed values from a function, as described above).\n\n\n\n\nJSON\n\n\nThis specification is now maintained as part of the \nSolidity documentation\n.\n\n\nThe JSON format for a contract's interface is given by an array of function and/or event descriptions. A function description is a JSON object with the fields:\n\n\n\n\ntype\n: \n\"function\"\n, \n\"constructor\"\n, or \n\"fallback\"\n (the \nunnamed \"default\" function\n);\n\n\nname\n: the name of the function;\n\n\ninputs\n: an array of objects, each of which contains:\n\n\nname\n: the name of the parameter;\n\n\ntype\n: the canonical type of the parameter.\n\n\noutputs\n: an array of objects similar to \ninputs\n, can be omitted if function doesn't return anything;\n\n\nconstant\n: \ntrue\n if function is \nspecified to not modify blockchain state\n;\n\n\npayable\n: \ntrue\n if function accepts ether, defaults to \nfalse\n.\n\n\n\n\ntype\n can be omitted, defaulting to \n\"function\"\n.\n\n\nConstructor and fallback function never have \nname\n or \noutputs\n. Fallback function doesn't have \ninputs\n either.\n\n\nSending non-zero ether to non-payable function will throw. Don't do it.\n\n\nAn event description is a JSON object with fairly similar fields:\n\n\n\n\ntype\n: always \n\"event\"\n\n\nname\n: the name of the event;\n\n\ninputs\n: an array of objects, each of which contains:\n\n\nname\n: the name of the parameter;\n\n\ntype\n: the canonical type of the parameter.\n\n\nindexed\n: \ntrue\n if the field is part of the log's topics, \nfalse\n if it one of the log's data segment.\n\n\nanonymous\n: \ntrue\n if the event was declared as \nanonymous\n.\n\n\n\n\nFor example,\n\n\ncontract\n \nTest\n \n{\n\n  \nfunction\n \nTest\n(){\n \nb\n \n=\n \n0x12345678901234567890123456789012\n;\n \n}\n\n  \nevent\n \nEvent\n(\nuint\n \nindexed\n \na\n,\n \nbytes32\n \nb\n);\n\n  \nevent\n \nEvent2\n(\nuint\n \nindexed\n \na\n,\n \nbytes32\n \nb\n);\n\n  \nfunction\n \nfoo\n(\nuint\n \na\n)\n \n{\n \nEvent\n(\na\n,\n \nb\n);\n \n}\n\n  \nbytes32\n \nb\n;\n\n\n}\n\n\n\n\n\nwould result in the JSON:\n\n\n[{\n\n\ntype\n:\nevent\n,\n\n\ninputs\n:\n \n[{\nname\n:\na\n,\ntype\n:\nuint256\n,\nindexed\n:\ntrue\n},{\nname\n:\nb\n,\ntype\n:\nbytes32\n,\nindexed\n:\nfalse\n}],\n\n\nname\n:\nEvent\n\n\n},\n \n{\n\n\ntype\n:\nevent\n,\n\n\ninputs\n:\n \n[{\nname\n:\na\n,\ntype\n:\nuint256\n,\nindexed\n:\ntrue\n},{\nname\n:\nb\n,\ntype\n:\nbytes32\n,\nindexed\n:\nfalse\n}],\n\n\nname\n:\nEvent2\n\n\n},\n \n{\n\n\ntype\n:\nfunction\n,\n\n\ninputs\n:\n \n[{\nname\n:\na\n,\ntype\n:\nuint256\n}],\n\n\nname\n:\nfoo\n,\n\n\noutputs\n:\n \n[]\n\n\n}]\n\n\n\n\n\nExample Javascript Usage\n\n\nThis specification is now maintained as part of the \nSolidity documentation\n.\n\n\nvar\n \nTest\n \n=\n \neth\n.\ncontract\n(\n\n\n[{\n\n\ntype\n:\nevent\n,\n\n\ninputs\n:\n \n[{\nname\n:\na\n,\ntype\n:\nuint256\n,\nindexed\n:\ntrue\n},{\nname\n:\nb\n,\ntype\n:\nbytes32\n,\nindexed\n:\nfalse\n}],\n\n\nname\n:\nEvent\n\n\n},\n \n{\n\n\ntype\n:\nevent\n,\n\n\ninputs\n:\n \n[{\nname\n:\na\n,\ntype\n:\nuint256\n,\nindexed\n:\ntrue\n},{\nname\n:\nb\n,\ntype\n:\nbytes32\n,\nindexed\n:\nfalse\n}],\n\n\nname\n:\nEvent2\n\n\n},\n \n{\n\n\ntype\n:\nfunction\n,\n\n\ninputs\n:\n \n[{\nname\n:\na\n,\ntype\n:\nuint256\n}],\n\n\nname\n:\nfoo\n,\n\n\noutputs\n:\n \n[]\n\n\n}]);\n\n\nvar\n \ntheTest\n \n=\n \nnew\n \nTest\n(\naddrTest\n);\n\n\n\n// examples of usage:\n\n\n// every log entry (\nevent\n) coming from theTest (i.e. Event \n Event2):\n\n\nvar\n \nf0\n \n=\n \neth\n.\nfilter\n(\ntheTest\n);\n\n\n// just log entries (\nevents\n) of type \nEvent\n coming from theTest:\n\n\nvar\n \nf1\n \n=\n \neth\n.\nfilter\n(\ntheTest\n.\nEvent\n);\n\n\n// also written as\n\n\nvar\n \nf1\n \n=\n \ntheTest\n.\nEvent\n();\n\n\n// just log entries (\nevents\n) of type \nEvent\n and \nEvent2\n coming from theTest:\n\n\nvar\n \nf2\n \n=\n \neth\n.\nfilter\n([\ntheTest\n.\nEvent\n,\n \ntheTest\n.\nEvent2\n]);\n\n\n// just log entries (\nevents\n) of type \nEvent\n coming from theTest with indexed parameter \na\n equal to 69:\n\n\nvar\n \nf3\n \n=\n \neth\n.\nfilter\n(\ntheTest\n.\nEvent\n,\n \n{\na\n:\n \n69\n});\n\n\n// also written as\n\n\nvar\n \nf3\n \n=\n \ntheTest\n.\nEvent\n({\na\n:\n \n69\n});\n\n\n// just log entries (\nevents\n) of type \nEvent\n coming from theTest with indexed parameter \na\n equal to 69 or 42:\n\n\nvar\n \nf4\n \n=\n \neth\n.\nfilter\n(\ntheTest\n.\nEvent\n,\n \n{\na\n:\n \n[\n69\n,\n \n42\n]});\n\n\n// also written as\n\n\nvar\n \nf4\n \n=\n \ntheTest\n.\nEvent\n({\na\n:\n \n[\n69\n,\n \n42\n]});\n\n\n\n// options may also be supplied as a second parameter with `earliest`, `latest`, `offset` and `max`, as defined for `eth.filter`.\n\n\nvar\n \noptions\n \n=\n \n{\n \nmax\n:\n \n100\n \n};\n\n\nvar\n \nf4\n \n=\n \ntheTest\n.\nEvent\n({\na\n:\n \n[\n69\n,\n \n42\n]},\n \noptions\n);\n\n\n\nvar\n \ntrigger\n;\n\n\nf4\n.\nwatch\n(\ntrigger\n);\n\n\n\n// call foo to make an Event:\n\n\ntheTest\n.\nfoo\n(\n69\n);\n\n\n\n// would call trigger like:\n\n\n//trigger(theTest.Event, {\na\n: 69, \nb\n: \n0x12345678901234567890123456789012\n}, n);\n\n\n// where n is the block number that the event triggered in.\n\n\n\n\n\nImplementation:\n\n\n// e.g. f4 would be similar to:\n\n\nweb3\n.\neth\n.\nfilter\n({\nmax\n:\n \n100\n,\n \naddress\n:\n \ntheTest\n.\naddress\n,\n \ntopics\n:\n \n[\n \n[\n69\n,\n \n42\n]\n \n]});\n\n\n// except that the resultant data would need to be converted from the basic log entry format like:\n\n\n{\n\n  \naddress\n:\n \ntheTest\n.\naddress\n,\n\n  \ntopics\n:\n \n[\nweb3\n.\nsha3\n(\nEvent(uint256,bytes32)\n),\n \n0x00\n...\n0045\n \n/* 69 in hex format */\n],\n\n  \ndata\n:\n \n0x12345678901234567890123456789012\n,\n\n  \nnumber\n:\n \nn\n\n\n}\n\n\n// into data good for the trigger, specifically the three fields:\n\n  \nTest\n.\nEvent\n \n// derivable from the first topic\n\n  \n{\na\n:\n \n69\n,\n \nb\n:\n \n0x12345678901234567890123456789012\n}\n \n// derivable from the \nindexed\n bool in the interface, the later \ntopics\n and the \ndata\n\n  \nn\n \n// from the \nnumber\n\n\n\n\n\nEvent result:\n\n[\n \n{\n\n  \nevent\n:\n \nTest\n.\nEvent\n,\n\n  \nargs\n:\n \n{\na\n:\n \n69\n,\n \nb\n:\n \n0x12345678901234567890123456789012\n},\n\n  \nnumber\n:\n \nn\n\n  \n},\n\n  \n{\n \n...\n\n  \n}\n \n...\n\n\n]", 
            "title": "\u5408\u540cABI"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#basic-design", 
            "text": "We assume the Application Binary Interface (ABI) is strongly typed, known at compilation time and static. No introspection mechanism will be provided. We assert that all contracts will have the interface definitions of any contracts they call available at compile-time.  This specification does not address contracts whose interface is dynamic or otherwise known only at run-time. Should these cases become important they can be adequately handled as facilities built within the Ethereum ecosystem.", 
            "title": "Basic design"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#function-selector", 
            "text": "The first four bytes of the call data for a function call specifies the function to be called. It is the\nfirst (left, high-order in big-endian) four bytes of the Keccak (SHA-3) hash of the signature of the function. The signature is defined as the canonical expression of the basic prototype, i.e.\nthe function name with the parenthesised list of parameter types. Parameter types are split by a single comma - no spaces are used.", 
            "title": "Function Selector"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#argument-encoding", 
            "text": "Starting from the fifth byte, the encoded arguments follow. This encoding is also used in other places, e.g. the return values and also event arguments are encoded in the same way, without the four bytes specifying the function.", 
            "title": "Argument Encoding"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#types", 
            "text": "The following elementary types exist:\n-  uint M : unsigned integer type of  M  bits,  0   M  = 256 ,  M % 8 == 0 . e.g.  uint32 ,  uint8 ,  uint256 .\n-  int M : two's complement signed integer type of  M  bits,  0   M  = 256 ,  M % 8 == 0 .\n-  address : equivalent to  uint160 , except for the assumed interpretation and language typing.\n-  uint ,  int : synonyms for  uint256 ,  int256  respectively (not to be used for computing the function selector).\n-  bool : equivalent to  uint8  restricted to the values 0 and 1\n-  fixed M x N : signed fixed-point decimal number of  M  bits,  0   M  = 256 ,  M % 8 ==0 , and  0   N  = 80 , which denotes the value  v  as  v / (10 ** N) .\n-  ufixed M x N : unsigned variant of  fixed M x N .\n-  fixed ,  ufixed : synonyms for  fixed128x19 ,  ufixed128x19  respectively (not to be used for computing the function selector).\n-  bytes M : binary type of  M  bytes,  0   M  = 32 .\n-  function : equivalent to  bytes24 : an address, followed by a function selector  The following (fixed-size) array type exists:\n-  type [M] : a fixed-length array of the given fixed-length type.  The following non-fixed-size types exist:\n-  bytes : dynamic sized byte sequence.\n-  string : dynamic sized unicode string assumed to be UTF-8 encoded.\n-  type [] : a variable-length array of the given fixed-length type.", 
            "title": "Types"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#formal-specification-of-the-encoding", 
            "text": "This specification is now maintained as part of the  Solidity documentation .  We will now formally specify the encoding, such that it will have the following\nproperties, which are especially useful if some arguments are nested arrays:  Properties:    The number of reads necessary to access a value is at most the depth of the\nvalue inside the argument array structure, i.e. four reads are needed to\nretrieve  a_i[k][l][r] . In a previous version of the ABI, the number of reads scaled\nlinearly with the total number of dynamic parameters in the worst case.    The data of a variable or array element is not interleaved with other data\nand it is relocatable, i.e. it only uses relative \"addresses\"    We distinguish static and dynamic types. Static types are encoded in-place and dynamic types are encoded at a separately allocated location after the current block.  Definition:  The following types are called \"dynamic\":   bytes    string    T[]  for any  T    T[k]  for any dynamic  T  and any  k   0  All other types are called \"static\".  Definition:   len(a)  is the number of bytes in a binary string  a .\nThe type of  len(a)  is assumed to be  uint256 .  We define  enc , the actual encoding, as a mapping of values of the ABI types to binary strings such\nthat  len(enc(X))  depends on the value of  X  if and only if the type of  X \nis dynamic.  Definition:  For any ABI value  X , we recursively define  enc(X) , depending\non the type of  X  being   T[k]  for any  T  and  k :   enc(X) = head(X[0]) ... head(X[k-1]) tail(X[0]) ... tail(X[k-1])  where  head  and  tail  are defined for  X[i]  being of a static type as\n     head(X[i]) = enc(X[i])  and  tail(X[i]) = \"\"  (the empty string)\n  and as\n     head(X[i]) = enc(len(head(X[0]) ... head(X[k-1]) tail(X[0]) ... tail(X[i-1]))) \n     tail(X[i]) = enc(X[i]) \n  otherwise.  Note that in the dynamic case,  head(X[i])  is well-defined since the lengths of\n  the head parts only depend on the types and not the values. Its value is the offset\n  of the beginning of  tail(X[i])  relative to the start of  enc(X) .   T[]  where  X  has  k  elements ( k  is assumed to be of type  uint256 ):   enc(X) = enc(k) enc([X[1], ..., X[k]])  i.e. it is encoded as if it were an array of static size  k , prefixed with\n  the number of elements.   bytes , of length  k  (which is assumed to be of type  uint256 ):   enc(X) = enc(k) pad_right(X) , i.e. the number of bytes is encoded as a\n     uint256  followed by the actual value of  X  as a byte sequence, followed by\n    the minimum number of zero-bytes such that  len(enc(X))  is a multiple of 32.   string :   enc(X) = enc(enc_utf8(X)) , i.e.  X  is utf-8 encoded and this value is interpreted as of  bytes  type and encoded further. Note that the length used in this subsequent encoding is the number of bytes of the utf-8 encoded string, not its number of characters.   uint M :  enc(X)  is the big-endian encoding of  X , padded on the higher-order (left) side with zero-bytes such that the length is a multiple of 32 bytes.  address : as in the  uint160  case  int M :  enc(X)  is the big-endian two's complement encoding of  X , padded on the higher-order (left) side with  0xff  for negative  X  and with zero bytes for positive  X  such that the length is a multiple of 32 bytes.  bool : as in the  uint8  case, where  1  is used for  true  and  0  for  false  fixed M x N :  enc(X)  is  enc(X * 2**N)  where  X * 2**N  is interpreted as a  int256 .  fixed : as in the  fixed128x19  case  ufixed M x N :  enc(X)  is  enc(X * 2**N)  where  X * 2**N  is interpreted as a  uint256 .  ufixed : as in the  ufixed128x19  case  bytes M :  enc(X)  is the sequence of bytes in  X  padded with zero-bytes to a length of 32.   Note that for any  X ,  len(enc(X))  is a multiple of 32.", 
            "title": "Formal Specification of the Encoding"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#function-selector-and-argument-encoding", 
            "text": "All in all, a call to the function  f  with parameters  a_1, ..., a_n  is encoded as  function_selector(f) enc([a_1, ..., a_n])  and the return values  v_1, ..., v_k  of  f  are encoded as  enc([v_1, ..., v_k])  where the types of  [a_1, ..., a_n]  and  [v_1, ..., v_k]  are assumed to be\nfixed-size arrays of length  n  and  k , respectively. Note that strictly, [a_1, ..., a_n]  can be an \"array\" with elements of different types, but the\nencoding is still well-defined as the assumed common type  T  (above) is not\nactually used.", 
            "title": "Function Selector and Argument Encoding"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#examples", 
            "text": "This specification is now maintained as part of the  Solidity documentation .  Given the contract:  contract   Foo   { \n   function   bar ( fixed [ 2 ]   xy )   {} \n   function   baz ( uint32   x ,   bool   y )   returns   ( bool   r )   {   r   =   x     32   ||   y ;   } \n   function   sam ( bytes   name ,   bool   z ,   uint []   data )   {}  }   Thus for our  Foo  example if we wanted to call  baz  with the parameters  69  and  true , we would pass 68 bytes total, which can be broken down into:   0xcdcd77c0 : the Method ID. This is derived as the first 4 bytes of the Keccak hash of the ASCII form of the signature  baz(uint32,bool) .  0x0000000000000000000000000000000000000000000000000000000000000045 : the first parameter, a uint32 value  69  padded to 32 bytes  0x0000000000000000000000000000000000000000000000000000000000000001 : the second parameter - boolean  true , padded to 32 bytes   In total: 0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001 \nIt returns a single  bool . If, for example, it were to return  false , its output would be the single byte array  0x0000000000000000000000000000000000000000000000000000000000000000 , a single bool.  If we wanted to call  bar  with the argument  [2.125, 8.5] , we would pass 68 bytes total, broken down into:\n-  0xab55044d : the Method ID. This is derived from the signature  bar(fixed128x19[2]) . Note that  fixed  is replaced with its canonical representation  fixed128x19 .\n-  0x0000000000000000000000000000000220000000000000000000000000000000 : the first part of the first parameter, a fixed128x19 value  2.125 .\n-  0x0000000000000000000000000000000880000000000000000000000000000000 : the second part of the first parameter, a fixed128x19 value  8.5 .  In total: 0xab55044d00000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000  If we wanted to call  sam  with the arguments  \"dave\" ,  true  and  [1,2,3] , we would pass 292 bytes total, broken down into:\n-  0xa5643bf2 : the Method ID. This is derived from the signature  sam(bytes,bool,uint256[]) . Note that  uint  is replaced with its canonical representation  uint256 .\n-  0x0000000000000000000000000000000000000000000000000000000000000060 : the location of the data part of the first parameter (dynamic type), measured in bytes from the start of the arguments block. In this case,  0x60 .\n-  0x0000000000000000000000000000000000000000000000000000000000000001 : the second parameter: boolean true.\n-  0x00000000000000000000000000000000000000000000000000000000000000a0 : the location of the data part of the third parameter (dynamic type), measured in bytes. In this case,  0xa0 .\n-  0x0000000000000000000000000000000000000000000000000000000000000004 : the data part of the first argument, it starts with the length of the byte array in elements, in this case, 4.\n-  0x6461766500000000000000000000000000000000000000000000000000000000 : the contents of the first argument: the UTF-8 (equal to ASCII in this case) encoding of  \"dave\" , padded on the right to 32 bytes.\n-  0x0000000000000000000000000000000000000000000000000000000000000003 : the data part of the third argument, it starts with the length of the array in elements, in this case, 3.\n-  0x0000000000000000000000000000000000000000000000000000000000000001 : the first entry of the third parameter.\n-  0x0000000000000000000000000000000000000000000000000000000000000002 : the second entry of the third parameter.\n-  0x0000000000000000000000000000000000000000000000000000000000000003 : the third entry of the third parameter.  In total: 0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003", 
            "title": "Examples"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#use-of-dynamic-types", 
            "text": "This specification is now maintained as part of the  Solidity documentation .  A call to a function with the signature  f(uint,uint32[],bytes10,bytes)  with values  (0x123, [0x456, 0x789], \"1234567890\", \"Hello, world!\")  is encoded in the following way:  We take the first four bytes of  sha3(\"f(uint256,uint32[],bytes10,bytes)\") , i.e.  0x8be65246 .\nThen we encode the head parts of all four arguments. For the static types  uint256  and  bytes10 , these are directly the values we want to pass, whereas for the dynamic types  uint32[]  and  bytes , we use the offset in bytes to the start of their data area, measured from the start of the value encoding (i.e. not counting the first four bytes containing the hash of the function signature). These are:   0x0000000000000000000000000000000000000000000000000000000000000123  ( 0x123  padded to 32 bytes)  0x0000000000000000000000000000000000000000000000000000000000000080  (offset to start of data part of second parameter, 4*32 bytes, exactly the size of the head part)  0x3132333435363738393000000000000000000000000000000000000000000000  ( \"1234567890\"  padded to 32 bytes on the right)  0x00000000000000000000000000000000000000000000000000000000000000e0  (offset to start of data part of fourth parameter = offset to start of data part of first dynamic parameter + size of data part of first dynamic parameter = 4*32 + 3*32 (see below))   After this, the data part of the first dynamic argument,  [0x456, 0x789]  follows:   0x0000000000000000000000000000000000000000000000000000000000000002  (number of elements of the array, 2)  0x0000000000000000000000000000000000000000000000000000000000000456  (first element)  0x0000000000000000000000000000000000000000000000000000000000000789  (second element)   Finally, we encode the data part of the second dynamic argument,  \"Hello, world!\" :   0x000000000000000000000000000000000000000000000000000000000000000d  (number of elements (bytes in this case): 13)  0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000  ( \"Hello, world!\"  padded to 32 bytes on the right)   All together, the encoding is (newline after function selector and each 32-bytes for clarity):  0x8be65246\n0000000000000000000000000000000000000000000000000000000000000123\n0000000000000000000000000000000000000000000000000000000000000080\n3132333435363738393000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000e0\n0000000000000000000000000000000000000000000000000000000000000002\n0000000000000000000000000000000000000000000000000000000000000456\n0000000000000000000000000000000000000000000000000000000000000789\n000000000000000000000000000000000000000000000000000000000000000d\n48656c6c6f2c20776f726c642100000000000000000000000000000000000000", 
            "title": "Use of Dynamic Types"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#events", 
            "text": "This specification is now maintained as part of the  Solidity documentation .  Events are an abstraction of the Ethereum logging/event-watching protocol. Log entries provide the contract's address, a series of up to four topics and some arbitrary length binary data. Events leverage the existing function ABI in order to interpret this (together with an interface spec) as a properly typed structure.  Given an event name and series of event parameters, we split them into two sub-series: those which are indexed and those which are not. Those which are indexed, which may number up to 3, are used alongside the Keccak hash of the event signature to form the topics of the log entry. Those which are not indexed form the byte array of the event.  In effect, a log entry using this ABI is described as:   address : the address of the contract (intrinsically provided by Ethereum);  topics[0] :  keccak(EVENT_NAME+\"(\"+EVENT_ARGS.map(canonical_type_of).join(\",\")+\")\")  ( canonical_type_of  is a function that simply returns the canonical type of a given argument, e.g. for  uint indexed foo , it would return  uint256 ). If the event is declared as  anonymous  the  topics[0]  is not generated;  topics[n] :  EVENT_INDEXED_ARGS[n - 1]  ( EVENT_INDEXED_ARGS  is the series of  EVENT_ARGS  that are indexed);  data :  abi_serialise(EVENT_NON_INDEXED_ARGS)  ( EVENT_NON_INDEXED_ARGS  is the series of  EVENT_ARGS  that are not indexed,  abi_serialise  is the ABI serialisation function used for returning a series of typed values from a function, as described above).", 
            "title": "Events"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#json", 
            "text": "This specification is now maintained as part of the  Solidity documentation .  The JSON format for a contract's interface is given by an array of function and/or event descriptions. A function description is a JSON object with the fields:   type :  \"function\" ,  \"constructor\" , or  \"fallback\"  (the  unnamed \"default\" function );  name : the name of the function;  inputs : an array of objects, each of which contains:  name : the name of the parameter;  type : the canonical type of the parameter.  outputs : an array of objects similar to  inputs , can be omitted if function doesn't return anything;  constant :  true  if function is  specified to not modify blockchain state ;  payable :  true  if function accepts ether, defaults to  false .   type  can be omitted, defaulting to  \"function\" .  Constructor and fallback function never have  name  or  outputs . Fallback function doesn't have  inputs  either.  Sending non-zero ether to non-payable function will throw. Don't do it.  An event description is a JSON object with fairly similar fields:   type : always  \"event\"  name : the name of the event;  inputs : an array of objects, each of which contains:  name : the name of the parameter;  type : the canonical type of the parameter.  indexed :  true  if the field is part of the log's topics,  false  if it one of the log's data segment.  anonymous :  true  if the event was declared as  anonymous .   For example,  contract   Test   { \n   function   Test (){   b   =   0x12345678901234567890123456789012 ;   } \n   event   Event ( uint   indexed   a ,   bytes32   b ); \n   event   Event2 ( uint   indexed   a ,   bytes32   b ); \n   function   foo ( uint   a )   {   Event ( a ,   b );   } \n   bytes32   b ;  }   would result in the JSON:  [{  type : event ,  inputs :   [{ name : a , type : uint256 , indexed : true },{ name : b , type : bytes32 , indexed : false }],  name : Event  },   {  type : event ,  inputs :   [{ name : a , type : uint256 , indexed : true },{ name : b , type : bytes32 , indexed : false }],  name : Event2  },   {  type : function ,  inputs :   [{ name : a , type : uint256 }],  name : foo ,  outputs :   []  }]", 
            "title": "JSON"
        }, 
        {
            "location": "/Technologies/Ethereum-Contract-ABI/#example-javascript-usage", 
            "text": "This specification is now maintained as part of the  Solidity documentation .  var   Test   =   eth . contract (  [{  type : event ,  inputs :   [{ name : a , type : uint256 , indexed : true },{ name : b , type : bytes32 , indexed : false }],  name : Event  },   {  type : event ,  inputs :   [{ name : a , type : uint256 , indexed : true },{ name : b , type : bytes32 , indexed : false }],  name : Event2  },   {  type : function ,  inputs :   [{ name : a , type : uint256 }],  name : foo ,  outputs :   []  }]);  var   theTest   =   new   Test ( addrTest );  // examples of usage:  // every log entry ( event ) coming from theTest (i.e. Event   Event2):  var   f0   =   eth . filter ( theTest );  // just log entries ( events ) of type  Event  coming from theTest:  var   f1   =   eth . filter ( theTest . Event );  // also written as  var   f1   =   theTest . Event ();  // just log entries ( events ) of type  Event  and  Event2  coming from theTest:  var   f2   =   eth . filter ([ theTest . Event ,   theTest . Event2 ]);  // just log entries ( events ) of type  Event  coming from theTest with indexed parameter  a  equal to 69:  var   f3   =   eth . filter ( theTest . Event ,   { a :   69 });  // also written as  var   f3   =   theTest . Event ({ a :   69 });  // just log entries ( events ) of type  Event  coming from theTest with indexed parameter  a  equal to 69 or 42:  var   f4   =   eth . filter ( theTest . Event ,   { a :   [ 69 ,   42 ]});  // also written as  var   f4   =   theTest . Event ({ a :   [ 69 ,   42 ]});  // options may also be supplied as a second parameter with `earliest`, `latest`, `offset` and `max`, as defined for `eth.filter`.  var   options   =   {   max :   100   };  var   f4   =   theTest . Event ({ a :   [ 69 ,   42 ]},   options );  var   trigger ;  f4 . watch ( trigger );  // call foo to make an Event:  theTest . foo ( 69 );  // would call trigger like:  //trigger(theTest.Event, { a : 69,  b :  0x12345678901234567890123456789012 }, n);  // where n is the block number that the event triggered in.   Implementation:  // e.g. f4 would be similar to:  web3 . eth . filter ({ max :   100 ,   address :   theTest . address ,   topics :   [   [ 69 ,   42 ]   ]});  // except that the resultant data would need to be converted from the basic log entry format like:  { \n   address :   theTest . address , \n   topics :   [ web3 . sha3 ( Event(uint256,bytes32) ),   0x00 ... 0045   /* 69 in hex format */ ], \n   data :   0x12345678901234567890123456789012 , \n   number :   n  }  // into data good for the trigger, specifically the three fields: \n   Test . Event   // derivable from the first topic \n   { a :   69 ,   b :   0x12345678901234567890123456789012 }   // derivable from the  indexed  bool in the interface, the later  topics  and the  data \n   n   // from the  number   Event result: [   { \n   event :   Test . Event , \n   args :   { a :   69 ,   b :   0x12345678901234567890123456789012 }, \n   number :   n \n   }, \n   {   ... \n   }   ...  ]", 
            "title": "Example Javascript Usage"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/", 
            "text": "Send a JSONRPC request to \nhttps://badblocks.ethdev.com\n:\n\n\nCall \neth_badBlock(BADBLOCK)\n, with \nBADBLOCK\n the object described below:\n\n\nBADBLOCK Object Format\n\n\nNOTE: All hex is lower-case.\n\n\nTypes\n\n\n\n\nDATA\n: freeform byte array as a string of hex, \nno 0x prefix\n.\n\n\nDATA_20\n: like DATA, always of length 40.\n\n\nHEX\n: string of hex-encoded big-endian integer, used for VM stack/memory/storage items, \nno 0x prefix\n, \nno leading zeroes\n.\n\n\nINT\n: simple JS integer.\n\n\nBIGINT\n: string of decimal-encoded integer, used for potentially bigints.\n\n\nTAG_ERROR\n: described later.\n\n\nTAG_INST\n: string of an EVM instruction mnemonic, uppercase e.g. \n\"PUSH4\"\n or \n\"STOP\"\n.\n\n\nVMTRACE\n: described later.\n\n\n\n\nType modifiers\n\n\n\n\nSOMETIMES\n: field is omitted under certain circumstances.\n\n\nNONSTANDARD\n: field may safely be omitted.\n\n\n\n\nBADBLOCKS object\n\n\n{\n\n    \nblock\n:\n \nDATA\n\n    \nerrortype\n:\n \nTAG_ERROR\n\n    \nhints\n:\n \n{\n \n(all\n \nitems\n \nOPTIONAL)\n\n        \nreceipts\n:\n \n[\n \nDATA\n,\n \n...\n \n],\n \nOPTIONAL\n\n        \nvmtrace\n:\n \nVMTRACE\n,\n \nOPTIONAL\n\n    \n},\n \nOPTIONAL\n\n\n}\n\n\n\n\n\nWhere:\n\n\nreceipts\n is simply the array of RLP-encoded receipts.\n\n\nTAG_ERROR\n is a string containing one of (specified roughly in order of ability to detect):\n\n\nGeneric:\n\n\n\n\nRLPError\n: One of the following:\n\n\nBadRLP\n: Generally invalid RLP (e.g. 0x8100).\n\n\nBadCast\n: Given RLP is of an incorrect type (e.g. 0x00 being interpreted as an integer).\n\n\nOversizeRLP\n: Additional bytes trailing an otherwise valid RLP fragment (e.g. 0x8000).\n\n\nUndersizeRLP\n: Bytes missing from the end of an otherwise valid RLP fragment (e.g. 0x81).\n\n\n\n\nBlock-specific:\n\n\n\n\nInvalidBlock\n: One of the following:\n\n\nInvalidBlockFormat\n: Block format is wrong (!= array, != 3 items \nc.).\n\n\nTooManyUncles\n: More than 2 uncles mentioned.\n\n\nInvalidTransactionsRoot\n: Transactions root is different to that derived from transactions given in block.\n\n\nInvalidUnclesHash\n: Uncles hash is different to that derived from uncles given in block.\n\n\nInvalidGasUsed\n: Gas used is not equal to the gasUsed in the last receipt (or previous block if no transactions).\n\n\nInvalidStateRoot\n: State root mentioned is different to that calculated (i.e. reward application is incorrect).\n\n\nInvalidReceiptsRoot\n: Receipts root mentioned is different to that calculated (i.e. appliaction of a transaction resulted in different logs, gas-used or state-root). \"receipts\" and \"vmtrace\" should be hinted.\n\n\n\n\nBlock-header-specific\n\n\n\n\nInvalidHeader\n: One of the following:\n\n\nInvalidBlockHeaderItemCount\n: Wrong item count in header.\n\n\nTooMuchGasUsed\n: Header states gas used as bigger than gas limit.\n\n\nExtraDataTooBig\n: Header's extra data is greater than limit.\n\n\nInvalidDifficulty\n: Difficulty is incorrect given previous block's difficulty and timestamp.\n\n\nInvalidGasLimit\n: Gas limit does not fall within bounds given previous block's gas limit.\n\n\nInvalidBlockNonce\n: Nonce does not result in a proof of work which satisfies the given difficulty.\n\n\nInvalidNumber\n: Number is not equal to parent number + 1.\n\n\nInvalidTimestamp\n: Timestamp is not greater than parent's.\n\n\nInvalidLogBloom\n: LogBloom is not equal to the bitwise-OR of all receipts' LogBlooms.\n\n\n\n\nTransaction-specific\n\n\n\n\nInvalidTransaction\n: One of the following:\n\n\nOutOfGasIntrinsic\n: GAS below amount required for any transaction.\n\n\nBlockGasLimitReached\n: Too much gas being used for the transaction within this block.\n\n\nInvalidSignature\n: Transaction's signature is invalid.\n\n\nOutOfGasBase\n: GAS below amount required for this transaction.\n\n\nNotEnoughCash\n: Balance of sender too low.\n\n\nInvalidNonce\n: Transaction nonce is wrong.\n\n\n\n\nUncle-specific\n\n\n\n\nInvalidUncle\n: One of the following:\n\n\nUncleInChain\n: Uncle has already been included in the current chain (either as a direct ancestor or one of its included uncles).\n\n\nUncleTooOld\n: Uncle is older than the 6th generation uncle.\n\n\nUncleIsBrother\n: Uncle is newer than the 1st generation uncle.\n\n\n\n\nand \nVMTRACE\n is the object:\n\n\n[\n\n    \n{\n\n        \nstack\n:\n \n[\n \nHEX\n,\n \n...\n \n]\n\n        \nmemory\n:\n \nHEX\n,\n \nSOMETIMES\n\n        \nsha3memory\n:\n \nDATA_\n32\n,\n \nSOMETIMES\n\n        \nstorage\n:\n \n{\n \nHEX:\n \nHEX\n \n},\n \nSOMETIMES\n\n        \ngas\n:\n \nBIGINT\n\n        \npc\n:\n \nBIGINT\n\n        \ninst\n:\n \nINT\n\n        \ndepth\n:\n \nINT\n,\n \nOPTIONAL\n\n        \nsteps\n:\n \nINT\n\n        \naddress\n:\n \nDATA_\n20\n,\n \nSOMETIMES\n\n        \nmemexpand\n:\n \nBIGINT\n,\n \nNONSTANDARD\n\n        \ngascost\n:\n \nBIGINT\n,\n \nNONSTANDARD\n\n        \ninstname\n:\n \nSTRING\n,\n \nNONSTANDARD\n\n    \n},\n\n    \n...\n\n\n]\n\n\n\n\n\n\n\nstack\n: The stack, prior to execution.\n\n\nmemory\n: The memory, prior to execution. Omitted when previous operation was not memory-dependent (MLOAD/MSTORE/MSTORE8/SHA3/CALL/CALLCODE/CREATE/CALLDATACOPY/CODECOPY/EXTCODECOPY), not first operation of CALL/CREATE context or when memory \n= 1024 bytes large.\n\n\nsha3memory\n: The Keccak hash of the memory, prior to execution. Omitted when previous operation was not memory-dependent (MLOAD/MSTORE/MSTORE8/SHA3/CALL/CALLCODE/CREATE/CALLDATACOPY/CODECOPY/EXTCODECOPY), not first operation of CALL/CREATE context or when memory \n 1024 bytes large.\n\n\nstorage\n: The contents of storage that SSTOREs operate on (RE-READ THAT!), prior to execution. Omitted when previous operation is not storage-dependent (SLOAD/SSTORE) and not first operation of CALL/CREATE context.\n\n\ngas\n: The amount of gas available prior to this instruction.\n\n\npc\n: The program counter, immediately prior to execution.\n\n\ninst\n: The instruction opcode index that is to be executed (e.g. STOP would be 0).\n\n\ndepth\n: The depth of in present context in CALL/CREATE stack. Omitted when no change since previous operation and not first operation of CALL/CREATE context.\n\n\nsteps\n: The number of steps taken so far in present CALL/CREATE context prior to executing the current instruction.\n\n\naddress\n: The address of account that would be returned by \nMYADDRESS\n opcode. Omitted when no change since previous operation and not first operation of CALL/CREATE context.\n\n\nmemexpand\n: The size that memory is to be expanded by in words for this operation. Omitted when zero.\n\n\ngascost\n: The total cost of gas for executing this instruction (technically the /maximum/ total cost of gas - CALL/CREATE may return gas).", 
            "title": "\u574f\u5757\u62a5\u544a"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#badblock-object-format", 
            "text": "NOTE: All hex is lower-case.", 
            "title": "BADBLOCK Object Format"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#types", 
            "text": "DATA : freeform byte array as a string of hex,  no 0x prefix .  DATA_20 : like DATA, always of length 40.  HEX : string of hex-encoded big-endian integer, used for VM stack/memory/storage items,  no 0x prefix ,  no leading zeroes .  INT : simple JS integer.  BIGINT : string of decimal-encoded integer, used for potentially bigints.  TAG_ERROR : described later.  TAG_INST : string of an EVM instruction mnemonic, uppercase e.g.  \"PUSH4\"  or  \"STOP\" .  VMTRACE : described later.", 
            "title": "Types"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#type-modifiers", 
            "text": "SOMETIMES : field is omitted under certain circumstances.  NONSTANDARD : field may safely be omitted.", 
            "title": "Type modifiers"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#badblocks-object", 
            "text": "{ \n     block :   DATA \n     errortype :   TAG_ERROR \n     hints :   {   (all   items   OPTIONAL) \n         receipts :   [   DATA ,   ...   ],   OPTIONAL \n         vmtrace :   VMTRACE ,   OPTIONAL \n     },   OPTIONAL  }   Where:  receipts  is simply the array of RLP-encoded receipts.  TAG_ERROR  is a string containing one of (specified roughly in order of ability to detect):", 
            "title": "BADBLOCKS object"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#generic", 
            "text": "RLPError : One of the following:  BadRLP : Generally invalid RLP (e.g. 0x8100).  BadCast : Given RLP is of an incorrect type (e.g. 0x00 being interpreted as an integer).  OversizeRLP : Additional bytes trailing an otherwise valid RLP fragment (e.g. 0x8000).  UndersizeRLP : Bytes missing from the end of an otherwise valid RLP fragment (e.g. 0x81).", 
            "title": "Generic:"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#block-specific", 
            "text": "InvalidBlock : One of the following:  InvalidBlockFormat : Block format is wrong (!= array, != 3 items  c.).  TooManyUncles : More than 2 uncles mentioned.  InvalidTransactionsRoot : Transactions root is different to that derived from transactions given in block.  InvalidUnclesHash : Uncles hash is different to that derived from uncles given in block.  InvalidGasUsed : Gas used is not equal to the gasUsed in the last receipt (or previous block if no transactions).  InvalidStateRoot : State root mentioned is different to that calculated (i.e. reward application is incorrect).  InvalidReceiptsRoot : Receipts root mentioned is different to that calculated (i.e. appliaction of a transaction resulted in different logs, gas-used or state-root). \"receipts\" and \"vmtrace\" should be hinted.", 
            "title": "Block-specific:"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#block-header-specific", 
            "text": "InvalidHeader : One of the following:  InvalidBlockHeaderItemCount : Wrong item count in header.  TooMuchGasUsed : Header states gas used as bigger than gas limit.  ExtraDataTooBig : Header's extra data is greater than limit.  InvalidDifficulty : Difficulty is incorrect given previous block's difficulty and timestamp.  InvalidGasLimit : Gas limit does not fall within bounds given previous block's gas limit.  InvalidBlockNonce : Nonce does not result in a proof of work which satisfies the given difficulty.  InvalidNumber : Number is not equal to parent number + 1.  InvalidTimestamp : Timestamp is not greater than parent's.  InvalidLogBloom : LogBloom is not equal to the bitwise-OR of all receipts' LogBlooms.", 
            "title": "Block-header-specific"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#transaction-specific", 
            "text": "InvalidTransaction : One of the following:  OutOfGasIntrinsic : GAS below amount required for any transaction.  BlockGasLimitReached : Too much gas being used for the transaction within this block.  InvalidSignature : Transaction's signature is invalid.  OutOfGasBase : GAS below amount required for this transaction.  NotEnoughCash : Balance of sender too low.  InvalidNonce : Transaction nonce is wrong.", 
            "title": "Transaction-specific"
        }, 
        {
            "location": "/Technologies/Bad-Block-Reporting/#uncle-specific", 
            "text": "InvalidUncle : One of the following:  UncleInChain : Uncle has already been included in the current chain (either as a direct ancestor or one of its included uncles).  UncleTooOld : Uncle is older than the 6th generation uncle.  UncleIsBrother : Uncle is newer than the 1st generation uncle.   and  VMTRACE  is the object:  [ \n     { \n         stack :   [   HEX ,   ...   ] \n         memory :   HEX ,   SOMETIMES \n         sha3memory :   DATA_ 32 ,   SOMETIMES \n         storage :   {   HEX:   HEX   },   SOMETIMES \n         gas :   BIGINT \n         pc :   BIGINT \n         inst :   INT \n         depth :   INT ,   OPTIONAL \n         steps :   INT \n         address :   DATA_ 20 ,   SOMETIMES \n         memexpand :   BIGINT ,   NONSTANDARD \n         gascost :   BIGINT ,   NONSTANDARD \n         instname :   STRING ,   NONSTANDARD \n     }, \n     ...  ]    stack : The stack, prior to execution.  memory : The memory, prior to execution. Omitted when previous operation was not memory-dependent (MLOAD/MSTORE/MSTORE8/SHA3/CALL/CALLCODE/CREATE/CALLDATACOPY/CODECOPY/EXTCODECOPY), not first operation of CALL/CREATE context or when memory  = 1024 bytes large.  sha3memory : The Keccak hash of the memory, prior to execution. Omitted when previous operation was not memory-dependent (MLOAD/MSTORE/MSTORE8/SHA3/CALL/CALLCODE/CREATE/CALLDATACOPY/CODECOPY/EXTCODECOPY), not first operation of CALL/CREATE context or when memory   1024 bytes large.  storage : The contents of storage that SSTOREs operate on (RE-READ THAT!), prior to execution. Omitted when previous operation is not storage-dependent (SLOAD/SSTORE) and not first operation of CALL/CREATE context.  gas : The amount of gas available prior to this instruction.  pc : The program counter, immediately prior to execution.  inst : The instruction opcode index that is to be executed (e.g. STOP would be 0).  depth : The depth of in present context in CALL/CREATE stack. Omitted when no change since previous operation and not first operation of CALL/CREATE context.  steps : The number of steps taken so far in present CALL/CREATE context prior to executing the current instruction.  address : The address of account that would be returned by  MYADDRESS  opcode. Omitted when no change since previous operation and not first operation of CALL/CREATE context.  memexpand : The size that memory is to be expanded by in words for this operation. Omitted when zero.  gascost : The total cost of gas for executing this instruction (technically the /maximum/ total cost of gas - CALL/CREATE may return gas).", 
            "title": "Uncle-specific"
        }, 
        {
            "location": "/Technologies/Bad-Chain-Canary/", 
            "text": "There were canary contracts to notify that a given chain was bad. They were very easy to use; check storage location 0 of contract at the given address (see below). If non-zero, client would not mine (at least without a non-default option being given to ignore the canary and mine on a known-bad chain).\n\n\nSpecifically there are three modes they could be in:\n\n\n\n\n0\n All fine. Carry on.\n\n\n1\n Bad chain. Client should not mine on it. Client upgrade not yet available.\n\n\n2\n Update required. Just as for \n1\n; additionally, an update to your client is available and would be prudent.\n\n\n\n\nClients that implemented this protocol displayed a message to the user to make any non-zero status clear. For a status of 2, the user would be notified than an immediate upgrade was required, regardless of whether mining was enabled.\n\n\nAddresses\n\n\n\n\nFor Olympic: \n0x6879392ee114f8a4e133f0ff3dc4bc1717fe9344\n\n\nFor Frontier: Multiple people\n\n\nFor Homestead and later, clients don't support this contract anymore. The last clients removed this in mid-2016.", 
            "title": "\u574f\u94fe\u91d1\u4e1d\u96c0"
        }, 
        {
            "location": "/Technologies/Bad-Chain-Canary/#addresses", 
            "text": "For Olympic:  0x6879392ee114f8a4e133f0ff3dc4bc1717fe9344  For Frontier: Multiple people  For Homestead and later, clients don't support this contract anymore. The last clients removed this in mid-2016.", 
            "title": "Addresses"
        }, 
        {
            "location": "/EthashDashimoto/", 
            "text": "\u6316\u77ff\u7b97\u6cd5 - Ethash/Dashimoto\n\n\n\u4ee5\u592a\u5e01(ether)\u7684\u6316\u77ff\u7b97\u6cd5\u53eb\u505aEthash, \u53c8\u540dDashimoto (Dagger-Hashimoto)\uff0c\u662fHashimoto\u7b97\u6cd5\u7ed3\u5408Dagger\u4e4b\u540e\u4ea7\u6210\u7684\u4e00\u4e2a\u53d8\u79cd\u3002\u5b83\u7684\u7279\u70b9\u662f\u6316\u77ff\u7684\u6548\u7387\u57fa\u672c\u4e0eCPU\u65e0\u5173\uff0c\u5374\u548c\u5185\u5b58\u5927\u5c0f\u548c\u5185\u5b58\u5e26\u5bbd\u6b63\u76f8\u5173\u3002\u5bf9\u5185\u5b58\u5927\u5c0f\u548c\u5e26\u5bbd\u7684\u8981\u6c42\u610f\u5473\u7740\u90a3\u4e9b\u901a\u8fc7\u5171\u4eab\u5185\u5b58\u7684\u65b9\u5f0f\u5927\u89c4\u6a21\u90e8\u7f72\u7684\u77ff\u673a\u82af\u7247\u5e76\u4e0d\u80fd\u5728\u6316\u77ff\u6548\u7387\u4e0a\u6709\u7ebf\u6027\u6216\u8005\u8d85\u7ebf\u6027(super-linear)\u7684\u589e\u957f\u3002\n\n\n\u63a5\u4e0b\u6765\u8ba9\u6211\u4eec\u770b\u770bDashimoto\u7684\u57fa\u672c\u6d41\u7a0b\uff1a\n\n\n\n\n\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5757(block)\uff0c\u5148\u8ba1\u7b97\u51fa\u4e00\u4e2a\u79cd\u5b50(seed)\u3002\u79cd\u5b50\u7684\u8ba1\u7b97\u53ea\u4f9d\u8d56\u4e8e\u5f53\u524d\u5757\u7684\u4fe1\u606f\uff0c\u4f8b\u5982block number\u4ee5\u53cablock headers\u3002\n\n\n\u4f7f\u7528\u79cd\u5b50\u4ea7\u751f32MB\u7684\u4f2a\u968f\u673a\u6570\u636e\u96c6\uff0c\u79f0\u4e3acache\u3002\u8f7b\u5ba2\u6237\u7aef\u9700\u8981\u4fdd\u5b58cache\u3002\n\n\n\u57fa\u4e8ecache\u518d\u751f\u6210\u4e00\u4e2a1GB\u5927\u5c0f\u7684\u6570\u636e\u96c6\uff0c\u79f0\u4e3athe DAG\u3002\u8fd9\u4e2a\u6570\u636e\u96c6\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u90fd\u53ea\u4f9d\u8d56cache\u4e2d\u7684\u67d0\u51e0\u4e2a\u5143\u7d20\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u53ea\u8981\u6709cache\u5c31\u53ef\u4ee5\u5feb\u901f\u8ba1\u7b97\u51faDAG\u4e2d\u6307\u5b9a\u4f4d\u7f6e\u7684\u5143\u7d20\u3002\u5b8c\u6574\u7684\u53ef\u6316\u77ff\u7684\u5ba2\u6237\u7aef\u9700\u8981\u4fdd\u5b58DAG\u3002\n\n\n\u6316\u77ff\u53ef\u4ee5\u6982\u62ec\u4e3a\u4eceDAG\u4e2d\u968f\u673a\u9009\u62e9\u5143\u7d20\u7136\u540e\u5bf9\u5176\u8fdb\u884chash\u7684\u8fc7\u7a0b\u3002\u9a8c\u8bc1\u7684\u8fc7\u7a0b\u4e5f\u662f\u4e00\u6837\uff0c\u53ea\u4e0d\u8fc7\u4e0d\u662f\u4eceDAG\u91cc\u9762\u9009\u62e9\u5143\u7d20\uff0c\u800c\u662f\u57fa\u4e8ecache\u8ba1\u7b97\u5f97\u5230\u6307\u5b9a\u4f4d\u7f6e\u7684\u5143\u7d20\uff0c\u7136\u540e\u9a8c\u8bc1\u8fd9\u4e2a\u5143\u7d20\u96c6\u5408\u7684hash\u7ed3\u679c\u5c0f\u4e8e\u67d0\u4e2a\u503c\u3002\u7531\u4e8ecache\u5f88\u5c0f, \u800c\u4e14\u6307\u5b9a\u4f4d\u7f6e\u7684DAG\u5143\u7d20\u5f88\u5bb9\u6613\u8ba1\u7b97\uff0c\u56e0\u6b64\u9a8c\u8bc1\u8fc7\u7a0b\u53ea\u9700\u8981\u666e\u901aCPU\u548c\u666e\u901a\u5185\u5b58\u5373\u53ef\u5b8c\u6210\u3002\n\n\ncache\u548cDAG\u6bcf\u4e00\u4e2a\u5468\u671f\u66f4\u65b0\u4e00\u6b21\uff0c\u4e00\u4e2a\u5468\u671f\u7684\u957f\u5ea6\u662f1000\u4e2a\u5757\u3002\u4e5f\u5c31\u662f\u8bf4\u8fd91000\u4e2a\u5757\u4ea7\u751f\u7684cache\u548cDAG\u662f\u5b8c\u5168\u4e00\u6837\u7684\uff0c\u56e0\u6b64\u6316\u77ff\u7684\u4e3b\u8981\u5de5\u4f5c\u5728\u4e8e\u4eceDAG\u4e2d\u8bfb\u53d6\u6570\u636e\uff0c\u800c\u4e0d\u662f\u66f4\u65b0cache\u548cDAG\u3002DAG\u7684\u5927\u5c0f\u968f\u65f6\u95f4\u7684\u63a8\u79fb\u7ebf\u6027\u589e\u957f\uff0c\u4ece1GB\u5f00\u59cb\uff0c\u6bcf\u5e74\u589e\u52a0\u5927\u7ea67GB \u2013 \u56e0\u6b64\u52302015\u5e7412\u6708\u5927\u7ea6\u662f8GB, \u52302016\u5e7412\u6708\u5927\u7ea615GB\u3002\n\n\n\n\n\u6ce8\uff1a\u4ee5\u4e0a\u6b65\u9aa4\u4e2d\u7684\u6570\u5b57\u5df2\u7ecf\u968f\u7740\u5f00\u53d1\u7684\u63a8\u8fdb\u6709\u4e86\u8c03\u6574\uff0c\u51c6\u786e\u503c\u8bf7\u53c2\u8003\u6e90\u4ee3\u7801\u3002", 
            "title": "\u6982\u8ff0"
        }, 
        {
            "location": "/EthashDashimoto/#-ethashdashimoto", 
            "text": "\u4ee5\u592a\u5e01(ether)\u7684\u6316\u77ff\u7b97\u6cd5\u53eb\u505aEthash, \u53c8\u540dDashimoto (Dagger-Hashimoto)\uff0c\u662fHashimoto\u7b97\u6cd5\u7ed3\u5408Dagger\u4e4b\u540e\u4ea7\u6210\u7684\u4e00\u4e2a\u53d8\u79cd\u3002\u5b83\u7684\u7279\u70b9\u662f\u6316\u77ff\u7684\u6548\u7387\u57fa\u672c\u4e0eCPU\u65e0\u5173\uff0c\u5374\u548c\u5185\u5b58\u5927\u5c0f\u548c\u5185\u5b58\u5e26\u5bbd\u6b63\u76f8\u5173\u3002\u5bf9\u5185\u5b58\u5927\u5c0f\u548c\u5e26\u5bbd\u7684\u8981\u6c42\u610f\u5473\u7740\u90a3\u4e9b\u901a\u8fc7\u5171\u4eab\u5185\u5b58\u7684\u65b9\u5f0f\u5927\u89c4\u6a21\u90e8\u7f72\u7684\u77ff\u673a\u82af\u7247\u5e76\u4e0d\u80fd\u5728\u6316\u77ff\u6548\u7387\u4e0a\u6709\u7ebf\u6027\u6216\u8005\u8d85\u7ebf\u6027(super-linear)\u7684\u589e\u957f\u3002  \u63a5\u4e0b\u6765\u8ba9\u6211\u4eec\u770b\u770bDashimoto\u7684\u57fa\u672c\u6d41\u7a0b\uff1a   \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5757(block)\uff0c\u5148\u8ba1\u7b97\u51fa\u4e00\u4e2a\u79cd\u5b50(seed)\u3002\u79cd\u5b50\u7684\u8ba1\u7b97\u53ea\u4f9d\u8d56\u4e8e\u5f53\u524d\u5757\u7684\u4fe1\u606f\uff0c\u4f8b\u5982block number\u4ee5\u53cablock headers\u3002  \u4f7f\u7528\u79cd\u5b50\u4ea7\u751f32MB\u7684\u4f2a\u968f\u673a\u6570\u636e\u96c6\uff0c\u79f0\u4e3acache\u3002\u8f7b\u5ba2\u6237\u7aef\u9700\u8981\u4fdd\u5b58cache\u3002  \u57fa\u4e8ecache\u518d\u751f\u6210\u4e00\u4e2a1GB\u5927\u5c0f\u7684\u6570\u636e\u96c6\uff0c\u79f0\u4e3athe DAG\u3002\u8fd9\u4e2a\u6570\u636e\u96c6\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u90fd\u53ea\u4f9d\u8d56cache\u4e2d\u7684\u67d0\u51e0\u4e2a\u5143\u7d20\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u53ea\u8981\u6709cache\u5c31\u53ef\u4ee5\u5feb\u901f\u8ba1\u7b97\u51faDAG\u4e2d\u6307\u5b9a\u4f4d\u7f6e\u7684\u5143\u7d20\u3002\u5b8c\u6574\u7684\u53ef\u6316\u77ff\u7684\u5ba2\u6237\u7aef\u9700\u8981\u4fdd\u5b58DAG\u3002  \u6316\u77ff\u53ef\u4ee5\u6982\u62ec\u4e3a\u4eceDAG\u4e2d\u968f\u673a\u9009\u62e9\u5143\u7d20\u7136\u540e\u5bf9\u5176\u8fdb\u884chash\u7684\u8fc7\u7a0b\u3002\u9a8c\u8bc1\u7684\u8fc7\u7a0b\u4e5f\u662f\u4e00\u6837\uff0c\u53ea\u4e0d\u8fc7\u4e0d\u662f\u4eceDAG\u91cc\u9762\u9009\u62e9\u5143\u7d20\uff0c\u800c\u662f\u57fa\u4e8ecache\u8ba1\u7b97\u5f97\u5230\u6307\u5b9a\u4f4d\u7f6e\u7684\u5143\u7d20\uff0c\u7136\u540e\u9a8c\u8bc1\u8fd9\u4e2a\u5143\u7d20\u96c6\u5408\u7684hash\u7ed3\u679c\u5c0f\u4e8e\u67d0\u4e2a\u503c\u3002\u7531\u4e8ecache\u5f88\u5c0f, \u800c\u4e14\u6307\u5b9a\u4f4d\u7f6e\u7684DAG\u5143\u7d20\u5f88\u5bb9\u6613\u8ba1\u7b97\uff0c\u56e0\u6b64\u9a8c\u8bc1\u8fc7\u7a0b\u53ea\u9700\u8981\u666e\u901aCPU\u548c\u666e\u901a\u5185\u5b58\u5373\u53ef\u5b8c\u6210\u3002  cache\u548cDAG\u6bcf\u4e00\u4e2a\u5468\u671f\u66f4\u65b0\u4e00\u6b21\uff0c\u4e00\u4e2a\u5468\u671f\u7684\u957f\u5ea6\u662f1000\u4e2a\u5757\u3002\u4e5f\u5c31\u662f\u8bf4\u8fd91000\u4e2a\u5757\u4ea7\u751f\u7684cache\u548cDAG\u662f\u5b8c\u5168\u4e00\u6837\u7684\uff0c\u56e0\u6b64\u6316\u77ff\u7684\u4e3b\u8981\u5de5\u4f5c\u5728\u4e8e\u4eceDAG\u4e2d\u8bfb\u53d6\u6570\u636e\uff0c\u800c\u4e0d\u662f\u66f4\u65b0cache\u548cDAG\u3002DAG\u7684\u5927\u5c0f\u968f\u65f6\u95f4\u7684\u63a8\u79fb\u7ebf\u6027\u589e\u957f\uff0c\u4ece1GB\u5f00\u59cb\uff0c\u6bcf\u5e74\u589e\u52a0\u5927\u7ea67GB \u2013 \u56e0\u6b64\u52302015\u5e7412\u6708\u5927\u7ea6\u662f8GB, \u52302016\u5e7412\u6708\u5927\u7ea615GB\u3002   \u6ce8\uff1a\u4ee5\u4e0a\u6b65\u9aa4\u4e2d\u7684\u6570\u5b57\u5df2\u7ecf\u968f\u7740\u5f00\u53d1\u7684\u63a8\u8fdb\u6709\u4e86\u8c03\u6574\uff0c\u51c6\u786e\u503c\u8bf7\u53c2\u8003\u6e90\u4ee3\u7801\u3002", 
            "title": "\u6316\u77ff\u7b97\u6cd5 - Ethash/Dashimoto"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/", 
            "text": "Ethash\n\n\nThis spec is REVISION 23. Whenever you substantively (ie. not clarifications) update the algorithm, please update the revision number in this sentence. Also, in all implementations please include a spec revision number\n\n\nEthash is the planned PoW algorithm for Ethereum 1.0. It is the latest version of Dagger-Hashimoto, although it can no longer appropriately be called that since many of the original features of both algorithms have been drastically changed in the last month of research and development. See \nhttps://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md\n for the original version.\n\n\n\u7b97\u6cd5\u6240\u91c7\u7528\u7684\u4e00\u822c\u8def\u7ebf\u5982\u4e0b\uff1a\n\n\n\n\nThere exists a \nseed\n which can be computed for each block by scanning through the block headers up until that point.\n\n\nFrom the seed, one can compute a \n16 MB pseudorandom cache\n. Light clients store the cache.\n\n\nFrom the cache, we can generate a \n1 GB dataset\n, with the property that each item in the dataset depends on only a small number of items from the cache. Full clients and miners store the dataset.  The dataset grows linearly with time.\n\n\nMining involves grabbing random slices of the dataset and hashing them together. Verification can be done with low memory by using the cache to regenerate the specific pieces of the dataset that you need, so you only need to store the cache.\n\n\n\n\nThe large dataset is updated once every 30000 blocks, so the vast majority of a miner's effort will be reading the dataset, not making changes to it.\n\n\nSee \nhttps://github.com/ethereum/wiki/wiki/Ethash-Design-Rationale\n for design rationale considerations for this algorithm.\n\n\n\u5b9a\u4e49\n\n\n\u6211\u4eec\u91c7\u7528\u4ee5\u4e0b\u5b9a\u4e49:\n\n\nWORD_BYTES = 4                    # bytes in word\nDATASET_BYTES_INIT = 2**30        # bytes in dataset at genesis\nDATASET_BYTES_GROWTH = 2**23      # dataset growth per epoch\nCACHE_BYTES_INIT = 2**24          # bytes in cache at genesis\nCACHE_BYTES_GROWTH = 2**17        # cache growth per epoch\nCACHE_MULTIPLIER=1024             # Size of the DAG relative to the cache\nEPOCH_LENGTH = 30000              # blocks per epoch\nMIX_BYTES = 128                   # width of mix\nHASH_BYTES = 64                   # hash length in bytes\nDATASET_PARENTS = 256             # number of parents of each dataset element\nCACHE_ROUNDS = 3                  # number of rounds in cache production\nACCESSES = 64                     # number of accesses in hashimoto loop\n\n\n\n\nA note regarding \"SHA3\" hashes described in this specification\n\n\nEthereum's development coincided with the development of the SHA3 standard, and the\nstandards process made a late change in the padding of the finalized hash algorithm, so that Ethereum's\n\"sha3_256\" and \"sha3_512\" hashes are not standard sha3 hashes, but a variant often referred\nto as \"Keccak-256\" and \"Keccak-512\" in other contexts. See discussion, e.g. \nhere\n, \nhere\n, or \nhere\n.\n\n\nPlease keep that in mind as \"sha3\" hashes are referred to in the description of the algorithm below.\n\n\n\u53c2\u6570\n\n\nThe parameters for Ethash's cache and dataset depend on the block number. The cache size and dataset size both grow linearly; however, we always take the highest prime below the linearly growing threshold in order to reduce the risk of accidental regularities leading to cyclic behavior.\n\n\ndef\n \nget_cache_size\n(\nblock_number\n):\n\n    \nsz\n \n=\n \nCACHE_BYTES_INIT\n \n+\n \nCACHE_BYTES_GROWTH\n \n*\n \n(\nblock_number\n \n//\n \nEPOCH_LENGTH\n)\n\n    \nsz\n \n-=\n \nHASH_BYTES\n\n    \nwhile\n \nnot\n \nisprime\n(\nsz\n \n/\n \nHASH_BYTES\n):\n\n        \nsz\n \n-=\n \n2\n \n*\n \nHASH_BYTES\n\n    \nreturn\n \nsz\n\n\n\ndef\n \nget_full_size\n(\nblock_number\n):\n\n    \nsz\n \n=\n \nDATASET_BYTES_INIT\n \n+\n \nDATASET_BYTES_GROWTH\n \n*\n \n(\nblock_number\n \n//\n \nEPOCH_LENGTH\n)\n\n    \nsz\n \n-=\n \nMIX_BYTES\n\n    \nwhile\n \nnot\n \nisprime\n(\nsz\n \n/\n \nMIX_BYTES\n):\n\n        \nsz\n \n-=\n \n2\n \n*\n \nMIX_BYTES\n\n    \nreturn\n \nsz\n\n\n\n\n\nTables of dataset and cache size values are provided in the appendix.\n\n\n\u7f13\u5b58\u4e00\u4ee3\n\n\nNow, we specify the function for producing a cache:\n\n\ndef\n \nmkcache\n(\ncache_size\n,\n \nseed\n):\n\n    \nn\n \n=\n \ncache_size\n \n//\n \nHASH_BYTES\n\n\n    \n# Sequentially produce the initial dataset\n\n    \no\n \n=\n \n[\nsha3_512\n(\nseed\n)]\n\n    \nfor\n \ni\n \nin\n \nrange\n(\n1\n,\n \nn\n):\n\n        \no\n.\nappend\n(\nsha3_512\n(\no\n[\n-\n1\n]))\n\n\n    \n# Use a low-round version of randmemohash\n\n    \nfor\n \n_\n \nin\n \nrange\n(\nCACHE_ROUNDS\n):\n\n        \nfor\n \ni\n \nin\n \nrange\n(\nn\n):\n\n            \nv\n \n=\n \no\n[\ni\n][\n0\n]\n \n%\n \nn\n\n            \no\n[\ni\n]\n \n=\n \nsha3_512\n(\nmap\n(\nxor\n,\n \no\n[(\ni\n-\n1\n+\nn\n)\n \n%\n \nn\n],\n \no\n[\nv\n]))\n\n\n    \nreturn\n \no\n\n\n\n\n\nThe cache production process involves first sequentially filling up 32 MB of memory, then performing two passes of Sergio Demian Lerner's \nRandMemoHash\n algorithm from \nStrict Memory Hard Hashing Functions\n (2014)\n. The output is a set of 524288 64-byte values.\n\n\n\u6570\u636e\u805a\u5408\u51fd\u6570\n\n\nWe use an algorithm inspired by the \nFNV hash\n in some cases as a non-associative substitute for XOR. Note that we multiply the prime with the full 32-bit input, in contrast with the FNV-1 spec which multiplies the prime with one byte (octet) in turn.\n\n\nFNV_PRIME\n \n=\n \n0x01000193\n\n\n\ndef\n \nfnv\n(\nv1\n,\n \nv2\n):\n\n    \nreturn\n \n((\nv1\n \n*\n \nFNV_PRIME\n)\n \n^\n \nv2\n)\n \n%\n \n2\n**\n32\n\n\n\n\n\nPlease note, even the yellow paper specifies fnv as v1*(FNV_PRIME ^ v2), all current implementations consistently use the above definition.\n\n\n\u5b8c\u6574\u7684\u6570\u636e\u96c6\u8ba1\u7b97\n\n\nEach 64-byte item in the full 1 GB dataset is computed as follows:\n\n\ndef\n \ncalc_dataset_item\n(\ncache\n,\n \ni\n):\n\n    \nn\n \n=\n \nlen\n(\ncache\n)\n\n    \nr\n \n=\n \nHASH_BYTES\n \n//\n \nWORD_BYTES\n\n    \n# initialize the mix\n\n    \nmix\n \n=\n \ncopy\n.\ncopy\n(\ncache\n[\ni\n \n%\n \nn\n])\n\n    \nmix\n[\n0\n]\n \n^=\n \ni\n\n    \nmix\n \n=\n \nsha3_512\n(\nmix\n)\n\n    \n# fnv it with a lot of random cache nodes based on i\n\n    \nfor\n \nj\n \nin\n \nrange\n(\nDATASET_PARENTS\n):\n\n        \ncache_index\n \n=\n \nfnv\n(\ni\n \n^\n \nj\n,\n \nmix\n[\nj\n \n%\n \nr\n])\n\n        \nmix\n \n=\n \nmap\n(\nfnv\n,\n \nmix\n,\n \ncache\n[\ncache_index\n \n%\n \nn\n])\n\n    \nreturn\n \nsha3_512\n(\nmix\n)\n\n\n\n\n\nEssentially, we combine data from 256 pseudorandomly selected cache nodes, and hash that to compute the dataset node. The entire dataset is then generated by:\n\n\ndef\n \ncalc_dataset\n(\nfull_size\n,\n \ncache\n):\n\n    \nreturn\n \n[\ncalc_dataset_item\n(\ncache\n,\n \ni\n)\n \nfor\n \ni\n \nin\n \nrange\n(\nfull_size\n \n//\n \nHASH_BYTES\n)]\n\n\n\n\n\n\u4e3b\u5faa\u73af\n\n\nNow, we specify the main \"hashimoto\"-like loop, where we aggregate data from the full dataset in order to produce our final value for a particular header and nonce. In the code below, \nheader\n represents the SHA3-256 \nhash\n of the \nRLP\n representation of a \ntruncated\n block header, that is, of a header excluding the fields \nmixHash\n and \nnonce\n. \nnonce\n is the eight bytes of a 64 bit unsigned integer in big-endian order. So \nnonce[::-1]\n is the eight-byte little-endian representation of that value:\n\n\ndef\n \nhashimoto\n(\nheader\n,\n \nnonce\n,\n \nfull_size\n,\n \ndataset_lookup\n):\n\n    \nn\n \n=\n \nfull_size\n \n/\n \nHASH_BYTES\n\n    \nw\n \n=\n \nMIX_BYTES\n \n//\n \nWORD_BYTES\n\n    \nmixhashes\n \n=\n \nMIX_BYTES\n \n/\n \nHASH_BYTES\n\n    \n# combine header+nonce into a 64 byte seed\n\n    \ns\n \n=\n \nsha3_512\n(\nheader\n \n+\n \nnonce\n[::\n-\n1\n])\n\n    \n# start the mix with replicated s\n\n    \nmix\n \n=\n \n[]\n\n    \nfor\n \n_\n \nin\n \nrange\n(\nMIX_BYTES\n \n/\n \nHASH_BYTES\n):\n\n        \nmix\n.\nextend\n(\ns\n)\n\n    \n# mix in random dataset nodes\n\n    \nfor\n \ni\n \nin\n \nrange\n(\nACCESSES\n):\n\n        \np\n \n=\n \nfnv\n(\ni\n \n^\n \ns\n[\n0\n],\n \nmix\n[\ni\n \n%\n \nw\n])\n \n%\n \n(\nn\n \n//\n \nmixhashes\n)\n \n*\n \nmixhashes\n\n        \nnewdata\n \n=\n \n[]\n\n        \nfor\n \nj\n \nin\n \nrange\n(\nMIX_BYTES\n \n/\n \nHASH_BYTES\n):\n\n            \nnewdata\n.\nextend\n(\ndataset_lookup\n(\np\n \n+\n \nj\n))\n\n        \nmix\n \n=\n \nmap\n(\nfnv\n,\n \nmix\n,\n \nnewdata\n)\n\n    \n# compress mix\n\n    \ncmix\n \n=\n \n[]\n\n    \nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n \nlen\n(\nmix\n),\n \n4\n):\n\n        \ncmix\n.\nappend\n(\nfnv\n(\nfnv\n(\nfnv\n(\nmix\n[\ni\n],\n \nmix\n[\ni\n+\n1\n]),\n \nmix\n[\ni\n+\n2\n]),\n \nmix\n[\ni\n+\n3\n]))\n\n    \nreturn\n \n{\n\n        \nmix digest\n:\n \nserialize_hash\n(\ncmix\n),\n\n        \nresult\n:\n \nserialize_hash\n(\nsha3_256\n(\ns\n+\ncmix\n))\n\n    \n}\n\n\n\ndef\n \nhashimoto_light\n(\nfull_size\n,\n \ncache\n,\n \nheader\n,\n \nnonce\n):\n\n    \nreturn\n \nhashimoto\n(\nheader\n,\n \nnonce\n,\n \nfull_size\n,\n \nlambda\n \nx\n:\n \ncalc_dataset_item\n(\ncache\n,\n \nx\n))\n\n\n\ndef\n \nhashimoto_full\n(\nfull_size\n,\n \ndataset\n,\n \nheader\n,\n \nnonce\n):\n\n    \nreturn\n \nhashimoto\n(\nheader\n,\n \nnonce\n,\n \nfull_size\n,\n \nlambda\n \nx\n:\n \ndataset\n[\nx\n])\n\n\n\n\n\nEssentially, we maintain a \"mix\" 128 bytes wide, and repeatedly sequentially fetch 128 bytes from the full dataset and use the \nfnv\n function to combine it with the mix. 128 bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.\n\n\nIf the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of \nsha3_256\n at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes.  It also serves to provide statistical assurance that the result is an unbiased, 256 bit number.\n\n\n\u6316\u77ff\n\n\nThe mining algorithm is defined as follows:\n\n\ndef\n \nmine\n(\nfull_size\n,\n \ndataset\n,\n \nheader\n,\n \ndifficulty\n):\n\n    \ntarget\n \n=\n \nzpad\n(\nencode_int\n(\n2\n**\n256\n \n//\n \ndifficulty\n),\n \n64\n)[::\n-\n1\n]\n\n    \nfrom\n \nrandom\n \nimport\n \nrandint\n\n    \nnonce\n \n=\n \nrandint\n(\n0\n,\n \n2\n**\n64\n)\n\n    \nwhile\n \nhashimoto_full\n(\nfull_size\n,\n \ndataset\n,\n \nheader\n,\n \nnonce\n)\n \n \ntarget\n:\n\n        \nnonce\n \n=\n \n(\nnonce\n \n+\n \n1\n)\n \n%\n \n2\n**\n64\n\n    \nreturn\n \nnonce\n\n\n\n\n\n\u5b9a\u4e49\u79cd\u5b50\u6563\u5217\n\n\nIn order to compute the seed hash that would be used to mine on top of a given block, we use the following algorithm:\n\n\n \ndef\n \nget_seedhash\n(\nblock\n):\n\n     \ns\n \n=\n \n\\x00\n \n*\n \n32\n\n     \nfor\n \ni\n \nin\n \nrange\n(\nblock\n.\nnumber\n \n//\n \nEPOCH_LENGTH\n):\n\n         \ns\n \n=\n \nserialize_hash\n(\nsha3_256\n(\ns\n))\n\n     \nreturn\n \ns\n\n\n\n\n\nNote that for smooth mining and verifying, we recommend pre-computing future seedhashes and datasets in a separate thread.\n\n\n\u9644\u5f55\n\n\nThe following code should be prepended if you are interested in running the above python spec as code.\n\n\nimport\n \nsha3\n,\n \ncopy\n\n\n\n# Assumes little endian bit ordering (same as Intel architectures)\n\n\ndef\n \ndecode_int\n(\ns\n):\n\n    \nreturn\n \nint\n(\ns\n[::\n-\n1\n]\n.\nencode\n(\nhex\n),\n \n16\n)\n \nif\n \ns\n \nelse\n \n0\n\n\n\ndef\n \nencode_int\n(\ns\n):\n\n    \na\n \n=\n \n%x\n \n%\n \ns\n\n    \nreturn\n \n \nif\n \ns\n \n==\n \n0\n \nelse\n \n(\n0\n \n*\n \n(\nlen\n(\na\n)\n \n%\n \n2\n)\n \n+\n \na\n)\n.\ndecode\n(\nhex\n)[::\n-\n1\n]\n\n\n\ndef\n \nzpad\n(\ns\n,\n \nlength\n):\n\n    \nreturn\n \ns\n \n+\n \n\\x00\n \n*\n \nmax\n(\n0\n,\n \nlength\n \n-\n \nlen\n(\ns\n))\n\n\n\ndef\n \nserialize_hash\n(\nh\n):\n\n    \nreturn\n \n.\njoin\n([\nzpad\n(\nencode_int\n(\nx\n),\n \n4\n)\n \nfor\n \nx\n \nin\n \nh\n])\n\n\n\ndef\n \ndeserialize_hash\n(\nh\n):\n\n    \nreturn\n \n[\ndecode_int\n(\nh\n[\ni\n:\ni\n+\nWORD_BYTES\n])\n \nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n \nlen\n(\nh\n),\n \nWORD_BYTES\n)]\n\n\n\ndef\n \nhash_words\n(\nh\n,\n \nsz\n,\n \nx\n):\n\n    \nif\n \nisinstance\n(\nx\n,\n \nlist\n):\n\n        \nx\n \n=\n \nserialize_hash\n(\nx\n)\n\n    \ny\n \n=\n \nh\n(\nx\n)\n\n    \nreturn\n \ndeserialize_hash\n(\ny\n)\n\n\n\ndef\n \nserialize_cache\n(\nds\n):\n\n    \nreturn\n \n.\njoin\n([\nserialize_hash\n(\nh\n)\n \nfor\n \nh\n \nin\n \nds\n])\n\n\n\nserialize_dataset\n \n=\n \nserialize_cache\n\n\n\n# sha3 hash function, outputs 64 bytes\n\n\ndef\n \nsha3_512\n(\nx\n):\n\n    \nreturn\n \nhash_words\n(\nlambda\n \nv\n:\n \nsha3\n.\nsha3_512\n(\nv\n)\n.\ndigest\n(),\n \n64\n,\n \nx\n)\n\n\n\ndef\n \nsha3_256\n(\nx\n):\n\n    \nreturn\n \nhash_words\n(\nlambda\n \nv\n:\n \nsha3\n.\nsha3_256\n(\nv\n)\n.\ndigest\n(),\n \n32\n,\n \nx\n)\n\n\n\ndef\n \nxor\n(\na\n,\n \nb\n):\n\n    \nreturn\n \na\n \n^\n \nb\n\n\n\ndef\n \nisprime\n(\nx\n):\n\n    \nfor\n \ni\n \nin\n \nrange\n(\n2\n,\n \nint\n(\nx\n**\n0.5\n)):\n\n         \nif\n \nx\n \n%\n \ni\n \n==\n \n0\n:\n\n             \nreturn\n \nFalse\n\n    \nreturn\n \nTrue\n\n\n\n\n\n\u6570\u636e\u5927\u5c0f\n\n\nThe following lookup tables provide approximately 2048 tabulated epochs of data sizes and cache sizes.  They were generated with the \nMathematica\n function provided here:\n\n\ndef\n \nget_datasize\n(\nblock_number\n):\n\n    \nreturn\n \ndata_sizes\n[\nblock_number\n \n//\n \nEPOCH_LENGTH\n]\n\n\n\ndef\n \nget_cachesize\n(\nblock_number\n):\n\n    \nreturn\n \ncache_sizes\n[\nblock_number\n \n//\n \nEPOCH_LENGTH\n]\n\n\n\ndata_sizes\n \n=\n \n[\n\n    \n1073739904\n,\n \n1082130304\n,\n \n1090514816\n,\n \n1098906752\n,\n \n1107293056\n,\n\n    \n1115684224\n,\n \n1124070016\n,\n \n1132461952\n,\n \n1140849536\n,\n \n1149232768\n,\n\n    \n1157627776\n,\n \n1166013824\n,\n \n1174404736\n,\n \n1182786944\n,\n \n1191180416\n,\n\n    \n1199568512\n,\n \n1207958912\n,\n \n1216345216\n,\n \n1224732032\n,\n \n1233124736\n,\n\n    \n1241513344\n,\n \n1249902464\n,\n \n1258290304\n,\n \n1266673792\n,\n \n1275067264\n,\n\n    \n1283453312\n,\n \n1291844992\n,\n \n1300234112\n,\n \n1308619904\n,\n \n1317010048\n,\n\n    \n1325397376\n,\n \n1333787776\n,\n \n1342176128\n,\n \n1350561664\n,\n \n1358954368\n,\n\n    \n1367339392\n,\n \n1375731584\n,\n \n1384118144\n,\n \n1392507008\n,\n \n1400897408\n,\n\n    \n1409284736\n,\n \n1417673344\n,\n \n1426062464\n,\n \n1434451072\n,\n \n1442839168\n,\n\n    \n1451229056\n,\n \n1459615616\n,\n \n1468006016\n,\n \n1476394112\n,\n \n1484782976\n,\n\n    \n1493171584\n,\n \n1501559168\n,\n \n1509948032\n,\n \n1518337664\n,\n \n1526726528\n,\n\n    \n1535114624\n,\n \n1543503488\n,\n \n1551892096\n,\n \n1560278656\n,\n \n1568669056\n,\n\n    \n1577056384\n,\n \n1585446272\n,\n \n1593831296\n,\n \n1602219392\n,\n \n1610610304\n,\n\n    \n1619000192\n,\n \n1627386752\n,\n \n1635773824\n,\n \n1644164224\n,\n \n1652555648\n,\n\n    \n1660943488\n,\n \n1669332608\n,\n \n1677721216\n,\n \n1686109312\n,\n \n1694497664\n,\n\n    \n1702886272\n,\n \n1711274624\n,\n \n1719661184\n,\n \n1728047744\n,\n \n1736434816\n,\n\n    \n1744829056\n,\n \n1753218944\n,\n \n1761606272\n,\n \n1769995904\n,\n \n1778382464\n,\n\n    \n1786772864\n,\n \n1795157888\n,\n \n1803550592\n,\n \n1811937664\n,\n \n1820327552\n,\n\n    \n1828711552\n,\n \n1837102976\n,\n \n1845488768\n,\n \n1853879936\n,\n \n1862269312\n,\n\n    \n1870656896\n,\n \n1879048064\n,\n \n1887431552\n,\n \n1895825024\n,\n \n1904212096\n,\n\n    \n1912601216\n,\n \n1920988544\n,\n \n1929379456\n,\n \n1937765504\n,\n \n1946156672\n,\n\n    \n1954543232\n,\n \n1962932096\n,\n \n1971321728\n,\n \n1979707264\n,\n \n1988093056\n,\n\n    \n1996487552\n,\n \n2004874624\n,\n \n2013262208\n,\n \n2021653888\n,\n \n2030039936\n,\n\n    \n2038430848\n,\n \n2046819968\n,\n \n2055208576\n,\n \n2063596672\n,\n \n2071981952\n,\n\n    \n2080373632\n,\n \n2088762752\n,\n \n2097149056\n,\n \n2105539712\n,\n \n2113928576\n,\n\n    \n2122315136\n,\n \n2130700672\n,\n \n2139092608\n,\n \n2147483264\n,\n \n2155872128\n,\n\n    \n2164257664\n,\n \n2172642176\n,\n \n2181035392\n,\n \n2189426048\n,\n \n2197814912\n,\n\n    \n2206203008\n,\n \n2214587264\n,\n \n2222979712\n,\n \n2231367808\n,\n \n2239758208\n,\n\n    \n2248145024\n,\n \n2256527744\n,\n \n2264922752\n,\n \n2273312128\n,\n \n2281701248\n,\n\n    \n2290086272\n,\n \n2298476672\n,\n \n2306867072\n,\n \n2315251072\n,\n \n2323639168\n,\n\n    \n2332032128\n,\n \n2340420224\n,\n \n2348808064\n,\n \n2357196416\n,\n \n2365580416\n,\n\n    \n2373966976\n,\n \n2382363008\n,\n \n2390748544\n,\n \n2399139968\n,\n \n2407530368\n,\n\n    \n2415918976\n,\n \n2424307328\n,\n \n2432695424\n,\n \n2441084288\n,\n \n2449472384\n,\n\n    \n2457861248\n,\n \n2466247808\n,\n \n2474637184\n,\n \n2483026816\n,\n \n2491414144\n,\n\n    \n2499803776\n,\n \n2508191872\n,\n \n2516582272\n,\n \n2524970368\n,\n \n2533359232\n,\n\n    \n2541743488\n,\n \n2550134144\n,\n \n2558525056\n,\n \n2566913408\n,\n \n2575301504\n,\n\n    \n2583686528\n,\n \n2592073856\n,\n \n2600467328\n,\n \n2608856192\n,\n \n2617240448\n,\n\n    \n2625631616\n,\n \n2634022016\n,\n \n2642407552\n,\n \n2650796416\n,\n \n2659188352\n,\n\n    \n2667574912\n,\n \n2675965312\n,\n \n2684352896\n,\n \n2692738688\n,\n \n2701130624\n,\n\n    \n2709518464\n,\n \n2717907328\n,\n \n2726293376\n,\n \n2734685056\n,\n \n2743073152\n,\n\n    \n2751462016\n,\n \n2759851648\n,\n \n2768232832\n,\n \n2776625536\n,\n \n2785017728\n,\n\n    \n2793401984\n,\n \n2801794432\n,\n \n2810182016\n,\n \n2818571648\n,\n \n2826959488\n,\n\n    \n2835349376\n,\n \n2843734144\n,\n \n2852121472\n,\n \n2860514432\n,\n \n2868900992\n,\n\n    \n2877286784\n,\n \n2885676928\n,\n \n2894069632\n,\n \n2902451584\n,\n \n2910843008\n,\n\n    \n2919234688\n,\n \n2927622784\n,\n \n2936011648\n,\n \n2944400768\n,\n \n2952789376\n,\n\n    \n2961177728\n,\n \n2969565568\n,\n \n2977951616\n,\n \n2986338944\n,\n \n2994731392\n,\n\n    \n3003120256\n,\n \n3011508352\n,\n \n3019895936\n,\n \n3028287104\n,\n \n3036675968\n,\n\n    \n3045063808\n,\n \n3053452928\n,\n \n3061837696\n,\n \n3070228352\n,\n \n3078615424\n,\n\n    \n3087003776\n,\n \n3095394944\n,\n \n3103782272\n,\n \n3112173184\n,\n \n3120562048\n,\n\n    \n3128944768\n,\n \n3137339264\n,\n \n3145725056\n,\n \n3154109312\n,\n \n3162505088\n,\n\n    \n3170893184\n,\n \n3179280256\n,\n \n3187669376\n,\n \n3196056704\n,\n \n3204445568\n,\n\n    \n3212836736\n,\n \n3221224064\n,\n \n3229612928\n,\n \n3238002304\n,\n \n3246391168\n,\n\n    \n3254778496\n,\n \n3263165824\n,\n \n3271556224\n,\n \n3279944576\n,\n \n3288332416\n,\n\n    \n3296719232\n,\n \n3305110912\n,\n \n3313500032\n,\n \n3321887104\n,\n \n3330273152\n,\n\n    \n3338658944\n,\n \n3347053184\n,\n \n3355440512\n,\n \n3363827072\n,\n \n3372220288\n,\n\n    \n3380608384\n,\n \n3388997504\n,\n \n3397384576\n,\n \n3405774208\n,\n \n3414163072\n,\n\n    \n3422551936\n,\n \n3430937984\n,\n \n3439328384\n,\n \n3447714176\n,\n \n3456104576\n,\n\n    \n3464493952\n,\n \n3472883584\n,\n \n3481268864\n,\n \n3489655168\n,\n \n3498048896\n,\n\n    \n3506434432\n,\n \n3514826368\n,\n \n3523213952\n,\n \n3531603584\n,\n \n3539987072\n,\n\n    \n3548380288\n,\n \n3556763264\n,\n \n3565157248\n,\n \n3573545344\n,\n \n3581934464\n,\n\n    \n3590324096\n,\n \n3598712704\n,\n \n3607098752\n,\n \n3615488384\n,\n \n3623877248\n,\n\n    \n3632265856\n,\n \n3640646528\n,\n \n3649043584\n,\n \n3657430144\n,\n \n3665821568\n,\n\n    \n3674207872\n,\n \n3682597504\n,\n \n3690984832\n,\n \n3699367808\n,\n \n3707764352\n,\n\n    \n3716152448\n,\n \n3724541056\n,\n \n3732925568\n,\n \n3741318016\n,\n \n3749706368\n,\n\n    \n3758091136\n,\n \n3766481536\n,\n \n3774872704\n,\n \n3783260032\n,\n \n3791650432\n,\n\n    \n3800036224\n,\n \n3808427648\n,\n \n3816815488\n,\n \n3825204608\n,\n \n3833592704\n,\n\n    \n3841981568\n,\n \n3850370432\n,\n \n3858755968\n,\n \n3867147904\n,\n \n3875536256\n,\n\n    \n3883920512\n,\n \n3892313728\n,\n \n3900702592\n,\n \n3909087872\n,\n \n3917478784\n,\n\n    \n3925868416\n,\n \n3934256512\n,\n \n3942645376\n,\n \n3951032192\n,\n \n3959422336\n,\n\n    \n3967809152\n,\n \n3976200064\n,\n \n3984588416\n,\n \n3992974976\n,\n \n4001363584\n,\n\n    \n4009751168\n,\n \n4018141312\n,\n \n4026530432\n,\n \n4034911616\n,\n \n4043308928\n,\n\n    \n4051695488\n,\n \n4060084352\n,\n \n4068472448\n,\n \n4076862848\n,\n \n4085249408\n,\n\n    \n4093640576\n,\n \n4102028416\n,\n \n4110413696\n,\n \n4118805632\n,\n \n4127194496\n,\n\n    \n4135583104\n,\n \n4143971968\n,\n \n4152360832\n,\n \n4160746112\n,\n \n4169135744\n,\n\n    \n4177525888\n,\n \n4185912704\n,\n \n4194303616\n,\n \n4202691968\n,\n \n4211076736\n,\n\n    \n4219463552\n,\n \n4227855488\n,\n \n4236246656\n,\n \n4244633728\n,\n \n4253022848\n,\n\n    \n4261412224\n,\n \n4269799808\n,\n \n4278184832\n,\n \n4286578048\n,\n \n4294962304\n,\n\n    \n4303349632\n,\n \n4311743104\n,\n \n4320130432\n,\n \n4328521088\n,\n \n4336909184\n,\n\n    \n4345295488\n,\n \n4353687424\n,\n \n4362073472\n,\n \n4370458496\n,\n \n4378852736\n,\n\n    \n4387238528\n,\n \n4395630208\n,\n \n4404019072\n,\n \n4412407424\n,\n \n4420790656\n,\n\n    \n4429182848\n,\n \n4437571456\n,\n \n4445962112\n,\n \n4454344064\n,\n \n4462738048\n,\n\n    \n4471119232\n,\n \n4479516544\n,\n \n4487904128\n,\n \n4496289664\n,\n \n4504682368\n,\n\n    \n4513068416\n,\n \n4521459584\n,\n \n4529846144\n,\n \n4538232704\n,\n \n4546619776\n,\n\n    \n4555010176\n,\n \n4563402112\n,\n \n4571790208\n,\n \n4580174464\n,\n \n4588567936\n,\n\n    \n4596957056\n,\n \n4605344896\n,\n \n4613734016\n,\n \n4622119808\n,\n \n4630511488\n,\n\n    \n4638898816\n,\n \n4647287936\n,\n \n4655675264\n,\n \n4664065664\n,\n \n4672451968\n,\n\n    \n4680842624\n,\n \n4689231488\n,\n \n4697620352\n,\n \n4706007424\n,\n \n4714397056\n,\n\n    \n4722786176\n,\n \n4731173248\n,\n \n4739562368\n,\n \n4747951744\n,\n \n4756340608\n,\n\n    \n4764727936\n,\n \n4773114496\n,\n \n4781504384\n,\n \n4789894784\n,\n \n4798283648\n,\n\n    \n4806667648\n,\n \n4815059584\n,\n \n4823449472\n,\n \n4831835776\n,\n \n4840226176\n,\n\n    \n4848612224\n,\n \n4857003392\n,\n \n4865391488\n,\n \n4873780096\n,\n \n4882169728\n,\n\n    \n4890557312\n,\n \n4898946944\n,\n \n4907333248\n,\n \n4915722368\n,\n \n4924110976\n,\n\n    \n4932499328\n,\n \n4940889728\n,\n \n4949276032\n,\n \n4957666432\n,\n \n4966054784\n,\n\n    \n4974438016\n,\n \n4982831488\n,\n \n4991221376\n,\n \n4999607168\n,\n \n5007998848\n,\n\n    \n5016386432\n,\n \n5024763776\n,\n \n5033164672\n,\n \n5041544576\n,\n \n5049941888\n,\n\n    \n5058329728\n,\n \n5066717056\n,\n \n5075107456\n,\n \n5083494272\n,\n \n5091883904\n,\n\n    \n5100273536\n,\n \n5108662144\n,\n \n5117048192\n,\n \n5125436032\n,\n \n5133827456\n,\n\n    \n5142215296\n,\n \n5150605184\n,\n \n5158993024\n,\n \n5167382144\n,\n \n5175769472\n,\n\n    \n5184157568\n,\n \n5192543872\n,\n \n5200936064\n,\n \n5209324928\n,\n \n5217711232\n,\n\n    \n5226102656\n,\n \n5234490496\n,\n \n5242877312\n,\n \n5251263872\n,\n \n5259654016\n,\n\n    \n5268040832\n,\n \n5276434304\n,\n \n5284819328\n,\n \n5293209728\n,\n \n5301598592\n,\n\n    \n5309986688\n,\n \n5318374784\n,\n \n5326764416\n,\n \n5335151488\n,\n \n5343542144\n,\n\n    \n5351929472\n,\n \n5360319872\n,\n \n5368706944\n,\n \n5377096576\n,\n \n5385484928\n,\n\n    \n5393871232\n,\n \n5402263424\n,\n \n5410650496\n,\n \n5419040384\n,\n \n5427426944\n,\n\n    \n5435816576\n,\n \n5444205952\n,\n \n5452594816\n,\n \n5460981376\n,\n \n5469367936\n,\n\n    \n5477760896\n,\n \n5486148736\n,\n \n5494536832\n,\n \n5502925952\n,\n \n5511315328\n,\n\n    \n5519703424\n,\n \n5528089984\n,\n \n5536481152\n,\n \n5544869504\n,\n \n5553256064\n,\n\n    \n5561645696\n,\n \n5570032768\n,\n \n5578423936\n,\n \n5586811264\n,\n \n5595193216\n,\n\n    \n5603585408\n,\n \n5611972736\n,\n \n5620366208\n,\n \n5628750464\n,\n \n5637143936\n,\n\n    \n5645528192\n,\n \n5653921408\n,\n \n5662310272\n,\n \n5670694784\n,\n \n5679082624\n,\n\n    \n5687474048\n,\n \n5695864448\n,\n \n5704251008\n,\n \n5712641408\n,\n \n5721030272\n,\n\n    \n5729416832\n,\n \n5737806208\n,\n \n5746194304\n,\n \n5754583936\n,\n \n5762969984\n,\n\n    \n5771358592\n,\n \n5779748224\n,\n \n5788137856\n,\n \n5796527488\n,\n \n5804911232\n,\n\n    \n5813300608\n,\n \n5821692544\n,\n \n5830082176\n,\n \n5838468992\n,\n \n5846855552\n,\n\n    \n5855247488\n,\n \n5863636096\n,\n \n5872024448\n,\n \n5880411008\n,\n \n5888799872\n,\n\n    \n5897186432\n,\n \n5905576832\n,\n \n5913966976\n,\n \n5922352768\n,\n \n5930744704\n,\n\n    \n5939132288\n,\n \n5947522432\n,\n \n5955911296\n,\n \n5964299392\n,\n \n5972688256\n,\n\n    \n5981074304\n,\n \n5989465472\n,\n \n5997851008\n,\n \n6006241408\n,\n \n6014627968\n,\n\n    \n6023015552\n,\n \n6031408256\n,\n \n6039796096\n,\n \n6048185216\n,\n \n6056574848\n,\n\n    \n6064963456\n,\n \n6073351808\n,\n \n6081736064\n,\n \n6090128768\n,\n \n6098517632\n,\n\n    \n6106906496\n,\n \n6115289216\n,\n \n6123680896\n,\n \n6132070016\n,\n \n6140459648\n,\n\n    \n6148849024\n,\n \n6157237376\n,\n \n6165624704\n,\n \n6174009728\n,\n \n6182403712\n,\n\n    \n6190792064\n,\n \n6199176064\n,\n \n6207569792\n,\n \n6215952256\n,\n \n6224345216\n,\n\n    \n6232732544\n,\n \n6241124224\n,\n \n6249510272\n,\n \n6257899136\n,\n \n6266287744\n,\n\n    \n6274676864\n,\n \n6283065728\n,\n \n6291454336\n,\n \n6299843456\n,\n \n6308232064\n,\n\n    \n6316620928\n,\n \n6325006208\n,\n \n6333395584\n,\n \n6341784704\n,\n \n6350174848\n,\n\n    \n6358562176\n,\n \n6366951296\n,\n \n6375337856\n,\n \n6383729536\n,\n \n6392119168\n,\n\n    \n6400504192\n,\n \n6408895616\n,\n \n6417283456\n,\n \n6425673344\n,\n \n6434059136\n,\n\n    \n6442444672\n,\n \n6450837376\n,\n \n6459223424\n,\n \n6467613056\n,\n \n6476004224\n,\n\n    \n6484393088\n,\n \n6492781952\n,\n \n6501170048\n,\n \n6509555072\n,\n \n6517947008\n,\n\n    \n6526336384\n,\n \n6534725504\n,\n \n6543112832\n,\n \n6551500672\n,\n \n6559888768\n,\n\n    \n6568278656\n,\n \n6576662912\n,\n \n6585055616\n,\n \n6593443456\n,\n \n6601834112\n,\n\n    \n6610219648\n,\n \n6618610304\n,\n \n6626999168\n,\n \n6635385472\n,\n \n6643777408\n,\n\n    \n6652164224\n,\n \n6660552832\n,\n \n6668941952\n,\n \n6677330048\n,\n \n6685719424\n,\n\n    \n6694107776\n,\n \n6702493568\n,\n \n6710882176\n,\n \n6719274112\n,\n \n6727662976\n,\n\n    \n6736052096\n,\n \n6744437632\n,\n \n6752825984\n,\n \n6761213824\n,\n \n6769604224\n,\n\n    \n6777993856\n,\n \n6786383488\n,\n \n6794770816\n,\n \n6803158144\n,\n \n6811549312\n,\n\n    \n6819937664\n,\n \n6828326528\n,\n \n6836706176\n,\n \n6845101696\n,\n \n6853491328\n,\n\n    \n6861880448\n,\n \n6870269312\n,\n \n6878655104\n,\n \n6887046272\n,\n \n6895433344\n,\n\n    \n6903822208\n,\n \n6912212864\n,\n \n6920596864\n,\n \n6928988288\n,\n \n6937377152\n,\n\n    \n6945764992\n,\n \n6954149248\n,\n \n6962544256\n,\n \n6970928768\n,\n \n6979317376\n,\n\n    \n6987709312\n,\n \n6996093824\n,\n \n7004487296\n,\n \n7012875392\n,\n \n7021258624\n,\n\n    \n7029652352\n,\n \n7038038912\n,\n \n7046427776\n,\n \n7054818944\n,\n \n7063207808\n,\n\n    \n7071595136\n,\n \n7079980928\n,\n \n7088372608\n,\n \n7096759424\n,\n \n7105149824\n,\n\n    \n7113536896\n,\n \n7121928064\n,\n \n7130315392\n,\n \n7138699648\n,\n \n7147092352\n,\n\n    \n7155479168\n,\n \n7163865728\n,\n \n7172249984\n,\n \n7180648064\n,\n \n7189036672\n,\n\n    \n7197424768\n,\n \n7205810816\n,\n \n7214196608\n,\n \n7222589824\n,\n \n7230975104\n,\n\n    \n7239367552\n,\n \n7247755904\n,\n \n7256145536\n,\n \n7264533376\n,\n \n7272921472\n,\n\n    \n7281308032\n,\n \n7289694848\n,\n \n7298088832\n,\n \n7306471808\n,\n \n7314864512\n,\n\n    \n7323253888\n,\n \n7331643008\n,\n \n7340029568\n,\n \n7348419712\n,\n \n7356808832\n,\n\n    \n7365196672\n,\n \n7373585792\n,\n \n7381973888\n,\n \n7390362752\n,\n \n7398750592\n,\n\n    \n7407138944\n,\n \n7415528576\n,\n \n7423915648\n,\n \n7432302208\n,\n \n7440690304\n,\n\n    \n7449080192\n,\n \n7457472128\n,\n \n7465860992\n,\n \n7474249088\n,\n \n7482635648\n,\n\n    \n7491023744\n,\n \n7499412608\n,\n \n7507803008\n,\n \n7516192384\n,\n \n7524579968\n,\n\n    \n7532967296\n,\n \n7541358464\n,\n \n7549745792\n,\n \n7558134656\n,\n \n7566524032\n,\n\n    \n7574912896\n,\n \n7583300992\n,\n \n7591690112\n,\n \n7600075136\n,\n \n7608466816\n,\n\n    \n7616854912\n,\n \n7625244544\n,\n \n7633629824\n,\n \n7642020992\n,\n \n7650410368\n,\n\n    \n7658794112\n,\n \n7667187328\n,\n \n7675574912\n,\n \n7683961984\n,\n \n7692349568\n,\n\n    \n7700739712\n,\n \n7709130368\n,\n \n7717519232\n,\n \n7725905536\n,\n \n7734295424\n,\n\n    \n7742683264\n,\n \n7751069056\n,\n \n7759457408\n,\n \n7767849088\n,\n \n7776238208\n,\n\n    \n7784626816\n,\n \n7793014912\n,\n \n7801405312\n,\n \n7809792128\n,\n \n7818179968\n,\n\n    \n7826571136\n,\n \n7834957184\n,\n \n7843347328\n,\n \n7851732352\n,\n \n7860124544\n,\n\n    \n7868512384\n,\n \n7876902016\n,\n \n7885287808\n,\n \n7893679744\n,\n \n7902067072\n,\n\n    \n7910455936\n,\n \n7918844288\n,\n \n7927230848\n,\n \n7935622784\n,\n \n7944009344\n,\n\n    \n7952400256\n,\n \n7960786048\n,\n \n7969176704\n,\n \n7977565312\n,\n \n7985953408\n,\n\n    \n7994339968\n,\n \n8002730368\n,\n \n8011119488\n,\n \n8019508096\n,\n \n8027896192\n,\n\n    \n8036285056\n,\n \n8044674688\n,\n \n8053062272\n,\n \n8061448832\n,\n \n8069838464\n,\n\n    \n8078227328\n,\n \n8086616704\n,\n \n8095006592\n,\n \n8103393664\n,\n \n8111783552\n,\n\n    \n8120171392\n,\n \n8128560256\n,\n \n8136949376\n,\n \n8145336704\n,\n \n8153726848\n,\n\n    \n8162114944\n,\n \n8170503296\n,\n \n8178891904\n,\n \n8187280768\n,\n \n8195669632\n,\n\n    \n8204058496\n,\n \n8212444544\n,\n \n8220834176\n,\n \n8229222272\n,\n \n8237612672\n,\n\n    \n8246000768\n,\n \n8254389376\n,\n \n8262775168\n,\n \n8271167104\n,\n \n8279553664\n,\n\n    \n8287944064\n,\n \n8296333184\n,\n \n8304715136\n,\n \n8313108352\n,\n \n8321497984\n,\n\n    \n8329885568\n,\n \n8338274432\n,\n \n8346663296\n,\n \n8355052928\n,\n \n8363441536\n,\n\n    \n8371828352\n,\n \n8380217984\n,\n \n8388606592\n,\n \n8396996224\n,\n \n8405384576\n,\n\n    \n8413772672\n,\n \n8422161536\n,\n \n8430549376\n,\n \n8438939008\n,\n \n8447326592\n,\n\n    \n8455715456\n,\n \n8464104832\n,\n \n8472492928\n,\n \n8480882048\n,\n \n8489270656\n,\n\n    \n8497659776\n,\n \n8506045312\n,\n \n8514434944\n,\n \n8522823808\n,\n \n8531208832\n,\n\n    \n8539602304\n,\n \n8547990656\n,\n \n8556378752\n,\n \n8564768384\n,\n \n8573154176\n,\n\n    \n8581542784\n,\n \n8589933952\n,\n \n8598322816\n,\n \n8606705024\n,\n \n8615099264\n,\n\n    \n8623487872\n,\n \n8631876992\n,\n \n8640264064\n,\n \n8648653952\n,\n \n8657040256\n,\n\n    \n8665430656\n,\n \n8673820544\n,\n \n8682209152\n,\n \n8690592128\n,\n \n8698977152\n,\n\n    \n8707374464\n,\n \n8715763328\n,\n \n8724151424\n,\n \n8732540032\n,\n \n8740928384\n,\n\n    \n8749315712\n,\n \n8757704576\n,\n \n8766089344\n,\n \n8774480768\n,\n \n8782871936\n,\n\n    \n8791260032\n,\n \n8799645824\n,\n \n8808034432\n,\n \n8816426368\n,\n \n8824812928\n,\n\n    \n8833199488\n,\n \n8841591424\n,\n \n8849976448\n,\n \n8858366336\n,\n \n8866757248\n,\n\n    \n8875147136\n,\n \n8883532928\n,\n \n8891923328\n,\n \n8900306816\n,\n \n8908700288\n,\n\n    \n8917088384\n,\n \n8925478784\n,\n \n8933867392\n,\n \n8942250368\n,\n \n8950644608\n,\n\n    \n8959032704\n,\n \n8967420544\n,\n \n8975809664\n,\n \n8984197504\n,\n \n8992584064\n,\n\n    \n9000976256\n,\n \n9009362048\n,\n \n9017752448\n,\n \n9026141312\n,\n \n9034530688\n,\n\n    \n9042917504\n,\n \n9051307904\n,\n \n9059694208\n,\n \n9068084864\n,\n \n9076471424\n,\n\n    \n9084861824\n,\n \n9093250688\n,\n \n9101638528\n,\n \n9110027648\n,\n \n9118416512\n,\n\n    \n9126803584\n,\n \n9135188096\n,\n \n9143581312\n,\n \n9151969664\n,\n \n9160356224\n,\n\n    \n9168747136\n,\n \n9177134464\n,\n \n9185525632\n,\n \n9193910144\n,\n \n9202302848\n,\n\n    \n9210690688\n,\n \n9219079552\n,\n \n9227465344\n,\n \n9235854464\n,\n \n9244244864\n,\n\n    \n9252633472\n,\n \n9261021824\n,\n \n9269411456\n,\n \n9277799296\n,\n \n9286188928\n,\n\n    \n9294574208\n,\n \n9302965888\n,\n \n9311351936\n,\n \n9319740032\n,\n \n9328131968\n,\n\n    \n9336516736\n,\n \n9344907392\n,\n \n9353296768\n,\n \n9361685888\n,\n \n9370074752\n,\n\n    \n9378463616\n,\n \n9386849408\n,\n \n9395239808\n,\n \n9403629184\n,\n \n9412016512\n,\n\n    \n9420405376\n,\n \n9428795008\n,\n \n9437181568\n,\n \n9445570688\n,\n \n9453960832\n,\n\n    \n9462346624\n,\n \n9470738048\n,\n \n9479121536\n,\n \n9487515008\n,\n \n9495903616\n,\n\n    \n9504289664\n,\n \n9512678528\n,\n \n9521067904\n,\n \n9529456256\n,\n \n9537843584\n,\n\n    \n9546233728\n,\n \n9554621312\n,\n \n9563011456\n,\n \n9571398784\n,\n \n9579788672\n,\n\n    \n9588178304\n,\n \n9596567168\n,\n \n9604954496\n,\n \n9613343104\n,\n \n9621732992\n,\n\n    \n9630121856\n,\n \n9638508416\n,\n \n9646898816\n,\n \n9655283584\n,\n \n9663675776\n,\n\n    \n9672061312\n,\n \n9680449664\n,\n \n9688840064\n,\n \n9697230464\n,\n \n9705617536\n,\n\n    \n9714003584\n,\n \n9722393984\n,\n \n9730772608\n,\n \n9739172224\n,\n \n9747561088\n,\n\n    \n9755945344\n,\n \n9764338816\n,\n \n9772726144\n,\n \n9781116544\n,\n \n9789503872\n,\n\n    \n9797892992\n,\n \n9806282624\n,\n \n9814670464\n,\n \n9823056512\n,\n \n9831439232\n,\n\n    \n9839833984\n,\n \n9848224384\n,\n \n9856613504\n,\n \n9865000576\n,\n \n9873391232\n,\n\n    \n9881772416\n,\n \n9890162816\n,\n \n9898556288\n,\n \n9906940544\n,\n \n9915333248\n,\n\n    \n9923721088\n,\n \n9932108672\n,\n \n9940496512\n,\n \n9948888448\n,\n \n9957276544\n,\n\n    \n9965666176\n,\n \n9974048384\n,\n \n9982441088\n,\n \n9990830464\n,\n \n9999219584\n,\n\n    \n10007602816\n,\n \n10015996544\n,\n \n10024385152\n,\n \n10032774016\n,\n \n10041163648\n,\n\n    \n10049548928\n,\n \n10057940096\n,\n \n10066329472\n,\n \n10074717824\n,\n \n10083105152\n,\n\n    \n10091495296\n,\n \n10099878784\n,\n \n10108272256\n,\n \n10116660608\n,\n \n10125049216\n,\n\n    \n10133437312\n,\n \n10141825664\n,\n \n10150213504\n,\n \n10158601088\n,\n \n10166991232\n,\n\n    \n10175378816\n,\n \n10183766144\n,\n \n10192157312\n,\n \n10200545408\n,\n \n10208935552\n,\n\n    \n10217322112\n,\n \n10225712768\n,\n \n10234099328\n,\n \n10242489472\n,\n \n10250876032\n,\n\n    \n10259264896\n,\n \n10267656064\n,\n \n10276042624\n,\n \n10284429184\n,\n \n10292820352\n,\n\n    \n10301209472\n,\n \n10309598848\n,\n \n10317987712\n,\n \n10326375296\n,\n \n10334763392\n,\n\n    \n10343153536\n,\n \n10351541632\n,\n \n10359930752\n,\n \n10368318592\n,\n \n10376707456\n,\n\n    \n10385096576\n,\n \n10393484672\n,\n \n10401867136\n,\n \n10410262144\n,\n \n10418647424\n,\n\n    \n10427039104\n,\n \n10435425664\n,\n \n10443810176\n,\n \n10452203648\n,\n \n10460589952\n,\n\n    \n10468982144\n,\n \n10477369472\n,\n \n10485759104\n,\n \n10494147712\n,\n \n10502533504\n,\n\n    \n10510923392\n,\n \n10519313536\n,\n \n10527702656\n,\n \n10536091264\n,\n \n10544478592\n,\n\n    \n10552867712\n,\n \n10561255808\n,\n \n10569642368\n,\n \n10578032768\n,\n \n10586423168\n,\n\n    \n10594805632\n,\n \n10603200128\n,\n \n10611588992\n,\n \n10619976064\n,\n \n10628361344\n,\n\n    \n10636754048\n,\n \n10645143424\n,\n \n10653531776\n,\n \n10661920384\n,\n \n10670307968\n,\n\n    \n10678696832\n,\n \n10687086464\n,\n \n10695475072\n,\n \n10703863168\n,\n \n10712246144\n,\n\n    \n10720639616\n,\n \n10729026688\n,\n \n10737414784\n,\n \n10745806208\n,\n \n10754190976\n,\n\n    \n10762581376\n,\n \n10770971264\n,\n \n10779356288\n,\n \n10787747456\n,\n \n10796135552\n,\n\n    \n10804525184\n,\n \n10812915584\n,\n \n10821301888\n,\n \n10829692288\n,\n \n10838078336\n,\n\n    \n10846469248\n,\n \n10854858368\n,\n \n10863247232\n,\n \n10871631488\n,\n \n10880023424\n,\n\n    \n10888412032\n,\n \n10896799616\n,\n \n10905188992\n,\n \n10913574016\n,\n \n10921964672\n,\n\n    \n10930352768\n,\n \n10938742912\n,\n \n10947132544\n,\n \n10955518592\n,\n \n10963909504\n,\n\n    \n10972298368\n,\n \n10980687488\n,\n \n10989074816\n,\n \n10997462912\n,\n \n11005851776\n,\n\n    \n11014241152\n,\n \n11022627712\n,\n \n11031017344\n,\n \n11039403904\n,\n \n11047793024\n,\n\n    \n11056184704\n,\n \n11064570752\n,\n \n11072960896\n,\n \n11081343872\n,\n \n11089737856\n,\n\n    \n11098128256\n,\n \n11106514816\n,\n \n11114904448\n,\n \n11123293568\n,\n \n11131680128\n,\n\n    \n11140065152\n,\n \n11148458368\n,\n \n11156845696\n,\n \n11165236864\n,\n \n11173624192\n,\n\n    \n11182013824\n,\n \n11190402688\n,\n \n11198790784\n,\n \n11207179136\n,\n \n11215568768\n,\n\n    \n11223957376\n,\n \n11232345728\n,\n \n11240734592\n,\n \n11249122688\n,\n \n11257511296\n,\n\n    \n11265899648\n,\n \n11274285952\n,\n \n11282675584\n,\n \n11291065472\n,\n \n11299452544\n,\n\n    \n11307842432\n,\n \n11316231296\n,\n \n11324616832\n,\n \n11333009024\n,\n \n11341395584\n,\n\n    \n11349782656\n,\n \n11358172288\n,\n \n11366560384\n,\n \n11374950016\n,\n \n11383339648\n,\n\n    \n11391721856\n,\n \n11400117376\n,\n \n11408504192\n,\n \n11416893568\n,\n \n11425283456\n,\n\n    \n11433671552\n,\n \n11442061184\n,\n \n11450444672\n,\n \n11458837888\n,\n \n11467226752\n,\n\n    \n11475611776\n,\n \n11484003968\n,\n \n11492392064\n,\n \n11500780672\n,\n \n11509169024\n,\n\n    \n11517550976\n,\n \n11525944448\n,\n \n11534335616\n,\n \n11542724224\n,\n \n11551111808\n,\n\n    \n11559500672\n,\n \n11567890304\n,\n \n11576277376\n,\n \n11584667008\n,\n \n11593056128\n,\n\n    \n11601443456\n,\n \n11609830016\n,\n \n11618221952\n,\n \n11626607488\n,\n \n11634995072\n,\n\n    \n11643387776\n,\n \n11651775104\n,\n \n11660161664\n,\n \n11668552576\n,\n \n11676940928\n,\n\n    \n11685330304\n,\n \n11693718656\n,\n \n11702106496\n,\n \n11710496128\n,\n \n11718882688\n,\n\n    \n11727273088\n,\n \n11735660416\n,\n \n11744050048\n,\n \n11752437376\n,\n \n11760824704\n,\n\n    \n11769216128\n,\n \n11777604736\n,\n \n11785991296\n,\n \n11794381952\n,\n \n11802770048\n,\n\n    \n11811157888\n,\n \n11819548544\n,\n \n11827932544\n,\n \n11836324736\n,\n \n11844713344\n,\n\n    \n11853100928\n,\n \n11861486464\n,\n \n11869879936\n,\n \n11878268032\n,\n \n11886656896\n,\n\n    \n11895044992\n,\n \n11903433088\n,\n \n11911822976\n,\n \n11920210816\n,\n \n11928600448\n,\n\n    \n11936987264\n,\n \n11945375872\n,\n \n11953761152\n,\n \n11962151296\n,\n \n11970543488\n,\n\n    \n11978928512\n,\n \n11987320448\n,\n \n11995708288\n,\n \n12004095104\n,\n \n12012486272\n,\n\n    \n12020875136\n,\n \n12029255552\n,\n \n12037652096\n,\n \n12046039168\n,\n \n12054429568\n,\n\n    \n12062813824\n,\n \n12071206528\n,\n \n12079594624\n,\n \n12087983744\n,\n \n12096371072\n,\n\n    \n12104759936\n,\n \n12113147264\n,\n \n12121534592\n,\n \n12129924992\n,\n \n12138314624\n,\n\n    \n12146703232\n,\n \n12155091584\n,\n \n12163481216\n,\n \n12171864704\n,\n \n12180255872\n,\n\n    \n12188643968\n,\n \n12197034112\n,\n \n12205424512\n,\n \n12213811328\n,\n \n12222199424\n,\n\n    \n12230590336\n,\n \n12238977664\n,\n \n12247365248\n,\n \n12255755392\n,\n \n12264143488\n,\n\n    \n12272531584\n,\n \n12280920448\n,\n \n12289309568\n,\n \n12297694592\n,\n \n12306086528\n,\n\n    \n12314475392\n,\n \n12322865024\n,\n \n12331253632\n,\n \n12339640448\n,\n \n12348029312\n,\n\n    \n12356418944\n,\n \n12364805248\n,\n \n12373196672\n,\n \n12381580928\n,\n \n12389969024\n,\n\n    \n12398357632\n,\n \n12406750592\n,\n \n12415138432\n,\n \n12423527552\n,\n \n12431916416\n,\n\n    \n12440304512\n,\n \n12448692352\n,\n \n12457081216\n,\n \n12465467776\n,\n \n12473859968\n,\n\n    \n12482245504\n,\n \n12490636672\n,\n \n12499025536\n,\n \n12507411584\n,\n \n12515801728\n,\n\n    \n12524190592\n,\n \n12532577152\n,\n \n12540966272\n,\n \n12549354368\n,\n \n12557743232\n,\n\n    \n12566129536\n,\n \n12574523264\n,\n \n12582911872\n,\n \n12591299456\n,\n \n12599688064\n,\n\n    \n12608074624\n,\n \n12616463488\n,\n \n12624845696\n,\n \n12633239936\n,\n \n12641631616\n,\n\n    \n12650019968\n,\n \n12658407296\n,\n \n12666795136\n,\n \n12675183232\n,\n \n12683574656\n,\n\n    \n12691960192\n,\n \n12700350592\n,\n \n12708740224\n,\n \n12717128576\n,\n \n12725515904\n,\n\n    \n12733906816\n,\n \n12742295168\n,\n \n12750680192\n,\n \n12759071872\n,\n \n12767460736\n,\n\n    \n12775848832\n,\n \n12784236928\n,\n \n12792626816\n,\n \n12801014656\n,\n \n12809404288\n,\n\n    \n12817789312\n,\n \n12826181504\n,\n \n12834568832\n,\n \n12842954624\n,\n \n12851345792\n,\n\n    \n12859732352\n,\n \n12868122496\n,\n \n12876512128\n,\n \n12884901248\n,\n \n12893289088\n,\n\n    \n12901672832\n,\n \n12910067584\n,\n \n12918455168\n,\n \n12926842496\n,\n \n12935232896\n,\n\n    \n12943620736\n,\n \n12952009856\n,\n \n12960396928\n,\n \n12968786816\n,\n \n12977176192\n,\n\n    \n12985563776\n,\n \n12993951104\n,\n \n13002341504\n,\n \n13010730368\n,\n \n13019115392\n,\n\n    \n13027506304\n,\n \n13035895168\n,\n \n13044272512\n,\n \n13052673152\n,\n \n13061062528\n,\n\n    \n13069446272\n,\n \n13077838976\n,\n \n13086227072\n,\n \n13094613632\n,\n \n13103000192\n,\n\n    \n13111393664\n,\n \n13119782528\n,\n \n13128157568\n,\n \n13136559232\n,\n \n13144945024\n,\n\n    \n13153329536\n,\n \n13161724288\n,\n \n13170111872\n,\n \n13178502784\n,\n \n13186884736\n,\n\n    \n13195279744\n,\n \n13203667072\n,\n \n13212057472\n,\n \n13220445824\n,\n \n13228832128\n,\n\n    \n13237221248\n,\n \n13245610624\n,\n \n13254000512\n,\n \n13262388352\n,\n \n13270777472\n,\n\n    \n13279166336\n,\n \n13287553408\n,\n \n13295943296\n,\n \n13304331904\n,\n \n13312719488\n,\n\n    \n13321108096\n,\n \n13329494656\n,\n \n13337885824\n,\n \n13346274944\n,\n \n13354663808\n,\n\n    \n13363051136\n,\n \n13371439232\n,\n \n13379825024\n,\n \n13388210816\n,\n \n13396605056\n,\n\n    \n13404995456\n,\n \n13413380224\n,\n \n13421771392\n,\n \n13430159744\n,\n \n13438546048\n,\n\n    \n13446937216\n,\n \n13455326848\n,\n \n13463708288\n,\n \n13472103808\n,\n \n13480492672\n,\n\n    \n13488875648\n,\n \n13497269888\n,\n \n13505657728\n,\n \n13514045312\n,\n \n13522435712\n,\n\n    \n13530824576\n,\n \n13539210112\n,\n \n13547599232\n,\n \n13555989376\n,\n \n13564379008\n,\n\n    \n13572766336\n,\n \n13581154432\n,\n \n13589544832\n,\n \n13597932928\n,\n \n13606320512\n,\n\n    \n13614710656\n,\n \n13623097472\n,\n \n13631477632\n,\n \n13639874944\n,\n \n13648264064\n,\n\n    \n13656652928\n,\n \n13665041792\n,\n \n13673430656\n,\n \n13681818496\n,\n \n13690207616\n,\n\n    \n13698595712\n,\n \n13706982272\n,\n \n13715373184\n,\n \n13723762048\n,\n \n13732150144\n,\n\n    \n13740536704\n,\n \n13748926592\n,\n \n13757316224\n,\n \n13765700992\n,\n \n13774090112\n,\n\n    \n13782477952\n,\n \n13790869376\n,\n \n13799259008\n,\n \n13807647872\n,\n \n13816036736\n,\n\n    \n13824425344\n,\n \n13832814208\n,\n \n13841202304\n,\n \n13849591424\n,\n \n13857978752\n,\n\n    \n13866368896\n,\n \n13874754688\n,\n \n13883145344\n,\n \n13891533184\n,\n \n13899919232\n,\n\n    \n13908311168\n,\n \n13916692096\n,\n \n13925085056\n,\n \n13933473152\n,\n \n13941866368\n,\n\n    \n13950253696\n,\n \n13958643584\n,\n \n13967032192\n,\n \n13975417216\n,\n \n13983807616\n,\n\n    \n13992197504\n,\n \n14000582272\n,\n \n14008973696\n,\n \n14017363072\n,\n \n14025752192\n,\n\n    \n14034137984\n,\n \n14042528384\n,\n \n14050918016\n,\n \n14059301504\n,\n \n14067691648\n,\n\n    \n14076083584\n,\n \n14084470144\n,\n \n14092852352\n,\n \n14101249664\n,\n \n14109635968\n,\n\n    \n14118024832\n,\n \n14126407552\n,\n \n14134804352\n,\n \n14143188608\n,\n \n14151577984\n,\n\n    \n14159968384\n,\n \n14168357248\n,\n \n14176741504\n,\n \n14185127296\n,\n \n14193521024\n,\n\n    \n14201911424\n,\n \n14210301824\n,\n \n14218685056\n,\n \n14227067264\n,\n \n14235467392\n,\n\n    \n14243855488\n,\n \n14252243072\n,\n \n14260630144\n,\n \n14269021568\n,\n \n14277409408\n,\n\n    \n14285799296\n,\n \n14294187904\n,\n \n14302571392\n,\n \n14310961792\n,\n \n14319353728\n,\n\n    \n14327738752\n,\n \n14336130944\n,\n \n14344518784\n,\n \n14352906368\n,\n \n14361296512\n,\n\n    \n14369685376\n,\n \n14378071424\n,\n \n14386462592\n,\n \n14394848128\n,\n \n14403230848\n,\n\n    \n14411627392\n,\n \n14420013952\n,\n \n14428402304\n,\n \n14436793472\n,\n \n14445181568\n,\n\n    \n14453569664\n,\n \n14461959808\n,\n \n14470347904\n,\n \n14478737024\n,\n \n14487122816\n,\n\n    \n14495511424\n,\n \n14503901824\n,\n \n14512291712\n,\n \n14520677504\n,\n \n14529064832\n,\n\n    \n14537456768\n,\n \n14545845632\n,\n \n14554234496\n,\n \n14562618496\n,\n \n14571011456\n,\n\n    \n14579398784\n,\n \n14587789184\n,\n \n14596172672\n,\n \n14604564608\n,\n \n14612953984\n,\n\n    \n14621341312\n,\n \n14629724288\n,\n \n14638120832\n,\n \n14646503296\n,\n \n14654897536\n,\n\n    \n14663284864\n,\n \n14671675264\n,\n \n14680061056\n,\n \n14688447616\n,\n \n14696835968\n,\n\n    \n14705228416\n,\n \n14713616768\n,\n \n14722003328\n,\n \n14730392192\n,\n \n14738784128\n,\n\n    \n14747172736\n,\n \n14755561088\n,\n \n14763947648\n,\n \n14772336512\n,\n \n14780725376\n,\n\n    \n14789110144\n,\n \n14797499776\n,\n \n14805892736\n,\n \n14814276992\n,\n \n14822670208\n,\n\n    \n14831056256\n,\n \n14839444352\n,\n \n14847836032\n,\n \n14856222848\n,\n \n14864612992\n,\n\n    \n14872997504\n,\n \n14881388672\n,\n \n14889775744\n,\n \n14898165376\n,\n \n14906553472\n,\n\n    \n14914944896\n,\n \n14923329664\n,\n \n14931721856\n,\n \n14940109696\n,\n \n14948497024\n,\n\n    \n14956887424\n,\n \n14965276544\n,\n \n14973663616\n,\n \n14982053248\n,\n \n14990439808\n,\n\n    \n14998830976\n,\n \n15007216768\n,\n \n15015605888\n,\n \n15023995264\n,\n \n15032385152\n,\n\n    \n15040768384\n,\n \n15049154944\n,\n \n15057549184\n,\n \n15065939072\n,\n \n15074328448\n,\n\n    \n15082715008\n,\n \n15091104128\n,\n \n15099493504\n,\n \n15107879296\n,\n \n15116269184\n,\n\n    \n15124659584\n,\n \n15133042304\n,\n \n15141431936\n,\n \n15149824384\n,\n \n15158214272\n,\n\n    \n15166602368\n,\n \n15174991232\n,\n \n15183378304\n,\n \n15191760512\n,\n \n15200154496\n,\n\n    \n15208542592\n,\n \n15216931712\n,\n \n15225323392\n,\n \n15233708416\n,\n \n15242098048\n,\n\n    \n15250489216\n,\n \n15258875264\n,\n \n15267265408\n,\n \n15275654528\n,\n \n15284043136\n,\n\n    \n15292431488\n,\n \n15300819584\n,\n \n15309208192\n,\n \n15317596544\n,\n \n15325986176\n,\n\n    \n15334374784\n,\n \n15342763648\n,\n \n15351151744\n,\n \n15359540608\n,\n \n15367929728\n,\n\n    \n15376318336\n,\n \n15384706432\n,\n \n15393092992\n,\n \n15401481856\n,\n \n15409869952\n,\n\n    \n15418258816\n,\n \n15426649984\n,\n \n15435037568\n,\n \n15443425664\n,\n \n15451815296\n,\n\n    \n15460203392\n,\n \n15468589184\n,\n \n15476979328\n,\n \n15485369216\n,\n \n15493755776\n,\n\n    \n15502146944\n,\n \n15510534272\n,\n \n15518924416\n,\n \n15527311232\n,\n \n15535699072\n,\n\n    \n15544089472\n,\n \n15552478336\n,\n \n15560866688\n,\n \n15569254528\n,\n \n15577642624\n,\n\n    \n15586031488\n,\n \n15594419072\n,\n \n15602809472\n,\n \n15611199104\n,\n \n15619586432\n,\n\n    \n15627975296\n,\n \n15636364928\n,\n \n15644753792\n,\n \n15653141888\n,\n \n15661529216\n,\n\n    \n15669918848\n,\n \n15678305152\n,\n \n15686696576\n,\n \n15695083136\n,\n \n15703474048\n,\n\n    \n15711861632\n,\n \n15720251264\n,\n \n15728636288\n,\n \n15737027456\n,\n \n15745417088\n,\n\n    \n15753804928\n,\n \n15762194048\n,\n \n15770582656\n,\n \n15778971008\n,\n \n15787358336\n,\n\n    \n15795747712\n,\n \n15804132224\n,\n \n15812523392\n,\n \n15820909696\n,\n \n15829300096\n,\n\n    \n15837691264\n,\n \n15846071936\n,\n \n15854466944\n,\n \n15862855808\n,\n \n15871244672\n,\n\n    \n15879634816\n,\n \n15888020608\n,\n \n15896409728\n,\n \n15904799104\n,\n \n15913185152\n,\n\n    \n15921577088\n,\n \n15929966464\n,\n \n15938354816\n,\n \n15946743424\n,\n \n15955129472\n,\n\n    \n15963519872\n,\n \n15971907968\n,\n \n15980296064\n,\n \n15988684928\n,\n \n15997073024\n,\n\n    \n16005460864\n,\n \n16013851264\n,\n \n16022241152\n,\n \n16030629248\n,\n \n16039012736\n,\n\n    \n16047406976\n,\n \n16055794816\n,\n \n16064181376\n,\n \n16072571264\n,\n \n16080957824\n,\n\n    \n16089346688\n,\n \n16097737856\n,\n \n16106125184\n,\n \n16114514816\n,\n \n16122904192\n,\n\n    \n16131292544\n,\n \n16139678848\n,\n \n16148066944\n,\n \n16156453504\n,\n \n16164839552\n,\n\n    \n16173236096\n,\n \n16181623424\n,\n \n16190012032\n,\n \n16198401152\n,\n \n16206790528\n,\n\n    \n16215177344\n,\n \n16223567744\n,\n \n16231956352\n,\n \n16240344704\n,\n \n16248731008\n,\n\n    \n16257117824\n,\n \n16265504384\n,\n \n16273898624\n,\n \n16282281856\n,\n \n16290668672\n,\n\n    \n16299064192\n,\n \n16307449216\n,\n \n16315842176\n,\n \n16324230016\n,\n \n16332613504\n,\n\n    \n16341006464\n,\n \n16349394304\n,\n \n16357783168\n,\n \n16366172288\n,\n \n16374561664\n,\n\n    \n16382951296\n,\n \n16391337856\n,\n \n16399726208\n,\n \n16408116352\n,\n \n16416505472\n,\n\n    \n16424892032\n,\n \n16433282176\n,\n \n16441668224\n,\n \n16450058624\n,\n \n16458448768\n,\n\n    \n16466836864\n,\n \n16475224448\n,\n \n16483613056\n,\n \n16492001408\n,\n \n16500391808\n,\n\n    \n16508779648\n,\n \n16517166976\n,\n \n16525555328\n,\n \n16533944192\n,\n \n16542330752\n,\n\n    \n16550719616\n,\n \n16559110528\n,\n \n16567497088\n,\n \n16575888512\n,\n \n16584274816\n,\n\n    \n16592665472\n,\n \n16601051008\n,\n \n16609442944\n,\n \n16617832064\n,\n \n16626218624\n,\n\n    \n16634607488\n,\n \n16642996096\n,\n \n16651385728\n,\n \n16659773824\n,\n \n16668163712\n,\n\n    \n16676552576\n,\n \n16684938112\n,\n \n16693328768\n,\n \n16701718144\n,\n \n16710095488\n,\n\n    \n16718492288\n,\n \n16726883968\n,\n \n16735272832\n,\n \n16743661184\n,\n \n16752049792\n,\n\n    \n16760436608\n,\n \n16768827008\n,\n \n16777214336\n,\n \n16785599104\n,\n \n16793992832\n,\n\n    \n16802381696\n,\n \n16810768768\n,\n \n16819151744\n,\n \n16827542656\n,\n \n16835934848\n,\n\n    \n16844323712\n,\n \n16852711552\n,\n \n16861101952\n,\n \n16869489536\n,\n \n16877876864\n,\n\n    \n16886265728\n,\n \n16894653056\n,\n \n16903044736\n,\n \n16911431296\n,\n \n16919821696\n,\n\n    \n16928207488\n,\n \n16936592768\n,\n \n16944987776\n,\n \n16953375616\n,\n \n16961763968\n,\n\n    \n16970152832\n,\n \n16978540928\n,\n \n16986929536\n,\n \n16995319168\n,\n \n17003704448\n,\n\n    \n17012096896\n,\n \n17020481152\n,\n \n17028870784\n,\n \n17037262208\n,\n \n17045649536\n,\n\n    \n17054039936\n,\n \n17062426496\n,\n \n17070814336\n,\n \n17079205504\n,\n \n17087592064\n,\n\n    \n17095978112\n,\n \n17104369024\n,\n \n17112759424\n,\n \n17121147776\n,\n \n17129536384\n,\n\n    \n17137926016\n,\n \n17146314368\n,\n \n17154700928\n,\n \n17163089792\n,\n \n17171480192\n,\n\n    \n17179864192\n,\n \n17188256896\n,\n \n17196644992\n,\n \n17205033856\n,\n \n17213423488\n,\n\n    \n17221811072\n,\n \n17230198912\n,\n \n17238588032\n,\n \n17246976896\n,\n \n17255360384\n,\n\n    \n17263754624\n,\n \n17272143232\n,\n \n17280530048\n,\n \n17288918912\n,\n \n17297309312\n,\n\n    \n17305696384\n,\n \n17314085504\n,\n \n17322475136\n,\n \n17330863744\n,\n \n17339252096\n,\n\n    \n17347640192\n,\n \n17356026496\n,\n \n17364413824\n,\n \n17372796544\n,\n \n17381190016\n,\n\n    \n17389583488\n,\n \n17397972608\n,\n \n17406360704\n,\n \n17414748544\n,\n \n17423135872\n,\n\n    \n17431527296\n,\n \n17439915904\n,\n \n17448303232\n,\n \n17456691584\n,\n \n17465081728\n,\n\n    \n17473468288\n,\n \n17481857408\n,\n \n17490247552\n,\n \n17498635904\n,\n \n17507022464\n,\n\n    \n17515409024\n,\n \n17523801728\n,\n \n17532189824\n,\n \n17540577664\n,\n \n17548966016\n,\n\n    \n17557353344\n,\n \n17565741184\n,\n \n17574131584\n,\n \n17582519168\n,\n \n17590907008\n,\n\n    \n17599296128\n,\n \n17607687808\n,\n \n17616076672\n,\n \n17624455808\n,\n \n17632852352\n,\n\n    \n17641238656\n,\n \n17649630848\n,\n \n17658018944\n,\n \n17666403968\n,\n \n17674794112\n,\n\n    \n17683178368\n,\n \n17691573376\n,\n \n17699962496\n,\n \n17708350592\n,\n \n17716739968\n,\n\n    \n17725126528\n,\n \n17733517184\n,\n \n17741898112\n,\n \n17750293888\n,\n \n17758673024\n,\n\n    \n17767070336\n,\n \n17775458432\n,\n \n17783848832\n,\n \n17792236928\n,\n \n17800625536\n,\n\n    \n17809012352\n,\n \n17817402752\n,\n \n17825785984\n,\n \n17834178944\n,\n \n17842563968\n,\n\n    \n17850955648\n,\n \n17859344512\n,\n \n17867732864\n,\n \n17876119424\n,\n \n17884511872\n,\n\n    \n17892900224\n,\n \n17901287296\n,\n \n17909677696\n,\n \n17918058112\n,\n \n17926451072\n,\n\n    \n17934843776\n,\n \n17943230848\n,\n \n17951609216\n,\n \n17960008576\n,\n \n17968397696\n,\n\n    \n17976784256\n,\n \n17985175424\n,\n \n17993564032\n,\n \n18001952128\n,\n \n18010339712\n,\n\n    \n18018728576\n,\n \n18027116672\n,\n \n18035503232\n,\n \n18043894144\n,\n \n18052283264\n,\n\n    \n18060672128\n,\n \n18069056384\n,\n \n18077449856\n,\n \n18085837184\n,\n \n18094225792\n,\n\n    \n18102613376\n,\n \n18111004544\n,\n \n18119388544\n,\n \n18127781248\n,\n \n18136170368\n,\n\n    \n18144558976\n,\n \n18152947328\n,\n \n18161336192\n,\n \n18169724288\n,\n \n18178108544\n,\n\n    \n18186498944\n,\n \n18194886784\n,\n \n18203275648\n,\n \n18211666048\n,\n \n18220048768\n,\n\n    \n18228444544\n,\n \n18236833408\n,\n \n18245220736\n\n\n]\n\n\n\ncache_sizes\n \n=\n \n[\n\n    \n16776896\n,\n \n16907456\n,\n \n17039296\n,\n \n17170112\n,\n \n17301056\n,\n \n17432512\n,\n \n17563072\n,\n\n    \n17693888\n,\n \n17824192\n,\n \n17955904\n,\n \n18087488\n,\n \n18218176\n,\n \n18349504\n,\n \n18481088\n,\n\n    \n18611392\n,\n \n18742336\n,\n \n18874304\n,\n \n19004224\n,\n \n19135936\n,\n \n19267264\n,\n \n19398208\n,\n\n    \n19529408\n,\n \n19660096\n,\n \n19791424\n,\n \n19922752\n,\n \n20053952\n,\n \n20184896\n,\n \n20315968\n,\n\n    \n20446912\n,\n \n20576576\n,\n \n20709184\n,\n \n20840384\n,\n \n20971072\n,\n \n21102272\n,\n \n21233216\n,\n\n    \n21364544\n,\n \n21494848\n,\n \n21626816\n,\n \n21757376\n,\n \n21887552\n,\n \n22019392\n,\n \n22151104\n,\n\n    \n22281536\n,\n \n22412224\n,\n \n22543936\n,\n \n22675264\n,\n \n22806464\n,\n \n22935872\n,\n \n23068096\n,\n\n    \n23198272\n,\n \n23330752\n,\n \n23459008\n,\n \n23592512\n,\n \n23723968\n,\n \n23854912\n,\n \n23986112\n,\n\n    \n24116672\n,\n \n24247616\n,\n \n24378688\n,\n \n24509504\n,\n \n24640832\n,\n \n24772544\n,\n \n24903488\n,\n\n    \n25034432\n,\n \n25165376\n,\n \n25296704\n,\n \n25427392\n,\n \n25558592\n,\n \n25690048\n,\n \n25820096\n,\n\n    \n25951936\n,\n \n26081728\n,\n \n26214208\n,\n \n26345024\n,\n \n26476096\n,\n \n26606656\n,\n \n26737472\n,\n\n    \n26869184\n,\n \n26998208\n,\n \n27131584\n,\n \n27262528\n,\n \n27393728\n,\n \n27523904\n,\n \n27655744\n,\n\n    \n27786688\n,\n \n27917888\n,\n \n28049344\n,\n \n28179904\n,\n \n28311488\n,\n \n28441792\n,\n \n28573504\n,\n\n    \n28700864\n,\n \n28835648\n,\n \n28966208\n,\n \n29096768\n,\n \n29228608\n,\n \n29359808\n,\n \n29490752\n,\n\n    \n29621824\n,\n \n29752256\n,\n \n29882816\n,\n \n30014912\n,\n \n30144448\n,\n \n30273728\n,\n \n30406976\n,\n\n    \n30538432\n,\n \n30670784\n,\n \n30799936\n,\n \n30932672\n,\n \n31063744\n,\n \n31195072\n,\n \n31325248\n,\n\n    \n31456192\n,\n \n31588288\n,\n \n31719232\n,\n \n31850432\n,\n \n31981504\n,\n \n32110784\n,\n \n32243392\n,\n\n    \n32372672\n,\n \n32505664\n,\n \n32636608\n,\n \n32767808\n,\n \n32897344\n,\n \n33029824\n,\n \n33160768\n,\n\n    \n33289664\n,\n \n33423296\n,\n \n33554368\n,\n \n33683648\n,\n \n33816512\n,\n \n33947456\n,\n \n34076992\n,\n\n    \n34208704\n,\n \n34340032\n,\n \n34471744\n,\n \n34600256\n,\n \n34734016\n,\n \n34864576\n,\n \n34993984\n,\n\n    \n35127104\n,\n \n35258176\n,\n \n35386688\n,\n \n35518528\n,\n \n35650624\n,\n \n35782336\n,\n \n35910976\n,\n\n    \n36044608\n,\n \n36175808\n,\n \n36305728\n,\n \n36436672\n,\n \n36568384\n,\n \n36699968\n,\n \n36830656\n,\n\n    \n36961984\n,\n \n37093312\n,\n \n37223488\n,\n \n37355072\n,\n \n37486528\n,\n \n37617472\n,\n \n37747904\n,\n\n    \n37879232\n,\n \n38009792\n,\n \n38141888\n,\n \n38272448\n,\n \n38403392\n,\n \n38535104\n,\n \n38660672\n,\n\n    \n38795584\n,\n \n38925632\n,\n \n39059264\n,\n \n39190336\n,\n \n39320768\n,\n \n39452096\n,\n \n39581632\n,\n\n    \n39713984\n,\n \n39844928\n,\n \n39974848\n,\n \n40107968\n,\n \n40238144\n,\n \n40367168\n,\n \n40500032\n,\n\n    \n40631744\n,\n \n40762816\n,\n \n40894144\n,\n \n41023552\n,\n \n41155904\n,\n \n41286208\n,\n \n41418304\n,\n\n    \n41547712\n,\n \n41680448\n,\n \n41811904\n,\n \n41942848\n,\n \n42073792\n,\n \n42204992\n,\n \n42334912\n,\n\n    \n42467008\n,\n \n42597824\n,\n \n42729152\n,\n \n42860096\n,\n \n42991552\n,\n \n43122368\n,\n \n43253696\n,\n\n    \n43382848\n,\n \n43515712\n,\n \n43646912\n,\n \n43777088\n,\n \n43907648\n,\n \n44039104\n,\n \n44170432\n,\n\n    \n44302144\n,\n \n44433344\n,\n \n44564288\n,\n \n44694976\n,\n \n44825152\n,\n \n44956864\n,\n \n45088448\n,\n\n    \n45219008\n,\n \n45350464\n,\n \n45481024\n,\n \n45612608\n,\n \n45744064\n,\n \n45874496\n,\n \n46006208\n,\n\n    \n46136768\n,\n \n46267712\n,\n \n46399424\n,\n \n46529344\n,\n \n46660672\n,\n \n46791488\n,\n \n46923328\n,\n\n    \n47053504\n,\n \n47185856\n,\n \n47316928\n,\n \n47447872\n,\n \n47579072\n,\n \n47710144\n,\n \n47839936\n,\n\n    \n47971648\n,\n \n48103232\n,\n \n48234176\n,\n \n48365248\n,\n \n48496192\n,\n \n48627136\n,\n \n48757312\n,\n\n    \n48889664\n,\n \n49020736\n,\n \n49149248\n,\n \n49283008\n,\n \n49413824\n,\n \n49545152\n,\n \n49675712\n,\n\n    \n49807168\n,\n \n49938368\n,\n \n50069056\n,\n \n50200256\n,\n \n50331584\n,\n \n50462656\n,\n \n50593472\n,\n\n    \n50724032\n,\n \n50853952\n,\n \n50986048\n,\n \n51117632\n,\n \n51248576\n,\n \n51379904\n,\n \n51510848\n,\n\n    \n51641792\n,\n \n51773248\n,\n \n51903296\n,\n \n52035136\n,\n \n52164032\n,\n \n52297664\n,\n \n52427968\n,\n\n    \n52557376\n,\n \n52690112\n,\n \n52821952\n,\n \n52952896\n,\n \n53081536\n,\n \n53213504\n,\n \n53344576\n,\n\n    \n53475776\n,\n \n53608384\n,\n \n53738816\n,\n \n53870528\n,\n \n54000832\n,\n \n54131776\n,\n \n54263744\n,\n\n    \n54394688\n,\n \n54525248\n,\n \n54655936\n,\n \n54787904\n,\n \n54918592\n,\n \n55049152\n,\n \n55181248\n,\n\n    \n55312064\n,\n \n55442752\n,\n \n55574336\n,\n \n55705024\n,\n \n55836224\n,\n \n55967168\n,\n \n56097856\n,\n\n    \n56228672\n,\n \n56358592\n,\n \n56490176\n,\n \n56621888\n,\n \n56753728\n,\n \n56884928\n,\n \n57015488\n,\n\n    \n57146816\n,\n \n57278272\n,\n \n57409216\n,\n \n57540416\n,\n \n57671104\n,\n \n57802432\n,\n \n57933632\n,\n\n    \n58064576\n,\n \n58195264\n,\n \n58326976\n,\n \n58457408\n,\n \n58588864\n,\n \n58720192\n,\n \n58849984\n,\n\n    \n58981696\n,\n \n59113024\n,\n \n59243456\n,\n \n59375552\n,\n \n59506624\n,\n \n59637568\n,\n \n59768512\n,\n\n    \n59897792\n,\n \n60030016\n,\n \n60161984\n,\n \n60293056\n,\n \n60423872\n,\n \n60554432\n,\n \n60683968\n,\n\n    \n60817216\n,\n \n60948032\n,\n \n61079488\n,\n \n61209664\n,\n \n61341376\n,\n \n61471936\n,\n \n61602752\n,\n\n    \n61733696\n,\n \n61865792\n,\n \n61996736\n,\n \n62127808\n,\n \n62259136\n,\n \n62389568\n,\n \n62520512\n,\n\n    \n62651584\n,\n \n62781632\n,\n \n62910784\n,\n \n63045056\n,\n \n63176128\n,\n \n63307072\n,\n \n63438656\n,\n\n    \n63569216\n,\n \n63700928\n,\n \n63831616\n,\n \n63960896\n,\n \n64093888\n,\n \n64225088\n,\n \n64355392\n,\n\n    \n64486976\n,\n \n64617664\n,\n \n64748608\n,\n \n64879424\n,\n \n65009216\n,\n \n65142464\n,\n \n65273792\n,\n\n    \n65402816\n,\n \n65535424\n,\n \n65666752\n,\n \n65797696\n,\n \n65927744\n,\n \n66060224\n,\n \n66191296\n,\n\n    \n66321344\n,\n \n66453056\n,\n \n66584384\n,\n \n66715328\n,\n \n66846656\n,\n \n66977728\n,\n \n67108672\n,\n\n    \n67239104\n,\n \n67370432\n,\n \n67501888\n,\n \n67631296\n,\n \n67763776\n,\n \n67895104\n,\n \n68026304\n,\n\n    \n68157248\n,\n \n68287936\n,\n \n68419264\n,\n \n68548288\n,\n \n68681408\n,\n \n68811968\n,\n \n68942912\n,\n\n    \n69074624\n,\n \n69205568\n,\n \n69337024\n,\n \n69467584\n,\n \n69599168\n,\n \n69729472\n,\n \n69861184\n,\n\n    \n69989824\n,\n \n70122944\n,\n \n70253888\n,\n \n70385344\n,\n \n70515904\n,\n \n70647232\n,\n \n70778816\n,\n\n    \n70907968\n,\n \n71040832\n,\n \n71171648\n,\n \n71303104\n,\n \n71432512\n,\n \n71564992\n,\n \n71695168\n,\n\n    \n71826368\n,\n \n71958464\n,\n \n72089536\n,\n \n72219712\n,\n \n72350144\n,\n \n72482624\n,\n \n72613568\n,\n\n    \n72744512\n,\n \n72875584\n,\n \n73006144\n,\n \n73138112\n,\n \n73268672\n,\n \n73400128\n,\n \n73530944\n,\n\n    \n73662272\n,\n \n73793344\n,\n \n73924544\n,\n \n74055104\n,\n \n74185792\n,\n \n74316992\n,\n \n74448832\n,\n\n    \n74579392\n,\n \n74710976\n,\n \n74841664\n,\n \n74972864\n,\n \n75102784\n,\n \n75233344\n,\n \n75364544\n,\n\n    \n75497024\n,\n \n75627584\n,\n \n75759296\n,\n \n75890624\n,\n \n76021696\n,\n \n76152256\n,\n \n76283072\n,\n\n    \n76414144\n,\n \n76545856\n,\n \n76676672\n,\n \n76806976\n,\n \n76937792\n,\n \n77070016\n,\n \n77200832\n,\n\n    \n77331392\n,\n \n77462464\n,\n \n77593664\n,\n \n77725376\n,\n \n77856448\n,\n \n77987776\n,\n \n78118336\n,\n\n    \n78249664\n,\n \n78380992\n,\n \n78511424\n,\n \n78642496\n,\n \n78773056\n,\n \n78905152\n,\n \n79033664\n,\n\n    \n79166656\n,\n \n79297472\n,\n \n79429568\n,\n \n79560512\n,\n \n79690816\n,\n \n79822784\n,\n \n79953472\n,\n\n    \n80084672\n,\n \n80214208\n,\n \n80346944\n,\n \n80477632\n,\n \n80608576\n,\n \n80740288\n,\n \n80870848\n,\n\n    \n81002048\n,\n \n81133504\n,\n \n81264448\n,\n \n81395648\n,\n \n81525952\n,\n \n81657536\n,\n \n81786304\n,\n\n    \n81919808\n,\n \n82050112\n,\n \n82181312\n,\n \n82311616\n,\n \n82443968\n,\n \n82573376\n,\n \n82705984\n,\n\n    \n82835776\n,\n \n82967744\n,\n \n83096768\n,\n \n83230528\n,\n \n83359552\n,\n \n83491264\n,\n \n83622464\n,\n\n    \n83753536\n,\n \n83886016\n,\n \n84015296\n,\n \n84147776\n,\n \n84277184\n,\n \n84409792\n,\n \n84540608\n,\n\n    \n84672064\n,\n \n84803008\n,\n \n84934336\n,\n \n85065152\n,\n \n85193792\n,\n \n85326784\n,\n \n85458496\n,\n\n    \n85589312\n,\n \n85721024\n,\n \n85851968\n,\n \n85982656\n,\n \n86112448\n,\n \n86244416\n,\n \n86370112\n,\n\n    \n86506688\n,\n \n86637632\n,\n \n86769344\n,\n \n86900672\n,\n \n87031744\n,\n \n87162304\n,\n \n87293632\n,\n\n    \n87424576\n,\n \n87555392\n,\n \n87687104\n,\n \n87816896\n,\n \n87947968\n,\n \n88079168\n,\n \n88211264\n,\n\n    \n88341824\n,\n \n88473152\n,\n \n88603712\n,\n \n88735424\n,\n \n88862912\n,\n \n88996672\n,\n \n89128384\n,\n\n    \n89259712\n,\n \n89390272\n,\n \n89521984\n,\n \n89652544\n,\n \n89783872\n,\n \n89914816\n,\n \n90045376\n,\n\n    \n90177088\n,\n \n90307904\n,\n \n90438848\n,\n \n90569152\n,\n \n90700096\n,\n \n90832832\n,\n \n90963776\n,\n\n    \n91093696\n,\n \n91223744\n,\n \n91356992\n,\n \n91486784\n,\n \n91618496\n,\n \n91749824\n,\n \n91880384\n,\n\n    \n92012224\n,\n \n92143552\n,\n \n92273344\n,\n \n92405696\n,\n \n92536768\n,\n \n92666432\n,\n \n92798912\n,\n\n    \n92926016\n,\n \n93060544\n,\n \n93192128\n,\n \n93322816\n,\n \n93453632\n,\n \n93583936\n,\n \n93715136\n,\n\n    \n93845056\n,\n \n93977792\n,\n \n94109504\n,\n \n94240448\n,\n \n94371776\n,\n \n94501184\n,\n \n94632896\n,\n\n    \n94764224\n,\n \n94895552\n,\n \n95023424\n,\n \n95158208\n,\n \n95287744\n,\n \n95420224\n,\n \n95550016\n,\n\n    \n95681216\n,\n \n95811904\n,\n \n95943872\n,\n \n96075328\n,\n \n96203584\n,\n \n96337856\n,\n \n96468544\n,\n\n    \n96599744\n,\n \n96731072\n,\n \n96860992\n,\n \n96992576\n,\n \n97124288\n,\n \n97254848\n,\n \n97385536\n,\n\n    \n97517248\n,\n \n97647808\n,\n \n97779392\n,\n \n97910464\n,\n \n98041408\n,\n \n98172608\n,\n \n98303168\n,\n\n    \n98434496\n,\n \n98565568\n,\n \n98696768\n,\n \n98827328\n,\n \n98958784\n,\n \n99089728\n,\n \n99220928\n,\n\n    \n99352384\n,\n \n99482816\n,\n \n99614272\n,\n \n99745472\n,\n \n99876416\n,\n \n100007104\n,\n\n    \n100138048\n,\n \n100267072\n,\n \n100401088\n,\n \n100529984\n,\n \n100662592\n,\n \n100791872\n,\n\n    \n100925248\n,\n \n101056064\n,\n \n101187392\n,\n \n101317952\n,\n \n101449408\n,\n \n101580608\n,\n\n    \n101711296\n,\n \n101841728\n,\n \n101973824\n,\n \n102104896\n,\n \n102235712\n,\n \n102366016\n,\n\n    \n102498112\n,\n \n102628672\n,\n \n102760384\n,\n \n102890432\n,\n \n103021888\n,\n \n103153472\n,\n\n    \n103284032\n,\n \n103415744\n,\n \n103545152\n,\n \n103677248\n,\n \n103808576\n,\n \n103939648\n,\n\n    \n104070976\n,\n \n104201792\n,\n \n104332736\n,\n \n104462528\n,\n \n104594752\n,\n \n104725952\n,\n\n    \n104854592\n,\n \n104988608\n,\n \n105118912\n,\n \n105247808\n,\n \n105381184\n,\n \n105511232\n,\n\n    \n105643072\n,\n \n105774784\n,\n \n105903296\n,\n \n106037056\n,\n \n106167872\n,\n \n106298944\n,\n\n    \n106429504\n,\n \n106561472\n,\n \n106691392\n,\n \n106822592\n,\n \n106954304\n,\n \n107085376\n,\n\n    \n107216576\n,\n \n107346368\n,\n \n107478464\n,\n \n107609792\n,\n \n107739712\n,\n \n107872192\n,\n\n    \n108003136\n,\n \n108131392\n,\n \n108265408\n,\n \n108396224\n,\n \n108527168\n,\n \n108657344\n,\n\n    \n108789568\n,\n \n108920384\n,\n \n109049792\n,\n \n109182272\n,\n \n109312576\n,\n \n109444928\n,\n\n    \n109572928\n,\n \n109706944\n,\n \n109837888\n,\n \n109969088\n,\n \n110099648\n,\n \n110230976\n,\n\n    \n110362432\n,\n \n110492992\n,\n \n110624704\n,\n \n110755264\n,\n \n110886208\n,\n \n111017408\n,\n\n    \n111148864\n,\n \n111279296\n,\n \n111410752\n,\n \n111541952\n,\n \n111673024\n,\n \n111803456\n,\n\n    \n111933632\n,\n \n112066496\n,\n \n112196416\n,\n \n112328512\n,\n \n112457792\n,\n \n112590784\n,\n\n    \n112715968\n,\n \n112852672\n,\n \n112983616\n,\n \n113114944\n,\n \n113244224\n,\n \n113376448\n,\n\n    \n113505472\n,\n \n113639104\n,\n \n113770304\n,\n \n113901376\n,\n \n114031552\n,\n \n114163264\n,\n\n    \n114294592\n,\n \n114425536\n,\n \n114556864\n,\n \n114687424\n,\n \n114818624\n,\n \n114948544\n,\n\n    \n115080512\n,\n \n115212224\n,\n \n115343296\n,\n \n115473472\n,\n \n115605184\n,\n \n115736128\n,\n\n    \n115867072\n,\n \n115997248\n,\n \n116128576\n,\n \n116260288\n,\n \n116391488\n,\n \n116522944\n,\n\n    \n116652992\n,\n \n116784704\n,\n \n116915648\n,\n \n117046208\n,\n \n117178304\n,\n \n117308608\n,\n\n    \n117440192\n,\n \n117569728\n,\n \n117701824\n,\n \n117833024\n,\n \n117964096\n,\n \n118094656\n,\n\n    \n118225984\n,\n \n118357312\n,\n \n118489024\n,\n \n118617536\n,\n \n118749632\n,\n \n118882112\n,\n\n    \n119012416\n,\n \n119144384\n,\n \n119275328\n,\n \n119406016\n,\n \n119537344\n,\n \n119668672\n,\n\n    \n119798464\n,\n \n119928896\n,\n \n120061376\n,\n \n120192832\n,\n \n120321728\n,\n \n120454336\n,\n\n    \n120584512\n,\n \n120716608\n,\n \n120848192\n,\n \n120979136\n,\n \n121109056\n,\n \n121241408\n,\n\n    \n121372352\n,\n \n121502912\n,\n \n121634752\n,\n \n121764416\n,\n \n121895744\n,\n \n122027072\n,\n\n    \n122157632\n,\n \n122289088\n,\n \n122421184\n,\n \n122550592\n,\n \n122682944\n,\n \n122813888\n,\n\n    \n122945344\n,\n \n123075776\n,\n \n123207488\n,\n \n123338048\n,\n \n123468736\n,\n \n123600704\n,\n\n    \n123731264\n,\n \n123861952\n,\n \n123993664\n,\n \n124124608\n,\n \n124256192\n,\n \n124386368\n,\n\n    \n124518208\n,\n \n124649024\n,\n \n124778048\n,\n \n124911296\n,\n \n125041088\n,\n \n125173696\n,\n\n    \n125303744\n,\n \n125432896\n,\n \n125566912\n,\n \n125696576\n,\n \n125829056\n,\n \n125958592\n,\n\n    \n126090304\n,\n \n126221248\n,\n \n126352832\n,\n \n126483776\n,\n \n126615232\n,\n \n126746432\n,\n\n    \n126876608\n,\n \n127008704\n,\n \n127139392\n,\n \n127270336\n,\n \n127401152\n,\n \n127532224\n,\n\n    \n127663552\n,\n \n127794752\n,\n \n127925696\n,\n \n128055232\n,\n \n128188096\n,\n \n128319424\n,\n\n    \n128449856\n,\n \n128581312\n,\n \n128712256\n,\n \n128843584\n,\n \n128973632\n,\n \n129103808\n,\n\n    \n129236288\n,\n \n129365696\n,\n \n129498944\n,\n \n129629888\n,\n \n129760832\n,\n \n129892288\n,\n\n    \n130023104\n,\n \n130154048\n,\n \n130283968\n,\n \n130416448\n,\n \n130547008\n,\n \n130678336\n,\n\n    \n130807616\n,\n \n130939456\n,\n \n131071552\n,\n \n131202112\n,\n \n131331776\n,\n \n131464384\n,\n\n    \n131594048\n,\n \n131727296\n,\n \n131858368\n,\n \n131987392\n,\n \n132120256\n,\n \n132250816\n,\n\n    \n132382528\n,\n \n132513728\n,\n \n132644672\n,\n \n132774976\n,\n \n132905792\n,\n \n133038016\n,\n\n    \n133168832\n,\n \n133299392\n,\n \n133429312\n,\n \n133562048\n,\n \n133692992\n,\n \n133823296\n,\n\n    \n133954624\n,\n \n134086336\n,\n \n134217152\n,\n \n134348608\n,\n \n134479808\n,\n \n134607296\n,\n\n    \n134741056\n,\n \n134872384\n,\n \n135002944\n,\n \n135134144\n,\n \n135265472\n,\n \n135396544\n,\n\n    \n135527872\n,\n \n135659072\n,\n \n135787712\n,\n \n135921472\n,\n \n136052416\n,\n \n136182848\n,\n\n    \n136313792\n,\n \n136444864\n,\n \n136576448\n,\n \n136707904\n,\n \n136837952\n,\n \n136970048\n,\n\n    \n137099584\n,\n \n137232064\n,\n \n137363392\n,\n \n137494208\n,\n \n137625536\n,\n \n137755712\n,\n\n    \n137887424\n,\n \n138018368\n,\n \n138149824\n,\n \n138280256\n,\n \n138411584\n,\n \n138539584\n,\n\n    \n138672832\n,\n \n138804928\n,\n \n138936128\n,\n \n139066688\n,\n \n139196864\n,\n \n139328704\n,\n\n    \n139460032\n,\n \n139590208\n,\n \n139721024\n,\n \n139852864\n,\n \n139984576\n,\n \n140115776\n,\n\n    \n140245696\n,\n \n140376512\n,\n \n140508352\n,\n \n140640064\n,\n \n140769856\n,\n \n140902336\n,\n\n    \n141032768\n,\n \n141162688\n,\n \n141294016\n,\n \n141426496\n,\n \n141556544\n,\n \n141687488\n,\n\n    \n141819584\n,\n \n141949888\n,\n \n142080448\n,\n \n142212544\n,\n \n142342336\n,\n \n142474432\n,\n\n    \n142606144\n,\n \n142736192\n,\n \n142868288\n,\n \n142997824\n,\n \n143129408\n,\n \n143258944\n,\n\n    \n143392448\n,\n \n143523136\n,\n \n143653696\n,\n \n143785024\n,\n \n143916992\n,\n \n144045632\n,\n\n    \n144177856\n,\n \n144309184\n,\n \n144440768\n,\n \n144570688\n,\n \n144701888\n,\n \n144832448\n,\n\n    \n144965056\n,\n \n145096384\n,\n \n145227584\n,\n \n145358656\n,\n \n145489856\n,\n \n145620928\n,\n\n    \n145751488\n,\n \n145883072\n,\n \n146011456\n,\n \n146144704\n,\n \n146275264\n,\n \n146407232\n,\n\n    \n146538176\n,\n \n146668736\n,\n \n146800448\n,\n \n146931392\n,\n \n147062336\n,\n \n147193664\n,\n\n    \n147324224\n,\n \n147455936\n,\n \n147586624\n,\n \n147717056\n,\n \n147848768\n,\n \n147979456\n,\n\n    \n148110784\n,\n \n148242368\n,\n \n148373312\n,\n \n148503232\n,\n \n148635584\n,\n \n148766144\n,\n\n    \n148897088\n,\n \n149028416\n,\n \n149159488\n,\n \n149290688\n,\n \n149420224\n,\n \n149551552\n,\n\n    \n149683136\n,\n \n149814976\n,\n \n149943616\n,\n \n150076352\n,\n \n150208064\n,\n \n150338624\n,\n\n    \n150470464\n,\n \n150600256\n,\n \n150732224\n,\n \n150862784\n,\n \n150993088\n,\n \n151125952\n,\n\n    \n151254976\n,\n \n151388096\n,\n \n151519168\n,\n \n151649728\n,\n \n151778752\n,\n \n151911104\n,\n\n    \n152042944\n,\n \n152174144\n,\n \n152304704\n,\n \n152435648\n,\n \n152567488\n,\n \n152698816\n,\n\n    \n152828992\n,\n \n152960576\n,\n \n153091648\n,\n \n153222976\n,\n \n153353792\n,\n \n153484096\n,\n\n    \n153616192\n,\n \n153747008\n,\n \n153878336\n,\n \n154008256\n,\n \n154139968\n,\n \n154270912\n,\n\n    \n154402624\n,\n \n154533824\n,\n \n154663616\n,\n \n154795712\n,\n \n154926272\n,\n \n155057984\n,\n\n    \n155188928\n,\n \n155319872\n,\n \n155450816\n,\n \n155580608\n,\n \n155712064\n,\n \n155843392\n,\n\n    \n155971136\n,\n \n156106688\n,\n \n156237376\n,\n \n156367424\n,\n \n156499264\n,\n \n156630976\n,\n\n    \n156761536\n,\n \n156892352\n,\n \n157024064\n,\n \n157155008\n,\n \n157284416\n,\n \n157415872\n,\n\n    \n157545536\n,\n \n157677248\n,\n \n157810496\n,\n \n157938112\n,\n \n158071744\n,\n \n158203328\n,\n\n    \n158334656\n,\n \n158464832\n,\n \n158596288\n,\n \n158727616\n,\n \n158858048\n,\n \n158988992\n,\n\n    \n159121216\n,\n \n159252416\n,\n \n159381568\n,\n \n159513152\n,\n \n159645632\n,\n \n159776192\n,\n\n    \n159906496\n,\n \n160038464\n,\n \n160169536\n,\n \n160300352\n,\n \n160430656\n,\n \n160563008\n,\n\n    \n160693952\n,\n \n160822208\n,\n \n160956352\n,\n \n161086784\n,\n \n161217344\n,\n \n161349184\n,\n\n    \n161480512\n,\n \n161611456\n,\n \n161742272\n,\n \n161873216\n,\n \n162002752\n,\n \n162135872\n,\n\n    \n162266432\n,\n \n162397888\n,\n \n162529216\n,\n \n162660032\n,\n \n162790976\n,\n \n162922048\n,\n\n    \n163052096\n,\n \n163184576\n,\n \n163314752\n,\n \n163446592\n,\n \n163577408\n,\n \n163707968\n,\n\n    \n163839296\n,\n \n163969984\n,\n \n164100928\n,\n \n164233024\n,\n \n164364224\n,\n \n164494912\n,\n\n    \n164625856\n,\n \n164756672\n,\n \n164887616\n,\n \n165019072\n,\n \n165150016\n,\n \n165280064\n,\n\n    \n165412672\n,\n \n165543104\n,\n \n165674944\n,\n \n165805888\n,\n \n165936832\n,\n \n166067648\n,\n\n    \n166198336\n,\n \n166330048\n,\n \n166461248\n,\n \n166591552\n,\n \n166722496\n,\n \n166854208\n,\n\n    \n166985408\n,\n \n167116736\n,\n \n167246656\n,\n \n167378368\n,\n \n167508416\n,\n \n167641024\n,\n\n    \n167771584\n,\n \n167903168\n,\n \n168034112\n,\n \n168164032\n,\n \n168295744\n,\n \n168427456\n,\n\n    \n168557632\n,\n \n168688448\n,\n \n168819136\n,\n \n168951616\n,\n \n169082176\n,\n \n169213504\n,\n\n    \n169344832\n,\n \n169475648\n,\n \n169605952\n,\n \n169738048\n,\n \n169866304\n,\n \n169999552\n,\n\n    \n170131264\n,\n \n170262464\n,\n \n170393536\n,\n \n170524352\n,\n \n170655424\n,\n \n170782016\n,\n\n    \n170917696\n,\n \n171048896\n,\n \n171179072\n,\n \n171310784\n,\n \n171439936\n,\n \n171573184\n,\n\n    \n171702976\n,\n \n171835072\n,\n \n171966272\n,\n \n172097216\n,\n \n172228288\n,\n \n172359232\n,\n\n    \n172489664\n,\n \n172621376\n,\n \n172747712\n,\n \n172883264\n,\n \n173014208\n,\n \n173144512\n,\n\n    \n173275072\n,\n \n173407424\n,\n \n173539136\n,\n \n173669696\n,\n \n173800768\n,\n \n173931712\n,\n\n    \n174063424\n,\n \n174193472\n,\n \n174325696\n,\n \n174455744\n,\n \n174586816\n,\n \n174718912\n,\n\n    \n174849728\n,\n \n174977728\n,\n \n175109696\n,\n \n175242688\n,\n \n175374272\n,\n \n175504832\n,\n\n    \n175636288\n,\n \n175765696\n,\n \n175898432\n,\n \n176028992\n,\n \n176159936\n,\n \n176291264\n,\n\n    \n176422592\n,\n \n176552512\n,\n \n176684864\n,\n \n176815424\n,\n \n176946496\n,\n \n177076544\n,\n\n    \n177209152\n,\n \n177340096\n,\n \n177470528\n,\n \n177600704\n,\n \n177731648\n,\n \n177864256\n,\n\n    \n177994816\n,\n \n178126528\n,\n \n178257472\n,\n \n178387648\n,\n \n178518464\n,\n \n178650176\n,\n\n    \n178781888\n,\n \n178912064\n,\n \n179044288\n,\n \n179174848\n,\n \n179305024\n,\n \n179436736\n,\n\n    \n179568448\n,\n \n179698496\n,\n \n179830208\n,\n \n179960512\n,\n \n180092608\n,\n \n180223808\n,\n\n    \n180354752\n,\n \n180485696\n,\n \n180617152\n,\n \n180748096\n,\n \n180877504\n,\n \n181009984\n,\n\n    \n181139264\n,\n \n181272512\n,\n \n181402688\n,\n \n181532608\n,\n \n181663168\n,\n \n181795136\n,\n\n    \n181926592\n,\n \n182057536\n,\n \n182190016\n,\n \n182320192\n,\n \n182451904\n,\n \n182582336\n,\n\n    \n182713792\n,\n \n182843072\n,\n \n182976064\n,\n \n183107264\n,\n \n183237056\n,\n \n183368384\n,\n\n    \n183494848\n,\n \n183631424\n,\n \n183762752\n,\n \n183893824\n,\n \n184024768\n,\n \n184154816\n,\n\n    \n184286656\n,\n \n184417984\n,\n \n184548928\n,\n \n184680128\n,\n \n184810816\n,\n \n184941248\n,\n\n    \n185072704\n,\n \n185203904\n,\n \n185335616\n,\n \n185465408\n,\n \n185596352\n,\n \n185727296\n,\n\n    \n185859904\n,\n \n185989696\n,\n \n186121664\n,\n \n186252992\n,\n \n186383552\n,\n \n186514112\n,\n\n    \n186645952\n,\n \n186777152\n,\n \n186907328\n,\n \n187037504\n,\n \n187170112\n,\n \n187301824\n,\n\n    \n187429184\n,\n \n187562048\n,\n \n187693504\n,\n \n187825472\n,\n \n187957184\n,\n \n188087104\n,\n\n    \n188218304\n,\n \n188349376\n,\n \n188481344\n,\n \n188609728\n,\n \n188743616\n,\n \n188874304\n,\n\n    \n189005248\n,\n \n189136448\n,\n \n189265088\n,\n \n189396544\n,\n \n189528128\n,\n \n189660992\n,\n\n    \n189791936\n,\n \n189923264\n,\n \n190054208\n,\n \n190182848\n,\n \n190315072\n,\n \n190447424\n,\n\n    \n190577984\n,\n \n190709312\n,\n \n190840768\n,\n \n190971328\n,\n \n191102656\n,\n \n191233472\n,\n\n    \n191364032\n,\n \n191495872\n,\n \n191626816\n,\n \n191758016\n,\n \n191888192\n,\n \n192020288\n,\n\n    \n192148928\n,\n \n192282176\n,\n \n192413504\n,\n \n192542528\n,\n \n192674752\n,\n \n192805952\n,\n\n    \n192937792\n,\n \n193068608\n,\n \n193198912\n,\n \n193330496\n,\n \n193462208\n,\n \n193592384\n,\n\n    \n193723456\n,\n \n193854272\n,\n \n193985984\n,\n \n194116672\n,\n \n194247232\n,\n \n194379712\n,\n\n    \n194508352\n,\n \n194641856\n,\n \n194772544\n,\n \n194900672\n,\n \n195035072\n,\n \n195166016\n,\n\n    \n195296704\n,\n \n195428032\n,\n \n195558592\n,\n \n195690304\n,\n \n195818176\n,\n \n195952576\n,\n\n    \n196083392\n,\n \n196214336\n,\n \n196345792\n,\n \n196476736\n,\n \n196607552\n,\n \n196739008\n,\n\n    \n196869952\n,\n \n197000768\n,\n \n197130688\n,\n \n197262784\n,\n \n197394368\n,\n \n197523904\n,\n\n    \n197656384\n,\n \n197787584\n,\n \n197916608\n,\n \n198049472\n,\n \n198180544\n,\n \n198310208\n,\n\n    \n198442432\n,\n \n198573632\n,\n \n198705088\n,\n \n198834368\n,\n \n198967232\n,\n \n199097792\n,\n\n    \n199228352\n,\n \n199360192\n,\n \n199491392\n,\n \n199621696\n,\n \n199751744\n,\n \n199883968\n,\n\n    \n200014016\n,\n \n200146624\n,\n \n200276672\n,\n \n200408128\n,\n \n200540096\n,\n \n200671168\n,\n\n    \n200801984\n,\n \n200933312\n,\n \n201062464\n,\n \n201194944\n,\n \n201326144\n,\n \n201457472\n,\n\n    \n201588544\n,\n \n201719744\n,\n \n201850816\n,\n \n201981632\n,\n \n202111552\n,\n \n202244032\n,\n\n    \n202374464\n,\n \n202505152\n,\n \n202636352\n,\n \n202767808\n,\n \n202898368\n,\n \n203030336\n,\n\n    \n203159872\n,\n \n203292608\n,\n \n203423296\n,\n \n203553472\n,\n \n203685824\n,\n \n203816896\n,\n\n    \n203947712\n,\n \n204078272\n,\n \n204208192\n,\n \n204341056\n,\n \n204472256\n,\n \n204603328\n,\n\n    \n204733888\n,\n \n204864448\n,\n \n204996544\n,\n \n205125568\n,\n \n205258304\n,\n \n205388864\n,\n\n    \n205517632\n,\n \n205650112\n,\n \n205782208\n,\n \n205913536\n,\n \n206044736\n,\n \n206176192\n,\n\n    \n206307008\n,\n \n206434496\n,\n \n206569024\n,\n \n206700224\n,\n \n206831168\n,\n \n206961856\n,\n\n    \n207093056\n,\n \n207223616\n,\n \n207355328\n,\n \n207486784\n,\n \n207616832\n,\n \n207749056\n,\n\n    \n207879104\n,\n \n208010048\n,\n \n208141888\n,\n \n208273216\n,\n \n208404032\n,\n \n208534336\n,\n\n    \n208666048\n,\n \n208796864\n,\n \n208927424\n,\n \n209059264\n,\n \n209189824\n,\n \n209321792\n,\n\n    \n209451584\n,\n \n209582656\n,\n \n209715136\n,\n \n209845568\n,\n \n209976896\n,\n \n210106432\n,\n\n    \n210239296\n,\n \n210370112\n,\n \n210501568\n,\n \n210630976\n,\n \n210763712\n,\n \n210894272\n,\n\n    \n211024832\n,\n \n211156672\n,\n \n211287616\n,\n \n211418176\n,\n \n211549376\n,\n \n211679296\n,\n\n    \n211812032\n,\n \n211942592\n,\n \n212074432\n,\n \n212204864\n,\n \n212334016\n,\n \n212467648\n,\n\n    \n212597824\n,\n \n212727616\n,\n \n212860352\n,\n \n212991424\n,\n \n213120832\n,\n \n213253952\n,\n\n    \n213385024\n,\n \n213515584\n,\n \n213645632\n,\n \n213777728\n,\n \n213909184\n,\n \n214040128\n,\n\n    \n214170688\n,\n \n214302656\n,\n \n214433728\n,\n \n214564544\n,\n \n214695232\n,\n \n214826048\n,\n\n    \n214956992\n,\n \n215089088\n,\n \n215219776\n,\n \n215350592\n,\n \n215482304\n,\n \n215613248\n,\n\n    \n215743552\n,\n \n215874752\n,\n \n216005312\n,\n \n216137024\n,\n \n216267328\n,\n \n216399296\n,\n\n    \n216530752\n,\n \n216661696\n,\n \n216790592\n,\n \n216923968\n,\n \n217054528\n,\n \n217183168\n,\n\n    \n217316672\n,\n \n217448128\n,\n \n217579072\n,\n \n217709504\n,\n \n217838912\n,\n \n217972672\n,\n\n    \n218102848\n,\n \n218233024\n,\n \n218364736\n,\n \n218496832\n,\n \n218627776\n,\n \n218759104\n,\n\n    \n218888896\n,\n \n219021248\n,\n \n219151936\n,\n \n219281728\n,\n \n219413056\n,\n \n219545024\n,\n\n    \n219675968\n,\n \n219807296\n,\n \n219938624\n,\n \n220069312\n,\n \n220200128\n,\n \n220331456\n,\n\n    \n220461632\n,\n \n220592704\n,\n \n220725184\n,\n \n220855744\n,\n \n220987072\n,\n \n221117888\n,\n\n    \n221249216\n,\n \n221378368\n,\n \n221510336\n,\n \n221642048\n,\n \n221772736\n,\n \n221904832\n,\n\n    \n222031808\n,\n \n222166976\n,\n \n222297536\n,\n \n222428992\n,\n \n222559936\n,\n \n222690368\n,\n\n    \n222820672\n,\n \n222953152\n,\n \n223083968\n,\n \n223213376\n,\n \n223345984\n,\n \n223476928\n,\n\n    \n223608512\n,\n \n223738688\n,\n \n223869376\n,\n \n224001472\n,\n \n224132672\n,\n \n224262848\n,\n\n    \n224394944\n,\n \n224524864\n,\n \n224657344\n,\n \n224788288\n,\n \n224919488\n,\n \n225050432\n,\n\n    \n225181504\n,\n \n225312704\n,\n \n225443776\n,\n \n225574592\n,\n \n225704768\n,\n \n225834176\n,\n\n    \n225966784\n,\n \n226097216\n,\n \n226229824\n,\n \n226360384\n,\n \n226491712\n,\n \n226623424\n,\n\n    \n226754368\n,\n \n226885312\n,\n \n227015104\n,\n \n227147456\n,\n \n227278528\n,\n \n227409472\n,\n\n    \n227539904\n,\n \n227669696\n,\n \n227802944\n,\n \n227932352\n,\n \n228065216\n,\n \n228196288\n,\n\n    \n228326464\n,\n \n228457792\n,\n \n228588736\n,\n \n228720064\n,\n \n228850112\n,\n \n228981056\n,\n\n    \n229113152\n,\n \n229243328\n,\n \n229375936\n,\n \n229505344\n,\n \n229636928\n,\n \n229769152\n,\n\n    \n229894976\n,\n \n230030272\n,\n \n230162368\n,\n \n230292416\n,\n \n230424512\n,\n \n230553152\n,\n\n    \n230684864\n,\n \n230816704\n,\n \n230948416\n,\n \n231079616\n,\n \n231210944\n,\n \n231342016\n,\n\n    \n231472448\n,\n \n231603776\n,\n \n231733952\n,\n \n231866176\n,\n \n231996736\n,\n \n232127296\n,\n\n    \n232259392\n,\n \n232388672\n,\n \n232521664\n,\n \n232652608\n,\n \n232782272\n,\n \n232914496\n,\n\n    \n233043904\n,\n \n233175616\n,\n \n233306816\n,\n \n233438528\n,\n \n233569984\n,\n \n233699776\n,\n\n    \n233830592\n,\n \n233962688\n,\n \n234092224\n,\n \n234221888\n,\n \n234353984\n,\n \n234485312\n,\n\n    \n234618304\n,\n \n234749888\n,\n \n234880832\n,\n \n235011776\n,\n \n235142464\n,\n \n235274048\n,\n\n    \n235403456\n,\n \n235535936\n,\n \n235667392\n,\n \n235797568\n,\n \n235928768\n,\n \n236057152\n,\n\n    \n236190272\n,\n \n236322752\n,\n \n236453312\n,\n \n236583616\n,\n \n236715712\n,\n \n236846528\n,\n\n    \n236976448\n,\n \n237108544\n,\n \n237239104\n,\n \n237371072\n,\n \n237501632\n,\n \n237630784\n,\n\n    \n237764416\n,\n \n237895232\n,\n \n238026688\n,\n \n238157632\n,\n \n238286912\n,\n \n238419392\n,\n\n    \n238548032\n,\n \n238681024\n,\n \n238812608\n,\n \n238941632\n,\n \n239075008\n,\n \n239206336\n,\n\n    \n239335232\n,\n \n239466944\n,\n \n239599168\n,\n \n239730496\n,\n \n239861312\n,\n \n239992384\n,\n\n    \n240122816\n,\n \n240254656\n,\n \n240385856\n,\n \n240516928\n,\n \n240647872\n,\n \n240779072\n,\n\n    \n240909632\n,\n \n241040704\n,\n \n241171904\n,\n \n241302848\n,\n \n241433408\n,\n \n241565248\n,\n\n    \n241696192\n,\n \n241825984\n,\n \n241958848\n,\n \n242088256\n,\n \n242220224\n,\n \n242352064\n,\n\n    \n242481856\n,\n \n242611648\n,\n \n242744896\n,\n \n242876224\n,\n \n243005632\n,\n \n243138496\n,\n\n    \n243268672\n,\n \n243400384\n,\n \n243531712\n,\n \n243662656\n,\n \n243793856\n,\n \n243924544\n,\n\n    \n244054592\n,\n \n244187072\n,\n \n244316608\n,\n \n244448704\n,\n \n244580032\n,\n \n244710976\n,\n\n    \n244841536\n,\n \n244972864\n,\n \n245104448\n,\n \n245233984\n,\n \n245365312\n,\n \n245497792\n,\n\n    \n245628736\n,\n \n245759936\n,\n \n245889856\n,\n \n246021056\n,\n \n246152512\n,\n \n246284224\n,\n\n    \n246415168\n,\n \n246545344\n,\n \n246675904\n,\n \n246808384\n,\n \n246939584\n,\n \n247070144\n,\n\n    \n247199552\n,\n \n247331648\n,\n \n247463872\n,\n \n247593536\n,\n \n247726016\n,\n \n247857088\n,\n\n    \n247987648\n,\n \n248116928\n,\n \n248249536\n,\n \n248380736\n,\n \n248512064\n,\n \n248643008\n,\n\n    \n248773312\n,\n \n248901056\n,\n \n249036608\n,\n \n249167552\n,\n \n249298624\n,\n \n249429184\n,\n\n    \n249560512\n,\n \n249692096\n,\n \n249822784\n,\n \n249954112\n,\n \n250085312\n,\n \n250215488\n,\n\n    \n250345792\n,\n \n250478528\n,\n \n250608704\n,\n \n250739264\n,\n \n250870976\n,\n \n251002816\n,\n\n    \n251133632\n,\n \n251263552\n,\n \n251395136\n,\n \n251523904\n,\n \n251657792\n,\n \n251789248\n,\n\n    \n251919424\n,\n \n252051392\n,\n \n252182464\n,\n \n252313408\n,\n \n252444224\n,\n \n252575552\n,\n\n    \n252706624\n,\n \n252836032\n,\n \n252968512\n,\n \n253099712\n,\n \n253227584\n,\n \n253361728\n,\n\n    \n253493056\n,\n \n253623488\n,\n \n253754432\n,\n \n253885504\n,\n \n254017216\n,\n \n254148032\n,\n\n    \n254279488\n,\n \n254410432\n,\n \n254541376\n,\n \n254672576\n,\n \n254803264\n,\n \n254933824\n,\n\n    \n255065792\n,\n \n255196736\n,\n \n255326528\n,\n \n255458752\n,\n \n255589952\n,\n \n255721408\n,\n\n    \n255851072\n,\n \n255983296\n,\n \n256114624\n,\n \n256244416\n,\n \n256374208\n,\n \n256507712\n,\n\n    \n256636096\n,\n \n256768832\n,\n \n256900544\n,\n \n257031616\n,\n \n257162176\n,\n \n257294272\n,\n\n    \n257424448\n,\n \n257555776\n,\n \n257686976\n,\n \n257818432\n,\n \n257949632\n,\n \n258079552\n,\n\n    \n258211136\n,\n \n258342464\n,\n \n258473408\n,\n \n258603712\n,\n \n258734656\n,\n \n258867008\n,\n\n    \n258996544\n,\n \n259127744\n,\n \n259260224\n,\n \n259391296\n,\n \n259522112\n,\n \n259651904\n,\n\n    \n259784384\n,\n \n259915328\n,\n \n260045888\n,\n \n260175424\n,\n \n260308544\n,\n \n260438336\n,\n\n    \n260570944\n,\n \n260700992\n,\n \n260832448\n,\n \n260963776\n,\n \n261092672\n,\n \n261226304\n,\n\n    \n261356864\n,\n \n261487936\n,\n \n261619648\n,\n \n261750592\n,\n \n261879872\n,\n \n262011968\n,\n\n    \n262143424\n,\n \n262274752\n,\n \n262404416\n,\n \n262537024\n,\n \n262667968\n,\n \n262799296\n,\n\n    \n262928704\n,\n \n263061184\n,\n \n263191744\n,\n \n263322944\n,\n \n263454656\n,\n \n263585216\n,\n\n    \n263716672\n,\n \n263847872\n,\n \n263978944\n,\n \n264108608\n,\n \n264241088\n,\n \n264371648\n,\n\n    \n264501184\n,\n \n264632768\n,\n \n264764096\n,\n \n264895936\n,\n \n265024576\n,\n \n265158464\n,\n\n    \n265287488\n,\n \n265418432\n,\n \n265550528\n,\n \n265681216\n,\n \n265813312\n,\n \n265943488\n,\n\n    \n266075968\n,\n \n266206144\n,\n \n266337728\n,\n \n266468032\n,\n \n266600384\n,\n \n266731072\n,\n\n    \n266862272\n,\n \n266993344\n,\n \n267124288\n,\n \n267255616\n,\n \n267386432\n,\n \n267516992\n,\n\n    \n267648704\n,\n \n267777728\n,\n \n267910592\n,\n \n268040512\n,\n \n268172096\n,\n \n268302784\n,\n\n    \n268435264\n,\n \n268566208\n,\n \n268696256\n,\n \n268828096\n,\n \n268959296\n,\n \n269090368\n,\n\n    \n269221312\n,\n \n269352256\n,\n \n269482688\n,\n \n269614784\n,\n \n269745856\n,\n \n269876416\n,\n\n    \n270007616\n,\n \n270139328\n,\n \n270270272\n,\n \n270401216\n,\n \n270531904\n,\n \n270663616\n,\n\n    \n270791744\n,\n \n270924736\n,\n \n271056832\n,\n \n271186112\n,\n \n271317184\n,\n \n271449536\n,\n\n    \n271580992\n,\n \n271711936\n,\n \n271843136\n,\n \n271973056\n,\n \n272105408\n,\n \n272236352\n,\n\n    \n272367296\n,\n \n272498368\n,\n \n272629568\n,\n \n272759488\n,\n \n272891456\n,\n \n273022784\n,\n\n    \n273153856\n,\n \n273284672\n,\n \n273415616\n,\n \n273547072\n,\n \n273677632\n,\n \n273808448\n,\n\n    \n273937088\n,\n \n274071488\n,\n \n274200896\n,\n \n274332992\n,\n \n274463296\n,\n \n274595392\n,\n\n    \n274726208\n,\n \n274857536\n,\n \n274988992\n,\n \n275118656\n,\n \n275250496\n,\n \n275382208\n,\n\n    \n275513024\n,\n \n275643968\n,\n \n275775296\n,\n \n275906368\n,\n \n276037184\n,\n \n276167872\n,\n\n    \n276297664\n,\n \n276429376\n,\n \n276560576\n,\n \n276692672\n,\n \n276822976\n,\n \n276955072\n,\n\n    \n277085632\n,\n \n277216832\n,\n \n277347008\n,\n \n277478848\n,\n \n277609664\n,\n \n277740992\n,\n\n    \n277868608\n,\n \n278002624\n,\n \n278134336\n,\n \n278265536\n,\n \n278395328\n,\n \n278526784\n,\n\n    \n278657728\n,\n \n278789824\n,\n \n278921152\n,\n \n279052096\n,\n \n279182912\n,\n \n279313088\n,\n\n    \n279443776\n,\n \n279576256\n,\n \n279706048\n,\n \n279838528\n,\n \n279969728\n,\n \n280099648\n,\n\n    \n280230976\n,\n \n280361408\n,\n \n280493632\n,\n \n280622528\n,\n \n280755392\n,\n \n280887104\n,\n\n    \n281018176\n,\n \n281147968\n,\n \n281278912\n,\n \n281411392\n,\n \n281542592\n,\n \n281673152\n,\n\n    \n281803712\n,\n \n281935552\n,\n \n282066496\n,\n \n282197312\n,\n \n282329024\n,\n \n282458816\n,\n\n    \n282590272\n,\n \n282720832\n,\n \n282853184\n,\n \n282983744\n,\n \n283115072\n,\n \n283246144\n,\n\n    \n283377344\n,\n \n283508416\n,\n \n283639744\n,\n \n283770304\n,\n \n283901504\n,\n \n284032576\n,\n\n    \n284163136\n,\n \n284294848\n,\n \n284426176\n,\n \n284556992\n,\n \n284687296\n,\n \n284819264\n,\n\n    \n284950208\n,\n \n285081536\n\n\n]", 
            "title": "Ethash"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#ethash", 
            "text": "This spec is REVISION 23. Whenever you substantively (ie. not clarifications) update the algorithm, please update the revision number in this sentence. Also, in all implementations please include a spec revision number  Ethash is the planned PoW algorithm for Ethereum 1.0. It is the latest version of Dagger-Hashimoto, although it can no longer appropriately be called that since many of the original features of both algorithms have been drastically changed in the last month of research and development. See  https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md  for the original version.  \u7b97\u6cd5\u6240\u91c7\u7528\u7684\u4e00\u822c\u8def\u7ebf\u5982\u4e0b\uff1a   There exists a  seed  which can be computed for each block by scanning through the block headers up until that point.  From the seed, one can compute a  16 MB pseudorandom cache . Light clients store the cache.  From the cache, we can generate a  1 GB dataset , with the property that each item in the dataset depends on only a small number of items from the cache. Full clients and miners store the dataset.  The dataset grows linearly with time.  Mining involves grabbing random slices of the dataset and hashing them together. Verification can be done with low memory by using the cache to regenerate the specific pieces of the dataset that you need, so you only need to store the cache.   The large dataset is updated once every 30000 blocks, so the vast majority of a miner's effort will be reading the dataset, not making changes to it.  See  https://github.com/ethereum/wiki/wiki/Ethash-Design-Rationale  for design rationale considerations for this algorithm.", 
            "title": "Ethash"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_1", 
            "text": "\u6211\u4eec\u91c7\u7528\u4ee5\u4e0b\u5b9a\u4e49:  WORD_BYTES = 4                    # bytes in word\nDATASET_BYTES_INIT = 2**30        # bytes in dataset at genesis\nDATASET_BYTES_GROWTH = 2**23      # dataset growth per epoch\nCACHE_BYTES_INIT = 2**24          # bytes in cache at genesis\nCACHE_BYTES_GROWTH = 2**17        # cache growth per epoch\nCACHE_MULTIPLIER=1024             # Size of the DAG relative to the cache\nEPOCH_LENGTH = 30000              # blocks per epoch\nMIX_BYTES = 128                   # width of mix\nHASH_BYTES = 64                   # hash length in bytes\nDATASET_PARENTS = 256             # number of parents of each dataset element\nCACHE_ROUNDS = 3                  # number of rounds in cache production\nACCESSES = 64                     # number of accesses in hashimoto loop", 
            "title": "\u5b9a\u4e49"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#a-note-regarding-sha3-hashes-described-in-this-specification", 
            "text": "Ethereum's development coincided with the development of the SHA3 standard, and the\nstandards process made a late change in the padding of the finalized hash algorithm, so that Ethereum's\n\"sha3_256\" and \"sha3_512\" hashes are not standard sha3 hashes, but a variant often referred\nto as \"Keccak-256\" and \"Keccak-512\" in other contexts. See discussion, e.g.  here ,  here , or  here .  Please keep that in mind as \"sha3\" hashes are referred to in the description of the algorithm below.", 
            "title": "A note regarding \"SHA3\" hashes described in this specification"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_2", 
            "text": "The parameters for Ethash's cache and dataset depend on the block number. The cache size and dataset size both grow linearly; however, we always take the highest prime below the linearly growing threshold in order to reduce the risk of accidental regularities leading to cyclic behavior.  def   get_cache_size ( block_number ): \n     sz   =   CACHE_BYTES_INIT   +   CACHE_BYTES_GROWTH   *   ( block_number   //   EPOCH_LENGTH ) \n     sz   -=   HASH_BYTES \n     while   not   isprime ( sz   /   HASH_BYTES ): \n         sz   -=   2   *   HASH_BYTES \n     return   sz  def   get_full_size ( block_number ): \n     sz   =   DATASET_BYTES_INIT   +   DATASET_BYTES_GROWTH   *   ( block_number   //   EPOCH_LENGTH ) \n     sz   -=   MIX_BYTES \n     while   not   isprime ( sz   /   MIX_BYTES ): \n         sz   -=   2   *   MIX_BYTES \n     return   sz   Tables of dataset and cache size values are provided in the appendix.", 
            "title": "\u53c2\u6570"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_3", 
            "text": "Now, we specify the function for producing a cache:  def   mkcache ( cache_size ,   seed ): \n     n   =   cache_size   //   HASH_BYTES \n\n     # Sequentially produce the initial dataset \n     o   =   [ sha3_512 ( seed )] \n     for   i   in   range ( 1 ,   n ): \n         o . append ( sha3_512 ( o [ - 1 ])) \n\n     # Use a low-round version of randmemohash \n     for   _   in   range ( CACHE_ROUNDS ): \n         for   i   in   range ( n ): \n             v   =   o [ i ][ 0 ]   %   n \n             o [ i ]   =   sha3_512 ( map ( xor ,   o [( i - 1 + n )   %   n ],   o [ v ])) \n\n     return   o   The cache production process involves first sequentially filling up 32 MB of memory, then performing two passes of Sergio Demian Lerner's  RandMemoHash  algorithm from  Strict Memory Hard Hashing Functions  (2014) . The output is a set of 524288 64-byte values.", 
            "title": "\u7f13\u5b58\u4e00\u4ee3"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_4", 
            "text": "We use an algorithm inspired by the  FNV hash  in some cases as a non-associative substitute for XOR. Note that we multiply the prime with the full 32-bit input, in contrast with the FNV-1 spec which multiplies the prime with one byte (octet) in turn.  FNV_PRIME   =   0x01000193  def   fnv ( v1 ,   v2 ): \n     return   (( v1   *   FNV_PRIME )   ^   v2 )   %   2 ** 32   Please note, even the yellow paper specifies fnv as v1*(FNV_PRIME ^ v2), all current implementations consistently use the above definition.", 
            "title": "\u6570\u636e\u805a\u5408\u51fd\u6570"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_5", 
            "text": "Each 64-byte item in the full 1 GB dataset is computed as follows:  def   calc_dataset_item ( cache ,   i ): \n     n   =   len ( cache ) \n     r   =   HASH_BYTES   //   WORD_BYTES \n     # initialize the mix \n     mix   =   copy . copy ( cache [ i   %   n ]) \n     mix [ 0 ]   ^=   i \n     mix   =   sha3_512 ( mix ) \n     # fnv it with a lot of random cache nodes based on i \n     for   j   in   range ( DATASET_PARENTS ): \n         cache_index   =   fnv ( i   ^   j ,   mix [ j   %   r ]) \n         mix   =   map ( fnv ,   mix ,   cache [ cache_index   %   n ]) \n     return   sha3_512 ( mix )   Essentially, we combine data from 256 pseudorandomly selected cache nodes, and hash that to compute the dataset node. The entire dataset is then generated by:  def   calc_dataset ( full_size ,   cache ): \n     return   [ calc_dataset_item ( cache ,   i )   for   i   in   range ( full_size   //   HASH_BYTES )]", 
            "title": "\u5b8c\u6574\u7684\u6570\u636e\u96c6\u8ba1\u7b97"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_6", 
            "text": "Now, we specify the main \"hashimoto\"-like loop, where we aggregate data from the full dataset in order to produce our final value for a particular header and nonce. In the code below,  header  represents the SHA3-256  hash  of the  RLP  representation of a  truncated  block header, that is, of a header excluding the fields  mixHash  and  nonce .  nonce  is the eight bytes of a 64 bit unsigned integer in big-endian order. So  nonce[::-1]  is the eight-byte little-endian representation of that value:  def   hashimoto ( header ,   nonce ,   full_size ,   dataset_lookup ): \n     n   =   full_size   /   HASH_BYTES \n     w   =   MIX_BYTES   //   WORD_BYTES \n     mixhashes   =   MIX_BYTES   /   HASH_BYTES \n     # combine header+nonce into a 64 byte seed \n     s   =   sha3_512 ( header   +   nonce [:: - 1 ]) \n     # start the mix with replicated s \n     mix   =   [] \n     for   _   in   range ( MIX_BYTES   /   HASH_BYTES ): \n         mix . extend ( s ) \n     # mix in random dataset nodes \n     for   i   in   range ( ACCESSES ): \n         p   =   fnv ( i   ^   s [ 0 ],   mix [ i   %   w ])   %   ( n   //   mixhashes )   *   mixhashes \n         newdata   =   [] \n         for   j   in   range ( MIX_BYTES   /   HASH_BYTES ): \n             newdata . extend ( dataset_lookup ( p   +   j )) \n         mix   =   map ( fnv ,   mix ,   newdata ) \n     # compress mix \n     cmix   =   [] \n     for   i   in   range ( 0 ,   len ( mix ),   4 ): \n         cmix . append ( fnv ( fnv ( fnv ( mix [ i ],   mix [ i + 1 ]),   mix [ i + 2 ]),   mix [ i + 3 ])) \n     return   { \n         mix digest :   serialize_hash ( cmix ), \n         result :   serialize_hash ( sha3_256 ( s + cmix )) \n     }  def   hashimoto_light ( full_size ,   cache ,   header ,   nonce ): \n     return   hashimoto ( header ,   nonce ,   full_size ,   lambda   x :   calc_dataset_item ( cache ,   x ))  def   hashimoto_full ( full_size ,   dataset ,   header ,   nonce ): \n     return   hashimoto ( header ,   nonce ,   full_size ,   lambda   x :   dataset [ x ])   Essentially, we maintain a \"mix\" 128 bytes wide, and repeatedly sequentially fetch 128 bytes from the full dataset and use the  fnv  function to combine it with the mix. 128 bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.  If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of  sha3_256  at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes.  It also serves to provide statistical assurance that the result is an unbiased, 256 bit number.", 
            "title": "\u4e3b\u5faa\u73af"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_7", 
            "text": "The mining algorithm is defined as follows:  def   mine ( full_size ,   dataset ,   header ,   difficulty ): \n     target   =   zpad ( encode_int ( 2 ** 256   //   difficulty ),   64 )[:: - 1 ] \n     from   random   import   randint \n     nonce   =   randint ( 0 ,   2 ** 64 ) \n     while   hashimoto_full ( full_size ,   dataset ,   header ,   nonce )     target : \n         nonce   =   ( nonce   +   1 )   %   2 ** 64 \n     return   nonce", 
            "title": "\u6316\u77ff"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_8", 
            "text": "In order to compute the seed hash that would be used to mine on top of a given block, we use the following algorithm:    def   get_seedhash ( block ): \n      s   =   \\x00   *   32 \n      for   i   in   range ( block . number   //   EPOCH_LENGTH ): \n          s   =   serialize_hash ( sha3_256 ( s )) \n      return   s   Note that for smooth mining and verifying, we recommend pre-computing future seedhashes and datasets in a separate thread.", 
            "title": "\u5b9a\u4e49\u79cd\u5b50\u6563\u5217"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_9", 
            "text": "The following code should be prepended if you are interested in running the above python spec as code.  import   sha3 ,   copy  # Assumes little endian bit ordering (same as Intel architectures)  def   decode_int ( s ): \n     return   int ( s [:: - 1 ] . encode ( hex ),   16 )   if   s   else   0  def   encode_int ( s ): \n     a   =   %x   %   s \n     return     if   s   ==   0   else   ( 0   *   ( len ( a )   %   2 )   +   a ) . decode ( hex )[:: - 1 ]  def   zpad ( s ,   length ): \n     return   s   +   \\x00   *   max ( 0 ,   length   -   len ( s ))  def   serialize_hash ( h ): \n     return   . join ([ zpad ( encode_int ( x ),   4 )   for   x   in   h ])  def   deserialize_hash ( h ): \n     return   [ decode_int ( h [ i : i + WORD_BYTES ])   for   i   in   range ( 0 ,   len ( h ),   WORD_BYTES )]  def   hash_words ( h ,   sz ,   x ): \n     if   isinstance ( x ,   list ): \n         x   =   serialize_hash ( x ) \n     y   =   h ( x ) \n     return   deserialize_hash ( y )  def   serialize_cache ( ds ): \n     return   . join ([ serialize_hash ( h )   for   h   in   ds ])  serialize_dataset   =   serialize_cache  # sha3 hash function, outputs 64 bytes  def   sha3_512 ( x ): \n     return   hash_words ( lambda   v :   sha3 . sha3_512 ( v ) . digest (),   64 ,   x )  def   sha3_256 ( x ): \n     return   hash_words ( lambda   v :   sha3 . sha3_256 ( v ) . digest (),   32 ,   x )  def   xor ( a ,   b ): \n     return   a   ^   b  def   isprime ( x ): \n     for   i   in   range ( 2 ,   int ( x ** 0.5 )): \n          if   x   %   i   ==   0 : \n              return   False \n     return   True", 
            "title": "\u9644\u5f55"
        }, 
        {
            "location": "/EthashDashimoto/Ethash/#_10", 
            "text": "The following lookup tables provide approximately 2048 tabulated epochs of data sizes and cache sizes.  They were generated with the  Mathematica  function provided here:  def   get_datasize ( block_number ): \n     return   data_sizes [ block_number   //   EPOCH_LENGTH ]  def   get_cachesize ( block_number ): \n     return   cache_sizes [ block_number   //   EPOCH_LENGTH ]  data_sizes   =   [ \n     1073739904 ,   1082130304 ,   1090514816 ,   1098906752 ,   1107293056 , \n     1115684224 ,   1124070016 ,   1132461952 ,   1140849536 ,   1149232768 , \n     1157627776 ,   1166013824 ,   1174404736 ,   1182786944 ,   1191180416 , \n     1199568512 ,   1207958912 ,   1216345216 ,   1224732032 ,   1233124736 , \n     1241513344 ,   1249902464 ,   1258290304 ,   1266673792 ,   1275067264 , \n     1283453312 ,   1291844992 ,   1300234112 ,   1308619904 ,   1317010048 , \n     1325397376 ,   1333787776 ,   1342176128 ,   1350561664 ,   1358954368 , \n     1367339392 ,   1375731584 ,   1384118144 ,   1392507008 ,   1400897408 , \n     1409284736 ,   1417673344 ,   1426062464 ,   1434451072 ,   1442839168 , \n     1451229056 ,   1459615616 ,   1468006016 ,   1476394112 ,   1484782976 , \n     1493171584 ,   1501559168 ,   1509948032 ,   1518337664 ,   1526726528 , \n     1535114624 ,   1543503488 ,   1551892096 ,   1560278656 ,   1568669056 , \n     1577056384 ,   1585446272 ,   1593831296 ,   1602219392 ,   1610610304 , \n     1619000192 ,   1627386752 ,   1635773824 ,   1644164224 ,   1652555648 , \n     1660943488 ,   1669332608 ,   1677721216 ,   1686109312 ,   1694497664 , \n     1702886272 ,   1711274624 ,   1719661184 ,   1728047744 ,   1736434816 , \n     1744829056 ,   1753218944 ,   1761606272 ,   1769995904 ,   1778382464 , \n     1786772864 ,   1795157888 ,   1803550592 ,   1811937664 ,   1820327552 , \n     1828711552 ,   1837102976 ,   1845488768 ,   1853879936 ,   1862269312 , \n     1870656896 ,   1879048064 ,   1887431552 ,   1895825024 ,   1904212096 , \n     1912601216 ,   1920988544 ,   1929379456 ,   1937765504 ,   1946156672 , \n     1954543232 ,   1962932096 ,   1971321728 ,   1979707264 ,   1988093056 , \n     1996487552 ,   2004874624 ,   2013262208 ,   2021653888 ,   2030039936 , \n     2038430848 ,   2046819968 ,   2055208576 ,   2063596672 ,   2071981952 , \n     2080373632 ,   2088762752 ,   2097149056 ,   2105539712 ,   2113928576 , \n     2122315136 ,   2130700672 ,   2139092608 ,   2147483264 ,   2155872128 , \n     2164257664 ,   2172642176 ,   2181035392 ,   2189426048 ,   2197814912 , \n     2206203008 ,   2214587264 ,   2222979712 ,   2231367808 ,   2239758208 , \n     2248145024 ,   2256527744 ,   2264922752 ,   2273312128 ,   2281701248 , \n     2290086272 ,   2298476672 ,   2306867072 ,   2315251072 ,   2323639168 , \n     2332032128 ,   2340420224 ,   2348808064 ,   2357196416 ,   2365580416 , \n     2373966976 ,   2382363008 ,   2390748544 ,   2399139968 ,   2407530368 , \n     2415918976 ,   2424307328 ,   2432695424 ,   2441084288 ,   2449472384 , \n     2457861248 ,   2466247808 ,   2474637184 ,   2483026816 ,   2491414144 , \n     2499803776 ,   2508191872 ,   2516582272 ,   2524970368 ,   2533359232 , \n     2541743488 ,   2550134144 ,   2558525056 ,   2566913408 ,   2575301504 , \n     2583686528 ,   2592073856 ,   2600467328 ,   2608856192 ,   2617240448 , \n     2625631616 ,   2634022016 ,   2642407552 ,   2650796416 ,   2659188352 , \n     2667574912 ,   2675965312 ,   2684352896 ,   2692738688 ,   2701130624 , \n     2709518464 ,   2717907328 ,   2726293376 ,   2734685056 ,   2743073152 , \n     2751462016 ,   2759851648 ,   2768232832 ,   2776625536 ,   2785017728 , \n     2793401984 ,   2801794432 ,   2810182016 ,   2818571648 ,   2826959488 , \n     2835349376 ,   2843734144 ,   2852121472 ,   2860514432 ,   2868900992 , \n     2877286784 ,   2885676928 ,   2894069632 ,   2902451584 ,   2910843008 , \n     2919234688 ,   2927622784 ,   2936011648 ,   2944400768 ,   2952789376 , \n     2961177728 ,   2969565568 ,   2977951616 ,   2986338944 ,   2994731392 , \n     3003120256 ,   3011508352 ,   3019895936 ,   3028287104 ,   3036675968 , \n     3045063808 ,   3053452928 ,   3061837696 ,   3070228352 ,   3078615424 , \n     3087003776 ,   3095394944 ,   3103782272 ,   3112173184 ,   3120562048 , \n     3128944768 ,   3137339264 ,   3145725056 ,   3154109312 ,   3162505088 , \n     3170893184 ,   3179280256 ,   3187669376 ,   3196056704 ,   3204445568 , \n     3212836736 ,   3221224064 ,   3229612928 ,   3238002304 ,   3246391168 , \n     3254778496 ,   3263165824 ,   3271556224 ,   3279944576 ,   3288332416 , \n     3296719232 ,   3305110912 ,   3313500032 ,   3321887104 ,   3330273152 , \n     3338658944 ,   3347053184 ,   3355440512 ,   3363827072 ,   3372220288 , \n     3380608384 ,   3388997504 ,   3397384576 ,   3405774208 ,   3414163072 , \n     3422551936 ,   3430937984 ,   3439328384 ,   3447714176 ,   3456104576 , \n     3464493952 ,   3472883584 ,   3481268864 ,   3489655168 ,   3498048896 , \n     3506434432 ,   3514826368 ,   3523213952 ,   3531603584 ,   3539987072 , \n     3548380288 ,   3556763264 ,   3565157248 ,   3573545344 ,   3581934464 , \n     3590324096 ,   3598712704 ,   3607098752 ,   3615488384 ,   3623877248 , \n     3632265856 ,   3640646528 ,   3649043584 ,   3657430144 ,   3665821568 , \n     3674207872 ,   3682597504 ,   3690984832 ,   3699367808 ,   3707764352 , \n     3716152448 ,   3724541056 ,   3732925568 ,   3741318016 ,   3749706368 , \n     3758091136 ,   3766481536 ,   3774872704 ,   3783260032 ,   3791650432 , \n     3800036224 ,   3808427648 ,   3816815488 ,   3825204608 ,   3833592704 , \n     3841981568 ,   3850370432 ,   3858755968 ,   3867147904 ,   3875536256 , \n     3883920512 ,   3892313728 ,   3900702592 ,   3909087872 ,   3917478784 , \n     3925868416 ,   3934256512 ,   3942645376 ,   3951032192 ,   3959422336 , \n     3967809152 ,   3976200064 ,   3984588416 ,   3992974976 ,   4001363584 , \n     4009751168 ,   4018141312 ,   4026530432 ,   4034911616 ,   4043308928 , \n     4051695488 ,   4060084352 ,   4068472448 ,   4076862848 ,   4085249408 , \n     4093640576 ,   4102028416 ,   4110413696 ,   4118805632 ,   4127194496 , \n     4135583104 ,   4143971968 ,   4152360832 ,   4160746112 ,   4169135744 , \n     4177525888 ,   4185912704 ,   4194303616 ,   4202691968 ,   4211076736 , \n     4219463552 ,   4227855488 ,   4236246656 ,   4244633728 ,   4253022848 , \n     4261412224 ,   4269799808 ,   4278184832 ,   4286578048 ,   4294962304 , \n     4303349632 ,   4311743104 ,   4320130432 ,   4328521088 ,   4336909184 , \n     4345295488 ,   4353687424 ,   4362073472 ,   4370458496 ,   4378852736 , \n     4387238528 ,   4395630208 ,   4404019072 ,   4412407424 ,   4420790656 , \n     4429182848 ,   4437571456 ,   4445962112 ,   4454344064 ,   4462738048 , \n     4471119232 ,   4479516544 ,   4487904128 ,   4496289664 ,   4504682368 , \n     4513068416 ,   4521459584 ,   4529846144 ,   4538232704 ,   4546619776 , \n     4555010176 ,   4563402112 ,   4571790208 ,   4580174464 ,   4588567936 , \n     4596957056 ,   4605344896 ,   4613734016 ,   4622119808 ,   4630511488 , \n     4638898816 ,   4647287936 ,   4655675264 ,   4664065664 ,   4672451968 , \n     4680842624 ,   4689231488 ,   4697620352 ,   4706007424 ,   4714397056 , \n     4722786176 ,   4731173248 ,   4739562368 ,   4747951744 ,   4756340608 , \n     4764727936 ,   4773114496 ,   4781504384 ,   4789894784 ,   4798283648 , \n     4806667648 ,   4815059584 ,   4823449472 ,   4831835776 ,   4840226176 , \n     4848612224 ,   4857003392 ,   4865391488 ,   4873780096 ,   4882169728 , \n     4890557312 ,   4898946944 ,   4907333248 ,   4915722368 ,   4924110976 , \n     4932499328 ,   4940889728 ,   4949276032 ,   4957666432 ,   4966054784 , \n     4974438016 ,   4982831488 ,   4991221376 ,   4999607168 ,   5007998848 , \n     5016386432 ,   5024763776 ,   5033164672 ,   5041544576 ,   5049941888 , \n     5058329728 ,   5066717056 ,   5075107456 ,   5083494272 ,   5091883904 , \n     5100273536 ,   5108662144 ,   5117048192 ,   5125436032 ,   5133827456 , \n     5142215296 ,   5150605184 ,   5158993024 ,   5167382144 ,   5175769472 , \n     5184157568 ,   5192543872 ,   5200936064 ,   5209324928 ,   5217711232 , \n     5226102656 ,   5234490496 ,   5242877312 ,   5251263872 ,   5259654016 , \n     5268040832 ,   5276434304 ,   5284819328 ,   5293209728 ,   5301598592 , \n     5309986688 ,   5318374784 ,   5326764416 ,   5335151488 ,   5343542144 , \n     5351929472 ,   5360319872 ,   5368706944 ,   5377096576 ,   5385484928 , \n     5393871232 ,   5402263424 ,   5410650496 ,   5419040384 ,   5427426944 , \n     5435816576 ,   5444205952 ,   5452594816 ,   5460981376 ,   5469367936 , \n     5477760896 ,   5486148736 ,   5494536832 ,   5502925952 ,   5511315328 , \n     5519703424 ,   5528089984 ,   5536481152 ,   5544869504 ,   5553256064 , \n     5561645696 ,   5570032768 ,   5578423936 ,   5586811264 ,   5595193216 , \n     5603585408 ,   5611972736 ,   5620366208 ,   5628750464 ,   5637143936 , \n     5645528192 ,   5653921408 ,   5662310272 ,   5670694784 ,   5679082624 , \n     5687474048 ,   5695864448 ,   5704251008 ,   5712641408 ,   5721030272 , \n     5729416832 ,   5737806208 ,   5746194304 ,   5754583936 ,   5762969984 , \n     5771358592 ,   5779748224 ,   5788137856 ,   5796527488 ,   5804911232 , \n     5813300608 ,   5821692544 ,   5830082176 ,   5838468992 ,   5846855552 , \n     5855247488 ,   5863636096 ,   5872024448 ,   5880411008 ,   5888799872 , \n     5897186432 ,   5905576832 ,   5913966976 ,   5922352768 ,   5930744704 , \n     5939132288 ,   5947522432 ,   5955911296 ,   5964299392 ,   5972688256 , \n     5981074304 ,   5989465472 ,   5997851008 ,   6006241408 ,   6014627968 , \n     6023015552 ,   6031408256 ,   6039796096 ,   6048185216 ,   6056574848 , \n     6064963456 ,   6073351808 ,   6081736064 ,   6090128768 ,   6098517632 , \n     6106906496 ,   6115289216 ,   6123680896 ,   6132070016 ,   6140459648 , \n     6148849024 ,   6157237376 ,   6165624704 ,   6174009728 ,   6182403712 , \n     6190792064 ,   6199176064 ,   6207569792 ,   6215952256 ,   6224345216 , \n     6232732544 ,   6241124224 ,   6249510272 ,   6257899136 ,   6266287744 , \n     6274676864 ,   6283065728 ,   6291454336 ,   6299843456 ,   6308232064 , \n     6316620928 ,   6325006208 ,   6333395584 ,   6341784704 ,   6350174848 , \n     6358562176 ,   6366951296 ,   6375337856 ,   6383729536 ,   6392119168 , \n     6400504192 ,   6408895616 ,   6417283456 ,   6425673344 ,   6434059136 , \n     6442444672 ,   6450837376 ,   6459223424 ,   6467613056 ,   6476004224 , \n     6484393088 ,   6492781952 ,   6501170048 ,   6509555072 ,   6517947008 , \n     6526336384 ,   6534725504 ,   6543112832 ,   6551500672 ,   6559888768 , \n     6568278656 ,   6576662912 ,   6585055616 ,   6593443456 ,   6601834112 , \n     6610219648 ,   6618610304 ,   6626999168 ,   6635385472 ,   6643777408 , \n     6652164224 ,   6660552832 ,   6668941952 ,   6677330048 ,   6685719424 , \n     6694107776 ,   6702493568 ,   6710882176 ,   6719274112 ,   6727662976 , \n     6736052096 ,   6744437632 ,   6752825984 ,   6761213824 ,   6769604224 , \n     6777993856 ,   6786383488 ,   6794770816 ,   6803158144 ,   6811549312 , \n     6819937664 ,   6828326528 ,   6836706176 ,   6845101696 ,   6853491328 , \n     6861880448 ,   6870269312 ,   6878655104 ,   6887046272 ,   6895433344 , \n     6903822208 ,   6912212864 ,   6920596864 ,   6928988288 ,   6937377152 , \n     6945764992 ,   6954149248 ,   6962544256 ,   6970928768 ,   6979317376 , \n     6987709312 ,   6996093824 ,   7004487296 ,   7012875392 ,   7021258624 , \n     7029652352 ,   7038038912 ,   7046427776 ,   7054818944 ,   7063207808 , \n     7071595136 ,   7079980928 ,   7088372608 ,   7096759424 ,   7105149824 , \n     7113536896 ,   7121928064 ,   7130315392 ,   7138699648 ,   7147092352 , \n     7155479168 ,   7163865728 ,   7172249984 ,   7180648064 ,   7189036672 , \n     7197424768 ,   7205810816 ,   7214196608 ,   7222589824 ,   7230975104 , \n     7239367552 ,   7247755904 ,   7256145536 ,   7264533376 ,   7272921472 , \n     7281308032 ,   7289694848 ,   7298088832 ,   7306471808 ,   7314864512 , \n     7323253888 ,   7331643008 ,   7340029568 ,   7348419712 ,   7356808832 , \n     7365196672 ,   7373585792 ,   7381973888 ,   7390362752 ,   7398750592 , \n     7407138944 ,   7415528576 ,   7423915648 ,   7432302208 ,   7440690304 , \n     7449080192 ,   7457472128 ,   7465860992 ,   7474249088 ,   7482635648 , \n     7491023744 ,   7499412608 ,   7507803008 ,   7516192384 ,   7524579968 , \n     7532967296 ,   7541358464 ,   7549745792 ,   7558134656 ,   7566524032 , \n     7574912896 ,   7583300992 ,   7591690112 ,   7600075136 ,   7608466816 , \n     7616854912 ,   7625244544 ,   7633629824 ,   7642020992 ,   7650410368 , \n     7658794112 ,   7667187328 ,   7675574912 ,   7683961984 ,   7692349568 , \n     7700739712 ,   7709130368 ,   7717519232 ,   7725905536 ,   7734295424 , \n     7742683264 ,   7751069056 ,   7759457408 ,   7767849088 ,   7776238208 , \n     7784626816 ,   7793014912 ,   7801405312 ,   7809792128 ,   7818179968 , \n     7826571136 ,   7834957184 ,   7843347328 ,   7851732352 ,   7860124544 , \n     7868512384 ,   7876902016 ,   7885287808 ,   7893679744 ,   7902067072 , \n     7910455936 ,   7918844288 ,   7927230848 ,   7935622784 ,   7944009344 , \n     7952400256 ,   7960786048 ,   7969176704 ,   7977565312 ,   7985953408 , \n     7994339968 ,   8002730368 ,   8011119488 ,   8019508096 ,   8027896192 , \n     8036285056 ,   8044674688 ,   8053062272 ,   8061448832 ,   8069838464 , \n     8078227328 ,   8086616704 ,   8095006592 ,   8103393664 ,   8111783552 , \n     8120171392 ,   8128560256 ,   8136949376 ,   8145336704 ,   8153726848 , \n     8162114944 ,   8170503296 ,   8178891904 ,   8187280768 ,   8195669632 , \n     8204058496 ,   8212444544 ,   8220834176 ,   8229222272 ,   8237612672 , \n     8246000768 ,   8254389376 ,   8262775168 ,   8271167104 ,   8279553664 , \n     8287944064 ,   8296333184 ,   8304715136 ,   8313108352 ,   8321497984 , \n     8329885568 ,   8338274432 ,   8346663296 ,   8355052928 ,   8363441536 , \n     8371828352 ,   8380217984 ,   8388606592 ,   8396996224 ,   8405384576 , \n     8413772672 ,   8422161536 ,   8430549376 ,   8438939008 ,   8447326592 , \n     8455715456 ,   8464104832 ,   8472492928 ,   8480882048 ,   8489270656 , \n     8497659776 ,   8506045312 ,   8514434944 ,   8522823808 ,   8531208832 , \n     8539602304 ,   8547990656 ,   8556378752 ,   8564768384 ,   8573154176 , \n     8581542784 ,   8589933952 ,   8598322816 ,   8606705024 ,   8615099264 , \n     8623487872 ,   8631876992 ,   8640264064 ,   8648653952 ,   8657040256 , \n     8665430656 ,   8673820544 ,   8682209152 ,   8690592128 ,   8698977152 , \n     8707374464 ,   8715763328 ,   8724151424 ,   8732540032 ,   8740928384 , \n     8749315712 ,   8757704576 ,   8766089344 ,   8774480768 ,   8782871936 , \n     8791260032 ,   8799645824 ,   8808034432 ,   8816426368 ,   8824812928 , \n     8833199488 ,   8841591424 ,   8849976448 ,   8858366336 ,   8866757248 , \n     8875147136 ,   8883532928 ,   8891923328 ,   8900306816 ,   8908700288 , \n     8917088384 ,   8925478784 ,   8933867392 ,   8942250368 ,   8950644608 , \n     8959032704 ,   8967420544 ,   8975809664 ,   8984197504 ,   8992584064 , \n     9000976256 ,   9009362048 ,   9017752448 ,   9026141312 ,   9034530688 , \n     9042917504 ,   9051307904 ,   9059694208 ,   9068084864 ,   9076471424 , \n     9084861824 ,   9093250688 ,   9101638528 ,   9110027648 ,   9118416512 , \n     9126803584 ,   9135188096 ,   9143581312 ,   9151969664 ,   9160356224 , \n     9168747136 ,   9177134464 ,   9185525632 ,   9193910144 ,   9202302848 , \n     9210690688 ,   9219079552 ,   9227465344 ,   9235854464 ,   9244244864 , \n     9252633472 ,   9261021824 ,   9269411456 ,   9277799296 ,   9286188928 , \n     9294574208 ,   9302965888 ,   9311351936 ,   9319740032 ,   9328131968 , \n     9336516736 ,   9344907392 ,   9353296768 ,   9361685888 ,   9370074752 , \n     9378463616 ,   9386849408 ,   9395239808 ,   9403629184 ,   9412016512 , \n     9420405376 ,   9428795008 ,   9437181568 ,   9445570688 ,   9453960832 , \n     9462346624 ,   9470738048 ,   9479121536 ,   9487515008 ,   9495903616 , \n     9504289664 ,   9512678528 ,   9521067904 ,   9529456256 ,   9537843584 , \n     9546233728 ,   9554621312 ,   9563011456 ,   9571398784 ,   9579788672 , \n     9588178304 ,   9596567168 ,   9604954496 ,   9613343104 ,   9621732992 , \n     9630121856 ,   9638508416 ,   9646898816 ,   9655283584 ,   9663675776 , \n     9672061312 ,   9680449664 ,   9688840064 ,   9697230464 ,   9705617536 , \n     9714003584 ,   9722393984 ,   9730772608 ,   9739172224 ,   9747561088 , \n     9755945344 ,   9764338816 ,   9772726144 ,   9781116544 ,   9789503872 , \n     9797892992 ,   9806282624 ,   9814670464 ,   9823056512 ,   9831439232 , \n     9839833984 ,   9848224384 ,   9856613504 ,   9865000576 ,   9873391232 , \n     9881772416 ,   9890162816 ,   9898556288 ,   9906940544 ,   9915333248 , \n     9923721088 ,   9932108672 ,   9940496512 ,   9948888448 ,   9957276544 , \n     9965666176 ,   9974048384 ,   9982441088 ,   9990830464 ,   9999219584 , \n     10007602816 ,   10015996544 ,   10024385152 ,   10032774016 ,   10041163648 , \n     10049548928 ,   10057940096 ,   10066329472 ,   10074717824 ,   10083105152 , \n     10091495296 ,   10099878784 ,   10108272256 ,   10116660608 ,   10125049216 , \n     10133437312 ,   10141825664 ,   10150213504 ,   10158601088 ,   10166991232 , \n     10175378816 ,   10183766144 ,   10192157312 ,   10200545408 ,   10208935552 , \n     10217322112 ,   10225712768 ,   10234099328 ,   10242489472 ,   10250876032 , \n     10259264896 ,   10267656064 ,   10276042624 ,   10284429184 ,   10292820352 , \n     10301209472 ,   10309598848 ,   10317987712 ,   10326375296 ,   10334763392 , \n     10343153536 ,   10351541632 ,   10359930752 ,   10368318592 ,   10376707456 , \n     10385096576 ,   10393484672 ,   10401867136 ,   10410262144 ,   10418647424 , \n     10427039104 ,   10435425664 ,   10443810176 ,   10452203648 ,   10460589952 , \n     10468982144 ,   10477369472 ,   10485759104 ,   10494147712 ,   10502533504 , \n     10510923392 ,   10519313536 ,   10527702656 ,   10536091264 ,   10544478592 , \n     10552867712 ,   10561255808 ,   10569642368 ,   10578032768 ,   10586423168 , \n     10594805632 ,   10603200128 ,   10611588992 ,   10619976064 ,   10628361344 , \n     10636754048 ,   10645143424 ,   10653531776 ,   10661920384 ,   10670307968 , \n     10678696832 ,   10687086464 ,   10695475072 ,   10703863168 ,   10712246144 , \n     10720639616 ,   10729026688 ,   10737414784 ,   10745806208 ,   10754190976 , \n     10762581376 ,   10770971264 ,   10779356288 ,   10787747456 ,   10796135552 , \n     10804525184 ,   10812915584 ,   10821301888 ,   10829692288 ,   10838078336 , \n     10846469248 ,   10854858368 ,   10863247232 ,   10871631488 ,   10880023424 , \n     10888412032 ,   10896799616 ,   10905188992 ,   10913574016 ,   10921964672 , \n     10930352768 ,   10938742912 ,   10947132544 ,   10955518592 ,   10963909504 , \n     10972298368 ,   10980687488 ,   10989074816 ,   10997462912 ,   11005851776 , \n     11014241152 ,   11022627712 ,   11031017344 ,   11039403904 ,   11047793024 , \n     11056184704 ,   11064570752 ,   11072960896 ,   11081343872 ,   11089737856 , \n     11098128256 ,   11106514816 ,   11114904448 ,   11123293568 ,   11131680128 , \n     11140065152 ,   11148458368 ,   11156845696 ,   11165236864 ,   11173624192 , \n     11182013824 ,   11190402688 ,   11198790784 ,   11207179136 ,   11215568768 , \n     11223957376 ,   11232345728 ,   11240734592 ,   11249122688 ,   11257511296 , \n     11265899648 ,   11274285952 ,   11282675584 ,   11291065472 ,   11299452544 , \n     11307842432 ,   11316231296 ,   11324616832 ,   11333009024 ,   11341395584 , \n     11349782656 ,   11358172288 ,   11366560384 ,   11374950016 ,   11383339648 , \n     11391721856 ,   11400117376 ,   11408504192 ,   11416893568 ,   11425283456 , \n     11433671552 ,   11442061184 ,   11450444672 ,   11458837888 ,   11467226752 , \n     11475611776 ,   11484003968 ,   11492392064 ,   11500780672 ,   11509169024 , \n     11517550976 ,   11525944448 ,   11534335616 ,   11542724224 ,   11551111808 , \n     11559500672 ,   11567890304 ,   11576277376 ,   11584667008 ,   11593056128 , \n     11601443456 ,   11609830016 ,   11618221952 ,   11626607488 ,   11634995072 , \n     11643387776 ,   11651775104 ,   11660161664 ,   11668552576 ,   11676940928 , \n     11685330304 ,   11693718656 ,   11702106496 ,   11710496128 ,   11718882688 , \n     11727273088 ,   11735660416 ,   11744050048 ,   11752437376 ,   11760824704 , \n     11769216128 ,   11777604736 ,   11785991296 ,   11794381952 ,   11802770048 , \n     11811157888 ,   11819548544 ,   11827932544 ,   11836324736 ,   11844713344 , \n     11853100928 ,   11861486464 ,   11869879936 ,   11878268032 ,   11886656896 , \n     11895044992 ,   11903433088 ,   11911822976 ,   11920210816 ,   11928600448 , \n     11936987264 ,   11945375872 ,   11953761152 ,   11962151296 ,   11970543488 , \n     11978928512 ,   11987320448 ,   11995708288 ,   12004095104 ,   12012486272 , \n     12020875136 ,   12029255552 ,   12037652096 ,   12046039168 ,   12054429568 , \n     12062813824 ,   12071206528 ,   12079594624 ,   12087983744 ,   12096371072 , \n     12104759936 ,   12113147264 ,   12121534592 ,   12129924992 ,   12138314624 , \n     12146703232 ,   12155091584 ,   12163481216 ,   12171864704 ,   12180255872 , \n     12188643968 ,   12197034112 ,   12205424512 ,   12213811328 ,   12222199424 , \n     12230590336 ,   12238977664 ,   12247365248 ,   12255755392 ,   12264143488 , \n     12272531584 ,   12280920448 ,   12289309568 ,   12297694592 ,   12306086528 , \n     12314475392 ,   12322865024 ,   12331253632 ,   12339640448 ,   12348029312 , \n     12356418944 ,   12364805248 ,   12373196672 ,   12381580928 ,   12389969024 , \n     12398357632 ,   12406750592 ,   12415138432 ,   12423527552 ,   12431916416 , \n     12440304512 ,   12448692352 ,   12457081216 ,   12465467776 ,   12473859968 , \n     12482245504 ,   12490636672 ,   12499025536 ,   12507411584 ,   12515801728 , \n     12524190592 ,   12532577152 ,   12540966272 ,   12549354368 ,   12557743232 , \n     12566129536 ,   12574523264 ,   12582911872 ,   12591299456 ,   12599688064 , \n     12608074624 ,   12616463488 ,   12624845696 ,   12633239936 ,   12641631616 , \n     12650019968 ,   12658407296 ,   12666795136 ,   12675183232 ,   12683574656 , \n     12691960192 ,   12700350592 ,   12708740224 ,   12717128576 ,   12725515904 , \n     12733906816 ,   12742295168 ,   12750680192 ,   12759071872 ,   12767460736 , \n     12775848832 ,   12784236928 ,   12792626816 ,   12801014656 ,   12809404288 , \n     12817789312 ,   12826181504 ,   12834568832 ,   12842954624 ,   12851345792 , \n     12859732352 ,   12868122496 ,   12876512128 ,   12884901248 ,   12893289088 , \n     12901672832 ,   12910067584 ,   12918455168 ,   12926842496 ,   12935232896 , \n     12943620736 ,   12952009856 ,   12960396928 ,   12968786816 ,   12977176192 , \n     12985563776 ,   12993951104 ,   13002341504 ,   13010730368 ,   13019115392 , \n     13027506304 ,   13035895168 ,   13044272512 ,   13052673152 ,   13061062528 , \n     13069446272 ,   13077838976 ,   13086227072 ,   13094613632 ,   13103000192 , \n     13111393664 ,   13119782528 ,   13128157568 ,   13136559232 ,   13144945024 , \n     13153329536 ,   13161724288 ,   13170111872 ,   13178502784 ,   13186884736 , \n     13195279744 ,   13203667072 ,   13212057472 ,   13220445824 ,   13228832128 , \n     13237221248 ,   13245610624 ,   13254000512 ,   13262388352 ,   13270777472 , \n     13279166336 ,   13287553408 ,   13295943296 ,   13304331904 ,   13312719488 , \n     13321108096 ,   13329494656 ,   13337885824 ,   13346274944 ,   13354663808 , \n     13363051136 ,   13371439232 ,   13379825024 ,   13388210816 ,   13396605056 , \n     13404995456 ,   13413380224 ,   13421771392 ,   13430159744 ,   13438546048 , \n     13446937216 ,   13455326848 ,   13463708288 ,   13472103808 ,   13480492672 , \n     13488875648 ,   13497269888 ,   13505657728 ,   13514045312 ,   13522435712 , \n     13530824576 ,   13539210112 ,   13547599232 ,   13555989376 ,   13564379008 , \n     13572766336 ,   13581154432 ,   13589544832 ,   13597932928 ,   13606320512 , \n     13614710656 ,   13623097472 ,   13631477632 ,   13639874944 ,   13648264064 , \n     13656652928 ,   13665041792 ,   13673430656 ,   13681818496 ,   13690207616 , \n     13698595712 ,   13706982272 ,   13715373184 ,   13723762048 ,   13732150144 , \n     13740536704 ,   13748926592 ,   13757316224 ,   13765700992 ,   13774090112 , \n     13782477952 ,   13790869376 ,   13799259008 ,   13807647872 ,   13816036736 , \n     13824425344 ,   13832814208 ,   13841202304 ,   13849591424 ,   13857978752 , \n     13866368896 ,   13874754688 ,   13883145344 ,   13891533184 ,   13899919232 , \n     13908311168 ,   13916692096 ,   13925085056 ,   13933473152 ,   13941866368 , \n     13950253696 ,   13958643584 ,   13967032192 ,   13975417216 ,   13983807616 , \n     13992197504 ,   14000582272 ,   14008973696 ,   14017363072 ,   14025752192 , \n     14034137984 ,   14042528384 ,   14050918016 ,   14059301504 ,   14067691648 , \n     14076083584 ,   14084470144 ,   14092852352 ,   14101249664 ,   14109635968 , \n     14118024832 ,   14126407552 ,   14134804352 ,   14143188608 ,   14151577984 , \n     14159968384 ,   14168357248 ,   14176741504 ,   14185127296 ,   14193521024 , \n     14201911424 ,   14210301824 ,   14218685056 ,   14227067264 ,   14235467392 , \n     14243855488 ,   14252243072 ,   14260630144 ,   14269021568 ,   14277409408 , \n     14285799296 ,   14294187904 ,   14302571392 ,   14310961792 ,   14319353728 , \n     14327738752 ,   14336130944 ,   14344518784 ,   14352906368 ,   14361296512 , \n     14369685376 ,   14378071424 ,   14386462592 ,   14394848128 ,   14403230848 , \n     14411627392 ,   14420013952 ,   14428402304 ,   14436793472 ,   14445181568 , \n     14453569664 ,   14461959808 ,   14470347904 ,   14478737024 ,   14487122816 , \n     14495511424 ,   14503901824 ,   14512291712 ,   14520677504 ,   14529064832 , \n     14537456768 ,   14545845632 ,   14554234496 ,   14562618496 ,   14571011456 , \n     14579398784 ,   14587789184 ,   14596172672 ,   14604564608 ,   14612953984 , \n     14621341312 ,   14629724288 ,   14638120832 ,   14646503296 ,   14654897536 , \n     14663284864 ,   14671675264 ,   14680061056 ,   14688447616 ,   14696835968 , \n     14705228416 ,   14713616768 ,   14722003328 ,   14730392192 ,   14738784128 , \n     14747172736 ,   14755561088 ,   14763947648 ,   14772336512 ,   14780725376 , \n     14789110144 ,   14797499776 ,   14805892736 ,   14814276992 ,   14822670208 , \n     14831056256 ,   14839444352 ,   14847836032 ,   14856222848 ,   14864612992 , \n     14872997504 ,   14881388672 ,   14889775744 ,   14898165376 ,   14906553472 , \n     14914944896 ,   14923329664 ,   14931721856 ,   14940109696 ,   14948497024 , \n     14956887424 ,   14965276544 ,   14973663616 ,   14982053248 ,   14990439808 , \n     14998830976 ,   15007216768 ,   15015605888 ,   15023995264 ,   15032385152 , \n     15040768384 ,   15049154944 ,   15057549184 ,   15065939072 ,   15074328448 , \n     15082715008 ,   15091104128 ,   15099493504 ,   15107879296 ,   15116269184 , \n     15124659584 ,   15133042304 ,   15141431936 ,   15149824384 ,   15158214272 , \n     15166602368 ,   15174991232 ,   15183378304 ,   15191760512 ,   15200154496 , \n     15208542592 ,   15216931712 ,   15225323392 ,   15233708416 ,   15242098048 , \n     15250489216 ,   15258875264 ,   15267265408 ,   15275654528 ,   15284043136 , \n     15292431488 ,   15300819584 ,   15309208192 ,   15317596544 ,   15325986176 , \n     15334374784 ,   15342763648 ,   15351151744 ,   15359540608 ,   15367929728 , \n     15376318336 ,   15384706432 ,   15393092992 ,   15401481856 ,   15409869952 , \n     15418258816 ,   15426649984 ,   15435037568 ,   15443425664 ,   15451815296 , \n     15460203392 ,   15468589184 ,   15476979328 ,   15485369216 ,   15493755776 , \n     15502146944 ,   15510534272 ,   15518924416 ,   15527311232 ,   15535699072 , \n     15544089472 ,   15552478336 ,   15560866688 ,   15569254528 ,   15577642624 , \n     15586031488 ,   15594419072 ,   15602809472 ,   15611199104 ,   15619586432 , \n     15627975296 ,   15636364928 ,   15644753792 ,   15653141888 ,   15661529216 , \n     15669918848 ,   15678305152 ,   15686696576 ,   15695083136 ,   15703474048 , \n     15711861632 ,   15720251264 ,   15728636288 ,   15737027456 ,   15745417088 , \n     15753804928 ,   15762194048 ,   15770582656 ,   15778971008 ,   15787358336 , \n     15795747712 ,   15804132224 ,   15812523392 ,   15820909696 ,   15829300096 , \n     15837691264 ,   15846071936 ,   15854466944 ,   15862855808 ,   15871244672 , \n     15879634816 ,   15888020608 ,   15896409728 ,   15904799104 ,   15913185152 , \n     15921577088 ,   15929966464 ,   15938354816 ,   15946743424 ,   15955129472 , \n     15963519872 ,   15971907968 ,   15980296064 ,   15988684928 ,   15997073024 , \n     16005460864 ,   16013851264 ,   16022241152 ,   16030629248 ,   16039012736 , \n     16047406976 ,   16055794816 ,   16064181376 ,   16072571264 ,   16080957824 , \n     16089346688 ,   16097737856 ,   16106125184 ,   16114514816 ,   16122904192 , \n     16131292544 ,   16139678848 ,   16148066944 ,   16156453504 ,   16164839552 , \n     16173236096 ,   16181623424 ,   16190012032 ,   16198401152 ,   16206790528 , \n     16215177344 ,   16223567744 ,   16231956352 ,   16240344704 ,   16248731008 , \n     16257117824 ,   16265504384 ,   16273898624 ,   16282281856 ,   16290668672 , \n     16299064192 ,   16307449216 ,   16315842176 ,   16324230016 ,   16332613504 , \n     16341006464 ,   16349394304 ,   16357783168 ,   16366172288 ,   16374561664 , \n     16382951296 ,   16391337856 ,   16399726208 ,   16408116352 ,   16416505472 , \n     16424892032 ,   16433282176 ,   16441668224 ,   16450058624 ,   16458448768 , \n     16466836864 ,   16475224448 ,   16483613056 ,   16492001408 ,   16500391808 , \n     16508779648 ,   16517166976 ,   16525555328 ,   16533944192 ,   16542330752 , \n     16550719616 ,   16559110528 ,   16567497088 ,   16575888512 ,   16584274816 , \n     16592665472 ,   16601051008 ,   16609442944 ,   16617832064 ,   16626218624 , \n     16634607488 ,   16642996096 ,   16651385728 ,   16659773824 ,   16668163712 , \n     16676552576 ,   16684938112 ,   16693328768 ,   16701718144 ,   16710095488 , \n     16718492288 ,   16726883968 ,   16735272832 ,   16743661184 ,   16752049792 , \n     16760436608 ,   16768827008 ,   16777214336 ,   16785599104 ,   16793992832 , \n     16802381696 ,   16810768768 ,   16819151744 ,   16827542656 ,   16835934848 , \n     16844323712 ,   16852711552 ,   16861101952 ,   16869489536 ,   16877876864 , \n     16886265728 ,   16894653056 ,   16903044736 ,   16911431296 ,   16919821696 , \n     16928207488 ,   16936592768 ,   16944987776 ,   16953375616 ,   16961763968 , \n     16970152832 ,   16978540928 ,   16986929536 ,   16995319168 ,   17003704448 , \n     17012096896 ,   17020481152 ,   17028870784 ,   17037262208 ,   17045649536 , \n     17054039936 ,   17062426496 ,   17070814336 ,   17079205504 ,   17087592064 , \n     17095978112 ,   17104369024 ,   17112759424 ,   17121147776 ,   17129536384 , \n     17137926016 ,   17146314368 ,   17154700928 ,   17163089792 ,   17171480192 , \n     17179864192 ,   17188256896 ,   17196644992 ,   17205033856 ,   17213423488 , \n     17221811072 ,   17230198912 ,   17238588032 ,   17246976896 ,   17255360384 , \n     17263754624 ,   17272143232 ,   17280530048 ,   17288918912 ,   17297309312 , \n     17305696384 ,   17314085504 ,   17322475136 ,   17330863744 ,   17339252096 , \n     17347640192 ,   17356026496 ,   17364413824 ,   17372796544 ,   17381190016 , \n     17389583488 ,   17397972608 ,   17406360704 ,   17414748544 ,   17423135872 , \n     17431527296 ,   17439915904 ,   17448303232 ,   17456691584 ,   17465081728 , \n     17473468288 ,   17481857408 ,   17490247552 ,   17498635904 ,   17507022464 , \n     17515409024 ,   17523801728 ,   17532189824 ,   17540577664 ,   17548966016 , \n     17557353344 ,   17565741184 ,   17574131584 ,   17582519168 ,   17590907008 , \n     17599296128 ,   17607687808 ,   17616076672 ,   17624455808 ,   17632852352 , \n     17641238656 ,   17649630848 ,   17658018944 ,   17666403968 ,   17674794112 , \n     17683178368 ,   17691573376 ,   17699962496 ,   17708350592 ,   17716739968 , \n     17725126528 ,   17733517184 ,   17741898112 ,   17750293888 ,   17758673024 , \n     17767070336 ,   17775458432 ,   17783848832 ,   17792236928 ,   17800625536 , \n     17809012352 ,   17817402752 ,   17825785984 ,   17834178944 ,   17842563968 , \n     17850955648 ,   17859344512 ,   17867732864 ,   17876119424 ,   17884511872 , \n     17892900224 ,   17901287296 ,   17909677696 ,   17918058112 ,   17926451072 , \n     17934843776 ,   17943230848 ,   17951609216 ,   17960008576 ,   17968397696 , \n     17976784256 ,   17985175424 ,   17993564032 ,   18001952128 ,   18010339712 , \n     18018728576 ,   18027116672 ,   18035503232 ,   18043894144 ,   18052283264 , \n     18060672128 ,   18069056384 ,   18077449856 ,   18085837184 ,   18094225792 , \n     18102613376 ,   18111004544 ,   18119388544 ,   18127781248 ,   18136170368 , \n     18144558976 ,   18152947328 ,   18161336192 ,   18169724288 ,   18178108544 , \n     18186498944 ,   18194886784 ,   18203275648 ,   18211666048 ,   18220048768 , \n     18228444544 ,   18236833408 ,   18245220736  ]  cache_sizes   =   [ \n     16776896 ,   16907456 ,   17039296 ,   17170112 ,   17301056 ,   17432512 ,   17563072 , \n     17693888 ,   17824192 ,   17955904 ,   18087488 ,   18218176 ,   18349504 ,   18481088 , \n     18611392 ,   18742336 ,   18874304 ,   19004224 ,   19135936 ,   19267264 ,   19398208 , \n     19529408 ,   19660096 ,   19791424 ,   19922752 ,   20053952 ,   20184896 ,   20315968 , \n     20446912 ,   20576576 ,   20709184 ,   20840384 ,   20971072 ,   21102272 ,   21233216 , \n     21364544 ,   21494848 ,   21626816 ,   21757376 ,   21887552 ,   22019392 ,   22151104 , \n     22281536 ,   22412224 ,   22543936 ,   22675264 ,   22806464 ,   22935872 ,   23068096 , \n     23198272 ,   23330752 ,   23459008 ,   23592512 ,   23723968 ,   23854912 ,   23986112 , \n     24116672 ,   24247616 ,   24378688 ,   24509504 ,   24640832 ,   24772544 ,   24903488 , \n     25034432 ,   25165376 ,   25296704 ,   25427392 ,   25558592 ,   25690048 ,   25820096 , \n     25951936 ,   26081728 ,   26214208 ,   26345024 ,   26476096 ,   26606656 ,   26737472 , \n     26869184 ,   26998208 ,   27131584 ,   27262528 ,   27393728 ,   27523904 ,   27655744 , \n     27786688 ,   27917888 ,   28049344 ,   28179904 ,   28311488 ,   28441792 ,   28573504 , \n     28700864 ,   28835648 ,   28966208 ,   29096768 ,   29228608 ,   29359808 ,   29490752 , \n     29621824 ,   29752256 ,   29882816 ,   30014912 ,   30144448 ,   30273728 ,   30406976 , \n     30538432 ,   30670784 ,   30799936 ,   30932672 ,   31063744 ,   31195072 ,   31325248 , \n     31456192 ,   31588288 ,   31719232 ,   31850432 ,   31981504 ,   32110784 ,   32243392 , \n     32372672 ,   32505664 ,   32636608 ,   32767808 ,   32897344 ,   33029824 ,   33160768 , \n     33289664 ,   33423296 ,   33554368 ,   33683648 ,   33816512 ,   33947456 ,   34076992 , \n     34208704 ,   34340032 ,   34471744 ,   34600256 ,   34734016 ,   34864576 ,   34993984 , \n     35127104 ,   35258176 ,   35386688 ,   35518528 ,   35650624 ,   35782336 ,   35910976 , \n     36044608 ,   36175808 ,   36305728 ,   36436672 ,   36568384 ,   36699968 ,   36830656 , \n     36961984 ,   37093312 ,   37223488 ,   37355072 ,   37486528 ,   37617472 ,   37747904 , \n     37879232 ,   38009792 ,   38141888 ,   38272448 ,   38403392 ,   38535104 ,   38660672 , \n     38795584 ,   38925632 ,   39059264 ,   39190336 ,   39320768 ,   39452096 ,   39581632 , \n     39713984 ,   39844928 ,   39974848 ,   40107968 ,   40238144 ,   40367168 ,   40500032 , \n     40631744 ,   40762816 ,   40894144 ,   41023552 ,   41155904 ,   41286208 ,   41418304 , \n     41547712 ,   41680448 ,   41811904 ,   41942848 ,   42073792 ,   42204992 ,   42334912 , \n     42467008 ,   42597824 ,   42729152 ,   42860096 ,   42991552 ,   43122368 ,   43253696 , \n     43382848 ,   43515712 ,   43646912 ,   43777088 ,   43907648 ,   44039104 ,   44170432 , \n     44302144 ,   44433344 ,   44564288 ,   44694976 ,   44825152 ,   44956864 ,   45088448 , \n     45219008 ,   45350464 ,   45481024 ,   45612608 ,   45744064 ,   45874496 ,   46006208 , \n     46136768 ,   46267712 ,   46399424 ,   46529344 ,   46660672 ,   46791488 ,   46923328 , \n     47053504 ,   47185856 ,   47316928 ,   47447872 ,   47579072 ,   47710144 ,   47839936 , \n     47971648 ,   48103232 ,   48234176 ,   48365248 ,   48496192 ,   48627136 ,   48757312 , \n     48889664 ,   49020736 ,   49149248 ,   49283008 ,   49413824 ,   49545152 ,   49675712 , \n     49807168 ,   49938368 ,   50069056 ,   50200256 ,   50331584 ,   50462656 ,   50593472 , \n     50724032 ,   50853952 ,   50986048 ,   51117632 ,   51248576 ,   51379904 ,   51510848 , \n     51641792 ,   51773248 ,   51903296 ,   52035136 ,   52164032 ,   52297664 ,   52427968 , \n     52557376 ,   52690112 ,   52821952 ,   52952896 ,   53081536 ,   53213504 ,   53344576 , \n     53475776 ,   53608384 ,   53738816 ,   53870528 ,   54000832 ,   54131776 ,   54263744 , \n     54394688 ,   54525248 ,   54655936 ,   54787904 ,   54918592 ,   55049152 ,   55181248 , \n     55312064 ,   55442752 ,   55574336 ,   55705024 ,   55836224 ,   55967168 ,   56097856 , \n     56228672 ,   56358592 ,   56490176 ,   56621888 ,   56753728 ,   56884928 ,   57015488 , \n     57146816 ,   57278272 ,   57409216 ,   57540416 ,   57671104 ,   57802432 ,   57933632 , \n     58064576 ,   58195264 ,   58326976 ,   58457408 ,   58588864 ,   58720192 ,   58849984 , \n     58981696 ,   59113024 ,   59243456 ,   59375552 ,   59506624 ,   59637568 ,   59768512 , \n     59897792 ,   60030016 ,   60161984 ,   60293056 ,   60423872 ,   60554432 ,   60683968 , \n     60817216 ,   60948032 ,   61079488 ,   61209664 ,   61341376 ,   61471936 ,   61602752 , \n     61733696 ,   61865792 ,   61996736 ,   62127808 ,   62259136 ,   62389568 ,   62520512 , \n     62651584 ,   62781632 ,   62910784 ,   63045056 ,   63176128 ,   63307072 ,   63438656 , \n     63569216 ,   63700928 ,   63831616 ,   63960896 ,   64093888 ,   64225088 ,   64355392 , \n     64486976 ,   64617664 ,   64748608 ,   64879424 ,   65009216 ,   65142464 ,   65273792 , \n     65402816 ,   65535424 ,   65666752 ,   65797696 ,   65927744 ,   66060224 ,   66191296 , \n     66321344 ,   66453056 ,   66584384 ,   66715328 ,   66846656 ,   66977728 ,   67108672 , \n     67239104 ,   67370432 ,   67501888 ,   67631296 ,   67763776 ,   67895104 ,   68026304 , \n     68157248 ,   68287936 ,   68419264 ,   68548288 ,   68681408 ,   68811968 ,   68942912 , \n     69074624 ,   69205568 ,   69337024 ,   69467584 ,   69599168 ,   69729472 ,   69861184 , \n     69989824 ,   70122944 ,   70253888 ,   70385344 ,   70515904 ,   70647232 ,   70778816 , \n     70907968 ,   71040832 ,   71171648 ,   71303104 ,   71432512 ,   71564992 ,   71695168 , \n     71826368 ,   71958464 ,   72089536 ,   72219712 ,   72350144 ,   72482624 ,   72613568 , \n     72744512 ,   72875584 ,   73006144 ,   73138112 ,   73268672 ,   73400128 ,   73530944 , \n     73662272 ,   73793344 ,   73924544 ,   74055104 ,   74185792 ,   74316992 ,   74448832 , \n     74579392 ,   74710976 ,   74841664 ,   74972864 ,   75102784 ,   75233344 ,   75364544 , \n     75497024 ,   75627584 ,   75759296 ,   75890624 ,   76021696 ,   76152256 ,   76283072 , \n     76414144 ,   76545856 ,   76676672 ,   76806976 ,   76937792 ,   77070016 ,   77200832 , \n     77331392 ,   77462464 ,   77593664 ,   77725376 ,   77856448 ,   77987776 ,   78118336 , \n     78249664 ,   78380992 ,   78511424 ,   78642496 ,   78773056 ,   78905152 ,   79033664 , \n     79166656 ,   79297472 ,   79429568 ,   79560512 ,   79690816 ,   79822784 ,   79953472 , \n     80084672 ,   80214208 ,   80346944 ,   80477632 ,   80608576 ,   80740288 ,   80870848 , \n     81002048 ,   81133504 ,   81264448 ,   81395648 ,   81525952 ,   81657536 ,   81786304 , \n     81919808 ,   82050112 ,   82181312 ,   82311616 ,   82443968 ,   82573376 ,   82705984 , \n     82835776 ,   82967744 ,   83096768 ,   83230528 ,   83359552 ,   83491264 ,   83622464 , \n     83753536 ,   83886016 ,   84015296 ,   84147776 ,   84277184 ,   84409792 ,   84540608 , \n     84672064 ,   84803008 ,   84934336 ,   85065152 ,   85193792 ,   85326784 ,   85458496 , \n     85589312 ,   85721024 ,   85851968 ,   85982656 ,   86112448 ,   86244416 ,   86370112 , \n     86506688 ,   86637632 ,   86769344 ,   86900672 ,   87031744 ,   87162304 ,   87293632 , \n     87424576 ,   87555392 ,   87687104 ,   87816896 ,   87947968 ,   88079168 ,   88211264 , \n     88341824 ,   88473152 ,   88603712 ,   88735424 ,   88862912 ,   88996672 ,   89128384 , \n     89259712 ,   89390272 ,   89521984 ,   89652544 ,   89783872 ,   89914816 ,   90045376 , \n     90177088 ,   90307904 ,   90438848 ,   90569152 ,   90700096 ,   90832832 ,   90963776 , \n     91093696 ,   91223744 ,   91356992 ,   91486784 ,   91618496 ,   91749824 ,   91880384 , \n     92012224 ,   92143552 ,   92273344 ,   92405696 ,   92536768 ,   92666432 ,   92798912 , \n     92926016 ,   93060544 ,   93192128 ,   93322816 ,   93453632 ,   93583936 ,   93715136 , \n     93845056 ,   93977792 ,   94109504 ,   94240448 ,   94371776 ,   94501184 ,   94632896 , \n     94764224 ,   94895552 ,   95023424 ,   95158208 ,   95287744 ,   95420224 ,   95550016 , \n     95681216 ,   95811904 ,   95943872 ,   96075328 ,   96203584 ,   96337856 ,   96468544 , \n     96599744 ,   96731072 ,   96860992 ,   96992576 ,   97124288 ,   97254848 ,   97385536 , \n     97517248 ,   97647808 ,   97779392 ,   97910464 ,   98041408 ,   98172608 ,   98303168 , \n     98434496 ,   98565568 ,   98696768 ,   98827328 ,   98958784 ,   99089728 ,   99220928 , \n     99352384 ,   99482816 ,   99614272 ,   99745472 ,   99876416 ,   100007104 , \n     100138048 ,   100267072 ,   100401088 ,   100529984 ,   100662592 ,   100791872 , \n     100925248 ,   101056064 ,   101187392 ,   101317952 ,   101449408 ,   101580608 , \n     101711296 ,   101841728 ,   101973824 ,   102104896 ,   102235712 ,   102366016 , \n     102498112 ,   102628672 ,   102760384 ,   102890432 ,   103021888 ,   103153472 , \n     103284032 ,   103415744 ,   103545152 ,   103677248 ,   103808576 ,   103939648 , \n     104070976 ,   104201792 ,   104332736 ,   104462528 ,   104594752 ,   104725952 , \n     104854592 ,   104988608 ,   105118912 ,   105247808 ,   105381184 ,   105511232 , \n     105643072 ,   105774784 ,   105903296 ,   106037056 ,   106167872 ,   106298944 , \n     106429504 ,   106561472 ,   106691392 ,   106822592 ,   106954304 ,   107085376 , \n     107216576 ,   107346368 ,   107478464 ,   107609792 ,   107739712 ,   107872192 , \n     108003136 ,   108131392 ,   108265408 ,   108396224 ,   108527168 ,   108657344 , \n     108789568 ,   108920384 ,   109049792 ,   109182272 ,   109312576 ,   109444928 , \n     109572928 ,   109706944 ,   109837888 ,   109969088 ,   110099648 ,   110230976 , \n     110362432 ,   110492992 ,   110624704 ,   110755264 ,   110886208 ,   111017408 , \n     111148864 ,   111279296 ,   111410752 ,   111541952 ,   111673024 ,   111803456 , \n     111933632 ,   112066496 ,   112196416 ,   112328512 ,   112457792 ,   112590784 , \n     112715968 ,   112852672 ,   112983616 ,   113114944 ,   113244224 ,   113376448 , \n     113505472 ,   113639104 ,   113770304 ,   113901376 ,   114031552 ,   114163264 , \n     114294592 ,   114425536 ,   114556864 ,   114687424 ,   114818624 ,   114948544 , \n     115080512 ,   115212224 ,   115343296 ,   115473472 ,   115605184 ,   115736128 , \n     115867072 ,   115997248 ,   116128576 ,   116260288 ,   116391488 ,   116522944 , \n     116652992 ,   116784704 ,   116915648 ,   117046208 ,   117178304 ,   117308608 , \n     117440192 ,   117569728 ,   117701824 ,   117833024 ,   117964096 ,   118094656 , \n     118225984 ,   118357312 ,   118489024 ,   118617536 ,   118749632 ,   118882112 , \n     119012416 ,   119144384 ,   119275328 ,   119406016 ,   119537344 ,   119668672 , \n     119798464 ,   119928896 ,   120061376 ,   120192832 ,   120321728 ,   120454336 , \n     120584512 ,   120716608 ,   120848192 ,   120979136 ,   121109056 ,   121241408 , \n     121372352 ,   121502912 ,   121634752 ,   121764416 ,   121895744 ,   122027072 , \n     122157632 ,   122289088 ,   122421184 ,   122550592 ,   122682944 ,   122813888 , \n     122945344 ,   123075776 ,   123207488 ,   123338048 ,   123468736 ,   123600704 , \n     123731264 ,   123861952 ,   123993664 ,   124124608 ,   124256192 ,   124386368 , \n     124518208 ,   124649024 ,   124778048 ,   124911296 ,   125041088 ,   125173696 , \n     125303744 ,   125432896 ,   125566912 ,   125696576 ,   125829056 ,   125958592 , \n     126090304 ,   126221248 ,   126352832 ,   126483776 ,   126615232 ,   126746432 , \n     126876608 ,   127008704 ,   127139392 ,   127270336 ,   127401152 ,   127532224 , \n     127663552 ,   127794752 ,   127925696 ,   128055232 ,   128188096 ,   128319424 , \n     128449856 ,   128581312 ,   128712256 ,   128843584 ,   128973632 ,   129103808 , \n     129236288 ,   129365696 ,   129498944 ,   129629888 ,   129760832 ,   129892288 , \n     130023104 ,   130154048 ,   130283968 ,   130416448 ,   130547008 ,   130678336 , \n     130807616 ,   130939456 ,   131071552 ,   131202112 ,   131331776 ,   131464384 , \n     131594048 ,   131727296 ,   131858368 ,   131987392 ,   132120256 ,   132250816 , \n     132382528 ,   132513728 ,   132644672 ,   132774976 ,   132905792 ,   133038016 , \n     133168832 ,   133299392 ,   133429312 ,   133562048 ,   133692992 ,   133823296 , \n     133954624 ,   134086336 ,   134217152 ,   134348608 ,   134479808 ,   134607296 , \n     134741056 ,   134872384 ,   135002944 ,   135134144 ,   135265472 ,   135396544 , \n     135527872 ,   135659072 ,   135787712 ,   135921472 ,   136052416 ,   136182848 , \n     136313792 ,   136444864 ,   136576448 ,   136707904 ,   136837952 ,   136970048 , \n     137099584 ,   137232064 ,   137363392 ,   137494208 ,   137625536 ,   137755712 , \n     137887424 ,   138018368 ,   138149824 ,   138280256 ,   138411584 ,   138539584 , \n     138672832 ,   138804928 ,   138936128 ,   139066688 ,   139196864 ,   139328704 , \n     139460032 ,   139590208 ,   139721024 ,   139852864 ,   139984576 ,   140115776 , \n     140245696 ,   140376512 ,   140508352 ,   140640064 ,   140769856 ,   140902336 , \n     141032768 ,   141162688 ,   141294016 ,   141426496 ,   141556544 ,   141687488 , \n     141819584 ,   141949888 ,   142080448 ,   142212544 ,   142342336 ,   142474432 , \n     142606144 ,   142736192 ,   142868288 ,   142997824 ,   143129408 ,   143258944 , \n     143392448 ,   143523136 ,   143653696 ,   143785024 ,   143916992 ,   144045632 , \n     144177856 ,   144309184 ,   144440768 ,   144570688 ,   144701888 ,   144832448 , \n     144965056 ,   145096384 ,   145227584 ,   145358656 ,   145489856 ,   145620928 , \n     145751488 ,   145883072 ,   146011456 ,   146144704 ,   146275264 ,   146407232 , \n     146538176 ,   146668736 ,   146800448 ,   146931392 ,   147062336 ,   147193664 , \n     147324224 ,   147455936 ,   147586624 ,   147717056 ,   147848768 ,   147979456 , \n     148110784 ,   148242368 ,   148373312 ,   148503232 ,   148635584 ,   148766144 , \n     148897088 ,   149028416 ,   149159488 ,   149290688 ,   149420224 ,   149551552 , \n     149683136 ,   149814976 ,   149943616 ,   150076352 ,   150208064 ,   150338624 , \n     150470464 ,   150600256 ,   150732224 ,   150862784 ,   150993088 ,   151125952 , \n     151254976 ,   151388096 ,   151519168 ,   151649728 ,   151778752 ,   151911104 , \n     152042944 ,   152174144 ,   152304704 ,   152435648 ,   152567488 ,   152698816 , \n     152828992 ,   152960576 ,   153091648 ,   153222976 ,   153353792 ,   153484096 , \n     153616192 ,   153747008 ,   153878336 ,   154008256 ,   154139968 ,   154270912 , \n     154402624 ,   154533824 ,   154663616 ,   154795712 ,   154926272 ,   155057984 , \n     155188928 ,   155319872 ,   155450816 ,   155580608 ,   155712064 ,   155843392 , \n     155971136 ,   156106688 ,   156237376 ,   156367424 ,   156499264 ,   156630976 , \n     156761536 ,   156892352 ,   157024064 ,   157155008 ,   157284416 ,   157415872 , \n     157545536 ,   157677248 ,   157810496 ,   157938112 ,   158071744 ,   158203328 , \n     158334656 ,   158464832 ,   158596288 ,   158727616 ,   158858048 ,   158988992 , \n     159121216 ,   159252416 ,   159381568 ,   159513152 ,   159645632 ,   159776192 , \n     159906496 ,   160038464 ,   160169536 ,   160300352 ,   160430656 ,   160563008 , \n     160693952 ,   160822208 ,   160956352 ,   161086784 ,   161217344 ,   161349184 , \n     161480512 ,   161611456 ,   161742272 ,   161873216 ,   162002752 ,   162135872 , \n     162266432 ,   162397888 ,   162529216 ,   162660032 ,   162790976 ,   162922048 , \n     163052096 ,   163184576 ,   163314752 ,   163446592 ,   163577408 ,   163707968 , \n     163839296 ,   163969984 ,   164100928 ,   164233024 ,   164364224 ,   164494912 , \n     164625856 ,   164756672 ,   164887616 ,   165019072 ,   165150016 ,   165280064 , \n     165412672 ,   165543104 ,   165674944 ,   165805888 ,   165936832 ,   166067648 , \n     166198336 ,   166330048 ,   166461248 ,   166591552 ,   166722496 ,   166854208 , \n     166985408 ,   167116736 ,   167246656 ,   167378368 ,   167508416 ,   167641024 , \n     167771584 ,   167903168 ,   168034112 ,   168164032 ,   168295744 ,   168427456 , \n     168557632 ,   168688448 ,   168819136 ,   168951616 ,   169082176 ,   169213504 , \n     169344832 ,   169475648 ,   169605952 ,   169738048 ,   169866304 ,   169999552 , \n     170131264 ,   170262464 ,   170393536 ,   170524352 ,   170655424 ,   170782016 , \n     170917696 ,   171048896 ,   171179072 ,   171310784 ,   171439936 ,   171573184 , \n     171702976 ,   171835072 ,   171966272 ,   172097216 ,   172228288 ,   172359232 , \n     172489664 ,   172621376 ,   172747712 ,   172883264 ,   173014208 ,   173144512 , \n     173275072 ,   173407424 ,   173539136 ,   173669696 ,   173800768 ,   173931712 , \n     174063424 ,   174193472 ,   174325696 ,   174455744 ,   174586816 ,   174718912 , \n     174849728 ,   174977728 ,   175109696 ,   175242688 ,   175374272 ,   175504832 , \n     175636288 ,   175765696 ,   175898432 ,   176028992 ,   176159936 ,   176291264 , \n     176422592 ,   176552512 ,   176684864 ,   176815424 ,   176946496 ,   177076544 , \n     177209152 ,   177340096 ,   177470528 ,   177600704 ,   177731648 ,   177864256 , \n     177994816 ,   178126528 ,   178257472 ,   178387648 ,   178518464 ,   178650176 , \n     178781888 ,   178912064 ,   179044288 ,   179174848 ,   179305024 ,   179436736 , \n     179568448 ,   179698496 ,   179830208 ,   179960512 ,   180092608 ,   180223808 , \n     180354752 ,   180485696 ,   180617152 ,   180748096 ,   180877504 ,   181009984 , \n     181139264 ,   181272512 ,   181402688 ,   181532608 ,   181663168 ,   181795136 , \n     181926592 ,   182057536 ,   182190016 ,   182320192 ,   182451904 ,   182582336 , \n     182713792 ,   182843072 ,   182976064 ,   183107264 ,   183237056 ,   183368384 , \n     183494848 ,   183631424 ,   183762752 ,   183893824 ,   184024768 ,   184154816 , \n     184286656 ,   184417984 ,   184548928 ,   184680128 ,   184810816 ,   184941248 , \n     185072704 ,   185203904 ,   185335616 ,   185465408 ,   185596352 ,   185727296 , \n     185859904 ,   185989696 ,   186121664 ,   186252992 ,   186383552 ,   186514112 , \n     186645952 ,   186777152 ,   186907328 ,   187037504 ,   187170112 ,   187301824 , \n     187429184 ,   187562048 ,   187693504 ,   187825472 ,   187957184 ,   188087104 , \n     188218304 ,   188349376 ,   188481344 ,   188609728 ,   188743616 ,   188874304 , \n     189005248 ,   189136448 ,   189265088 ,   189396544 ,   189528128 ,   189660992 , \n     189791936 ,   189923264 ,   190054208 ,   190182848 ,   190315072 ,   190447424 , \n     190577984 ,   190709312 ,   190840768 ,   190971328 ,   191102656 ,   191233472 , \n     191364032 ,   191495872 ,   191626816 ,   191758016 ,   191888192 ,   192020288 , \n     192148928 ,   192282176 ,   192413504 ,   192542528 ,   192674752 ,   192805952 , \n     192937792 ,   193068608 ,   193198912 ,   193330496 ,   193462208 ,   193592384 , \n     193723456 ,   193854272 ,   193985984 ,   194116672 ,   194247232 ,   194379712 , \n     194508352 ,   194641856 ,   194772544 ,   194900672 ,   195035072 ,   195166016 , \n     195296704 ,   195428032 ,   195558592 ,   195690304 ,   195818176 ,   195952576 , \n     196083392 ,   196214336 ,   196345792 ,   196476736 ,   196607552 ,   196739008 , \n     196869952 ,   197000768 ,   197130688 ,   197262784 ,   197394368 ,   197523904 , \n     197656384 ,   197787584 ,   197916608 ,   198049472 ,   198180544 ,   198310208 , \n     198442432 ,   198573632 ,   198705088 ,   198834368 ,   198967232 ,   199097792 , \n     199228352 ,   199360192 ,   199491392 ,   199621696 ,   199751744 ,   199883968 , \n     200014016 ,   200146624 ,   200276672 ,   200408128 ,   200540096 ,   200671168 , \n     200801984 ,   200933312 ,   201062464 ,   201194944 ,   201326144 ,   201457472 , \n     201588544 ,   201719744 ,   201850816 ,   201981632 ,   202111552 ,   202244032 , \n     202374464 ,   202505152 ,   202636352 ,   202767808 ,   202898368 ,   203030336 , \n     203159872 ,   203292608 ,   203423296 ,   203553472 ,   203685824 ,   203816896 , \n     203947712 ,   204078272 ,   204208192 ,   204341056 ,   204472256 ,   204603328 , \n     204733888 ,   204864448 ,   204996544 ,   205125568 ,   205258304 ,   205388864 , \n     205517632 ,   205650112 ,   205782208 ,   205913536 ,   206044736 ,   206176192 , \n     206307008 ,   206434496 ,   206569024 ,   206700224 ,   206831168 ,   206961856 , \n     207093056 ,   207223616 ,   207355328 ,   207486784 ,   207616832 ,   207749056 , \n     207879104 ,   208010048 ,   208141888 ,   208273216 ,   208404032 ,   208534336 , \n     208666048 ,   208796864 ,   208927424 ,   209059264 ,   209189824 ,   209321792 , \n     209451584 ,   209582656 ,   209715136 ,   209845568 ,   209976896 ,   210106432 , \n     210239296 ,   210370112 ,   210501568 ,   210630976 ,   210763712 ,   210894272 , \n     211024832 ,   211156672 ,   211287616 ,   211418176 ,   211549376 ,   211679296 , \n     211812032 ,   211942592 ,   212074432 ,   212204864 ,   212334016 ,   212467648 , \n     212597824 ,   212727616 ,   212860352 ,   212991424 ,   213120832 ,   213253952 , \n     213385024 ,   213515584 ,   213645632 ,   213777728 ,   213909184 ,   214040128 , \n     214170688 ,   214302656 ,   214433728 ,   214564544 ,   214695232 ,   214826048 , \n     214956992 ,   215089088 ,   215219776 ,   215350592 ,   215482304 ,   215613248 , \n     215743552 ,   215874752 ,   216005312 ,   216137024 ,   216267328 ,   216399296 , \n     216530752 ,   216661696 ,   216790592 ,   216923968 ,   217054528 ,   217183168 , \n     217316672 ,   217448128 ,   217579072 ,   217709504 ,   217838912 ,   217972672 , \n     218102848 ,   218233024 ,   218364736 ,   218496832 ,   218627776 ,   218759104 , \n     218888896 ,   219021248 ,   219151936 ,   219281728 ,   219413056 ,   219545024 , \n     219675968 ,   219807296 ,   219938624 ,   220069312 ,   220200128 ,   220331456 , \n     220461632 ,   220592704 ,   220725184 ,   220855744 ,   220987072 ,   221117888 , \n     221249216 ,   221378368 ,   221510336 ,   221642048 ,   221772736 ,   221904832 , \n     222031808 ,   222166976 ,   222297536 ,   222428992 ,   222559936 ,   222690368 , \n     222820672 ,   222953152 ,   223083968 ,   223213376 ,   223345984 ,   223476928 , \n     223608512 ,   223738688 ,   223869376 ,   224001472 ,   224132672 ,   224262848 , \n     224394944 ,   224524864 ,   224657344 ,   224788288 ,   224919488 ,   225050432 , \n     225181504 ,   225312704 ,   225443776 ,   225574592 ,   225704768 ,   225834176 , \n     225966784 ,   226097216 ,   226229824 ,   226360384 ,   226491712 ,   226623424 , \n     226754368 ,   226885312 ,   227015104 ,   227147456 ,   227278528 ,   227409472 , \n     227539904 ,   227669696 ,   227802944 ,   227932352 ,   228065216 ,   228196288 , \n     228326464 ,   228457792 ,   228588736 ,   228720064 ,   228850112 ,   228981056 , \n     229113152 ,   229243328 ,   229375936 ,   229505344 ,   229636928 ,   229769152 , \n     229894976 ,   230030272 ,   230162368 ,   230292416 ,   230424512 ,   230553152 , \n     230684864 ,   230816704 ,   230948416 ,   231079616 ,   231210944 ,   231342016 , \n     231472448 ,   231603776 ,   231733952 ,   231866176 ,   231996736 ,   232127296 , \n     232259392 ,   232388672 ,   232521664 ,   232652608 ,   232782272 ,   232914496 , \n     233043904 ,   233175616 ,   233306816 ,   233438528 ,   233569984 ,   233699776 , \n     233830592 ,   233962688 ,   234092224 ,   234221888 ,   234353984 ,   234485312 , \n     234618304 ,   234749888 ,   234880832 ,   235011776 ,   235142464 ,   235274048 , \n     235403456 ,   235535936 ,   235667392 ,   235797568 ,   235928768 ,   236057152 , \n     236190272 ,   236322752 ,   236453312 ,   236583616 ,   236715712 ,   236846528 , \n     236976448 ,   237108544 ,   237239104 ,   237371072 ,   237501632 ,   237630784 , \n     237764416 ,   237895232 ,   238026688 ,   238157632 ,   238286912 ,   238419392 , \n     238548032 ,   238681024 ,   238812608 ,   238941632 ,   239075008 ,   239206336 , \n     239335232 ,   239466944 ,   239599168 ,   239730496 ,   239861312 ,   239992384 , \n     240122816 ,   240254656 ,   240385856 ,   240516928 ,   240647872 ,   240779072 , \n     240909632 ,   241040704 ,   241171904 ,   241302848 ,   241433408 ,   241565248 , \n     241696192 ,   241825984 ,   241958848 ,   242088256 ,   242220224 ,   242352064 , \n     242481856 ,   242611648 ,   242744896 ,   242876224 ,   243005632 ,   243138496 , \n     243268672 ,   243400384 ,   243531712 ,   243662656 ,   243793856 ,   243924544 , \n     244054592 ,   244187072 ,   244316608 ,   244448704 ,   244580032 ,   244710976 , \n     244841536 ,   244972864 ,   245104448 ,   245233984 ,   245365312 ,   245497792 , \n     245628736 ,   245759936 ,   245889856 ,   246021056 ,   246152512 ,   246284224 , \n     246415168 ,   246545344 ,   246675904 ,   246808384 ,   246939584 ,   247070144 , \n     247199552 ,   247331648 ,   247463872 ,   247593536 ,   247726016 ,   247857088 , \n     247987648 ,   248116928 ,   248249536 ,   248380736 ,   248512064 ,   248643008 , \n     248773312 ,   248901056 ,   249036608 ,   249167552 ,   249298624 ,   249429184 , \n     249560512 ,   249692096 ,   249822784 ,   249954112 ,   250085312 ,   250215488 , \n     250345792 ,   250478528 ,   250608704 ,   250739264 ,   250870976 ,   251002816 , \n     251133632 ,   251263552 ,   251395136 ,   251523904 ,   251657792 ,   251789248 , \n     251919424 ,   252051392 ,   252182464 ,   252313408 ,   252444224 ,   252575552 , \n     252706624 ,   252836032 ,   252968512 ,   253099712 ,   253227584 ,   253361728 , \n     253493056 ,   253623488 ,   253754432 ,   253885504 ,   254017216 ,   254148032 , \n     254279488 ,   254410432 ,   254541376 ,   254672576 ,   254803264 ,   254933824 , \n     255065792 ,   255196736 ,   255326528 ,   255458752 ,   255589952 ,   255721408 , \n     255851072 ,   255983296 ,   256114624 ,   256244416 ,   256374208 ,   256507712 , \n     256636096 ,   256768832 ,   256900544 ,   257031616 ,   257162176 ,   257294272 , \n     257424448 ,   257555776 ,   257686976 ,   257818432 ,   257949632 ,   258079552 , \n     258211136 ,   258342464 ,   258473408 ,   258603712 ,   258734656 ,   258867008 , \n     258996544 ,   259127744 ,   259260224 ,   259391296 ,   259522112 ,   259651904 , \n     259784384 ,   259915328 ,   260045888 ,   260175424 ,   260308544 ,   260438336 , \n     260570944 ,   260700992 ,   260832448 ,   260963776 ,   261092672 ,   261226304 , \n     261356864 ,   261487936 ,   261619648 ,   261750592 ,   261879872 ,   262011968 , \n     262143424 ,   262274752 ,   262404416 ,   262537024 ,   262667968 ,   262799296 , \n     262928704 ,   263061184 ,   263191744 ,   263322944 ,   263454656 ,   263585216 , \n     263716672 ,   263847872 ,   263978944 ,   264108608 ,   264241088 ,   264371648 , \n     264501184 ,   264632768 ,   264764096 ,   264895936 ,   265024576 ,   265158464 , \n     265287488 ,   265418432 ,   265550528 ,   265681216 ,   265813312 ,   265943488 , \n     266075968 ,   266206144 ,   266337728 ,   266468032 ,   266600384 ,   266731072 , \n     266862272 ,   266993344 ,   267124288 ,   267255616 ,   267386432 ,   267516992 , \n     267648704 ,   267777728 ,   267910592 ,   268040512 ,   268172096 ,   268302784 , \n     268435264 ,   268566208 ,   268696256 ,   268828096 ,   268959296 ,   269090368 , \n     269221312 ,   269352256 ,   269482688 ,   269614784 ,   269745856 ,   269876416 , \n     270007616 ,   270139328 ,   270270272 ,   270401216 ,   270531904 ,   270663616 , \n     270791744 ,   270924736 ,   271056832 ,   271186112 ,   271317184 ,   271449536 , \n     271580992 ,   271711936 ,   271843136 ,   271973056 ,   272105408 ,   272236352 , \n     272367296 ,   272498368 ,   272629568 ,   272759488 ,   272891456 ,   273022784 , \n     273153856 ,   273284672 ,   273415616 ,   273547072 ,   273677632 ,   273808448 , \n     273937088 ,   274071488 ,   274200896 ,   274332992 ,   274463296 ,   274595392 , \n     274726208 ,   274857536 ,   274988992 ,   275118656 ,   275250496 ,   275382208 , \n     275513024 ,   275643968 ,   275775296 ,   275906368 ,   276037184 ,   276167872 , \n     276297664 ,   276429376 ,   276560576 ,   276692672 ,   276822976 ,   276955072 , \n     277085632 ,   277216832 ,   277347008 ,   277478848 ,   277609664 ,   277740992 , \n     277868608 ,   278002624 ,   278134336 ,   278265536 ,   278395328 ,   278526784 , \n     278657728 ,   278789824 ,   278921152 ,   279052096 ,   279182912 ,   279313088 , \n     279443776 ,   279576256 ,   279706048 ,   279838528 ,   279969728 ,   280099648 , \n     280230976 ,   280361408 ,   280493632 ,   280622528 ,   280755392 ,   280887104 , \n     281018176 ,   281147968 ,   281278912 ,   281411392 ,   281542592 ,   281673152 , \n     281803712 ,   281935552 ,   282066496 ,   282197312 ,   282329024 ,   282458816 , \n     282590272 ,   282720832 ,   282853184 ,   282983744 ,   283115072 ,   283246144 , \n     283377344 ,   283508416 ,   283639744 ,   283770304 ,   283901504 ,   284032576 , \n     284163136 ,   284294848 ,   284426176 ,   284556992 ,   284687296 ,   284819264 , \n     284950208 ,   285081536  ]", 
            "title": "\u6570\u636e\u5927\u5c0f"
        }, 
        {
            "location": "/EthashDashimoto/Ethash-C-API/", 
            "text": "Ethash C \u63a5\u53e3\n\n\n\u8fd9\u53ea\u662f\u4e00\u4e2a\u6587\u6863 the request of the C API described in \nthis PR\n.\n\n\ntypedef\n \nint\n(\n*\nCallback\n)(\nunsigned\n);\n\n\ntypedef\n \n/*...*/\n \nethash_light_t\n;\n\n\ntypedef\n \n/*...*/\n \nethash_full_t\n;\n\n\ntypedef\n \nstruct\n \nethash_h256\n \n{\n \nuint8_t\n \nb\n[\n32\n];\n \n}\n \nethash_h256_t\n;\n\n\ntypedef\n \nstruct\n \nethash_result\n \n{\n \nethash_h256_t\n \nvalue\n;\n \nethash_h256_t\n \nhixhash\n;\n \n}\n \nethash_result_t\n;\n\n\n\nethash_light_t\n \nethash_light_new\n(\nunsigned\n \nnumber\n);\n\n\nethash_result_t\n \nethash_light_compute\n(\nethash_light_t\n \nlight\n,\n \nethash_h256_t\n \nheader_hash\n,\n \nuint64_t\n \nnonce\n);\n\n\nvoid\n \nethash_light_delete\n(\nethash_light_t\n \nlight\n);\n\n\n\nethash_full_t\n \nethash_full_new\n(\nethash_light_t\n \nlight\n,\n \nCallBack\n \nc\n);\n\n\nuint64_t\n \nethash_full_dag_size\n(\nethash_full_t\n \nfull\n);\n\n\nvoid\n \nconst\n*\n \nethash_full_dag\n(\nethash_full_t\n \nfull\n);\n\n\nethash_result_t\n \nethash_full_compute\n(\nethash_full_t\n \nfull\n,\n \nethash_h256_t\n \nheader_hash\n,\n \nuint64_t\n \nnonce\n);\n\n\nvoid\n \nethash_full_delete\n(\nethash_full_t\n \nfull\n);\n\n\n\n\n\nnon-zero return from Callback means \"cancel DAG creation\" - this should cause an immediate return of \nethash_full_new\n with 0.\n\n\nan object of type \nethash_full_t\n may be tested for validity with != 0\n\n\n\u7528\u6cd5\u793a\u4f8b:\n\n\nint\n \ncallback\n(\nunsigned\n \n_progress\n)\n\n\n{\n\n  \nprintf\n(\n\\r\nGenerating DAG. %d%% done...\n,\n \n_progress\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\nvoid\n \nmain\n()\n\n\n{\n\n  \nethash_light_t\n \nlight\n;\n\n  \nethash_h256_t\n \nseed\n;\n\n  \n// TODO: populate p, seed, light\n\n  \nethash_full_t\n \ndag\n \n=\n \nethash_full_new\n(\nlight\n,\n \nseed\n,\n \ncallback\n);\n\n  \nif\n \n(\n!\ndag\n)\n\n  \n{\n\n    \nprintf\n(\nFailed generating DAG :-(\n\\n\n);\n\n    \nexit\n(\n-\n1\n);\n\n  \n}\n\n  \nprintf\n(\nDAG Generated OK!\n\\n\n);\n\n\n  \nethash_h256_t\n \nheaderHash\n;\n\n  \n// TODO: populate headerHash\n\n  \nuint64_t\n \nnonce\n \n=\n \ntime\n(\n0\n);\n\n  \nethash_result\n \nret\n;\n\n  \nfor\n \n(;\n \n!\nisWinner\n(\nret\n);\n \nnonce\n++\n)\n\n    \nret\n \n=\n \nethash_full_compute\n(\ndag\n,\n \nheaderHash\n,\n \nnonce\n);\n\n  \nprintf\n(\nGot winner! nonce is %d\n\\n\n,\n \nnonce\n);\n\n  \nethash_full_delete\n(\ndag\n);\n\n\n}", 
            "title": "Ethash C API"
        }, 
        {
            "location": "/EthashDashimoto/Ethash-C-API/#ethash-c", 
            "text": "\u8fd9\u53ea\u662f\u4e00\u4e2a\u6587\u6863 the request of the C API described in  this PR .  typedef   int ( * Callback )( unsigned );  typedef   /*...*/   ethash_light_t ;  typedef   /*...*/   ethash_full_t ;  typedef   struct   ethash_h256   {   uint8_t   b [ 32 ];   }   ethash_h256_t ;  typedef   struct   ethash_result   {   ethash_h256_t   value ;   ethash_h256_t   hixhash ;   }   ethash_result_t ;  ethash_light_t   ethash_light_new ( unsigned   number );  ethash_result_t   ethash_light_compute ( ethash_light_t   light ,   ethash_h256_t   header_hash ,   uint64_t   nonce );  void   ethash_light_delete ( ethash_light_t   light );  ethash_full_t   ethash_full_new ( ethash_light_t   light ,   CallBack   c );  uint64_t   ethash_full_dag_size ( ethash_full_t   full );  void   const *   ethash_full_dag ( ethash_full_t   full );  ethash_result_t   ethash_full_compute ( ethash_full_t   full ,   ethash_h256_t   header_hash ,   uint64_t   nonce );  void   ethash_full_delete ( ethash_full_t   full );   non-zero return from Callback means \"cancel DAG creation\" - this should cause an immediate return of  ethash_full_new  with 0.  an object of type  ethash_full_t  may be tested for validity with != 0  \u7528\u6cd5\u793a\u4f8b:  int   callback ( unsigned   _progress )  { \n   printf ( \\r Generating DAG. %d%% done... ,   _progress ); \n   return   0 ;  }  void   main ()  { \n   ethash_light_t   light ; \n   ethash_h256_t   seed ; \n   // TODO: populate p, seed, light \n   ethash_full_t   dag   =   ethash_full_new ( light ,   seed ,   callback ); \n   if   ( ! dag ) \n   { \n     printf ( Failed generating DAG :-( \\n ); \n     exit ( - 1 ); \n   } \n   printf ( DAG Generated OK! \\n ); \n\n   ethash_h256_t   headerHash ; \n   // TODO: populate headerHash \n   uint64_t   nonce   =   time ( 0 ); \n   ethash_result   ret ; \n   for   (;   ! isWinner ( ret );   nonce ++ ) \n     ret   =   ethash_full_compute ( dag ,   headerHash ,   nonce ); \n   printf ( Got winner! nonce is %d \\n ,   nonce ); \n   ethash_full_delete ( dag );  }", 
            "title": "Ethash C \u63a5\u53e3"
        }, 
        {
            "location": "/EthashDashimoto/Ethash-DAG/", 
            "text": "Ethash DAG\n\n\nEthash is the PoW system. It requires a ~1GB dataset known as the DAG (see \nDagger Hashimoto\n). This typically takes hours to generate so we tend to memorise it. Clients wishing to store the DAG in a cache should conform to this spec in order to share the cache with other clients:\n\n\n\u4f4d\u7f6e\n\n\nThe DAG should be stored in a 1GB dump (for the initial epoch, anyway), in a file:\n\n\n\n\nMac/Linux: \n$(HOME)/.ethash/full-R\nREVISION\n-\nSEEDHASH\n\n\nWindows: \n$(HOME)/Appdata/Local/Ethash/full-R\nREVISION\n-\nSEEDHASH\n\n\n\n\n\u5728\u54ea:\n\n\n\n\nREVISION\n is a decimal integer, given as the C-constant \nREVISION\n in \nlibethash/ethash.h\n;\n\n\nSEEDHASH\n is 16 lowercase hex digits specifying the first 8 bytes of the epoch's seed hash.\n\n\n\n\nThere may be many such DAGs stored in this directory; it is up to the client and/or user to remove out of date ones.\n\n\n\u683c\u5f0f\n\n\nEach file should begin with an 8-byte magic number, \n0xfee1deadbaddcafe\n, written in little-endian format (i.e., bytes \nfe ca dd ba ad de e1 fe\n).\n\n\nThe Ethash algorithm expects the DAG as a two-dimensional array of uint32s (4-byte unsigned ints), with dimension (n \n 16) where n is a large number. (n starts at 16777186 and grows from there.) Following the magic number, the rows of the DAG should be written sequentially into the file, with no delimiter between rows and each unint32 encoded in little-endian format.", 
            "title": "Ethash DAG"
        }, 
        {
            "location": "/EthashDashimoto/Ethash-DAG/#ethash-dag", 
            "text": "Ethash is the PoW system. It requires a ~1GB dataset known as the DAG (see  Dagger Hashimoto ). This typically takes hours to generate so we tend to memorise it. Clients wishing to store the DAG in a cache should conform to this spec in order to share the cache with other clients:", 
            "title": "Ethash DAG"
        }, 
        {
            "location": "/EthashDashimoto/Ethash-DAG/#_1", 
            "text": "The DAG should be stored in a 1GB dump (for the initial epoch, anyway), in a file:   Mac/Linux:  $(HOME)/.ethash/full-R REVISION - SEEDHASH  Windows:  $(HOME)/Appdata/Local/Ethash/full-R REVISION - SEEDHASH   \u5728\u54ea:   REVISION  is a decimal integer, given as the C-constant  REVISION  in  libethash/ethash.h ;  SEEDHASH  is 16 lowercase hex digits specifying the first 8 bytes of the epoch's seed hash.   There may be many such DAGs stored in this directory; it is up to the client and/or user to remove out of date ones.", 
            "title": "\u4f4d\u7f6e"
        }, 
        {
            "location": "/EthashDashimoto/Ethash-DAG/#_2", 
            "text": "Each file should begin with an 8-byte magic number,  0xfee1deadbaddcafe , written in little-endian format (i.e., bytes  fe ca dd ba ad de e1 fe ).  The Ethash algorithm expects the DAG as a two-dimensional array of uint32s (4-byte unsigned ints), with dimension (n   16) where n is a large number. (n starts at 16777186 and grows from there.) Following the magic number, the rows of the DAG should be written sequentially into the file, with no delimiter between rows and each unint32 encoded in little-endian format.", 
            "title": "\u683c\u5f0f"
        }, 
        {
            "location": "/Whisper/", 
            "text": "\u79c1\u8bed Whisper\n\n\nIn a nutshell whisper is a communication protocol for DApps to communicate with each other.\n\n\n\u4f7f\u7528\u5b9e\u4f8b\n\n\n\n\n\n\nDApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.\n\n\n\n\n\n\nDApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.\n\n\n\n\n\n\nDApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.\n\n\n\n\n\n\nDApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.\n\n\n\n\n\n\nIn general, think transactions, but without the eventual archival, any necessity of being bound to what is said or automated execution \n state change.\n\n\n\u89c4\u683c\n\n\n\n\nLow-level\n API only exposed to DApps, never to users.\n\n\nLow-bandwidth\n Not designed for large data transfers.\n\n\nUncertain-latency\n Not designed for RTC.\n\n\nDark\n No reliable methods for tracing packets or\n\n\nTypical usage:\n\n\nLow-latency, 1-1 or 1-N signalling messages.\n\n\nHigh latency, high TTL 1-* publication messages.\n\n\n\n\nMessages less than 64K bytes, typically around 256 bytes.\n\n\n\u73b0\u6709\u89e3\u51b3\u65b9\u6848\n\n\n\n\nUDP: Similar in API-level, native multicasting. No TTL, security or privacy safeguards.\n\n\n0MQ\n: A distributed messaging system, no inherent privacy safeguards.\n\n\nBitmessage\n: Similar in the basic approach of P2P network exchanging messages with baseline PKI for dark comms. Higher-level (e-mail replacement, only \"several thousand/day\", larger mails), fixed TTL and no hinting to optimise for throughput. Unclear incentivisation.\n\n\nTeleHash\n: Secure connection-orientated RTC comms. Similar in approach to BitTorrent (uses modified Kademila tech), but rather than discovering peers for a given hash, it routes to the recipient given its hash. Uses DHT to do deterministic routing therefore insecure against simple statistical packet-analysis attacks against a large-scale attacker. Connection oriented, so no TTL and not designed for asynchronous data publication.\n\n\nTox\n: Higher-level (IM \n AV chat) replacement.\n\n\n\n\n\u57fa\u672c\u8bbe\u8ba1\n\n\nUses the \n\"shh\"\n protocol string of \u00d0\u039eVP2P.\n\n\nRest coming soon, once I've finished prototyping. Gav.\n\n\n\u6253\u8d25\u6d41\u91cf\u5206\u6790\u7684\u601d\u8003\n\n\n(from lokiverloren) All existing protocols for location obscured instant messaging have complicated problems to do with routing.\n\n\nThe Bitmessage protocol propagates messages blindly across the network, and the proper recipient knows how to decrypt it and receives it (just like everyone else) but then stores it and lets its' user know it's got a new message. The problem with this of course is that it greatly increases the exposure of the whole network to a body of encrypted material that ideally should not be easily accessed at all.\n\n\nNone of the others listed above particularly have any means to hide the source and destination of messages. I believe it is one of the core objectives of the Whisper protocol to hide location of sender and receiver and in transit, make it difficult if not impossible to establish one, the other or both.\n\n\nThe Tor system has a protocol for enabling connections between two nodes without either knowing where the other is, it is the Rendezvous protocol used for hidden services. Most readers of this will already understand how it works, but what happens is that a hidden service (the equivalent of a server listening on a port in the TCP/IP protocol) selects at random a number (I think, usually 6) 'introducer' nodes. In order to do this it establishes the standard 3-hop chain to each of the introducers, and when a user wants to establish a connection with a hidden service, they propagate a request to connect with hidden service that is associated with a particular public key. I'm not sure about how this request is propagated, obviously it would also have to be done through a circuit or the rendezvous introducer node knows who might be about to establish a circuit. Once one's client knows a valid rendezvous node it then establishes a connection to it and requests to have traffic relayed through its' circuit to the hidden service.\n\n\nI think there really isn't a better way to implement 'dark' parts of the connection protocol, because there has to be a different identity for a relay node as a client node, the same principle applies in Ethereum. However, using the rendezvous, it again makes possible something for connections between nodes that know each other (though they don't know the account or identity of the initiator) something other than the uniform 3 hop circuit. For generating a circuit to an exit node in Tor, it is of no danger that your client knows the identity of the relays in each hop along the way, but to do that \nwithin\n the network compromises location obfuscation security, tying your ethereum identity with your router identity (I think it may need to be explicitly pointed out that routing function is something that Ethereum nodes will perform).  When connecting to a rendezvous, you do not thereby reveal your location to the rendezvous, and the rendezvous does not know the location of the hidden service either, and establishing these connections only requires a public directory to be created for routers. It is not consequential information for an attacker and can be revealed directly by probing for a relevant server at your IP addresses anyway.\n\n\nThe contribution I would like to make to the discussion is this:\n\n\n\n\n\n\nIt is implied that the whisper protocol has to work through a system of location obfuscation relays like Tor. Not only this, but it must therefore also be using some form of the rendezvous protocol used in Tor for hidden services.\n\n\n\n\n\n\nHowever, as Tor was originally designed first to be a way to stop webservers logging your IP address in association with a session cookie and record, then secondarily added the ability to implement the equivalent of TCP/IP routing (listening ports) within the context of location obfuscation in the form of the rendezvous protocol, it is an artifact, a legacy of the first purpose that leads to the uniform utilisation of 3 hop nodes and connections that remain open rather than a session (connectionless) protocol like used in HTTP. What I suggest is that, depending on the needs of a particular connection, there can be occasion to mix up the obfuscation process so that it is further obscured from traffic analysis in the case of malicious nodes performing data gathering for an attacker.\n\n\n\n\n\n\nInstead of a connection like is normal between a browser and web server, for example, which is usually left open because of the latency of reestablishing such a connection, to make further requests, instead there can be a session cookie, and then you can alter the way your client sends data through the 'connection' to a hidden node. The connection, between two routing nodes, could be direct, 1 proxy intermediary, 2, or 3, it could use shared secrets instead and route fragments of datagrams across multiple heteregenous circuits, as well, and the receiver would then wait for sufficient fragments to assemble the original packets. Indeed, it could be possible in the case of (not quite related to whisper, but to the distributed data storage protocol) larger streams, break the stream up into parts and alter the obfuscation method through the process, further confusing the traffic analysis data.\n\n\nThe same considerations apply, fundamentally, the only differences have to do with the size of the data being transmitted, whether it's for a messaging system or distributed filesystem. The other criteria for deciding how to scramble the routing is latency. For some purposes one wants lower latency, and other purposes, greater security is vitally important. When in the process streams are fragmented into parts, it can also increase security to apply an All Or Nothing Transform to the entire package, then if part is intercepted but not the complete message, it is impossible to assemble the data, not even for cryptanalysis purposes.", 
            "title": "\u4f4e\u8bed\u63d0\u8bae"
        }, 
        {
            "location": "/Whisper/#whisper", 
            "text": "In a nutshell whisper is a communication protocol for DApps to communicate with each other.", 
            "title": "\u79c1\u8bed Whisper"
        }, 
        {
            "location": "/Whisper/#_1", 
            "text": "DApps that need to publish small amounts of information to each other and have the publication last some substantial amount of time. For example, a currency exchange DApp may use it to record an offer to sell some currency at a particular rate on an exchange. In this case, it may last anything between tens of minutes and days. The offer wouldn't be binding, merely a hint to get a potential deal started.    DApps that need to signal to each other in order to ultimately collaborate on a transaction. For example, a currency exchange DApp may use it to coordinate an offer prior to creating one (or two, depending on how the exchange is structured) transactions on the exchange.    DApps that need to provide non-real-time hinting or general communications between each other. E.g. a small chat-room app.    DApps that need to provide dark (plausible denial over perfect network traffic analysis) comms to two correspondents that know nothing of each other but a hash. This could be a DApp for a whistleblower to communicate to a known journalist exchange some small amount of verifiable material and arrange between themselves for some other protocol (Swarm, perhaps) to handle the bulk transfer.    In general, think transactions, but without the eventual archival, any necessity of being bound to what is said or automated execution   state change.", 
            "title": "\u4f7f\u7528\u5b9e\u4f8b"
        }, 
        {
            "location": "/Whisper/#_2", 
            "text": "Low-level  API only exposed to DApps, never to users.  Low-bandwidth  Not designed for large data transfers.  Uncertain-latency  Not designed for RTC.  Dark  No reliable methods for tracing packets or  Typical usage:  Low-latency, 1-1 or 1-N signalling messages.  High latency, high TTL 1-* publication messages.   Messages less than 64K bytes, typically around 256 bytes.", 
            "title": "\u89c4\u683c"
        }, 
        {
            "location": "/Whisper/#_3", 
            "text": "UDP: Similar in API-level, native multicasting. No TTL, security or privacy safeguards.  0MQ : A distributed messaging system, no inherent privacy safeguards.  Bitmessage : Similar in the basic approach of P2P network exchanging messages with baseline PKI for dark comms. Higher-level (e-mail replacement, only \"several thousand/day\", larger mails), fixed TTL and no hinting to optimise for throughput. Unclear incentivisation.  TeleHash : Secure connection-orientated RTC comms. Similar in approach to BitTorrent (uses modified Kademila tech), but rather than discovering peers for a given hash, it routes to the recipient given its hash. Uses DHT to do deterministic routing therefore insecure against simple statistical packet-analysis attacks against a large-scale attacker. Connection oriented, so no TTL and not designed for asynchronous data publication.  Tox : Higher-level (IM   AV chat) replacement.", 
            "title": "\u73b0\u6709\u89e3\u51b3\u65b9\u6848"
        }, 
        {
            "location": "/Whisper/#_4", 
            "text": "Uses the  \"shh\"  protocol string of \u00d0\u039eVP2P.  Rest coming soon, once I've finished prototyping. Gav.", 
            "title": "\u57fa\u672c\u8bbe\u8ba1"
        }, 
        {
            "location": "/Whisper/#_5", 
            "text": "(from lokiverloren) All existing protocols for location obscured instant messaging have complicated problems to do with routing.  The Bitmessage protocol propagates messages blindly across the network, and the proper recipient knows how to decrypt it and receives it (just like everyone else) but then stores it and lets its' user know it's got a new message. The problem with this of course is that it greatly increases the exposure of the whole network to a body of encrypted material that ideally should not be easily accessed at all.  None of the others listed above particularly have any means to hide the source and destination of messages. I believe it is one of the core objectives of the Whisper protocol to hide location of sender and receiver and in transit, make it difficult if not impossible to establish one, the other or both.  The Tor system has a protocol for enabling connections between two nodes without either knowing where the other is, it is the Rendezvous protocol used for hidden services. Most readers of this will already understand how it works, but what happens is that a hidden service (the equivalent of a server listening on a port in the TCP/IP protocol) selects at random a number (I think, usually 6) 'introducer' nodes. In order to do this it establishes the standard 3-hop chain to each of the introducers, and when a user wants to establish a connection with a hidden service, they propagate a request to connect with hidden service that is associated with a particular public key. I'm not sure about how this request is propagated, obviously it would also have to be done through a circuit or the rendezvous introducer node knows who might be about to establish a circuit. Once one's client knows a valid rendezvous node it then establishes a connection to it and requests to have traffic relayed through its' circuit to the hidden service.  I think there really isn't a better way to implement 'dark' parts of the connection protocol, because there has to be a different identity for a relay node as a client node, the same principle applies in Ethereum. However, using the rendezvous, it again makes possible something for connections between nodes that know each other (though they don't know the account or identity of the initiator) something other than the uniform 3 hop circuit. For generating a circuit to an exit node in Tor, it is of no danger that your client knows the identity of the relays in each hop along the way, but to do that  within  the network compromises location obfuscation security, tying your ethereum identity with your router identity (I think it may need to be explicitly pointed out that routing function is something that Ethereum nodes will perform).  When connecting to a rendezvous, you do not thereby reveal your location to the rendezvous, and the rendezvous does not know the location of the hidden service either, and establishing these connections only requires a public directory to be created for routers. It is not consequential information for an attacker and can be revealed directly by probing for a relevant server at your IP addresses anyway.  The contribution I would like to make to the discussion is this:    It is implied that the whisper protocol has to work through a system of location obfuscation relays like Tor. Not only this, but it must therefore also be using some form of the rendezvous protocol used in Tor for hidden services.    However, as Tor was originally designed first to be a way to stop webservers logging your IP address in association with a session cookie and record, then secondarily added the ability to implement the equivalent of TCP/IP routing (listening ports) within the context of location obfuscation in the form of the rendezvous protocol, it is an artifact, a legacy of the first purpose that leads to the uniform utilisation of 3 hop nodes and connections that remain open rather than a session (connectionless) protocol like used in HTTP. What I suggest is that, depending on the needs of a particular connection, there can be occasion to mix up the obfuscation process so that it is further obscured from traffic analysis in the case of malicious nodes performing data gathering for an attacker.    Instead of a connection like is normal between a browser and web server, for example, which is usually left open because of the latency of reestablishing such a connection, to make further requests, instead there can be a session cookie, and then you can alter the way your client sends data through the 'connection' to a hidden node. The connection, between two routing nodes, could be direct, 1 proxy intermediary, 2, or 3, it could use shared secrets instead and route fragments of datagrams across multiple heteregenous circuits, as well, and the receiver would then wait for sufficient fragments to assemble the original packets. Indeed, it could be possible in the case of (not quite related to whisper, but to the distributed data storage protocol) larger streams, break the stream up into parts and alter the obfuscation method through the process, further confusing the traffic analysis data.  The same considerations apply, fundamentally, the only differences have to do with the size of the data being transmitted, whether it's for a messaging system or distributed filesystem. The other criteria for deciding how to scramble the routing is latency. For some purposes one wants lower latency, and other purposes, greater security is vitally important. When in the process streams are fragmented into parts, it can also increase security to apply an All Or Nothing Transform to the entire package, then if part is intercepted but not the complete message, it is impossible to assemble the data, not even for cryptanalysis purposes.", 
            "title": "\u6253\u8d25\u6d41\u91cf\u5206\u6790\u7684\u601d\u8003"
        }, 
        {
            "location": "/Whisper/Overview/", 
            "text": "\u6982\u8ff0\n\n\n\u793a\u4f8b\n\n\nExample (\"Dream\") API Usage\n\n\nvar\n \nshh\n \n=\n \nweb3\n.\nshh\n;\n\n\nvar\n \nappName\n \n=\n \nMy silly app!\n;\n\n\nvar\n \nmyName\n \n=\n \nGav Would\n;\n\n\nvar\n \nmyIdentity\n \n=\n \nshh\n.\nnewIdentity\n();\n\n\n\nshh\n.\npost\n({\n\n  \nfrom\n:\n \nmyIdentity\n,\n\n  \ntopics\n:\n \n[\n \nweb3\n.\nfromAscii\n(\nappName\n)\n \n],\n\n  \npayload\n:\n \n[\n \nweb3\n.\nfromAscii\n(\nmyName\n),\n \nweb3\n.\nfromAscii\n(\nWhat is your name?\n)\n \n],\n\n  \nttl\n:\n \n100\n,\n\n  \npriority\n:\n \n1000\n\n\n});\n\n\n\nvar\n \nreplyWatch\n \n=\n \nshh\n.\nwatch\n({\n\n  \ntopics\n:\n \n[\n \nweb3\n.\nfromAscii\n(\nappName\n),\n \nmyIdentity\n \n],\n\n  \nto\n:\n \nmyIdentity\n\n\n});\n\n\n// could be \ntopic\n: [ web3.fromAscii(appName), null ] if we wanted to filter all such\n\n\n// messages for this app, but we\nd be unable to read the contents.\n\n\n\nreplyWatch\n.\narrived\n(\nfunction\n(\nm\n)\n\n\n{\n\n  \n// new message m\n\n  \nconsole\n.\nlog\n(\nReply from \n \n+\n \nweb3\n.\ntoAscii\n(\nm\n.\npayload\n)\n \n+\n \n whose address is \n \n+\n \nm\n.\nfrom\n);\n\n\n});\n\n\n\nvar\n \nbroadcastWatch\n \n=\n \nshh\n.\nwatch\n({\n \ntopic\n:\n \n[\n \nweb3\n.\nfromAscii\n(\nappName\n)\n \n]\n \n});\n\n\nbroadcastWatch\n.\narrived\n(\nfunction\n(\nm\n)\n\n\n{\n\n  \nif\n \n(\nm\n.\nfrom\n \n!=\n \nmyIdentity\n)\n\n  \n{\n\n    \n// new message m: someone\ns asking for our name. Let\ns tell them.\n\n    \nvar\n \nbroadcaster\n \n=\n \nweb3\n.\ntoAscii\n(\nm\n.\npayload\n).\nsubstr\n(\n0\n,\n \n32\n);\n\n    \nconsole\n.\nlog\n(\nBroadcast from \n \n+\n \nbroadcaster\n \n+\n \n; replying to tell them our name.\n);\n\n    \nshh\n.\npost\n({\n\n      \nfrom\n:\n \neth\n.\nkey\n,\n\n      \nto\n:\n \nm\n.\nfrom\n,\n\n      \ntopics\n:\n \n[\n \neth\n.\nfromAscii\n(\nappName\n),\n \nm\n.\nfrom\n \n],\n\n      \npayload\n:\n \n[\n \neth\n.\nfromAscii\n(\nmyName\n)\n \n],\n\n      \nttl\n:\n \n2\n,\n\n      \npriority\n:\n \n500\n\n    \n});\n\n  \n}\n\n\n});\n\n\n\n\n\n\u57fa\u672c\u64cd\u4f5c\n\n\npost\n takes a JSON object containing four key parameters:\n\n\nshh\n.\npost\n({\n \ntopics\n:\n \nt\n,\n \npayload\n:\n \np\n,\n \nttl\n:\n \nttl\n,\n \nworkToProve\n:\n \nwork\n \n});\n\n\n\n\n\n\n\ntopic\n, provided as either a list of, or a single, arbitrary data items that are used to encode the abstract topic of this message, later used to filter messages for those that are of interest;\n\n\npayload\n, provided similarly to topic but left as an unformatted byte array provides the data to be sent.\n\n\nttl\n is a time for the message to live on the network, specified in seconds. This defaults to 50.\n\n\nwork\n is the amount of priority you want the packet to have on the network. It is specified in milliseconds of processing time on your machine. This defaults to 50.\n\n\n\n\nTwo other parameters optionally specify the addressing: recipient (\nto\n), sender (\nfrom\n). The latter is meaningless unless a recipient has been specified.\n\n\n\u4f7f\u7528\u5b9e\u4f8b\n\n\n\n\nshh.post({ \"topic\": t, \"payload\": p });\n No signature, no encryption: Anonymous broadcast; a bit like an anonymous subject-filtered twitter feed.\n\n\nshh.post({ \"from\": myIdentity, \"topic\": t, \"payload\": p });\n Open signature, no encryption: Clear-signed broadcast; a bit like a normal twitter feed - anyone interested can see a particular identity is sending particular stuff out to no-one in particular.\n\n\nshh.post({ \"to\": recipient, \"topic\": t, \"payload\": p });\n No signature, encryption: Encrypted anonymous message; a bit like an anonymous drop-box - message is private to the owner of the dropbox. They can't tell from whom it is.\n\n\nshh.post({ \"from\": myIdentity, \"to\": recipient, \"topic\": t, \"payload\": p });\n Secret signature, encryption: Encrypted signed message; like a secure e-mail. One identity tells another something - nobody else can read it. The recipient alone knows it came from the sender.\n\n\nshh.post({ \"from\": myIdentity, \"to\": recipient, \"topic\": t, \"payload\": p, \"deniable\": d });\n Secret signature, encryption with optional plausible deniability. If boolean parameter \nd\n is \nfalse\n, it is equivalent to the previous call. If \nd\n is \ntrue\n, recipient cannot prove to any third party that the message originates from sender, though still can verify it for herself. This is achieved by the digital signature being calculated on the symmetric session encryption key instead of the message body.\n\n\n\n\nIn addition to the basic use cases, there will also be support for secure multi-casting. For this, you set up a group with \nshh.newGroup\n:\n\n\nvar\n \ngroup\n \n=\n \nshh\n.\nnewGroup\n(\neth\n.\nkey\n,\n \n[\n \nrecipient1\n,\n \nrecipient2\n \n]);\n\n\n\n\n\nThen can use this as a recipient as you would normally:\n\n\nshh\n.\npost\n({\n \nfrom\n:\n \neth\n.\nkey\n,\n \nto\n:\n \ngroup\n,\n \ntopic\n:\n \nt\n,\n \npayload\n:\n \np\n \n});\n\n\n\n\n\nThe \nnewGroup\n actually does something like:\n\n\nvar\n \ngroup\n \n=\n \nshh\n.\nnewIdentity\n();\n\n\nshh\n.\npost\n([\n \nfrom\n:\n \nmyIdentity\n,\n \nto\n:\n \nrecipient1\n,\n \ntopic\n:\n \n[\ninvSHA3\n(\n2\n^\n255\n),\n \nrecipient1\n],\n \npayload\n:\n \nsecretFromPublic\n(\ngroup\n)\n \n]);\n\n\nshh\n.\npost\n([\n \nfrom\n:\n \nmyIdentity\n,\n \nto\n:\n \nrecipient2\n,\n \ntopic\n:\n \n[\ninvSHA3\n(\n2\n^\n255\n),\n \nrecipient2\n],\n \npayload\n:\n \nsecretFromPublic\n(\ngroup\n)\n \n]);\n\n\nreturn\n \nkeypair\n;\n\n\n\n\n\nHere, the \ninvSHA3(2^255)\n topic is a sub-band topic (intercepted by the Whisper protocol layer) which takes the key and adds it to the key database. When a packet is addressed to \ngroup\n, it encrypts with group's public key. \ngroup\n is not generally used for signing. \nsecretFromPublic\n obviously isn't a public API and invSHA3 is only possible because we know each item of the topic is SHA3ed prior to amalgamation in the final topic.\n\n\nWhen signing a message (one with a \nfrom\n parameter), the message-hash is the hash of the clear-text (unencrypted) payload.\n\n\nTopics is constructed from a number of components - this simply compresses (sha3 + crop) each into a final set of 4-byte crypto-secure hashes. When composing filters, it's the same process. Importantly, all such hashes given in the filters must be includes in.\n\n\nTo filter on sender/recipient, they should be encoded within the topic by the sender.\n\n\n\u9759\u97f3\u8fd0\u884c\n\n\nIn normal operation (and assuming a non-degenerate attack condition), there is a trade-off between true anonymity/plausible deniability over ones communications and efficiency of operation. The more one advertises to ones peers attempting to \"fish\" for useful messages and steer such message towards oneself, the more one reveals to ones peers.\n\n\nFor a securely anonymous dynamic two-way conversation, this trade-off becomes problematic; significant topic-advertising would be necessary for the point-to-point conversation to happen with sensible latency and yet so little about the topic can be advertised to guide messages home without revealing substantial information should there be adversary peers around an endpoint. (If substantial numbers of adversary peers surround both endpoints, a tunnelling system similar to TOR must be used to guarantee security.)\n\n\nIn this situation, dynamic topic generation would be used. This effectively turns the datagram-orientated channel into a connection-oriented channel. The endpoint to begin the conversation sends a point-to-point (i.e. signed and encrypted) conversation-begin message that contains a randomly chosen 256-bit topic seed. The seed is combined (by both endpoints) with a message nonce (beginning at 0 and incrementing over the course of the conversation) to provide a secure chain of single-use topics. It then generates a bloom filter using randomly selected bits from the new topic to match against and gives the filter to its peers; once a randomly selected minimum of messages fitting this filter have been collected (we assume one of these is the message we are interested in), we send our reply, deriving a new topic (incrementing the nonce), then advertise for that with yet another topic (another nonce increment) with another randomly selected group of bits.", 
            "title": "\u8033\u8bed\u6982\u8ff0"
        }, 
        {
            "location": "/Whisper/Overview/#_1", 
            "text": "", 
            "title": "\u6982\u8ff0"
        }, 
        {
            "location": "/Whisper/Overview/#_2", 
            "text": "Example (\"Dream\") API Usage  var   shh   =   web3 . shh ;  var   appName   =   My silly app! ;  var   myName   =   Gav Would ;  var   myIdentity   =   shh . newIdentity ();  shh . post ({ \n   from :   myIdentity , \n   topics :   [   web3 . fromAscii ( appName )   ], \n   payload :   [   web3 . fromAscii ( myName ),   web3 . fromAscii ( What is your name? )   ], \n   ttl :   100 , \n   priority :   1000  });  var   replyWatch   =   shh . watch ({ \n   topics :   [   web3 . fromAscii ( appName ),   myIdentity   ], \n   to :   myIdentity  });  // could be  topic : [ web3.fromAscii(appName), null ] if we wanted to filter all such  // messages for this app, but we d be unable to read the contents.  replyWatch . arrived ( function ( m )  { \n   // new message m \n   console . log ( Reply from    +   web3 . toAscii ( m . payload )   +    whose address is    +   m . from );  });  var   broadcastWatch   =   shh . watch ({   topic :   [   web3 . fromAscii ( appName )   ]   });  broadcastWatch . arrived ( function ( m )  { \n   if   ( m . from   !=   myIdentity ) \n   { \n     // new message m: someone s asking for our name. Let s tell them. \n     var   broadcaster   =   web3 . toAscii ( m . payload ). substr ( 0 ,   32 ); \n     console . log ( Broadcast from    +   broadcaster   +   ; replying to tell them our name. ); \n     shh . post ({ \n       from :   eth . key , \n       to :   m . from , \n       topics :   [   eth . fromAscii ( appName ),   m . from   ], \n       payload :   [   eth . fromAscii ( myName )   ], \n       ttl :   2 , \n       priority :   500 \n     }); \n   }  });", 
            "title": "\u793a\u4f8b"
        }, 
        {
            "location": "/Whisper/Overview/#_3", 
            "text": "post  takes a JSON object containing four key parameters:  shh . post ({   topics :   t ,   payload :   p ,   ttl :   ttl ,   workToProve :   work   });    topic , provided as either a list of, or a single, arbitrary data items that are used to encode the abstract topic of this message, later used to filter messages for those that are of interest;  payload , provided similarly to topic but left as an unformatted byte array provides the data to be sent.  ttl  is a time for the message to live on the network, specified in seconds. This defaults to 50.  work  is the amount of priority you want the packet to have on the network. It is specified in milliseconds of processing time on your machine. This defaults to 50.   Two other parameters optionally specify the addressing: recipient ( to ), sender ( from ). The latter is meaningless unless a recipient has been specified.", 
            "title": "\u57fa\u672c\u64cd\u4f5c"
        }, 
        {
            "location": "/Whisper/Overview/#_4", 
            "text": "shh.post({ \"topic\": t, \"payload\": p });  No signature, no encryption: Anonymous broadcast; a bit like an anonymous subject-filtered twitter feed.  shh.post({ \"from\": myIdentity, \"topic\": t, \"payload\": p });  Open signature, no encryption: Clear-signed broadcast; a bit like a normal twitter feed - anyone interested can see a particular identity is sending particular stuff out to no-one in particular.  shh.post({ \"to\": recipient, \"topic\": t, \"payload\": p });  No signature, encryption: Encrypted anonymous message; a bit like an anonymous drop-box - message is private to the owner of the dropbox. They can't tell from whom it is.  shh.post({ \"from\": myIdentity, \"to\": recipient, \"topic\": t, \"payload\": p });  Secret signature, encryption: Encrypted signed message; like a secure e-mail. One identity tells another something - nobody else can read it. The recipient alone knows it came from the sender.  shh.post({ \"from\": myIdentity, \"to\": recipient, \"topic\": t, \"payload\": p, \"deniable\": d });  Secret signature, encryption with optional plausible deniability. If boolean parameter  d  is  false , it is equivalent to the previous call. If  d  is  true , recipient cannot prove to any third party that the message originates from sender, though still can verify it for herself. This is achieved by the digital signature being calculated on the symmetric session encryption key instead of the message body.   In addition to the basic use cases, there will also be support for secure multi-casting. For this, you set up a group with  shh.newGroup :  var   group   =   shh . newGroup ( eth . key ,   [   recipient1 ,   recipient2   ]);   Then can use this as a recipient as you would normally:  shh . post ({   from :   eth . key ,   to :   group ,   topic :   t ,   payload :   p   });   The  newGroup  actually does something like:  var   group   =   shh . newIdentity ();  shh . post ([   from :   myIdentity ,   to :   recipient1 ,   topic :   [ invSHA3 ( 2 ^ 255 ),   recipient1 ],   payload :   secretFromPublic ( group )   ]);  shh . post ([   from :   myIdentity ,   to :   recipient2 ,   topic :   [ invSHA3 ( 2 ^ 255 ),   recipient2 ],   payload :   secretFromPublic ( group )   ]);  return   keypair ;   Here, the  invSHA3(2^255)  topic is a sub-band topic (intercepted by the Whisper protocol layer) which takes the key and adds it to the key database. When a packet is addressed to  group , it encrypts with group's public key.  group  is not generally used for signing.  secretFromPublic  obviously isn't a public API and invSHA3 is only possible because we know each item of the topic is SHA3ed prior to amalgamation in the final topic.  When signing a message (one with a  from  parameter), the message-hash is the hash of the clear-text (unencrypted) payload.  Topics is constructed from a number of components - this simply compresses (sha3 + crop) each into a final set of 4-byte crypto-secure hashes. When composing filters, it's the same process. Importantly, all such hashes given in the filters must be includes in.  To filter on sender/recipient, they should be encoded within the topic by the sender.", 
            "title": "\u4f7f\u7528\u5b9e\u4f8b"
        }, 
        {
            "location": "/Whisper/Overview/#_5", 
            "text": "In normal operation (and assuming a non-degenerate attack condition), there is a trade-off between true anonymity/plausible deniability over ones communications and efficiency of operation. The more one advertises to ones peers attempting to \"fish\" for useful messages and steer such message towards oneself, the more one reveals to ones peers.  For a securely anonymous dynamic two-way conversation, this trade-off becomes problematic; significant topic-advertising would be necessary for the point-to-point conversation to happen with sensible latency and yet so little about the topic can be advertised to guide messages home without revealing substantial information should there be adversary peers around an endpoint. (If substantial numbers of adversary peers surround both endpoints, a tunnelling system similar to TOR must be used to guarantee security.)  In this situation, dynamic topic generation would be used. This effectively turns the datagram-orientated channel into a connection-oriented channel. The endpoint to begin the conversation sends a point-to-point (i.e. signed and encrypted) conversation-begin message that contains a randomly chosen 256-bit topic seed. The seed is combined (by both endpoints) with a message nonce (beginning at 0 and incrementing over the course of the conversation) to provide a secure chain of single-use topics. It then generates a bloom filter using randomly selected bits from the new topic to match against and gives the filter to its peers; once a randomly selected minimum of messages fitting this filter have been collected (we assume one of these is the message we are interested in), we send our reply, deriving a new topic (incrementing the nonce), then advertise for that with yet another topic (another nonce increment) with another randomly selected group of bits.", 
            "title": "\u9759\u97f3\u8fd0\u884c"
        }, 
        {
            "location": "/Whisper/Wire-Protocol/", 
            "text": "PoC-1 \u6709\u7ebf\u534f\u8bae\n\n\nPeer-to-peer communications between nodes running Whisper clients run using the underlying \n\u00d0\u039eVp2p Wire Protocol\n.\n\n\nThis is a preliminary wire protocol for the Whisper subsystem. It will change.\n\n\n\u8033\u8bed\u5b50\u534f\u8bae\n\n\nStatus\n\n[\n+0x00\n: \nP\n, \nprotocolVersion\n: \nP\n] Inform a peer of the \nwhisper\n status. This message should be send \nafter\n the initial handshake and \nprior\n to any \nwhisper\n related messages.\n\n\n\n\nprotocolVersion\n is one of:\n\n\n0x02\n for PoC-7.\n\n\n\n\n\n\n\n\nMessages\n\n[\n+0x01\n: \nP\n, [\nexpiry1\n: \nP\n, \nttl1\n: \nP\n, [\ntopic1x1\n: \nB_4\n, \ntopic1x2\n: \nB_4\n, ...], \ndata1\n: \nB\n, \nnonce1\n: \nP\n], [\nexpiry2\n: \nP\n, ...], ...] Specify one or more messages. Nodes should not resend the same message to a peer in the same session, nor send a message back to a peer from which it received. This packet may be empty. The packet must be sent at least once per second, and only after receiving a \nMessages\n message from the peer.\n\n\n\u4f1a\u8bdd\u7ba1\u7406\n\n\nFor the Whisper sub-protocol, upon an active session, a \nStatus\n message must be sent. Following the reception of the peer's \nStatus\n message, the Whisper session is active. The peer with the greatest Node Id should send a \nMessages\n message to begin the message rally. From that point, peers take it in turns to send (possibly empty) Messages packets.", 
            "title": "PoC-1 \u6709\u7ebf\u534f\u8bae"
        }, 
        {
            "location": "/Whisper/Wire-Protocol/#poc-1", 
            "text": "Peer-to-peer communications between nodes running Whisper clients run using the underlying  \u00d0\u039eVp2p Wire Protocol .  This is a preliminary wire protocol for the Whisper subsystem. It will change.", 
            "title": "PoC-1 \u6709\u7ebf\u534f\u8bae"
        }, 
        {
            "location": "/Whisper/Wire-Protocol/#_1", 
            "text": "Status \n[ +0x00 :  P ,  protocolVersion :  P ] Inform a peer of the  whisper  status. This message should be send  after  the initial handshake and  prior  to any  whisper  related messages.   protocolVersion  is one of:  0x02  for PoC-7.     Messages \n[ +0x01 :  P , [ expiry1 :  P ,  ttl1 :  P , [ topic1x1 :  B_4 ,  topic1x2 :  B_4 , ...],  data1 :  B ,  nonce1 :  P ], [ expiry2 :  P , ...], ...] Specify one or more messages. Nodes should not resend the same message to a peer in the same session, nor send a message back to a peer from which it received. This packet may be empty. The packet must be sent at least once per second, and only after receiving a  Messages  message from the peer.", 
            "title": "\u8033\u8bed\u5b50\u534f\u8bae"
        }, 
        {
            "location": "/Whisper/Wire-Protocol/#_2", 
            "text": "For the Whisper sub-protocol, upon an active session, a  Status  message must be sent. Following the reception of the peer's  Status  message, the Whisper session is active. The peer with the greatest Node Id should send a  Messages  message to begin the message rally. From that point, peers take it in turns to send (possibly empty) Messages packets.", 
            "title": "\u4f1a\u8bdd\u7ba1\u7406"
        }, 
        {
            "location": "/Whisper/PoC-2-Wire-Protocol/", 
            "text": "Peer-to-peer communications between nodes running Whisper clients run using the underlying \n\u00d0\u039eVp2p Wire Protocol\n.\n\n\nThis is a preliminary wire protocol for the Whisper subsystem. It will change.\n\n\nWhisper Sub-protocol\n\n\nStatus\n\n[\n+0x00\n: \nP\n, \nprotocolVersion\n: \nP\n] Inform a peer of the \nwhisper\n status. This message should be send \nafter\n the initial handshake and \nprior\n to any \nwhisper\n related messages.\n* \nprotocolVersion\n is one of:\n    * \n0x02\n for PoC-7.\n\n\nMessages\n\n[\n+0x01\n: \nP\n, [\nexpiry1\n: \nP\n, \nttl1\n: \nP\n, [\ntopic1x1\n: \nB_4\n, \ntopic1x2\n: \nB_4\n, ...], \ndata1\n: \nB\n, \nnonce1\n: \nP\n], [\nexpiry2\n: \nP\n, ...], ...] Specify one or more messages. Nodes should not resend the same message to a peer in the same session, nor send a message back to a peer from which it received. This packet may be empty. The packet must be sent at least once per second, and only after receiving a \nMessages\n message from the peer.\n\n\nTopicFilter\n\n[\n+0x02\n: \nP\n, \nbloom\n: \nB_64\n] Specify the bloom filter of the topics that the sender is interested in. The bloom method is defined below.\n\n\nSession Management\n\n\nFor the Whisper sub-protocol, upon an active session, a \nStatus\n message must be sent. Following the reception of the peer's \nStatus\n message, the Whisper session is active. The peer with the greatest Node Id should send a \nMessages\n message to begin the message rally. From that point, peers take it in turns to send (possibly empty) Messages packets.\n\n\nTopics and Abridged Topics\n\n\nTopics\n are 32-byte hashes, typically generated from \u00d0App-specified data. The \nabridged topic\n is the first 4 bytes of the topic. Abridged topics allow the identification (within the bounds of an acceptably high probability) of a given topic, useful for determining the utility of a topic for a given peer, yet do not give away the full topic information itself, allowing it to be used as a strong encryption key whose secret is not inherently available.\n\n\nBloomed Topics\n\n\nThe Bloom filter used in the \nTopicFilter\n message type is a means a identifying a number of topics to a peer without compromising (too much) privacy over precisely what topics are of interest. Precise control over the information content (and thus efficiency of the filter) may be maintained through the addition of bits.\n\n\nBlooms are formed by the bitwise OR operation on a number of bloomed topics. The bloom function takes the abridged topic (the first four bytes of the SHA3 of the \u00d0App/user level topic description) and projects them onto a 512-bit slice; in total, three bits are marked for each bloomed topic.\n\n\nThe projection function is defined as a mapping from a a 4-byte slice \nS\n to a 512-bit slice \nD\n; for ease of explanation, \nS\n will dereference to bytes, whereas \nD\n will dereference to bits.\n\n\nLET D[*] = 0\nFOREACH i IN { 0, 1, 2 } DO\nLET n = S[i]\nIF S[3] \n (2 ** i) THEN n += 512\nD[n] = 1\nEND FOR\n\n\n\n\nIn formal notation:\n\nD[i] := f(0) == i || f(1) == i || f(2) == i\n\n\nwhere:\n\nf(x) := S[x] + S[3][x] * 512\n\n\n(assuming a byte value \nS[i]\n may be further dereferenced into a bit value)", 
            "title": "PoC-2 \u6709\u7ebf\u534f\u8bae"
        }, 
        {
            "location": "/Whisper/PoC-2-Wire-Protocol/#whisper-sub-protocol", 
            "text": "Status \n[ +0x00 :  P ,  protocolVersion :  P ] Inform a peer of the  whisper  status. This message should be send  after  the initial handshake and  prior  to any  whisper  related messages.\n*  protocolVersion  is one of:\n    *  0x02  for PoC-7.  Messages \n[ +0x01 :  P , [ expiry1 :  P ,  ttl1 :  P , [ topic1x1 :  B_4 ,  topic1x2 :  B_4 , ...],  data1 :  B ,  nonce1 :  P ], [ expiry2 :  P , ...], ...] Specify one or more messages. Nodes should not resend the same message to a peer in the same session, nor send a message back to a peer from which it received. This packet may be empty. The packet must be sent at least once per second, and only after receiving a  Messages  message from the peer.  TopicFilter \n[ +0x02 :  P ,  bloom :  B_64 ] Specify the bloom filter of the topics that the sender is interested in. The bloom method is defined below.", 
            "title": "Whisper Sub-protocol"
        }, 
        {
            "location": "/Whisper/PoC-2-Wire-Protocol/#session-management", 
            "text": "For the Whisper sub-protocol, upon an active session, a  Status  message must be sent. Following the reception of the peer's  Status  message, the Whisper session is active. The peer with the greatest Node Id should send a  Messages  message to begin the message rally. From that point, peers take it in turns to send (possibly empty) Messages packets.", 
            "title": "Session Management"
        }, 
        {
            "location": "/Whisper/PoC-2-Wire-Protocol/#topics-and-abridged-topics", 
            "text": "Topics  are 32-byte hashes, typically generated from \u00d0App-specified data. The  abridged topic  is the first 4 bytes of the topic. Abridged topics allow the identification (within the bounds of an acceptably high probability) of a given topic, useful for determining the utility of a topic for a given peer, yet do not give away the full topic information itself, allowing it to be used as a strong encryption key whose secret is not inherently available.", 
            "title": "Topics and Abridged Topics"
        }, 
        {
            "location": "/Whisper/PoC-2-Wire-Protocol/#bloomed-topics", 
            "text": "The Bloom filter used in the  TopicFilter  message type is a means a identifying a number of topics to a peer without compromising (too much) privacy over precisely what topics are of interest. Precise control over the information content (and thus efficiency of the filter) may be maintained through the addition of bits.  Blooms are formed by the bitwise OR operation on a number of bloomed topics. The bloom function takes the abridged topic (the first four bytes of the SHA3 of the \u00d0App/user level topic description) and projects them onto a 512-bit slice; in total, three bits are marked for each bloomed topic.  The projection function is defined as a mapping from a a 4-byte slice  S  to a 512-bit slice  D ; for ease of explanation,  S  will dereference to bytes, whereas  D  will dereference to bits.  LET D[*] = 0\nFOREACH i IN { 0, 1, 2 } DO\nLET n = S[i]\nIF S[3]   (2 ** i) THEN n += 512\nD[n] = 1\nEND FOR  In formal notation: D[i] := f(0) == i || f(1) == i || f(2) == i \nwhere: f(x) := S[x] + S[3][x] * 512 \n(assuming a byte value  S[i]  may be further dereferenced into a bit value)", 
            "title": "Bloomed Topics"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/", 
            "text": "PoC-2 \u6709\u7ebf\u534f\u8bae\n\n\nThis page, in addition to the Whisper Wire Specification, details the full Whisper protocol for the first proof-of-concept and sets the vision for the final design. It evolve alongside the Whisper protocol as the prototype is refined. From it you should be able to develop compliant Whisper implementations. This document is intended to give only the base specification. Many of the aspects leading to an implementation of Whisper are game theoretic and best not prescribed in the specification, but rather left to individual implementation teams to determine for themselves.\n\n\nWhat Whisper Is (and Is Not)\n\n\nWhisper combines aspects of both DHTs and datagram messaging systems (e.g. UDP). As such it may be likened and compared to both, not dissimilar to the matter/energy duality (apologies to physicists for the blatant abuse of a fundamental and beautiful natural principle).\n\n\nWhisper is a pure identity-based messaging system. Whisper provides a low-level (non-application-specific) but easily-accessible API without being based upon or prejudiced by the low-level hardware attributes and characteristics, particularly the notion of singular endpoints.\n\n\nAlternatively, Whisper may be likened to a DHT with a per-entry configurable TTL and conventions for the signing and encryption of values. In this sense, Whisper provides the ability to have multiply-indexable, non-unique entries (i.e. the same entry having multiple keys, some or all of which may be the same as other entries).\n\n\nAs such, Whisper is not a typical communications system. It is not designed to replace or substitute TCP/IP, UDP, HTTP or any other traditional protocols; it is not designed to provide a connection oriented system, nor for simply delivering data betwixt a pair of specific network endpoints; it does not have a primary goal of maximising bandwidth or minimising latency (though as with any transmission system, these are concerns).\n\n\nWhisper is a new protocol designed expressly for a new paradigm of application development. It is designed from the ground up for easy and efficient multi-casting and broadcasting. Similarly, low-level partially-asynchronous communications is an important goal. Low-value traffic reduction or retardation is another goal (which might also be likened to the quest for QoS). It is designed to be a building block in next generation \u00d0Apps which require large-scale many-to-many data-discovery, signal negotiation and modest transmissions with an absolute minimum of fuss and the expectation that one has a very reasonable assurance of complete privacy.\n\n\nPitch-Black Darkness\n\n\nWhisper operates around the notion of being user-configurable with regard to how much information it leaks concerning the \u00d0App content and ultimately, the user activities. To understand information leakage, it is important to distinguish between mere encryption, and \ndarkness\n. Many protocols, both those designed around p2p and more traditional client/server models provide a level of encryption. For some, encryption forms an intrinsic part of the protocol and, applied alone, delivers its primary requirement. While decentralising and encrypting is a great start on building a legitimately \"post-Snowden\" Web, it is not the end.\n\n\nEven with encrypted communications, well-funded attackers are still able to compromise ones privacy, often quite easily. Bulk metadata collection becomes the new battleground, and is at once dismissed as a privacy concern by authorities yet trumpeted as the Next Big Thing by big-data outfits. In the case of a simple client/server model, metadata betrays with which hosts one communicates - this is often plenty enough to compromise privacy given that content is, in many cases, largely determinable from the host.\n\n\nWith decentralised communications systems, e.g. a basic non-routed but encrypted VoIP call or Telehash communication, a network packet-sniffing attacker may not be able to determine the specific content of a transmission, but with the help of ISP IP address logs they would be able to determine to whom one communicated, when and how often. For certain types of applications in various jurisdictions, this is enough to be a concerning lack of privacy.\n\n\nEven with encryption and packet forwarding through a third relay node, there is still ample room for a determined bulk transmissions-collector to execute statistical attacks on timing and bandwidth, effectively using their knowledge of certain network invariants and the fact that only a finite amount of actors are involved (i.e. that nodes tend to forward messages between the same two peers with minimal latency and that there aren't all that many pairs of nodes that are trying to communicate via the same relay). There are ways to mitigate this attack vector, such as using multiple third-party relays and switching between them randomly or to use very strict framing, however both are imperfect and can lead to substantial inefficiencies.\n\n\nA truly dark system is one that is utterly uncompromising in information leakage from metadata. At its most secure mode of operation, Whisper can (at a considerable cost of bandwidth and latency) deliver 100% dark operation. Even better, this applies not only for metadata collection from inter-peer conduits (i.e. backbone dragnet devices), but even against a much more arduous \"100% - 2\" attack; i.e. where every node in the network were compromised (though functional) save a pair running \u00d0Apps for people that wanted to communicate without anybody else knowing.\n\n\nRouting and Lack Thereof\n\n\nFundamentally, at least with the present state of computer science, all systems present a trade off between the efficiency of deterministic (and thus supposedly optimal) routing and darkness (or, put another way, routing privacy). One of Whisper's differences is in providing a user-configurable trade-off between ones routing privacy and ones routing efficiency.\n\n\nAt its most dark, Whisper nodes are entirely reactive - they receive and record pieces of data and forward them trying to maximise the utility of information transmission to the peers. These pieces of information include what is known as a \ntopic\n, which may be viewed both as a secure-probabilistic routing endpoint and/or a DHT multi-key.\n\n\nHowever, Whisper is also designed to be able to route probabilistically using two methods, both giving away minimal routing information and both being exceptionally resilient to statistical attacks from large-scale metadata collection.\n\n\nThe first builds on the functionality of the \u00d0\u039eV-p2p backend. This backend provides the ability of Whisper to rate peers and, over time, probabilistically alter (or \nsteer\n) its set of peers to those which tend to deliver useful (on-topic, timely, required for ones \u00d0Apps to function) information. Ultimately, as the network evolves and the peer-set is steered, the number of hops between this peer and any others that tend to be good conduits of useful information (be they the emitters or simply the well-positioned hubs) will tend to 0.\n\n\nPeer steering also provides the incentive for nodes to provide useful information to peers. The fear of being identified as an under-performing peer and thus being rotated out in favour of other nodes gives all nodes incentive to cooperate and share the most useful information. Useful in this case means provably difficult to author (use of a proof-of-work function helps here); a low time-to-live; and well-corresponding to any provided information on what might be useful (read on for more).\n\n\nThe second is more dynamic. Nodes are informed by their \u00d0Apps over what sort of topics are useful. Nodes are then allowed to advertise to each peer describing these topics. Topics may be described, using masks or Bloom filters, and thus in an incomplete manner, to reduce the amount of information leaked and make passive statistical attacks arbitrarily difficult to execute. The determination of the amount of information to give to peers is both made through an explicit setting from the user and through topic/traffic modelling: \"Given the information coming from this peer and my models of information distribution made from total traffic, am I receiving the amount of useful valuable information that I would expect to receive? If so, narrowing it down with additional description information to the peer may be warranted.\"\n\n\nThese settings can even be configured per-peer (more trusted/longer-lasting peers may be afforded greater amounts of information), and per-\u00d0App (those \u00d0Apps that may be more sensitive could be afforded less advertising than others). We can also make use of proof-of-work algorithms to minimise the changes of both DoS attacks and 'everything-but' attacks (where a peer is flooded with almost-useful information prompting it to give away more about its true requirements than it would do otherwise).\n\n\nThrough combining and reducing the Blooms/masks, weaker Nth-level information can be provided to peers about their peers' interests, forming a probabilistic topic-reception vortex around nodes, the \"topic-space\" gravity-well getting weaker and less certain the farther away with the network hop distance from any interested peers.\n\n\nBasic Protocol Elements\n\n\nEnvelopes\n\n\nThere are two key concepts in Whisper: \nEnvelopes\n and \nMessages\n. Envelopes may be considered items should Whisper be considered a DHT. Should Whisper be considered a datagram messaging system then envelopes become the packet format which house the potentially encrypted datagrams. Envelopes are necessarily comprehensible by any node (i.e. they themselves are unencrypted).\n\n\nThey contain information to the entry/datagram such as the original time to live (\nTTL\n), the absolute time for \nexpiry\n and, importantly, the \ntopics\n. Topics are a set of indexes to this item, recorded in order to help an interested party (\"recipient\") find it or have it routed to them. They might be likened to binary tags or keywords. Envelopes additionally contain a nonce allowing the original insertion node (\"sender\") to prove that some arbitrary amount of work was done in its composition. Finally, envelopes contain a message-\ndata\n field; this stores the actual payload, together with some information and potentially a signature; together this forms a message. This field may be encrypted.\n\n\nEnvelopes are transmitted as RLP-encoded structures. The precise definition is given by:\n\n\n[\nexpiry\n: \nP\n, \nttl\n: \nP\n, [\ntopic0\n: \nB_4\n, \ntopic1\n: \nB_4\n, ...], \ndata\n: \nB\n, \nnonce\n: \nP\n]\n\n\nHere, \nttl\n is given in seconds, \nexpiry\n is the Unix time of the intended expiry date/time for the envelope. Following this point in time the envelope should no longer be transmitted (or stored, unless there is some extenuating circumstance). Prior to this point in time less the \nttl\n (i.e. the implied insertion time), the envelope is considered utterly invalid and should be dropped immediately and the transmitting peer punished.\n\n\nnonce\n is an arbitrary value. We say the work proved through the value of the SHA3 of the concatenation of the nonce and the SHA3 of the RLP of the packet save the nonce (i.e. just a 4-item RLP list), each of the components as a fixed-length 256-bit hash. When this final hash is interpreted as a BE-encoded value, the smaller it is, the higher the work proved. This is used later to judge a peer.\n\n\nTopics\n\n\nTopics are cryptographically secure, probabilistic partial-classifications of the message. Each topic in the set (order is unimportant) is determined as the first (left) 4 bytes of the SHA3-256 hash of some arbitrary data given by the original author of the message. These might e.g. correspond to \"twitter\" hash-tags or an intended recipient's public key hashed with some session nonce or application-identity.\n\n\nFour bytes was chosen to minimise space should a large number of topics be mentioned while still keeping a sufficiently large space to avoid large-scale topic-collision (though it may yet be reviewed and possibly made dynamic in later revisions of the protocol).\n\n\nMessages\n\n\nA message is formed as the concatenation of a single byte for flags (at present only a single flag is used), followed by any additional data (as stipulated by the flags) and finally the actual payload. This series of bytes is what forms the \ndata\n item of the envelope and is always encrypted.\n\n\nIn the present protocol version, no explicit authentication token is given to indicate that the data field is encrypted; any would-be readers of the message must know ahead of time, through the choice of topic that they have specifically filtered for, that the message is encrypted with a particular key. This is likely to be altered in a further PoC to include a MAC.\n\n\nAny determination that the message is indeed from a particular sender is left for a higher-level to address. This is noted through the Javascript API allowing the \nto\n parameter to be passed only at the point of specifying the filter. Since the signature is a part of the message and not outside in the envelope, those unable to decrypt the message data are also unable to access any signature.\n\n\n\n\nflags\n: 1 byte\n\n\n(\nsignature\n: 65 bytes)\n\n\npayload\n: not fixed\n\n\n\n\nBit 0 of the flags determines whether the signature exists. All other bits are not yet given a purpose and should be set randomly. A message is invalid if bit 0 is set but the total data is less than 66 bytes (since this wouldn't allow it to contain a signature).\n\n\nPayloads are encrypted in one of two ways. If the message has a specific recipient, then by using ECIES with the specific recipient's SECP-256k1 public key. If the message has no recipient, then by AES-256 with a randomly generated key. This key is then XORed with each of the \nfull\n topics to form a salted topic. Each salted topic is stored prior to the encrypted data \nin the same order as the corresponding topics are in the envelope header\n.\n\n\nAs a recipient, payloads are decrypted in one of two ways. Through use of topics, it should be known whether the envelope is encrypted to a specific recipient (in which case use the private key to decrypt) or to a general multicast audience. In the latter case, we assume that at least one topic is known (since otherwise, the envelope could not be properly \"identified\"). In this case, we match the known \nfull\n topic to one of the abridged topics in the envelope, determine the index and de-salt the according salted-key at the beginning of the data segment in order to retrieve the final key.\n\n\nEncryption using the full topic with \"routing\" using the abridged topic ensures that nodes which are merely transiently storing the message and have no interest in the contents (thus have access only to routing information via the abridged topics) have no intrinsic ability to read the content of the message.\n\n\nThe signature, if provided, is the SHA3-256 hash of the unencrypted payload signed using ECDSA with the insertion-identity's secret key.\n\n\nThe signature portion is formed as the concatenation of the \nr\n, \ns\n and \nv\n parameters of the SECP-256k1 ECDSA signature, in that order. \nv\n is non-normalised and should be either 27 or 28. \nr\n and \ns\n are both big-endian encoded, fixed-width 32-byte unsigned.\n\n\nThe payload is otherwise unformatted binary data.\n\n\nIn the Javascript API, the distinction between envelopes and messages is blurred. This is because DApps should know nothing about envelopes whose message cannot be inspected; the fact that nodes pass envelopes around regardless of their ability to decode the message (or indeed their interest in it at all) is an important component in Whisper's dark communications strategy.\n\n\nBasic Operation\n\n\nNodes are expected to receive and send envelopes continuously, as per the \nprotocol specification\n. They should maintain a map of envelopes, indexed by expiry time, and prune accordingly. They should also efficiently deliver messages to the front-end API through maintaining mappings between topics and envelopes.\n\n\nWhen a node's envelope memory becomes exhausted, a node may drop envelopes it considers unimportant or unlikely to please its peers. Nodes should consider peers good that pass them envelopes with low TTLs and high proofs-of-work. Nodes should consider peers bad that pass then expired envelopes or, worse, those that have an implied insertion time prior to the present.\n\n\nNodes should always keep messages that its \u00d0Apps have created. Though not in PoC-1, later editions of this protocol may allow \u00d0Apps to mark messages as being \"archived\" and these should be stored and made available for additional time.\n\n\nNodes should retain a set of per-\u00d0App topics it is interested in.\n\n\nInserting (Authoring) Messages\n\n\nTo insert a message, little more is needed than to place the envelope containing it in the node's envelope set that it maintains; the node should, according to its normal heuristics retransmit the envelope in due course. Composing an envelope from a basic payload, possible identities for authoring and access, a number of topics, a time-to-live and some parameters concerning work-proving targets is done through a few steps:\n\n\n\n\nCompose \ndata\n through concatenating the relevant flag byte, a signature of the payload if the user specified a valid author identity, and the user-given payload.\n\n\nEncrypt the data if an access (\"destination\") identity's public key is given by the user.\n\n\nCompose \ntopics\n from the first 4 bytes of the SHA3 of each topic.\n\n\nSet user-given attribute \nttl\n.\n\n\nSet the \nexpiry\n as the present Unix time plus the time-to-live.\n\n\nSet the \nnonce\n as that which provides the most work proved as per the previous definition, after some fixed amount of time of cycling through candidates or after a candidate surpasses some boundary; either should be given by the user.\n\n\n\n\nTopic Masking and Advertising\n\n\nNodes can advertise their topics of interest to each other. For that purpose they use a special type of Whisper message (TopicFilterPacket). The size of Bloom Filter they send to each other must be 64 bytes. Subsequently the rating system will be introduced -- peers sending useful messages will be rated higher then those sending random messages.\n\n\nA message matches the bloom filter, if any one of the topics in this message, converted to the Whisper bloom hash, will match the bloom filter.\n\n\nWhisper bloom function accepts AbridgedTopic as a parameter (size: 4 bytes), and produces a 64-byte hash, where three bits (at the most) are set to one, and the rest are set to zeros, according to the following algorithm:\n\n\n\n\n\n\nSet all the bits in the resulting 64-byte hash to zero.\n\n\n\n\n\n\nWe take 9 bits form the AbridgedTopic, and convert to integer value (range: 0 - 511).\n\n\n\n\n\n\nThis value defines the index of the bit in the resulting 512-bit hash, which should be set to one.\n\n\n\n\n\n\nRepeat steps 1 \n 2 for the second and third bit to be set in the resulting hash.\n\n\n\n\n\n\nThus, in order to produce the bloom, we use 27 bits out of 32 in the AbridgedTopic. For more details, please see the implementation of the function: TopicBloomFilterBase\n::bloom() [libwhisper/BloomFilter.h].\n\n\nComing changes\n\n\nAlso being considered for is support for plausible deniability through the use of session keys and a formalisation of the multicast mechanism.", 
            "title": "PoC-2 \u767d\u76ae\u4e66"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#poc-2", 
            "text": "This page, in addition to the Whisper Wire Specification, details the full Whisper protocol for the first proof-of-concept and sets the vision for the final design. It evolve alongside the Whisper protocol as the prototype is refined. From it you should be able to develop compliant Whisper implementations. This document is intended to give only the base specification. Many of the aspects leading to an implementation of Whisper are game theoretic and best not prescribed in the specification, but rather left to individual implementation teams to determine for themselves.", 
            "title": "PoC-2 \u6709\u7ebf\u534f\u8bae"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#what-whisper-is-and-is-not", 
            "text": "Whisper combines aspects of both DHTs and datagram messaging systems (e.g. UDP). As such it may be likened and compared to both, not dissimilar to the matter/energy duality (apologies to physicists for the blatant abuse of a fundamental and beautiful natural principle).  Whisper is a pure identity-based messaging system. Whisper provides a low-level (non-application-specific) but easily-accessible API without being based upon or prejudiced by the low-level hardware attributes and characteristics, particularly the notion of singular endpoints.  Alternatively, Whisper may be likened to a DHT with a per-entry configurable TTL and conventions for the signing and encryption of values. In this sense, Whisper provides the ability to have multiply-indexable, non-unique entries (i.e. the same entry having multiple keys, some or all of which may be the same as other entries).  As such, Whisper is not a typical communications system. It is not designed to replace or substitute TCP/IP, UDP, HTTP or any other traditional protocols; it is not designed to provide a connection oriented system, nor for simply delivering data betwixt a pair of specific network endpoints; it does not have a primary goal of maximising bandwidth or minimising latency (though as with any transmission system, these are concerns).  Whisper is a new protocol designed expressly for a new paradigm of application development. It is designed from the ground up for easy and efficient multi-casting and broadcasting. Similarly, low-level partially-asynchronous communications is an important goal. Low-value traffic reduction or retardation is another goal (which might also be likened to the quest for QoS). It is designed to be a building block in next generation \u00d0Apps which require large-scale many-to-many data-discovery, signal negotiation and modest transmissions with an absolute minimum of fuss and the expectation that one has a very reasonable assurance of complete privacy.", 
            "title": "What Whisper Is (and Is Not)"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#pitch-black-darkness", 
            "text": "Whisper operates around the notion of being user-configurable with regard to how much information it leaks concerning the \u00d0App content and ultimately, the user activities. To understand information leakage, it is important to distinguish between mere encryption, and  darkness . Many protocols, both those designed around p2p and more traditional client/server models provide a level of encryption. For some, encryption forms an intrinsic part of the protocol and, applied alone, delivers its primary requirement. While decentralising and encrypting is a great start on building a legitimately \"post-Snowden\" Web, it is not the end.  Even with encrypted communications, well-funded attackers are still able to compromise ones privacy, often quite easily. Bulk metadata collection becomes the new battleground, and is at once dismissed as a privacy concern by authorities yet trumpeted as the Next Big Thing by big-data outfits. In the case of a simple client/server model, metadata betrays with which hosts one communicates - this is often plenty enough to compromise privacy given that content is, in many cases, largely determinable from the host.  With decentralised communications systems, e.g. a basic non-routed but encrypted VoIP call or Telehash communication, a network packet-sniffing attacker may not be able to determine the specific content of a transmission, but with the help of ISP IP address logs they would be able to determine to whom one communicated, when and how often. For certain types of applications in various jurisdictions, this is enough to be a concerning lack of privacy.  Even with encryption and packet forwarding through a third relay node, there is still ample room for a determined bulk transmissions-collector to execute statistical attacks on timing and bandwidth, effectively using their knowledge of certain network invariants and the fact that only a finite amount of actors are involved (i.e. that nodes tend to forward messages between the same two peers with minimal latency and that there aren't all that many pairs of nodes that are trying to communicate via the same relay). There are ways to mitigate this attack vector, such as using multiple third-party relays and switching between them randomly or to use very strict framing, however both are imperfect and can lead to substantial inefficiencies.  A truly dark system is one that is utterly uncompromising in information leakage from metadata. At its most secure mode of operation, Whisper can (at a considerable cost of bandwidth and latency) deliver 100% dark operation. Even better, this applies not only for metadata collection from inter-peer conduits (i.e. backbone dragnet devices), but even against a much more arduous \"100% - 2\" attack; i.e. where every node in the network were compromised (though functional) save a pair running \u00d0Apps for people that wanted to communicate without anybody else knowing.", 
            "title": "Pitch-Black Darkness"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#routing-and-lack-thereof", 
            "text": "Fundamentally, at least with the present state of computer science, all systems present a trade off between the efficiency of deterministic (and thus supposedly optimal) routing and darkness (or, put another way, routing privacy). One of Whisper's differences is in providing a user-configurable trade-off between ones routing privacy and ones routing efficiency.  At its most dark, Whisper nodes are entirely reactive - they receive and record pieces of data and forward them trying to maximise the utility of information transmission to the peers. These pieces of information include what is known as a  topic , which may be viewed both as a secure-probabilistic routing endpoint and/or a DHT multi-key.  However, Whisper is also designed to be able to route probabilistically using two methods, both giving away minimal routing information and both being exceptionally resilient to statistical attacks from large-scale metadata collection.  The first builds on the functionality of the \u00d0\u039eV-p2p backend. This backend provides the ability of Whisper to rate peers and, over time, probabilistically alter (or  steer ) its set of peers to those which tend to deliver useful (on-topic, timely, required for ones \u00d0Apps to function) information. Ultimately, as the network evolves and the peer-set is steered, the number of hops between this peer and any others that tend to be good conduits of useful information (be they the emitters or simply the well-positioned hubs) will tend to 0.  Peer steering also provides the incentive for nodes to provide useful information to peers. The fear of being identified as an under-performing peer and thus being rotated out in favour of other nodes gives all nodes incentive to cooperate and share the most useful information. Useful in this case means provably difficult to author (use of a proof-of-work function helps here); a low time-to-live; and well-corresponding to any provided information on what might be useful (read on for more).  The second is more dynamic. Nodes are informed by their \u00d0Apps over what sort of topics are useful. Nodes are then allowed to advertise to each peer describing these topics. Topics may be described, using masks or Bloom filters, and thus in an incomplete manner, to reduce the amount of information leaked and make passive statistical attacks arbitrarily difficult to execute. The determination of the amount of information to give to peers is both made through an explicit setting from the user and through topic/traffic modelling: \"Given the information coming from this peer and my models of information distribution made from total traffic, am I receiving the amount of useful valuable information that I would expect to receive? If so, narrowing it down with additional description information to the peer may be warranted.\"  These settings can even be configured per-peer (more trusted/longer-lasting peers may be afforded greater amounts of information), and per-\u00d0App (those \u00d0Apps that may be more sensitive could be afforded less advertising than others). We can also make use of proof-of-work algorithms to minimise the changes of both DoS attacks and 'everything-but' attacks (where a peer is flooded with almost-useful information prompting it to give away more about its true requirements than it would do otherwise).  Through combining and reducing the Blooms/masks, weaker Nth-level information can be provided to peers about their peers' interests, forming a probabilistic topic-reception vortex around nodes, the \"topic-space\" gravity-well getting weaker and less certain the farther away with the network hop distance from any interested peers.", 
            "title": "Routing and Lack Thereof"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#basic-protocol-elements", 
            "text": "", 
            "title": "Basic Protocol Elements"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#envelopes", 
            "text": "There are two key concepts in Whisper:  Envelopes  and  Messages . Envelopes may be considered items should Whisper be considered a DHT. Should Whisper be considered a datagram messaging system then envelopes become the packet format which house the potentially encrypted datagrams. Envelopes are necessarily comprehensible by any node (i.e. they themselves are unencrypted).  They contain information to the entry/datagram such as the original time to live ( TTL ), the absolute time for  expiry  and, importantly, the  topics . Topics are a set of indexes to this item, recorded in order to help an interested party (\"recipient\") find it or have it routed to them. They might be likened to binary tags or keywords. Envelopes additionally contain a nonce allowing the original insertion node (\"sender\") to prove that some arbitrary amount of work was done in its composition. Finally, envelopes contain a message- data  field; this stores the actual payload, together with some information and potentially a signature; together this forms a message. This field may be encrypted.  Envelopes are transmitted as RLP-encoded structures. The precise definition is given by:  [ expiry :  P ,  ttl :  P , [ topic0 :  B_4 ,  topic1 :  B_4 , ...],  data :  B ,  nonce :  P ]  Here,  ttl  is given in seconds,  expiry  is the Unix time of the intended expiry date/time for the envelope. Following this point in time the envelope should no longer be transmitted (or stored, unless there is some extenuating circumstance). Prior to this point in time less the  ttl  (i.e. the implied insertion time), the envelope is considered utterly invalid and should be dropped immediately and the transmitting peer punished.  nonce  is an arbitrary value. We say the work proved through the value of the SHA3 of the concatenation of the nonce and the SHA3 of the RLP of the packet save the nonce (i.e. just a 4-item RLP list), each of the components as a fixed-length 256-bit hash. When this final hash is interpreted as a BE-encoded value, the smaller it is, the higher the work proved. This is used later to judge a peer.", 
            "title": "Envelopes"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#topics", 
            "text": "Topics are cryptographically secure, probabilistic partial-classifications of the message. Each topic in the set (order is unimportant) is determined as the first (left) 4 bytes of the SHA3-256 hash of some arbitrary data given by the original author of the message. These might e.g. correspond to \"twitter\" hash-tags or an intended recipient's public key hashed with some session nonce or application-identity.  Four bytes was chosen to minimise space should a large number of topics be mentioned while still keeping a sufficiently large space to avoid large-scale topic-collision (though it may yet be reviewed and possibly made dynamic in later revisions of the protocol).", 
            "title": "Topics"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#messages", 
            "text": "A message is formed as the concatenation of a single byte for flags (at present only a single flag is used), followed by any additional data (as stipulated by the flags) and finally the actual payload. This series of bytes is what forms the  data  item of the envelope and is always encrypted.  In the present protocol version, no explicit authentication token is given to indicate that the data field is encrypted; any would-be readers of the message must know ahead of time, through the choice of topic that they have specifically filtered for, that the message is encrypted with a particular key. This is likely to be altered in a further PoC to include a MAC.  Any determination that the message is indeed from a particular sender is left for a higher-level to address. This is noted through the Javascript API allowing the  to  parameter to be passed only at the point of specifying the filter. Since the signature is a part of the message and not outside in the envelope, those unable to decrypt the message data are also unable to access any signature.   flags : 1 byte  ( signature : 65 bytes)  payload : not fixed   Bit 0 of the flags determines whether the signature exists. All other bits are not yet given a purpose and should be set randomly. A message is invalid if bit 0 is set but the total data is less than 66 bytes (since this wouldn't allow it to contain a signature).  Payloads are encrypted in one of two ways. If the message has a specific recipient, then by using ECIES with the specific recipient's SECP-256k1 public key. If the message has no recipient, then by AES-256 with a randomly generated key. This key is then XORed with each of the  full  topics to form a salted topic. Each salted topic is stored prior to the encrypted data  in the same order as the corresponding topics are in the envelope header .  As a recipient, payloads are decrypted in one of two ways. Through use of topics, it should be known whether the envelope is encrypted to a specific recipient (in which case use the private key to decrypt) or to a general multicast audience. In the latter case, we assume that at least one topic is known (since otherwise, the envelope could not be properly \"identified\"). In this case, we match the known  full  topic to one of the abridged topics in the envelope, determine the index and de-salt the according salted-key at the beginning of the data segment in order to retrieve the final key.  Encryption using the full topic with \"routing\" using the abridged topic ensures that nodes which are merely transiently storing the message and have no interest in the contents (thus have access only to routing information via the abridged topics) have no intrinsic ability to read the content of the message.  The signature, if provided, is the SHA3-256 hash of the unencrypted payload signed using ECDSA with the insertion-identity's secret key.  The signature portion is formed as the concatenation of the  r ,  s  and  v  parameters of the SECP-256k1 ECDSA signature, in that order.  v  is non-normalised and should be either 27 or 28.  r  and  s  are both big-endian encoded, fixed-width 32-byte unsigned.  The payload is otherwise unformatted binary data.  In the Javascript API, the distinction between envelopes and messages is blurred. This is because DApps should know nothing about envelopes whose message cannot be inspected; the fact that nodes pass envelopes around regardless of their ability to decode the message (or indeed their interest in it at all) is an important component in Whisper's dark communications strategy.", 
            "title": "Messages"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#basic-operation", 
            "text": "Nodes are expected to receive and send envelopes continuously, as per the  protocol specification . They should maintain a map of envelopes, indexed by expiry time, and prune accordingly. They should also efficiently deliver messages to the front-end API through maintaining mappings between topics and envelopes.  When a node's envelope memory becomes exhausted, a node may drop envelopes it considers unimportant or unlikely to please its peers. Nodes should consider peers good that pass them envelopes with low TTLs and high proofs-of-work. Nodes should consider peers bad that pass then expired envelopes or, worse, those that have an implied insertion time prior to the present.  Nodes should always keep messages that its \u00d0Apps have created. Though not in PoC-1, later editions of this protocol may allow \u00d0Apps to mark messages as being \"archived\" and these should be stored and made available for additional time.  Nodes should retain a set of per-\u00d0App topics it is interested in.", 
            "title": "Basic Operation"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#inserting-authoring-messages", 
            "text": "To insert a message, little more is needed than to place the envelope containing it in the node's envelope set that it maintains; the node should, according to its normal heuristics retransmit the envelope in due course. Composing an envelope from a basic payload, possible identities for authoring and access, a number of topics, a time-to-live and some parameters concerning work-proving targets is done through a few steps:   Compose  data  through concatenating the relevant flag byte, a signature of the payload if the user specified a valid author identity, and the user-given payload.  Encrypt the data if an access (\"destination\") identity's public key is given by the user.  Compose  topics  from the first 4 bytes of the SHA3 of each topic.  Set user-given attribute  ttl .  Set the  expiry  as the present Unix time plus the time-to-live.  Set the  nonce  as that which provides the most work proved as per the previous definition, after some fixed amount of time of cycling through candidates or after a candidate surpasses some boundary; either should be given by the user.", 
            "title": "Inserting (Authoring) Messages"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#topic-masking-and-advertising", 
            "text": "Nodes can advertise their topics of interest to each other. For that purpose they use a special type of Whisper message (TopicFilterPacket). The size of Bloom Filter they send to each other must be 64 bytes. Subsequently the rating system will be introduced -- peers sending useful messages will be rated higher then those sending random messages.  A message matches the bloom filter, if any one of the topics in this message, converted to the Whisper bloom hash, will match the bloom filter.  Whisper bloom function accepts AbridgedTopic as a parameter (size: 4 bytes), and produces a 64-byte hash, where three bits (at the most) are set to one, and the rest are set to zeros, according to the following algorithm:    Set all the bits in the resulting 64-byte hash to zero.    We take 9 bits form the AbridgedTopic, and convert to integer value (range: 0 - 511).    This value defines the index of the bit in the resulting 512-bit hash, which should be set to one.    Repeat steps 1   2 for the second and third bit to be set in the resulting hash.    Thus, in order to produce the bloom, we use 27 bits out of 32 in the AbridgedTopic. For more details, please see the implementation of the function: TopicBloomFilterBase ::bloom() [libwhisper/BloomFilter.h].", 
            "title": "Topic Masking and Advertising"
        }, 
        {
            "location": "/Whisper/PoC-2-Protocol-Spec/#coming-changes", 
            "text": "Also being considered for is support for plausible deniability through the use of session keys and a formalisation of the multicast mechanism.", 
            "title": "Coming changes"
        }, 
        {
            "location": "/Misc/Problems/", 
            "text": "\u52a0\u5bc6\u8d27\u5e01\u7684\u96be\u9898\n\n\nThe science of cryptography, which has existed to some degree for millennia but in a formal and systematized form for less than fifty years, can be most simply defined as the study of communication in an adversarial environment. In a similar vein, we can define cryptoeconomics as a field that goes one step further: the study of economic interaction in an adversarial environment. To distinguish itself from traditional economics, which certainly studies both economic interaction and adversaries, cryptoeconomics generally focuses on interactions that take place over network protocols. Particular domains of cryptoeconomics include:\n\n\n\n\nOnline trust and reputation systems\n\n\nCryptographic tokens / cryptocurrencies, and more generally digital assets\n\n\nSelf-executing \"smart\" contracts\n\n\nConsensus algorithms\n\n\nAnti-spam and anti-sybil attack algorithms\n\n\nIncentivized marketplaces for computational resources\n\n\nDecentralized systems for social welfare / mutual aid / basic income\n\n\nDecentralized governance (for both for-profit and non-profit entities)\n\n\n\n\nThe increasing prominence of cryptoeconomics in the last five years is to a large extent the result of the growth of cryptocurrencies and digital tokens, and brings a new, and interesting, dimension to cryptography. While before cryptography was, by and large, a purely computational and information-theoretic science, with strong guarantees built on security assumptions that are close to absolute, once money enters the picture the perfect world of mathematics must interact with a much more messy reality of human social structures, economic incentives, partial guarantees and known vulnerabilities that can only be mitigated, and not outright removed. While a cryptographer is used to assumptions of the form \"this algorithm is guaranteed to be unbreakable provided that these underlying math problems remain hard\", the world of cryptoeconomics must contend with fuzzy empirical factors such as the difficulty of collusion attacks, the relative quantity of altruistic, profit-seeking and anti-altruistic parties, the level of concentration of different kinds of resources, and in some cases even sociocultural circumstances.\n\n\nIn traditional applied cryptography, security assumptions tend to look something like this:\n\n\n\n\nNo one can do more than 2\n79\n computational steps\n\n\nFactoring is hard (ie. superpolynomial)\n\n\nTaking nth roots modulo composites is hard\n\n\nThe elliptic curve discrete logarithm problem cannot be solved faster than in 2\nn/2\n time\n\n\n\n\nIn cryptoeconomics, on the other hand, the basic security assumptions that we depend on are, alongside the cryptographic assumptions, roughly the following:\n\n\n\n\nNo set of individuals that control more than 25% of all computational resources is capable of colluding\n\n\nNo set of individuals that control more than 25% of all money is capable of colluding\n\n\nThe amount of computation of a certain proof of work function that can be accomplished with a given amount of money is not superlinear beyond a point which is reasonably low\n\n\nThere exist a non-negligible number of altruists and a non-negligible number of crazies or political opponents of the system, and the majority of users can be reasonably modeled as being close to economically rational\n\n\nThe number of users of a system is large, and users can appear or disappear at any time, although at least some users are persistent\n\n\nCensorship is impossible, and any two nodes can send messages to each other relatively quickly.\n\n\nIt is trivial to generate a very large number of IP addresses, and one can purchase an unlimited amount of network bandwidth\n\n\nMany users are anonymous, so negative reputations and debts are close to unenforceable\n\n\n\n\nThere will also be additional security assumptions specific to certain problems. Thus, quite often it will not even be possible to definitively say that a certain protocol is secure or insecure or that a certain problem has been solved. Rather, it will be necessary to create solutions that are optimized for particular empirical and social realities, and continue further and further optimizing them over time.\n\n\n\u6280\u672f\n\n\nThe decentralized consensus technology used in Bitcoin is impressive to a very large extent because of its simplicity. A 30-year-old problem in computer science was solved via a mechanism which is simple to implement, and so simple to understand that even some semi-technical teenagers can describe the entirety of how it works. However, at the same time the technology in its current form is very limited. The scalability in Bitcoin is very crude; the fact that every full node needs to process every transaction is a large roadblock to the future success of the platform, and a factor preventing its effective use in micropayments (arguably the one place where it is the most useful). Timestamping is flawed, and proof-of-computation algorithms are very limited in the types of computation that they can support. The fact that the original solution was so \"easy\", however, suggests that there is still a large opportunity to improve, and there are a number of directions in which improvement could be directed.\n\n\n1. \u533a\u5757\u94fe\u53ef\u6269\u5c55\u6027\n\n\nOne of the largest problems facing the cryptocurrency space today is the issue of scalability. It is an often repeated claim that, while mainstream payment networks process something like 2000 transactions per second, in its current form the Bitcoin network can only process seven. On a fundamental level, this is not strictly true; simply by changing the block size limit parameter, Bitcoin can easily be made to support 70 or even 7000 transactions per second. However, if Bitcoin does get to that scale, we run into a problem: it becomes impossible for the average user to run a full node, and full nodes become relegated only to that small collection of businesses that can afford the resources. Because mining only requires the block header, even miners can (and in practice most do) mine without downloading the blockchain.\n\n\nThe main concern with this is trust: if there are only a few entities capable of running full nodes, then those entities can conspire and agree to give themselves a large number of additional bitcoins, and there would be no way for other users to see for themselves that a block is invalid without processing an entire block themselves. Although such a fraud may potentially be discovered after the fact, power dynamics may create a situation where the default action is to simply go along with the fraudulent chain (and authorities can create a climate of fear to support such an action) and there is a coordination problem in switching back. Thus, at the extreme, Bitcoin with 7000 transactions per second has security properties that are essentially similar to a centralized system like Paypal, whereas what we want is a system that handles 7000 TPS with the same levels of decentralization that cryptocurrency originally promised to offer.\n\n\nIdeally, a blockchain design should exist that works, and has similar security properties to Bitcoin with regard to 51% attacks, that functions even if no single node processes more than \n1/n\n of all transactions where \nn\n can be scaled up to be as high as necessary, although perhaps at the cost of linearly or quadratically growing secondary inefficiencies and convergence concerns. This would allow the blockchain architecture to process an arbitrarily high number of TPS but at the same time retain the same level of decentralization that Satoshi envisioned.\n\n\n\u96be\u9898\n: create a blockchain design that maintains Bitcoin-like security guarantees, but where the maximum size of the most powerful node that needs to exist for the network to keep functioning is substantially sublinear in the number of transactions.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n:\n\n\n\n\nThere exist a large number of miners in the network\n\n\nMiners may be using specialized hardware or unspecialized hardware. Specialized hardware should be assumed to be more powerful than unspecialized hardware by a large (eg. 10000) constant factor at specific tasks.\n\n\nOrdinary users will be using unspecialized hardware\n\n\nIdeally, after some number of blocks (perhaps logarithmic in the total size of the network) every transaction should require 51% of network hashpower to reverse. However, solutions where transactions can pay very small fees for a lower \"level\" of security are acceptable, though one should take care to avoid situations where an attacker can profit by performing one attack to reverse very many small transactions at the same time\n\n\nIdeally, the solution should work for and maintain as many properties as possible of a generalized account-based blockchain (eg. Ethereum), though solutions specific to currency, domain registrations or other specialized use cases are acceptable\n\n\n\n\n2. \u65f6\u95f4\u6233\n\n\nAn important property that Bitcoin needs to keep is that there should be roughly one block generated every ten minutes; if a block is generated every day, the payment system becomes too slow, and if a block is generated every second there are serious centralization and network efficiency concerns that would make the consensus system essentially nonviable even assuming the absence of any attackers. To ensure this, the Bitcoin network adjusts difficulty so that if blocks are produced too quickly it becomes harder to mine a new block, and if blocks are produced too slowly it becomes easier.\n\n\nHowever, this solution requires an important ingredient: the blockchain must be aware of time. In order to solve this problem, Bitcoin requires miners to submit a timestamp in each block, and nodes reject a block if the block's timestamp is either (i) behind the median timestamp of the previous eleven blocks, or (ii) more than 2 hours into the future, from the point of view of the node's own internal clock. This algorithm is good enough for Bitcoin, because time serves only the very limited function of regulating the block creation rate over the long term, but there are potential vulnerabilities in this approach, issues which may compound in blockchains where time plays a more important role.\n\n\n\u96be\u9898\n: create a distributed incentive-compatible system, whether it is an overlay on top of a blockchain or its own blockchain, which maintains the current time to high accuracy.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nAll legitimate users have clocks in a normal distribution around some \"real\" time with standard deviation 20 seconds.\n\n\nNo two nodes are more than 20 seconds apart in terms of the amount of time it takes for a message originating from one node to reach any other node.\n\n\nThe solution is allowed to rely on an existing concept of \"N nodes\"; this would in practice be enforced with proof-of-stake or non-sybil tokens (see #9).\n\n\nThe system should continuously provide a time which is within 120s (or less if possible) of the internal clock of \n99% of honestly participating nodes. Note that this also implies that the system should be self-consistent to within about 190s.\n\n\nThe system should exist without relying on any kind of proof-of-work.\n\n\nExternal systems may end up relying on this system; hence, it should remain secure against attackers controlling \n 25% of nodes regardless of incentives.\n\n\n\n\n3. \u8ba1\u7b97\u7684\u4efb\u610f\u8bc1\u660e\n\n\nPerhaps the holy grail of the study zero-knowledge proofs is the concept of an arbitrary proof of computation: given a program P with input I, the challenge is to create a zero-knowledge proof that you ran P with input I and received output O, such that the proof can be verified quickly (ie. in polylogarithmic or ideally constant time) even if the original computation took a very large number of steps to complete. In an ideal setup, the proof would even hide the value of I, just proving that you ran P with some output with result O, and if I needs to be made public it can be embedded into the program. Such a primitive, if possible, would have massive implications for cryptocurrency:\n\n\n\n\nThe blockchain scalability problem would be much easier to solve. Instead of miners publishing blocks containing a list of transactions, they would be publishing a proof that they ran the blockchain state updater with some list of transactions and produced a certain output; thus, instead of transactions needing to be verified by every node in the network, they could be processed by one miner and then every other miner and user could quickly verify the proof of computation and if the proof turns out correct they would accept the new state. This is not a complete solution, because there would still be a need to transmit data, but the problem would be much easier with this powerful building block.\n\n\nThe blockchain privacy problem would be much easier to solve. The blockchain scalability solution above would hide the details behind individual transactions; it would only reveal the fact that all of them are legitimate, so transactions would be hidden from everyone but the sender and the receiver.\n\n\nIt would become computationally viable to use a Turing-complete consensus network as a generic distributed cloud computing system; if you have any computation you wanted done, you would be able to publish the program for miners and miners would be able to run the program for you and deliver the result alongside a proof of its validity.\n\n\n\n\nThere is a large amount of existing research on this topic, including a protocol known as \"SCIP\" (Succinct Computational Integrity and Privacy) that is already working in test environments, although with the limitation that a trusted third party is required to initially set up the keys; use of this prior work by both its original developers and others is encouraged.\n\n\n\u96be\u9898\n: create programs \nPOC_PROVE(P,I) -\n (O,Q)\n and \nPOC_VERIFY(P,O,Q) -\n { 0, 1 }\n such that \nPOC_PROVE\n runs program \nP\n on input \nI\n and returns the program output \nO\n and a proof-of-computation \nQ\n and \nPOC_VERIFY\n takes \nP\n, \nO\n and \nQ\n and outputs whether or not \nQ\n and \nO\n were legitimately produced by the \nPOC_PROVE\n algorithm using \nP\n.\n\n\n\u8981\u6c42\u548c\u5176\u4ed6\u5047\u8bbe\n\n\n\n\nThe runtime of \nPOC_PROVE\n should be in \nO(n*polylog(n))\n where \nn\n is the number of steps required to run the program.\n\n\nThe runtime of \nPOC_VERIFY\n should be either constant or logarithmic in the number of steps, and at most linear in the maximum memory usage of the program.\n\n\nThe protocol should require no trusted third parties. If TTPs are required, the protocol should include a mechanism for simulating one efficiently using secure multiparty computation.\n\n\n\n\n4. \u4ee3\u7801\u6df7\u6dc6\n\n\nFor many years now we have known how to encrypt data. Simple, robust and well-tested algorithms exist for both symmetric key encryption, where the same key is needed to encrypt and decrypt, and public key encryption, where the encryption key and decryption key are different and one cannot be derived from the other. However, there is another kind of encryption that can potentially be very useful, but for which we currently have no viable algorithm: the encryption of programs. The holy grail is to create an obfuscator \nO\n, such that given any program P the obfuscator can produce a second program \nO(P) = Q\n such that \nP\n and \nQ\n return the same output if given the same input and, importantly, \nQ\n reveals no information whatsoever about the internals of \nP\n. One can hide inside of \nQ\n a password, a secret encryption key, or one can simply use \nQ\n to hide the proprietary workings of the algorithm itself.\n\n\nIn 2007, it was proven that perfect \"black box\" encryption is impossible; essentially, the argument is that there is a difference between having black-box access to a program and having the code to that program, no matter how obfuscated, and one can construct certain classes of programs that resist obfuscation. However, there is also a weaker notion of obfuscation, known as indistinguishability obfuscation, that appears to be quite possible. The definition of an indistinguishability obfuscator \nO\n is that if you take two equivalent (ie. same inputs -\n same outputs) programs \nA\n and \nB\n and calculate \nO(A) = P\n and \nO(B) = Q\n, then there is no computationally feasible way for an outsider without access to \nA\n or \nB\n to tell whether \nP\n came from \nA\n or \nB\n.\n\n\nThis type of obfuscation may seem more limited, but it is nevertheless sufficient for many applications. For a heuristic argument why, consider two programs \nF\n and \nG\n where \nF\n internally contains and simply prints out that 32-byte string which is the hash of \"12345\", whereas G actually computes the hash of \"12345\" and prints it out. By the indistinguishability obfuscation definition, there is no computationally feasible way to tell \nO(F)\n from \nO(G)\n apart. Hence, if one can feasibly recover \"12345\" from \nO(G)\n, then for \nO(G)\n and \nO(F)\n to be indistinguishable one would also need to be able to feasibly recover \"12345\" from \nO(F)\n - a feat which essentially entails breaking the preimage resistance of a cryptographic hash function.\n\n\nRecently, a discovery was made by Craig Gentry, Amit Sahai et al on an algorithm which uses a construction known as \"multilinear jigsaw puzzles\" in order to accomplish this. Their algorithm, described here, claims to satisfy the indistinguishability obfuscation property, although at a high cost: the algorithm requires the use of fully homomorphic encryption, a highly inefficient construction that incurs roughly a one-billion-fold computational overhead.\n\n\nIf this construction can be made better, the potential benefits are massive. The most interesting possibility in the world of cryptocurrency is the idea of an on-blockchain contract containing private information. This basically allows for the scripting properties of Turing-complete blockchain technologies, such as Ethereum, to be exported into any other financial or non-financial system on the internet; for example, one can imagine an Ethereum contract which contains a user's online banking password, and if certain conditions of the contract are satisfied the contract would initiate an HTTPS session with the bank, using some node as an intermediary, and log into the bank account with the user's password and make a specified withdrawal. Because the contract would be obfuscated, there would be no way for the intermediary node, or any other player in the blockchain, to modify the request in-transit or determine the user's password. The same trick can be done with any other website, or much more easily with a \"dumb\" blockchain such as Bitcoin.\n\n\n\u96be\u9898\n: create a reasonably efficient indistinguishability obfuscation algorithm.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nSuccessful attacks must have an expected runtime above 2^80\n\n\nThe algorithm should be sufficiently fast that a standard ECDSA signature or an AES encryption should be feasible within 10\n8\n computational steps (more specifically, 10\n8\n gas in the Ethereum VM)\n\n\n\n\n5. \u57fa\u4e8e\u54c8\u5e0c\u7684\u52a0\u5bc6\n\n\nOne of the looming threats on the horizon to cryptocurrency, and cryptography in general, is the issue of quantum computers. Currently, the problem does not seem too severe; all quantum computers are either \"adiabatic quantum computers\", effective at only an extremely limited set of problems and perhaps not even better than classical computers at all, or machines with a very small number of qubits not capable of factoring numbers higher than 35. In the future, however, quantum computers may become much more powerful, and the recent revelations around the activities of government agencies such as the NSA have sparked fears, however unlikely, that the US military may control a quantum computer already. With this in mind, the movement toward quantum-proof cryptography has become a somewhat higher priority.\n\n\nTo date, all quantum-proof schemes fall into one of two categories. First, there are algorithms involving lattice-based constructions, relying on the hardness of the problem of finding a linear combination of vectors whose sum is much shorter than the length of any individual member. These algorithms appear to be powerful, and relatively efficient, but many distrust them because they rely on complicated mathematical objects and relatively unproven assumptions. However, there is also another class of algorithms that are quantum-proof: hash-based algorithms. One example of this is the classic Lamport signature: create a Merkle tree of 164 nodes (a figure chosen specifically to match 160 bits of security), publish the root, and then have the signature of a document be the combined Merkle tree proof of a subset of 82 nodes pseudorandomly chosen based on the hash of the document. This signature is one-time, and bulky (~3000 bytes), but fulfills the purpose.\n\n\nThe question is, can we do better? There is an approach known as hash ladders, allowing the size of a signature to be brought down to 420 bytes, and one can use Merkle trees on another level to increase the number of signatures possible, although at the cost of adding 100-300 bytes to the signature. However, even still these approaches are imperfect, and if hash-based cryptography is to be competitive the properties of the algorithms will need to be substantially improved in order to have nicer properties.\n\n\n\u96be\u9898\n: create a signature algorithm relying on no security assumption but the random oracle property of hashes that maintains 160 bits of security against classical computers (ie. 80 vs. quantum due to Grover's algorithm) with optimal size and other properties.\n\n\n\u8981\u6c42\u548c\u5176\u4ed6\u5047\u8bbe\n\n\n\n\nThe computational effort of producing a signature should be less than 2\n24\n computational steps, assuming a hash takes 2\n8\n steps (a reasonable assumption due to hardware optimizations and in the future hashing ASICs built into chips)\n\n\nThe size of a signature should be as small as possible\n\n\nThe size of a public key should be as small as possible\n\n\nThe signature algorithm should be scalable to add any number of uses, although likely at the cost of adding a constant number of bytes per signature for every 2x increase in the maximum number of uses, and if possible the setup time should be sublinear in the number of uses.\n\n\n\n\n\u5171\u8bc6\n\n\nOne of the key elements in the Bitcoin algorithm is the concept of \"proof of work\". In any Byzantine-fault-tolerant system, the security level is often defined as the minimum percentage of hostile nodes - for example, in the context of secret sharing, the Berlekamp-Welch algorithm with 2x redundancy is guaranteed to provide the correct output assuming that the total number of hostile nodes does not exceed 25% of the network, and in the context of Bitcoin mining the requirement is that the size of the set of honest nodes exceeds the size of any individual hostile coalition. However, all of these security guarantees have one important qualification: there must be some way to define what an individual node is. Before Bitcoin, most fault-tolerant algorithms had high computational complexity and assumed that the size of the network would be small, and so each node would be run by a known individual or organization and so it is possible to count each node individually.\n\n\nWith Bitcoin, however, nodes are numerous, mostly anonymous, and can enter or leave the system at any time. Unless one puts in careful thought, such a system would quickly run into what is known as a Sybil attack, where a hostile attacks simply creates five times as many nodes as the rest of the network combined, whether by running them all on the same machine or rented virtual private server or on a botnet, and uses this supermajority to subvert the network. In order to prevent this kind of attack, the only known solution is to use a resource-based counting mechanism. For this purpose, Bitcoin uses a scheme known as proof-of-work, which consists of solving problems that are difficult to solve, but easy to verify. The weight of a node in the consensus is based on the number of problem solutions that the node presents, and the Bitcoin system rewards nodes that present such solutions (\"miners\") with new bitcoins and transaction fees.\n\n\nBitcoin's proof of work algorithm is a simple design known as Hashcash, invented by Adam Back in 1995. The hashcash function works as follows:\n\n\ndef hashcash_produce(data, difficulty):\n    nonce = random.randrange(2**256)\n    while sha256(data + str(nonce)) \n 2**256 / difficulty:\n        nonce += 1\n    return nonce\n\ndef hashcash_verify(data, nonce, difficulty):\n    return sha256(data + str(nonce)) \n= 2**256 / difficulty\n\n\n\n\n\nNote that in the actual Bitcoin protocol nonces are limited to 32 bits; at higher difficulty levels, one is required to also manipulate transaction data in the block as a sort of \"extranonce\".\n\n\nOriginally, the intent behind the Bitcoin design was very egalitarian in nature. Every individual would mine on their own desktop computer, producing a highly decentralized network without any point of control and a distribution mechanism that spread the initial supply a BTC across a wide number of users. And for the first 18 months of Bitcoin's existence, the system worked. In the summer of 2010, however, developers released a Bitcoin miner that took advantage of the massive parallelization offered by the graphics processing unit (GPU) of powerful computers, mining about 10-50 times more efficiently than CPUs. In 2013, specialization took a further turn, with the introduction of devices called \"application-specific integrated circuits\" - chips designed in silicon with the sole purpose of Bitcoin mining in mind, providing another 10-50x rise in efficiency. CPU and GPU mining are now completely unprofitable, and the only way to mine is to either start a multimillion-dollar ASIC manufacturing company or purchase an ASIC from one that already exists.\n\n\nAnother related issue is mining pool centralization. Theoretically, the legitimate function of a mining pool is simple: instead of mining on their own and receiving a small chance of earning the block reward of 25 BTC, miners mine for a pool, and the pool sends them a proportionate constant payout (eg. 0.002 BTC per block). There are centralized mining pools, but there are also P2P pools which serve the same function. However, P2P pools require miners to validate the entire blockchain, something which general-purpose computers can easily do but ASICs are not capable of; as a result, ASIC miners nearly all opt for centralized mining pools. The result of these trends is grim. Right now, nearly 25% of all new ASIC hashpower is produced in a single factory in Shenzhen, and nearly 50% of the network is controlled by a single mining pool.\n\n\nThe second problem is easy to alleviate; one simply creates a mining algorithm that forces every mining node to store the entire blockchain. The first problem, that of mining centralization, is much harder. There is the possibility that the problem will solve itself over time, and as the Bitcoin mining industry grows it will naturally become more decentralized as room emerges for more firms to participate. However, that is an empirical claim that may or may not come to pass, and we need to be prepared for the eventuality that it does not. Furthermore, the wasted energy and computation costs of proof of work as they stand today may prove to be entirely avoidable, and it is worth looking to see if that aspect of consensus algorithms can be alleviated.\n\n\n6. \u6297ASIC\u7684\u5de5\u4f5c\u8bc1\u660e\n\n\nOne approach at solving the problem is creating a proof-of-work algorithm based on a type of computation that is very difficult to specialize. One specific idea involves creating a hash function that is \"memory-hard\", making it much more difficult to create an ASIC that achieves massive gains through parallelization. This idea is simple, but fundamentally limited - if a function is memory-hard to compute, it is also generally memory-hard to verify. Additionally, there may be ways to specialize hardware for an algorithm that have nothing to do with hyperparallelizing it. Another approach involves randomly generating new mining functions per block, trying to make specialization gains impossible because the ASIC ideally suited for performing arbitrary computations is by definition simply a CPU. There may also be other strategies aside from these two.\n\n\nUltimately, perfect ASIC resistance is impossible; there are always portions of circuits that are going to be unused by any specific algorithm and that can be trimmed to cut costs in a specialized device. However, what we are looking for is not perfect ASIC resistance but rather economic ASIC resistance. Economic ASIC resistance can be defined as follows. First of all, we note that in a non-specialized environment mining returns are sublinear - everyone owns one computer, say with N units of unused computational power, so up to N units of mining cost only the additional electricity cost, whereas mining beyond N units costs both electricity and hardware. If the cost of mining with specialized hardware, including the cost of research and development, is higher per unit hashpower than the cost of those first N units of mining per user then one can call an algorithm economically ASIC resistant.\n\n\nFor a more in-depth discussion on ASIC-resistant hardware, see \nhttps://blog.ethereum.org/2014/06/19/mining/\n\n\n\u96be\u9898\n: Create two functions, \nPoWProduce(data,diff) -\n nonce\n and \nPoWVerify(data,nonce,diff) -\n { 0, 1 }\n, to serve as alternatives to Hashcash such that it is economically unattractive to produce an ASIC for \nPoWProduce\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n:\n\n\n\n\nPoWProduce\n must have expected runtime linear in \ndiff\n\n\nPoWVerify\n must have runtime at most polylogarithmic in \ndiff\n\n\nRunning \nPoWProduce\n should be the most efficient, or very close to the most efficient, way to produce values that return \n1\n when checked with \nPoWVerify\n (ie. no software optimization)\n\n\nPoWProduce\n must not be superlinear in computational power or time; that is to say, the expected number of successful \nPoWProduce\n computations for a node with \nN\n dollars worth of hardware after \nt\n seconds should be bounded by \nkNt\n for some \nk\n. Furthermore, the linearity should kick in quickly; ie. $1000 worth of mining hardware should function with over 90% efficiency.\n\n\nIt should be shown with reasonably rigorous technological and economic analysis that the algorithm is economically ASIC resistant.\n\n\n\n\n7. \u6709\u7528\u7684\u5de5\u4f5c\u8bc1\u660e\n\n\nAnother related economic issue, often pointed out by detractors of Bitcoin, is that the proof of work done in the Bitcoin network is essentially wasted effort. Miners spend 24 hours a day cranking out SHA256 (or in more advanced implementations Scrypt) computations with the hopes of producing a block that has a very low hash value, and ultimately all of this work has no value to society. Traditional centralized networks, like Paypal and the credit card network, manage to get by without performing any proof of work computations at all, whereas in the Bitcoin ecosystem about a million US dollars of electricity and manufacturing effort is essentially wasted every day to prop up the network.\n\n\nOne way of solving the problem that many have proposed is making the proof of work function something which is simultaneously useful; a common candidate is something like Folding@home, an existing program where users can download software onto their computers to simulate protein folding and provide researchers with a large supply of data to help them cure diseases. The problem is, however, that Folding@home is not \"easy to verify\"; verifying the someone did a Folding@home computation correctly, and did not cut corners to maximize their rounds-per-second at the cost of making the result useless in actual research, takes as long as doing the computation oneself. If either an efficiently verifiable proof-of-computation for Folding@home can be produced, or if we can find some other useful computation which is easy to verify, then cryptocurrency mining could actually become a huge boon to society, not only removing the objection that Bitcoin wastes \"energy\", but even being socially beneficial by providing a public good.\n\n\nNote that there is one major concern with this approach that has been identified: if the useful PoW is implemented incorrectly, it can potentially reduce the cost of an attack on the network. If the useful PoW is useful in such a way that it is sometimes economically viable for certain very large entities to perform the computation even without the currency incentive, then those entities have an incentive to launch attacks against the network at no cost, since they would be performing the computations anyway. One simple, though crude and imperfect, way of addressing this problem is to make the PoW a half-and-half mix between useful and useless, making the cost of an attack at least 50% of what it would be in a useless-PoW environment. In practice, the overhead of making PoW verifiable may well introduce over 2x inefficiency unintentionally. Another economic solution is to make the computation a \"pure\" public good such that no individual entity derives a significant benefit from it. Proposed solutions to this problem should include a rigorous analysis of this issue.\n\n\n\u96be\u9898\n: Create two functions, \nPoWProduce(data,diff) -\n nonce\n and \nPoWVerify(data,nonce,diff) -\n { 0, 1 }\n, to serve as alternatives to Hashcash such that the outputs of \nPoWProduce\n are independently useful.\n\n\n\u9700\u6c42\n\n\n\n\nPoWProduce\n must have expected runtime linear in \ndiff\n\n\nPoWVerify\n must have expected runtime at most polylogarithmic in \ndiff\n\n\nRunning \nPoWProduce\n should be the most efficient way to produce values that return \n1\n when checked with \nPoWVerify\n\n\nPoWProduce\n must not be superlinear in computational power or time; that is to say, the expected number of successful \nPoWProduce\n computations for a node with \nN\n dollars worth of hardware after \nt\n seconds should be bounded by \nkNt\n for some \nk\n. Furthermore, the linearity should kick in quickly; ie. $1000 worth of mining hardware should function with over 90% efficiency.\n\n\nPoWProduce\n must produce a public good, such that the total value to everyone of the public good produced is greater than the cost of all resources invested into the mining process.\n\n\nThe system must be able to exist without a trusted third party, but it is reasonable to allow a trusted third party to serve as a data source for useful computations. If the trusted third party acts maliciously in any way, the public good may be negated but the blockchain mining should not be compromised.\n\n\n\n\n8. \u6743\u76ca\u8bc1\u660e\n\n\nAnother approach to solving the mining centralization problem is to abolish mining entirely, and move to some other mechanism for counting the weight of each node in the consensus. The most popular alternative under discussion to date is \"proof of stake\" - that is to say, instead of treating the consensus model as \"one unit of CPU power, one vote\" it becomes \"one currency unit, one vote\".\n\n\nA very simple proof of stake algorithm requires the miner mining the block to sign it with the private key to the address holding their coins, where the block is valid if \nsha256(PREVHASH + ADDRESS + TIMESTAMP) \n= 2^256 * BALANCE / DIFFICULTY\n where \nPREVHASH\n is the hash of the previous block, \nADDRESS\n is the signer's address with balance \nBALANCE\n, \nTIMESTAMP\n is the current Unix time in seconds and \nDIFFICULTY\n is an adjustable parameter to regulate the frequency of successful signatures. At first glance, this algorithm has the basic required properties: every miner has some random chance per second of succeeding, and if your address has twice as much money in it then you have double the chance of success.\n\n\nHowever, this algorithm has one important flaw: there is \"nothing at stake\". In the event of a fork, whether the fork is accidental or a malicious attempt to rewrite history and reverse a transaction, the optimal strategy for any miner is to mine on every chain, so that the miner gets their reward no matter which fork wins. Thus, assuming a large number of economically interested miners, an attacker may be able to send a transaction in exchange for some digital good (usually another cryptocurrency), receive the good, then start a fork of the blockchain from one block behind the transaction and send the money to themselves instead, and even with 1% of the total stake the attacker's fork would win because everyone else is mining on both.\n\n\nAnother problem to keep in mind is the issue of so-called \"long-range attacks\" - attacks where the miner attempts to start a fork not five or ten blocks behind the head of the main chain, as happens normally, but hundreds of thousands of blocks back. If an algorithm is designed incorrectly, it may be possible for an attacker to start from that far back, and then mine billions of blocks into the future (since no proof of work is required), and new users would not be able to tell that the blockchain with billions of blocks more is illegitimate. This can generally be solved with timestamping, but special corner cases do tend to appear in overcomplicated designs.\n\n\nThe Slasher algorithm, described \nhere\n and implemented by Zack Hess as a proof-of-concept \nhere\n, represents my own attempt at fixing the nothing-at-stake problem. The core idea is that (1) the miners for each block are determined ahead of time, so in the event of a fork a miner will either have an opportunity to mine a given block on all chains or no chains, and (2) if a miner is caught signing two distinct blocks with the same block number they can be deprived of their reward. The algorithm is viable and effective, but it suffers from two flaws of unknown significance. First, if all of the miners for a given block learn each other's identities beforehand, they can meet up and collude to shut down the network. Second, the nothing-at-stake problem remains for attacks going back more than 3000 blocks, although this is a smaller issue because such attacks would be very obvious and can automatically trigger warnings.\n\n\nFor a more in-depth discussion on proof of stake, see \nhttps://blog.ethereum.org/2014/07/05/stake/\n\n\n\u96be\u9898\n: create a proof-of-stake algorithm that solves the nothing-at-stake problem and long-range attack problems, without introducing new collusion risks that require less than 25% of stakeholders to succeed.\n\n\n\u989d\u5916\u8981\u6c42\u548c\u5047\u8bbe\n\n\n\n\nThe expected return from mining should be bounded by \nk\n times the miner's stake for some \nk\n, and assuming $1 billion total participating stake a stake of $1000 should be able to reach 90% of this maximum efficiency.\n\n\nThe algorithm should be fully incentive-compatible, addressing the double-voting issue defined above and the collusion issue defined above at both short and long range.\n\n\n\n\n9. \u5b58\u50a8\u8bc1\u660e\n\n\nA third approach to the problem is to use a scarce computational resource other than computational power or currency. In this regard, the two main alternatives that have been proposed are storage and bandwidth. There is no way in principle to provide an after-the-fact cryptographic proof that bandwidth was given or used, so proof of bandwidth should most accurately be considered a subset of social proof, discussed in later problems, but proof of storage is something that certainly can be done computationally. An advantage of proof-of-storage is that it is completely ASIC-resistant; the kind of storage that we have in hard drives is already close to optimal.\n\n\nThe most simple algorithm for proving that you own a file with \nN\n blocks is to build a Merkle tree out of it, publish the root, and every \nk\n blocks publish a Merkle tree proof of the \ni\nth block where \ni\n is the previous block hash mod \nN\n. However, this algorithm is limited because it is only a simple building block, not a complete solution. In order to turn this into a currency, one would need to determine which files are being stored, who stores whose files, to what extent and how the system should enforce redundancy, and if the files come from the users themselves how to prevent compression optimizations and long-range attacks.\n\n\nCurrently, the latest work in this area are two projects called Permacoin and Torcoin, which solve some of the problems in proof of storage with two insights. First, users should not be able to choose which files they store. Instead, files should be randomly selected based on their public key and users should be required to store ALL of the work assigned or else face a zero reward. This idea, provided in the context of proof of bandwidth in the case of Torcoin, prevents attacks involving users only storing their own data. Second, a Lamport-like signature algorithm can be used that requires users to have their private key and store their file locally; as a result; uploading all of one's files to the cloud is no longer a viable strategy. This, to some degree, forces redundancy.\n\n\nHowever, the problem with Permacoin is that it leaves unclear what files should be stored; cryptocurrency issuance can theoretically pay for billions of dollars of work per year, but there is no single static archive whose storage is worth billions. Ideally, the system would allow for new files to be added, and perhaps even allow users to upload their own files, but without introducing new vulnerabilities.\n\n\n\u96be\u9898\n: create a currency that uses proof-of-storage as its consensus and distribution algorithm.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nThe currency must be future-proof, being able to expand the amount of data stored over time; the system should not eventually fall into some failure state if hard disk space continues to get cheaper and more efficient.\n\n\nThe currency should ideally be maximally useful. At the least, the currency should allow people to upload their own files and have them stored, providing an uploading network with minimal cryptographic overhead, although ideally the currency should select for files that are public goods, providing net total value to society in excess of the number of currency units issued.\n\n\nThe expected return from mining should be at most slightly superlinear, ie. it must be bounded by \nks/(1-s)\n for some \nk\n, where \ns\n is the miner's share of the total network, although perfect linearity is ideal.\n\n\nThe system should be maximally resistant against mining pool centralization as a result of any small degree of superlinearity.\n\n\nThe system should be secure against nothing-at-stake and long-range attacks.\n\n\nThe system should be secure against attacker involving users uploading specially formatted files or storing their own data.\n\n\n\n\n\u7ecf\u6d4e\u5b66\n\n\nThe second part of cryptoeconomics, and the part where solutions are much less easy to verify and quantify, is of course the economics. Cryptocurrencies are not just cryptographic systems, they are also economic systems, and both kinds of security need to be taken into account. Sometimes, cryptographic security may even be slightly compromised in favor of an economic approach - if a signature algorithm takes more effort to crack than one could gain from cracking it, that is often a reasonable substitute for true security. At the same time, economic problems are also much more difficult to define. One cannot usually definitively know whether or not a problem has been solved without extensive experimentation, and the result will often depend on cultural factors or the other organizational and social structures used by the individuals involved. However, if the economic problems can be solved, the solutions may often have reach far beyond just cryptocurrency.\n\n\n10. \u7a33\u5b9a\u503c\u5bc6\u7801\n\n\nOne of the main problems with Bitcoin is the issue of price volatility. The value of a bitcoin often experiences very large fluctuations, rising or falling by as much as 25% in a single day and 3x in a month. The main economic reason behind this is that the supply of bitcoins is fixed, so its price is directly proportional to demand (and therefore, by efficient market hypothesis, the expected discounted future demand), and demand is very unpredictable. It is not known if Bitcoin will be simply a niche payment method for transactions requiring a high degree of privacy, a replacement for Western Union, a mainstream consumer payment system or the reserve currency of the world, and the expected value of a bitcoin differs over a thousandfold between these various levels of adoption. Furthermore, the utility of the Bitcoin protocol is heavily dependent on the movements of the Bitcoin price (ie. people are interested in Bitcoin more if the price is going up), creating a positive feedback loop, which has arguably been responsible for both Bitcoin's great meteoric rises and its many-month-long periods of rapid decline.\n\n\nTo solve this problem, there are generally two paths that can be taken. The first is to have the network somehow detect its current level of economic usage, and have a supply function that automatically increases supply when usage increases. This reduces uncertainty; even though the expected future level of adoption of the protocol may have a variance of 10-100x, the circumstance where adoption increases 100x will also have 100x more supply and so the value of the currency will remain the same. There is a problem that if usage decreases there is no way to remove units from circulation, but even still the lack of upward uncertainty should reduce upward volatility, and downward volatility would also naturally reduce because it is no longer bad news for the value of the currency when an opportunity for increased usage is suddenly removed. Furthermore, in the long term the economy can be expected to grow, so the zero-supply-growth floor may not even ever be reached in practice.\n\n\nThe problem is that measuring an economy in a secure way is a difficult problem. The most obvious metric that the system has access to is mining difficulty, but mining difficulty also goes up with Moore's law and in the short term with ASIC development, and there is no known way to estimate the impact of Moore's law alone and so the currency cannot know if its difficulty increased by 10x due to better hardware, a larger user volume or a combination of both. Other metrics, such as transaction count, are potentially gameable by entities that want the supply to change in a particular direction (generally, holders want a lower supply, miners want a higher supply).\n\n\nAnother approach is to attempt to create a currency which tracks a specific asset, using some kind of incentive-compatible scheme likely based on the game-theoretic concept of Schelling points, to feed price information about the asset into the system in a decentralized way. This could then be combined with a supply function mechanism as above, or it can be incorporated into a zero-total-supply currency system which uses debts collateralized with other cryptographic assets to offset its positive supply and thus gain the ability to grow and shrink with changes to usage in either direction. The problem here is constructing the scheme in such a way that there is no incentive for entities to feed in false price information in order to increase or decrease the supply of the asset in their favor.\n\n\n\u96be\u9898\n: construct a cryptographic asset with a stable price.\n\n\n\u8981\u6c42\n\n\n\n\nThe expected root-mean-square daily change in the logarithm of the price of the asset should be less than 25% of that of Bitcoin under similar conditions. Ideally, the asset should be guaranteed to almost always maintain a value within 10% of an arbitrary cryptographic or real-world asset for which price information is easily accessible\n\n\nThe expectation analysis should take into account black swan risks (ie. systems where the variance is 0% 99% of the time but 10x in a day the other 1% of the time are unacceptable)\n\n\nThe solution must come with a model, including parameters such as short-term-consumption purchases, medium-term purchases, speculative purchases, positive and negative media, adoption and regulatory events, irrational actors and actors with political motives, show that their model well fits the history of Bitcoin and potentially major altcoins without overfitting, and show that under the model the other two requirements hold\n\n\nZero-total-supply assets, ie. assets where each unit is balanced by a collateralized debt of a unit, are allowed, although such systems must include a robust margin-calling mechanism because it is assumed that most users are anonymous and can therefore trivially run away from debts\n\n\n\n\n11. \u5206\u6563\u7684\u516c\u5171\u4ea7\u54c1\u6fc0\u52b1\n\n\nOne of the challenges in economic systems in general is the problem of \"public goods\". For example, suppose that there is a scientific research project which will cost $1 million to complete, and it is known that if it is completed the resulting research will save one million people $5 each. In total, the social benefit is clear: if everyone contributes $1, then each individual person will see a benefit of $5 - $1 = $4 for $4 million total. However, the problem is that from the point of view of each individual person contributing does not make sense - whether or not you contribute has close to zero bearing on whether enough money will be collected, so everyone has the incentive to sit out and let everyone else throw their money in, with the result that no one does.\n\n\nSo far, most problems to public goods have involved centralization; some large organization, whether a big company or a government, agrees to offer some of its private services only to those individuals who participate in paying for the public good. Often this is done implicitly: for example, some of the money from each purchase of an iPad goes toward research and development (some of which is a public good, and some of which is an excludable \"club good\"). At other times, it's more explicit, as in the case of taxation. In order for decentralized economic systems (we'll refer to decentralized economic systems that somehow rely on cryptography and/or cryptocurrency as \"cryptoeconomic systems\") to be effective, ways of incentivizing production of public goods relevant to that system are required. A few possible approaches include:\n\n\n\n\nAssurance contracts\n - the idea behind an assurance contract is that \nN\n people may or may not put their funds into a pool, where that pool pays to produce a public good if and only if at least $X in total is contributed. Otherwise, the pool pays everyone back. If the pool creator acts optimally, the tipping point will be right at the top of the bell curve that is the probability distribution for how much other people might contribute, meaning that the chance that one user with their contribution of \nX/N\n will be pivotal should, by central limit theorem, approach \n~1/sqrt(N)\n, creating a \nsqrt(N)\n-sized amplifying effect on their donation.\n\n\nDominant assurance contracts\n - a special type of assurance contract, called a dominant assurance contract, involves an entrepreneur that pays all contributors back slightly more than 100% of what they put in if the fund fails to reach its target (and takes profits if the fund succeeds); this provides an incentive for someone to create optimally targeted assurance contracts.\n\n\nCurrency issuance\n - a cryptoeconomic system can contain its own currency or token system which is somehow necessary or useful in some part of the system. These currency units can then either be generated by the system and then sold or directly assigned to reward contribution. This approach gets around the free-rider problem because no one needs to pay the $1 explicitly; the value arises out of the emergent value of the network which is does not cost people to support.\n\n\nStatus goods issuance\n - a status good can be defined as a good that confers only relative benefit to its holder and not absolute benefit to society; for example, you may stand out in the public if you wear an expensive diamond necklace, but if everyone could trivially obtain such a necklace the situation would be very similar to a world with no diamond necklaces at all. A cryptoeconomic system can release its own status goods, and then sell or award them. One example of a status good is a \"badge\"; some online forums, for example, show a special badge beside users that have contributed funds to support the forum's development and maintenance. Another important example of a status good is a namespace; for example, a decentralized messaging protocol may be able to fund itself by selling off all of the 1-4 letter usernames.\n\n\nRecursive rewarding\n - this is in some ways a mirror image of the concept of \"recursive punishment\" that arguably underlies a large number of social protocols. For example, consider the case of tax-funded police forces. In natural circumstances, there often arise opportunities to take actions which are beneficial to the perpetrator, but ultimately harmful to society as a whole (eg. theft). The most common solution to this problem is punishment - an act which is harmful in itself, but which shifts the incentives so that attacking is no longer beneficial to the perpetrator. However, there is a problem: there is no incentive to participate in the punishment process. This is solved by making punishment obligatory, with non-participation (in modern society by paying taxes) itself punishable by the same mechanism. Recursive rewarding is a mirror image of this strategy: here, we reward a desirable action, and people who participate in the rewarding mechanism (eg. by giving reward recipients a discount in shops) are themselves to be rewarded.\n\n\n\n\nMany of these approached can arguably be done in concert, or even simultaneously within one mechanism.\n\n\n\u96be\u9898\n: come up with and implement methods for incentivizing public goods production in a decentralized environment.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nA fully trustworthy oracle exists for determining whether or not a certain public good task has been completed (in reality this is false, but this is the domain of another problem)\n\n\nThe agents involved can be a combination of individual humans, teams of humans, AIs, simple software programs and decentralized cryptographic entities\n\n\nA certain degree of cultural filtering or conditioning may be required for the mechanism to work, but this should be as small as possible\n\n\nNo reliance on trusted parties or centralized parties should be required. Where some kind of \"supernode\" role does exist, the protocol should provide a way for anyone to participate in that function with a mechanism for rewarding those who do it well\n\n\nThe mechanism should ideally be able to handle both public goods which everyone values and public goods which are only valued by a small portion of the population (eg. the production of a freely available book or video on a specific topic)\n\n\n\n\n12. \u58f0\u8a89\u7cfb\u7edf\n\n\nA concept which can arguably be considered to be a mirror image of currency is a reputation system. A reputation system serves three functions. First of all, it provides a mechanism for filtering honest people from dishonest people. Different people have different moral preference profiles, and so individuals who cheat less in one context are less likely to cheat in another context. Second, it provides an incentive not to cheat. If an individual can be said to possess a reputation of value \nR\n, and he enters a business deal where he is receiving payment \nV\n in exchange for a product with cost-of-production \nC\n, then as long as \nR \n C\n the reputation system removes the incentive to run away with the money because doing so would sacrifice the reputation. Finally, reputation can be thought of as a kind of point system that people value intrinsically, both in a private context and as a status good in comparison with others.\n\n\nMoney serves functions that are very similar. People who are willing to spend more money on something tend to want it more, creating a filtering function ensuring efficient resource consumption on the demand side. It provides an incentive not to cheat by consuming and not producing, because if you do so your remaining currency units and thus ability to consume in the future will go down. And finally, it is also very much an intrinsically valued point system; in fact, some argue that among very wealthy individuals this function of money is dominant.\n\n\nHowever, there are also differences. First, money is an absolute score - I have X units of currency C from the point of view of everyone in the world - but reputation is a relative measure, depending on both the owner of the reputation and the observer. I may have a high reputation in North America, a near-zero reputation in Africa, and a negative reputation among certain kinds of antitechnologist and ultranationalist groups. Second, reputation is free to give; it does not cost me anything to praise you, except potentially moral liability that I may incur if you turn out to act immorally in some way. This is in contrast with money, where adding X units to A means subtracting X units from B.\n\n\nHowever, up until very recently, reputation has been a very informal concept, having no concept of score and instead relying entirely on individual opinion. Because opinion is relatively easy to manipulate, this means that reputation as a concept has been highly suboptimal in its implementation, and has been quite vulnerable to informational and psychological attacks. Some specific problems are:\n\n\n\n\nHow do we know how what the value of someone's reputation with someone else is after a particular number of interactions? A common attack on informal reputation systems is the \"long con\" - act honestly but passively and cheaply for a very long time, accumulate trust, and then suddenly go all out and destructively capitalize on one's reputation as much as possible. The initial dormant phase is cheap for the attacker, but ends up resulting in the attacker accumulating a disproportionately large amount of trust for the community and thereby ultimately causing much more damage than good. Overcompensate for this too much, however, and there ends up being no opportunity to gain trust.\n\n\nHow do we incorporate secondary trust? In general, when \nA\n is deciding whether or not to trust \nB\n, \nA\n has not had any prior dealings with \nB\n, and therefore has no way of knowing whether or not \nB\n is trustworthy. One approach is to just look at all ratings for \nB\n, but then we run into the issue of Sybil attacks: what if \nB\n creates 50000 fake users, all of whom rate each other highly, to give good ratings to him? To solve this problem, reputation systems rely on a fallback known as a web of trust: find some chain of people \nP[1] ... P[k]\n such that \nA\n trusts \nP[1]\n, \nP[i]\n trusts \nP[i+1]\n for all \ni\n, and \nP[k]\n trusts \nB\n. Under the \"six degrees of separation hypothesis\", any two people in the world except those completely disconnected from society have such a chain of maximum length \nk = 5\n (so at most six hops total). However, the question arises, if \nA\n has a certain rating for \nP[1]\n and \nP[1]\n has a certain rating for \nB\n, what should the reputation system recommend to \nB\n?\n\n\nIf a reputation system becomes more formalized, are there market attacks that reduce its effectiveness to simply being just another form of money? Specifically, how would a reputation system where giving reputation is free handle users multiplying their reputation with millions of \"I praise you if you praise me\" trades? Will such trades need to be explicitly banned, punishable by loss of reputation, or is there a better solution?\n\n\nHow do we deal with double use attacks? Specifically, suppose that \nA\n has a reputation with value \nR = $1000\n. Using this reputation, \nA\n has a business dealing where \nP[1]\n trusts her for $600. Then, she simultaneously engages in such a dealing with \nP[2], P[3] ... P[10]\n, each of whom individually believe that \nA\n will not betray them since $600 \n $1000, and then runs away with $6000 taking the $1000 hit from the value of her reputation. How do we prevent such fractional reserve-like scenarios?\n\n\n\n\n\u96be\u9898\n: design a formalized reputation system, including a score \nrep(A,B) -\n V\n where \nV\n is the reputation of \nB\n from the point of view of \nA\n, a mechanism for determining the probability that one party can be trusted by another, and a mechanism for updating the reputation given a record of a particular open or finalized interaction.\n\n\nNote that for the purpose of this use case we are targeting specifically the \"can I trust you\" use case of reputation, and not the social-incentivizing \"\nwhuffie\n\"-esque currency-like aspect.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nThe system has access to a record of all finalized transactions inside the system and all transactions in progress, although entities are of course able to choose to make deals outside the system\n\n\nIt is allowed to introduce mechanisms like charity donations, public goods provision and sacrifices as a way of increasing one's reputation. However, if non-monetary contributions are allowed, there needs to be some mechanism for measuring their value\n\n\nFor simplicity, we can assume that interactions between two people are of the form \"A pays, then B sends the product and A receives\", with no possibility for loss beyond the principal (eg. food poisoning) or ambiguous quality. Ideally, however, the system should account for such possibilities.\n\n\nThe system should continue to be reasonably accurate whether the parties involved are simple programs (eg. micropayment software protocols), more complicated AIs, DAOs, individual humans or human centralized or decentralized organizations\n\n\nIf a mechanism is provided for determining the probability of a successful interaction, a success metric for the system can be defined as the sum over all transactions of \nV * (S * log(p) - (1-S) * log(1-p))\n, where \nS = 1\n if the transaction succeeded and \nS = 0\n if there was a registered complaint, \np\n is the assigned probability and \nV\n is the value of the transaction. The objective is to maximize this metric.\n\n\n\n\n\u5ea6\u91cf\n\n\nIn the world of cryptoeconomics, in order for something to be rewarded it must be measured. Some things are easy to measure; for example, just by looking at the string \"dog5356356\" and its SHA256 hash, \n0000390f327fefc900...\n, one can clearly see that around 2\n16\n SHA256 computations were done to produce it. Other computational results that cannot be verified so quickly can be easily measured competitively using challenge-response protocols, where different parties are incentivized to find errors in each other's proofs. Results to mathematical problems are also usually easy to computationally verify. Other things, however, cannot be verified just by looking them; in that case, in both the real world and the cryptographic world, there is only one solution: social proof.\n\n\nTo some extent, proof of work consensus is itself a form of social proof. Transaction A happened before transaction B because the majority of users say it did, and there is an economic incentive to go with the majority opinion (specifically, if you generate a block on the incorrect chain, that block will get discarded and the miner will receive no reward). Assuming that most participants act truthfully, the incentive is to go along with the projected majority and tell the truth as well. This insight can be extended into \nSchellingCoin\n, a generalized data feed protocol, protocols for proof of bandwidth, and anything else that can be quickly verified. The challenge is, however, what if verification has a cost? What if it takes some effort to determine whether or not a certain thing has happened, or what if the information is in principle only available to a few people? If there is too much gathering cost or secrecy, then centralization becomes necessary; the question is, how high can we go? How much can we measure without any social proof at all, and how much can we measure without a centralized verifier?\n\n\n13. \u5353\u8d8a\u7684\u8bc1\u660e\n\n\nOne interesting, and largely unexplored, solution to the problem of distribution specifically (there are reasons why it cannot be so easily used for mining) is using tasks that are socially useful but require original human-driven creative effort and talent. For example, one can come up with a \"proof of proof\" currency that rewards players for coming up with mathematical proofs of certain theorems. There is no generic algorithm, aside from brute force, for proving theorems, and yet proofs of theorems are theoretically computationally easy to verify: one simply needs to write every step of the proof in a formal language, allowing the use of only one inference rule (eg. \na + b = b + a\n or \na * (b + c) = a * b + a * c\n but not \na * (b + c) = a * c + b * a\n) between each step, and having a program verify the correctness of the inferences at each step.\n\n\nFor example, a proof of a common algebraic factorization problem appears as follows:\n\n\n  a^2 - b^2\n= a^2 - a*b + a*b - b^2\n= a*a - a*b + a*b - b^2\n= a*(a - b) + a*b - b^2\n= a*(a - b) + a*b - b*b\n= a*(a - b) + b*a - b*b\n= a*(a - b) + b*(a - b)\n= (a + b)*(a - b)\n\n\n\n\n\nEach step of the proof can be verified using pattern matching algorithms, but it is much harder for a computer to figure out that the trick is to add and subtract \na*b\n into the expression (technically, in this case specialized algorithms can do it, but in more general cases especially involving second-order logic it becomes intractable). Note that for computers the proof must be written down in excruciating detail; blockchain-based algorithms specifically heavily benefit from simplicity. To alleviate this problem, compilers can likely be made that can make small two and three-step inferences and expand shorter proofs into more complete ones.\n\n\nAlternatives to proof-of-proof include proof-of-optimization, finding optimal inputs to some function to maximize a particular output (eg. the ability of a radio antenna to receive signals), algorithms involving playing strategy games or multiplayer AI challenges (one can even require users to submit programs to the blockchain that play against each other), and solving a specific math problem at greater and greater difficulty (eg. factoring). Note that because success in these problems is very sporadic, and highly inegalitarian, one cannot use most of these algorithms for consensus; rather, it makes sense to focus on distribution.\n\n\n\u96be\u9898\n: create a proof-of-excellence distribution mechanism that rewards solving problems that are both dominated by human effort and whose solutions provide some benefit to humanity.\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nGiven a well-justified extrapolation of the global levels of human and computer competence at the underlying problem, over 75% of the rewards from the system should be provided by human labor, although software aids are allowed.\n\n\nThe algorithm must ideally be future-proof; that is to say, it must continue rewarding value production in the long term and should not be an area that will eventually be \"solved\" completely.\n\n\nThe distribution should be maximally egalitarian, though this is a secondary concern.\n\n\nThe system should be secure against front-running attacks, ie. if an individual submits a solution, then it should not be practical for even a moderately powerful attacker to look at the solution and then resubmit his own transaction containing the same solution and thereby steal the reward.\n\n\n\n\n14. \u53cdSybil\u7cfb\u7edf\n\n\nA problem that is somewhat related to the issue of a reputation system is the challenge of creating a \"unique identity system\" - a system for generating tokens that prove that an identity is not part of a Sybil attack. The naive form of anti-Sybil token is simple: a sacrifice or proof of deposit. In a sacrifice setup, such identities simply cost $X, and in a PoD system identities require a deposit of $Y in order to be active, where perhaps the deposit can be taken away or destroyed under certain circumstances. However, we would like to have a system that has nicer and more egalitarian features than \"one-dollar-one-vote\"; arguably, one-person-one-vote would be ideal.\n\n\nTo date, we have seen two major strategies for trying to solve this problem. One potential solution is to come up with a proof-of-work algorithm which is dominated by human labor, and not computers. This is not as difficult as it may seem; although computers get more and more powerful every year, there are a number of problems that have remained out of computers' reach for decades, and it may even be possible to identify a class of problems that are the artificial-intelligence-theoretic equivalent of \"NP-complete\" - problems such that, if they can be solved, it with high probability implies that AI can essentially replicate human activity in its entirety, in which case we are essentially in a post-scarcity utopia and money and incentivization may not even be necessary. These problems may be non-interactive challenges like CAPTCHAs, although all existing CAPTCHAs are far from adequate for the task, or they may be interactive strategy games like Go.\n\n\nThe second strategy is to use social proof, turning the muscle of decentralized information gathering toward a simple problem: are these two identities the same person? If they are not, then they receive two anti-Sybil tokens, and if they are they receive one token. In general, we can separately define two concepts of identity: voluntary identity and involuntary identity. A voluntary identity can be seen as a cluster of interactions which are in some fashion correlated with each other; for example, a cryptographic identity consists of the set of interactions signed by a particular public key. An involuntary identity is a cluster of interactions which are correlated with each other, but where the entity producing the interactions does not want the correlations to be visible. A simple unique identity system would rely on voluntary identities embedded in social networks, with the understanding that creating separate identities with reputations is an expensive task and so most people would not want to do it, but a more advanced system may try to detect involuntary slipups like writing style patterns or IP addresses.\n\n\nThe question is, can we use these mechanisms, either separately or together, and perhaps in combination with cryptoeconomic protocols and sacrifices as a fallback in order to create an anti-Sybil system which is highly egalitarian? We will accept that any scheme can be cracked at some cost; however, what we want is for it to be much more efficient for individuals to obtain \none\n anti-Sybil token \"the proper way\" rather than purchasing one off the grey/black market. The challenge is to push the grey/black market cost as high as possible, as much as possible without making the first token difficult.\n\n\n\u96be\u9898\n - create a mechanism for distributing anti-Sybil tokens\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n:\n\n\n\n\nEveryone is part of a social network with similar characteristics to social networks now found in the real world, and social data can be provably provided to cryptoeconomic systems (eg. blockchains, Ethereum contracts)\n\n\nThe cost of obtaining one anti-Sybil token for a human should be as low as possible\n\n\nThe cost of obtaining multiple anti-Sybil tokens for a human should be as high as possible\n\n\nThe cost of obtaining anti-Sybil tokens for an automated system should be as high as possible (this is a more important criterion than high cost for multi-obtainment for humans)\n\n\nThe system should not create dependency on centralized parties (eg. government passport offices) that have the power to cheat the system\n\n\n\n\n15. \u5206\u6563\u7684\u8d21\u732e\u6307\u6807\n\n\nIncentivizing the production of public goods is, unfortunately, not the only problem that centralization solves. The other problem is determining, first, which public goods are worth producing in the first place and, second, determining to what extent a particular effort actually accomplished the production of the public good. This challenge deals with the latter issue. Although in the case of computational tasks it's easy to come up with a proof of solution, for non-computational tasks the situation is much more difficult. If a cryptoeconomic system wants to incentivize users to build better graphical user interfaces to its own system, how would it rate people's contributions? \nEven more problematically\n, what about potentially quasi-adversarial tasks like incentivizing updates to its own code? What about a DAO that funds healthcare, or tries to incentivize adopting renewable energy?\n\n\nThis is a subclass of the general \"social proof\" problem; here, the particular challenge is that each individual datum in question is something that very few people are interested in, and data gathering costs are often high. Sometimes, there is not even a concept of a single \"correct\" value with respect to the particular metric; in the case of quality measurement for an interface, a solution like A/B testing may be required. In adversarial cases, there may need to be an opportunity for incentivized opponents to look at a solution and attempt to pick it apart.\n\n\n\u96be\u9898\n: come up with and implement a decentralized method for determining whether or not a particular task was performed by a specific person, and for estimating the quality of the work\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nThe agents involved can be a combination of individual humans, teams of humans, AIs, simple software programs and other DAOs\n\n\nThere is no cryptographically verifiable information about the completion of any task; the system must rely entirely on some form of social proof\n\n\n\n\n16. \u5206\u6563\u7684\u6210\u529f\u6307\u6807\n\n\nAnother, related, problem to the problem of decentralized contribution metrics is the problem of decentralized success metrics. On the macroscopic scale, how do we know if, and to what extent, an organization has succeeded in accomplishing its objectives? In the case of something like Bitcoin, there is a simple, but imperfect, answer: success can be measured by the hashpower of the network. This setup is reasonably effective, but is flawed in two ways: first, hashpower is an imperfect proxy for price, because the development or nondevelopment of ASICs may skew the results, and second, price is an imperfect proxy for success, because the currency may have greater success as something with a lower market capitalization if it is more used in other ways. In the case of a DAO funding healthcare or anti-climate-change efforts, however, no such heuristic exists at all. Once again, some concept of social proof is the only option.\n\n\nHere, information gathering costs are low, and information is accessible to everyone in the public, so a higher level of accuracy is possible, hopefully even enough for financial contracts based off of the metric to be possible. However, in order to maintain that higher level of accuracy, and in the presence of such financial derivatives, new problems arise. Can one moderately powerful entity manipulate the metric for their own benefit? If information gathering costs do exist, is the system vulnerable to falling into a centralized equilibrium, where everyone is incentivized to simply follow along with the actions of some specific party?\n\n\n\u96be\u9898\n: come up with and implement a decentralized method for measuring numerical real-world variables\n\n\n\u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42\n\n\n\n\nThe agents involved can be a combination of individual humans, teams of humans, AIs, simple software programs and other DAOs\n\n\nThe system should be able to measure anything that humans can currently reach a rough consensus on (eg. price of an asset, temperature, global CO2 concentration", 
            "title": "\u52a0\u5bc6\u8d27\u5e01\u7684\u96be\u9898"
        }, 
        {
            "location": "/Misc/Problems/#_1", 
            "text": "The science of cryptography, which has existed to some degree for millennia but in a formal and systematized form for less than fifty years, can be most simply defined as the study of communication in an adversarial environment. In a similar vein, we can define cryptoeconomics as a field that goes one step further: the study of economic interaction in an adversarial environment. To distinguish itself from traditional economics, which certainly studies both economic interaction and adversaries, cryptoeconomics generally focuses on interactions that take place over network protocols. Particular domains of cryptoeconomics include:   Online trust and reputation systems  Cryptographic tokens / cryptocurrencies, and more generally digital assets  Self-executing \"smart\" contracts  Consensus algorithms  Anti-spam and anti-sybil attack algorithms  Incentivized marketplaces for computational resources  Decentralized systems for social welfare / mutual aid / basic income  Decentralized governance (for both for-profit and non-profit entities)   The increasing prominence of cryptoeconomics in the last five years is to a large extent the result of the growth of cryptocurrencies and digital tokens, and brings a new, and interesting, dimension to cryptography. While before cryptography was, by and large, a purely computational and information-theoretic science, with strong guarantees built on security assumptions that are close to absolute, once money enters the picture the perfect world of mathematics must interact with a much more messy reality of human social structures, economic incentives, partial guarantees and known vulnerabilities that can only be mitigated, and not outright removed. While a cryptographer is used to assumptions of the form \"this algorithm is guaranteed to be unbreakable provided that these underlying math problems remain hard\", the world of cryptoeconomics must contend with fuzzy empirical factors such as the difficulty of collusion attacks, the relative quantity of altruistic, profit-seeking and anti-altruistic parties, the level of concentration of different kinds of resources, and in some cases even sociocultural circumstances.  In traditional applied cryptography, security assumptions tend to look something like this:   No one can do more than 2 79  computational steps  Factoring is hard (ie. superpolynomial)  Taking nth roots modulo composites is hard  The elliptic curve discrete logarithm problem cannot be solved faster than in 2 n/2  time   In cryptoeconomics, on the other hand, the basic security assumptions that we depend on are, alongside the cryptographic assumptions, roughly the following:   No set of individuals that control more than 25% of all computational resources is capable of colluding  No set of individuals that control more than 25% of all money is capable of colluding  The amount of computation of a certain proof of work function that can be accomplished with a given amount of money is not superlinear beyond a point which is reasonably low  There exist a non-negligible number of altruists and a non-negligible number of crazies or political opponents of the system, and the majority of users can be reasonably modeled as being close to economically rational  The number of users of a system is large, and users can appear or disappear at any time, although at least some users are persistent  Censorship is impossible, and any two nodes can send messages to each other relatively quickly.  It is trivial to generate a very large number of IP addresses, and one can purchase an unlimited amount of network bandwidth  Many users are anonymous, so negative reputations and debts are close to unenforceable   There will also be additional security assumptions specific to certain problems. Thus, quite often it will not even be possible to definitively say that a certain protocol is secure or insecure or that a certain problem has been solved. Rather, it will be necessary to create solutions that are optimized for particular empirical and social realities, and continue further and further optimizing them over time.", 
            "title": "\u52a0\u5bc6\u8d27\u5e01\u7684\u96be\u9898"
        }, 
        {
            "location": "/Misc/Problems/#_2", 
            "text": "The decentralized consensus technology used in Bitcoin is impressive to a very large extent because of its simplicity. A 30-year-old problem in computer science was solved via a mechanism which is simple to implement, and so simple to understand that even some semi-technical teenagers can describe the entirety of how it works. However, at the same time the technology in its current form is very limited. The scalability in Bitcoin is very crude; the fact that every full node needs to process every transaction is a large roadblock to the future success of the platform, and a factor preventing its effective use in micropayments (arguably the one place where it is the most useful). Timestamping is flawed, and proof-of-computation algorithms are very limited in the types of computation that they can support. The fact that the original solution was so \"easy\", however, suggests that there is still a large opportunity to improve, and there are a number of directions in which improvement could be directed.", 
            "title": "\u6280\u672f"
        }, 
        {
            "location": "/Misc/Problems/#1", 
            "text": "One of the largest problems facing the cryptocurrency space today is the issue of scalability. It is an often repeated claim that, while mainstream payment networks process something like 2000 transactions per second, in its current form the Bitcoin network can only process seven. On a fundamental level, this is not strictly true; simply by changing the block size limit parameter, Bitcoin can easily be made to support 70 or even 7000 transactions per second. However, if Bitcoin does get to that scale, we run into a problem: it becomes impossible for the average user to run a full node, and full nodes become relegated only to that small collection of businesses that can afford the resources. Because mining only requires the block header, even miners can (and in practice most do) mine without downloading the blockchain.  The main concern with this is trust: if there are only a few entities capable of running full nodes, then those entities can conspire and agree to give themselves a large number of additional bitcoins, and there would be no way for other users to see for themselves that a block is invalid without processing an entire block themselves. Although such a fraud may potentially be discovered after the fact, power dynamics may create a situation where the default action is to simply go along with the fraudulent chain (and authorities can create a climate of fear to support such an action) and there is a coordination problem in switching back. Thus, at the extreme, Bitcoin with 7000 transactions per second has security properties that are essentially similar to a centralized system like Paypal, whereas what we want is a system that handles 7000 TPS with the same levels of decentralization that cryptocurrency originally promised to offer.  Ideally, a blockchain design should exist that works, and has similar security properties to Bitcoin with regard to 51% attacks, that functions even if no single node processes more than  1/n  of all transactions where  n  can be scaled up to be as high as necessary, although perhaps at the cost of linearly or quadratically growing secondary inefficiencies and convergence concerns. This would allow the blockchain architecture to process an arbitrarily high number of TPS but at the same time retain the same level of decentralization that Satoshi envisioned.  \u96be\u9898 : create a blockchain design that maintains Bitcoin-like security guarantees, but where the maximum size of the most powerful node that needs to exist for the network to keep functioning is substantially sublinear in the number of transactions.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42 :   There exist a large number of miners in the network  Miners may be using specialized hardware or unspecialized hardware. Specialized hardware should be assumed to be more powerful than unspecialized hardware by a large (eg. 10000) constant factor at specific tasks.  Ordinary users will be using unspecialized hardware  Ideally, after some number of blocks (perhaps logarithmic in the total size of the network) every transaction should require 51% of network hashpower to reverse. However, solutions where transactions can pay very small fees for a lower \"level\" of security are acceptable, though one should take care to avoid situations where an attacker can profit by performing one attack to reverse very many small transactions at the same time  Ideally, the solution should work for and maintain as many properties as possible of a generalized account-based blockchain (eg. Ethereum), though solutions specific to currency, domain registrations or other specialized use cases are acceptable", 
            "title": "1. \u533a\u5757\u94fe\u53ef\u6269\u5c55\u6027"
        }, 
        {
            "location": "/Misc/Problems/#2", 
            "text": "An important property that Bitcoin needs to keep is that there should be roughly one block generated every ten minutes; if a block is generated every day, the payment system becomes too slow, and if a block is generated every second there are serious centralization and network efficiency concerns that would make the consensus system essentially nonviable even assuming the absence of any attackers. To ensure this, the Bitcoin network adjusts difficulty so that if blocks are produced too quickly it becomes harder to mine a new block, and if blocks are produced too slowly it becomes easier.  However, this solution requires an important ingredient: the blockchain must be aware of time. In order to solve this problem, Bitcoin requires miners to submit a timestamp in each block, and nodes reject a block if the block's timestamp is either (i) behind the median timestamp of the previous eleven blocks, or (ii) more than 2 hours into the future, from the point of view of the node's own internal clock. This algorithm is good enough for Bitcoin, because time serves only the very limited function of regulating the block creation rate over the long term, but there are potential vulnerabilities in this approach, issues which may compound in blockchains where time plays a more important role.  \u96be\u9898 : create a distributed incentive-compatible system, whether it is an overlay on top of a blockchain or its own blockchain, which maintains the current time to high accuracy.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   All legitimate users have clocks in a normal distribution around some \"real\" time with standard deviation 20 seconds.  No two nodes are more than 20 seconds apart in terms of the amount of time it takes for a message originating from one node to reach any other node.  The solution is allowed to rely on an existing concept of \"N nodes\"; this would in practice be enforced with proof-of-stake or non-sybil tokens (see #9).  The system should continuously provide a time which is within 120s (or less if possible) of the internal clock of  99% of honestly participating nodes. Note that this also implies that the system should be self-consistent to within about 190s.  The system should exist without relying on any kind of proof-of-work.  External systems may end up relying on this system; hence, it should remain secure against attackers controlling   25% of nodes regardless of incentives.", 
            "title": "2. \u65f6\u95f4\u6233"
        }, 
        {
            "location": "/Misc/Problems/#3", 
            "text": "Perhaps the holy grail of the study zero-knowledge proofs is the concept of an arbitrary proof of computation: given a program P with input I, the challenge is to create a zero-knowledge proof that you ran P with input I and received output O, such that the proof can be verified quickly (ie. in polylogarithmic or ideally constant time) even if the original computation took a very large number of steps to complete. In an ideal setup, the proof would even hide the value of I, just proving that you ran P with some output with result O, and if I needs to be made public it can be embedded into the program. Such a primitive, if possible, would have massive implications for cryptocurrency:   The blockchain scalability problem would be much easier to solve. Instead of miners publishing blocks containing a list of transactions, they would be publishing a proof that they ran the blockchain state updater with some list of transactions and produced a certain output; thus, instead of transactions needing to be verified by every node in the network, they could be processed by one miner and then every other miner and user could quickly verify the proof of computation and if the proof turns out correct they would accept the new state. This is not a complete solution, because there would still be a need to transmit data, but the problem would be much easier with this powerful building block.  The blockchain privacy problem would be much easier to solve. The blockchain scalability solution above would hide the details behind individual transactions; it would only reveal the fact that all of them are legitimate, so transactions would be hidden from everyone but the sender and the receiver.  It would become computationally viable to use a Turing-complete consensus network as a generic distributed cloud computing system; if you have any computation you wanted done, you would be able to publish the program for miners and miners would be able to run the program for you and deliver the result alongside a proof of its validity.   There is a large amount of existing research on this topic, including a protocol known as \"SCIP\" (Succinct Computational Integrity and Privacy) that is already working in test environments, although with the limitation that a trusted third party is required to initially set up the keys; use of this prior work by both its original developers and others is encouraged.  \u96be\u9898 : create programs  POC_PROVE(P,I) -  (O,Q)  and  POC_VERIFY(P,O,Q) -  { 0, 1 }  such that  POC_PROVE  runs program  P  on input  I  and returns the program output  O  and a proof-of-computation  Q  and  POC_VERIFY  takes  P ,  O  and  Q  and outputs whether or not  Q  and  O  were legitimately produced by the  POC_PROVE  algorithm using  P .  \u8981\u6c42\u548c\u5176\u4ed6\u5047\u8bbe   The runtime of  POC_PROVE  should be in  O(n*polylog(n))  where  n  is the number of steps required to run the program.  The runtime of  POC_VERIFY  should be either constant or logarithmic in the number of steps, and at most linear in the maximum memory usage of the program.  The protocol should require no trusted third parties. If TTPs are required, the protocol should include a mechanism for simulating one efficiently using secure multiparty computation.", 
            "title": "3. \u8ba1\u7b97\u7684\u4efb\u610f\u8bc1\u660e"
        }, 
        {
            "location": "/Misc/Problems/#4", 
            "text": "For many years now we have known how to encrypt data. Simple, robust and well-tested algorithms exist for both symmetric key encryption, where the same key is needed to encrypt and decrypt, and public key encryption, where the encryption key and decryption key are different and one cannot be derived from the other. However, there is another kind of encryption that can potentially be very useful, but for which we currently have no viable algorithm: the encryption of programs. The holy grail is to create an obfuscator  O , such that given any program P the obfuscator can produce a second program  O(P) = Q  such that  P  and  Q  return the same output if given the same input and, importantly,  Q  reveals no information whatsoever about the internals of  P . One can hide inside of  Q  a password, a secret encryption key, or one can simply use  Q  to hide the proprietary workings of the algorithm itself.  In 2007, it was proven that perfect \"black box\" encryption is impossible; essentially, the argument is that there is a difference between having black-box access to a program and having the code to that program, no matter how obfuscated, and one can construct certain classes of programs that resist obfuscation. However, there is also a weaker notion of obfuscation, known as indistinguishability obfuscation, that appears to be quite possible. The definition of an indistinguishability obfuscator  O  is that if you take two equivalent (ie. same inputs -  same outputs) programs  A  and  B  and calculate  O(A) = P  and  O(B) = Q , then there is no computationally feasible way for an outsider without access to  A  or  B  to tell whether  P  came from  A  or  B .  This type of obfuscation may seem more limited, but it is nevertheless sufficient for many applications. For a heuristic argument why, consider two programs  F  and  G  where  F  internally contains and simply prints out that 32-byte string which is the hash of \"12345\", whereas G actually computes the hash of \"12345\" and prints it out. By the indistinguishability obfuscation definition, there is no computationally feasible way to tell  O(F)  from  O(G)  apart. Hence, if one can feasibly recover \"12345\" from  O(G) , then for  O(G)  and  O(F)  to be indistinguishable one would also need to be able to feasibly recover \"12345\" from  O(F)  - a feat which essentially entails breaking the preimage resistance of a cryptographic hash function.  Recently, a discovery was made by Craig Gentry, Amit Sahai et al on an algorithm which uses a construction known as \"multilinear jigsaw puzzles\" in order to accomplish this. Their algorithm, described here, claims to satisfy the indistinguishability obfuscation property, although at a high cost: the algorithm requires the use of fully homomorphic encryption, a highly inefficient construction that incurs roughly a one-billion-fold computational overhead.  If this construction can be made better, the potential benefits are massive. The most interesting possibility in the world of cryptocurrency is the idea of an on-blockchain contract containing private information. This basically allows for the scripting properties of Turing-complete blockchain technologies, such as Ethereum, to be exported into any other financial or non-financial system on the internet; for example, one can imagine an Ethereum contract which contains a user's online banking password, and if certain conditions of the contract are satisfied the contract would initiate an HTTPS session with the bank, using some node as an intermediary, and log into the bank account with the user's password and make a specified withdrawal. Because the contract would be obfuscated, there would be no way for the intermediary node, or any other player in the blockchain, to modify the request in-transit or determine the user's password. The same trick can be done with any other website, or much more easily with a \"dumb\" blockchain such as Bitcoin.  \u96be\u9898 : create a reasonably efficient indistinguishability obfuscation algorithm.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   Successful attacks must have an expected runtime above 2^80  The algorithm should be sufficiently fast that a standard ECDSA signature or an AES encryption should be feasible within 10 8  computational steps (more specifically, 10 8  gas in the Ethereum VM)", 
            "title": "4. \u4ee3\u7801\u6df7\u6dc6"
        }, 
        {
            "location": "/Misc/Problems/#5", 
            "text": "One of the looming threats on the horizon to cryptocurrency, and cryptography in general, is the issue of quantum computers. Currently, the problem does not seem too severe; all quantum computers are either \"adiabatic quantum computers\", effective at only an extremely limited set of problems and perhaps not even better than classical computers at all, or machines with a very small number of qubits not capable of factoring numbers higher than 35. In the future, however, quantum computers may become much more powerful, and the recent revelations around the activities of government agencies such as the NSA have sparked fears, however unlikely, that the US military may control a quantum computer already. With this in mind, the movement toward quantum-proof cryptography has become a somewhat higher priority.  To date, all quantum-proof schemes fall into one of two categories. First, there are algorithms involving lattice-based constructions, relying on the hardness of the problem of finding a linear combination of vectors whose sum is much shorter than the length of any individual member. These algorithms appear to be powerful, and relatively efficient, but many distrust them because they rely on complicated mathematical objects and relatively unproven assumptions. However, there is also another class of algorithms that are quantum-proof: hash-based algorithms. One example of this is the classic Lamport signature: create a Merkle tree of 164 nodes (a figure chosen specifically to match 160 bits of security), publish the root, and then have the signature of a document be the combined Merkle tree proof of a subset of 82 nodes pseudorandomly chosen based on the hash of the document. This signature is one-time, and bulky (~3000 bytes), but fulfills the purpose.  The question is, can we do better? There is an approach known as hash ladders, allowing the size of a signature to be brought down to 420 bytes, and one can use Merkle trees on another level to increase the number of signatures possible, although at the cost of adding 100-300 bytes to the signature. However, even still these approaches are imperfect, and if hash-based cryptography is to be competitive the properties of the algorithms will need to be substantially improved in order to have nicer properties.  \u96be\u9898 : create a signature algorithm relying on no security assumption but the random oracle property of hashes that maintains 160 bits of security against classical computers (ie. 80 vs. quantum due to Grover's algorithm) with optimal size and other properties.  \u8981\u6c42\u548c\u5176\u4ed6\u5047\u8bbe   The computational effort of producing a signature should be less than 2 24  computational steps, assuming a hash takes 2 8  steps (a reasonable assumption due to hardware optimizations and in the future hashing ASICs built into chips)  The size of a signature should be as small as possible  The size of a public key should be as small as possible  The signature algorithm should be scalable to add any number of uses, although likely at the cost of adding a constant number of bytes per signature for every 2x increase in the maximum number of uses, and if possible the setup time should be sublinear in the number of uses.", 
            "title": "5. \u57fa\u4e8e\u54c8\u5e0c\u7684\u52a0\u5bc6"
        }, 
        {
            "location": "/Misc/Problems/#_3", 
            "text": "One of the key elements in the Bitcoin algorithm is the concept of \"proof of work\". In any Byzantine-fault-tolerant system, the security level is often defined as the minimum percentage of hostile nodes - for example, in the context of secret sharing, the Berlekamp-Welch algorithm with 2x redundancy is guaranteed to provide the correct output assuming that the total number of hostile nodes does not exceed 25% of the network, and in the context of Bitcoin mining the requirement is that the size of the set of honest nodes exceeds the size of any individual hostile coalition. However, all of these security guarantees have one important qualification: there must be some way to define what an individual node is. Before Bitcoin, most fault-tolerant algorithms had high computational complexity and assumed that the size of the network would be small, and so each node would be run by a known individual or organization and so it is possible to count each node individually.  With Bitcoin, however, nodes are numerous, mostly anonymous, and can enter or leave the system at any time. Unless one puts in careful thought, such a system would quickly run into what is known as a Sybil attack, where a hostile attacks simply creates five times as many nodes as the rest of the network combined, whether by running them all on the same machine or rented virtual private server or on a botnet, and uses this supermajority to subvert the network. In order to prevent this kind of attack, the only known solution is to use a resource-based counting mechanism. For this purpose, Bitcoin uses a scheme known as proof-of-work, which consists of solving problems that are difficult to solve, but easy to verify. The weight of a node in the consensus is based on the number of problem solutions that the node presents, and the Bitcoin system rewards nodes that present such solutions (\"miners\") with new bitcoins and transaction fees.  Bitcoin's proof of work algorithm is a simple design known as Hashcash, invented by Adam Back in 1995. The hashcash function works as follows:  def hashcash_produce(data, difficulty):\n    nonce = random.randrange(2**256)\n    while sha256(data + str(nonce))   2**256 / difficulty:\n        nonce += 1\n    return nonce\n\ndef hashcash_verify(data, nonce, difficulty):\n    return sha256(data + str(nonce))  = 2**256 / difficulty  Note that in the actual Bitcoin protocol nonces are limited to 32 bits; at higher difficulty levels, one is required to also manipulate transaction data in the block as a sort of \"extranonce\".  Originally, the intent behind the Bitcoin design was very egalitarian in nature. Every individual would mine on their own desktop computer, producing a highly decentralized network without any point of control and a distribution mechanism that spread the initial supply a BTC across a wide number of users. And for the first 18 months of Bitcoin's existence, the system worked. In the summer of 2010, however, developers released a Bitcoin miner that took advantage of the massive parallelization offered by the graphics processing unit (GPU) of powerful computers, mining about 10-50 times more efficiently than CPUs. In 2013, specialization took a further turn, with the introduction of devices called \"application-specific integrated circuits\" - chips designed in silicon with the sole purpose of Bitcoin mining in mind, providing another 10-50x rise in efficiency. CPU and GPU mining are now completely unprofitable, and the only way to mine is to either start a multimillion-dollar ASIC manufacturing company or purchase an ASIC from one that already exists.  Another related issue is mining pool centralization. Theoretically, the legitimate function of a mining pool is simple: instead of mining on their own and receiving a small chance of earning the block reward of 25 BTC, miners mine for a pool, and the pool sends them a proportionate constant payout (eg. 0.002 BTC per block). There are centralized mining pools, but there are also P2P pools which serve the same function. However, P2P pools require miners to validate the entire blockchain, something which general-purpose computers can easily do but ASICs are not capable of; as a result, ASIC miners nearly all opt for centralized mining pools. The result of these trends is grim. Right now, nearly 25% of all new ASIC hashpower is produced in a single factory in Shenzhen, and nearly 50% of the network is controlled by a single mining pool.  The second problem is easy to alleviate; one simply creates a mining algorithm that forces every mining node to store the entire blockchain. The first problem, that of mining centralization, is much harder. There is the possibility that the problem will solve itself over time, and as the Bitcoin mining industry grows it will naturally become more decentralized as room emerges for more firms to participate. However, that is an empirical claim that may or may not come to pass, and we need to be prepared for the eventuality that it does not. Furthermore, the wasted energy and computation costs of proof of work as they stand today may prove to be entirely avoidable, and it is worth looking to see if that aspect of consensus algorithms can be alleviated.", 
            "title": "\u5171\u8bc6"
        }, 
        {
            "location": "/Misc/Problems/#6-asic", 
            "text": "One approach at solving the problem is creating a proof-of-work algorithm based on a type of computation that is very difficult to specialize. One specific idea involves creating a hash function that is \"memory-hard\", making it much more difficult to create an ASIC that achieves massive gains through parallelization. This idea is simple, but fundamentally limited - if a function is memory-hard to compute, it is also generally memory-hard to verify. Additionally, there may be ways to specialize hardware for an algorithm that have nothing to do with hyperparallelizing it. Another approach involves randomly generating new mining functions per block, trying to make specialization gains impossible because the ASIC ideally suited for performing arbitrary computations is by definition simply a CPU. There may also be other strategies aside from these two.  Ultimately, perfect ASIC resistance is impossible; there are always portions of circuits that are going to be unused by any specific algorithm and that can be trimmed to cut costs in a specialized device. However, what we are looking for is not perfect ASIC resistance but rather economic ASIC resistance. Economic ASIC resistance can be defined as follows. First of all, we note that in a non-specialized environment mining returns are sublinear - everyone owns one computer, say with N units of unused computational power, so up to N units of mining cost only the additional electricity cost, whereas mining beyond N units costs both electricity and hardware. If the cost of mining with specialized hardware, including the cost of research and development, is higher per unit hashpower than the cost of those first N units of mining per user then one can call an algorithm economically ASIC resistant.  For a more in-depth discussion on ASIC-resistant hardware, see  https://blog.ethereum.org/2014/06/19/mining/  \u96be\u9898 : Create two functions,  PoWProduce(data,diff) -  nonce  and  PoWVerify(data,nonce,diff) -  { 0, 1 } , to serve as alternatives to Hashcash such that it is economically unattractive to produce an ASIC for  PoWProduce  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42 :   PoWProduce  must have expected runtime linear in  diff  PoWVerify  must have runtime at most polylogarithmic in  diff  Running  PoWProduce  should be the most efficient, or very close to the most efficient, way to produce values that return  1  when checked with  PoWVerify  (ie. no software optimization)  PoWProduce  must not be superlinear in computational power or time; that is to say, the expected number of successful  PoWProduce  computations for a node with  N  dollars worth of hardware after  t  seconds should be bounded by  kNt  for some  k . Furthermore, the linearity should kick in quickly; ie. $1000 worth of mining hardware should function with over 90% efficiency.  It should be shown with reasonably rigorous technological and economic analysis that the algorithm is economically ASIC resistant.", 
            "title": "6. \u6297ASIC\u7684\u5de5\u4f5c\u8bc1\u660e"
        }, 
        {
            "location": "/Misc/Problems/#7", 
            "text": "Another related economic issue, often pointed out by detractors of Bitcoin, is that the proof of work done in the Bitcoin network is essentially wasted effort. Miners spend 24 hours a day cranking out SHA256 (or in more advanced implementations Scrypt) computations with the hopes of producing a block that has a very low hash value, and ultimately all of this work has no value to society. Traditional centralized networks, like Paypal and the credit card network, manage to get by without performing any proof of work computations at all, whereas in the Bitcoin ecosystem about a million US dollars of electricity and manufacturing effort is essentially wasted every day to prop up the network.  One way of solving the problem that many have proposed is making the proof of work function something which is simultaneously useful; a common candidate is something like Folding@home, an existing program where users can download software onto their computers to simulate protein folding and provide researchers with a large supply of data to help them cure diseases. The problem is, however, that Folding@home is not \"easy to verify\"; verifying the someone did a Folding@home computation correctly, and did not cut corners to maximize their rounds-per-second at the cost of making the result useless in actual research, takes as long as doing the computation oneself. If either an efficiently verifiable proof-of-computation for Folding@home can be produced, or if we can find some other useful computation which is easy to verify, then cryptocurrency mining could actually become a huge boon to society, not only removing the objection that Bitcoin wastes \"energy\", but even being socially beneficial by providing a public good.  Note that there is one major concern with this approach that has been identified: if the useful PoW is implemented incorrectly, it can potentially reduce the cost of an attack on the network. If the useful PoW is useful in such a way that it is sometimes economically viable for certain very large entities to perform the computation even without the currency incentive, then those entities have an incentive to launch attacks against the network at no cost, since they would be performing the computations anyway. One simple, though crude and imperfect, way of addressing this problem is to make the PoW a half-and-half mix between useful and useless, making the cost of an attack at least 50% of what it would be in a useless-PoW environment. In practice, the overhead of making PoW verifiable may well introduce over 2x inefficiency unintentionally. Another economic solution is to make the computation a \"pure\" public good such that no individual entity derives a significant benefit from it. Proposed solutions to this problem should include a rigorous analysis of this issue.  \u96be\u9898 : Create two functions,  PoWProduce(data,diff) -  nonce  and  PoWVerify(data,nonce,diff) -  { 0, 1 } , to serve as alternatives to Hashcash such that the outputs of  PoWProduce  are independently useful.  \u9700\u6c42   PoWProduce  must have expected runtime linear in  diff  PoWVerify  must have expected runtime at most polylogarithmic in  diff  Running  PoWProduce  should be the most efficient way to produce values that return  1  when checked with  PoWVerify  PoWProduce  must not be superlinear in computational power or time; that is to say, the expected number of successful  PoWProduce  computations for a node with  N  dollars worth of hardware after  t  seconds should be bounded by  kNt  for some  k . Furthermore, the linearity should kick in quickly; ie. $1000 worth of mining hardware should function with over 90% efficiency.  PoWProduce  must produce a public good, such that the total value to everyone of the public good produced is greater than the cost of all resources invested into the mining process.  The system must be able to exist without a trusted third party, but it is reasonable to allow a trusted third party to serve as a data source for useful computations. If the trusted third party acts maliciously in any way, the public good may be negated but the blockchain mining should not be compromised.", 
            "title": "7. \u6709\u7528\u7684\u5de5\u4f5c\u8bc1\u660e"
        }, 
        {
            "location": "/Misc/Problems/#8", 
            "text": "Another approach to solving the mining centralization problem is to abolish mining entirely, and move to some other mechanism for counting the weight of each node in the consensus. The most popular alternative under discussion to date is \"proof of stake\" - that is to say, instead of treating the consensus model as \"one unit of CPU power, one vote\" it becomes \"one currency unit, one vote\".  A very simple proof of stake algorithm requires the miner mining the block to sign it with the private key to the address holding their coins, where the block is valid if  sha256(PREVHASH + ADDRESS + TIMESTAMP)  = 2^256 * BALANCE / DIFFICULTY  where  PREVHASH  is the hash of the previous block,  ADDRESS  is the signer's address with balance  BALANCE ,  TIMESTAMP  is the current Unix time in seconds and  DIFFICULTY  is an adjustable parameter to regulate the frequency of successful signatures. At first glance, this algorithm has the basic required properties: every miner has some random chance per second of succeeding, and if your address has twice as much money in it then you have double the chance of success.  However, this algorithm has one important flaw: there is \"nothing at stake\". In the event of a fork, whether the fork is accidental or a malicious attempt to rewrite history and reverse a transaction, the optimal strategy for any miner is to mine on every chain, so that the miner gets their reward no matter which fork wins. Thus, assuming a large number of economically interested miners, an attacker may be able to send a transaction in exchange for some digital good (usually another cryptocurrency), receive the good, then start a fork of the blockchain from one block behind the transaction and send the money to themselves instead, and even with 1% of the total stake the attacker's fork would win because everyone else is mining on both.  Another problem to keep in mind is the issue of so-called \"long-range attacks\" - attacks where the miner attempts to start a fork not five or ten blocks behind the head of the main chain, as happens normally, but hundreds of thousands of blocks back. If an algorithm is designed incorrectly, it may be possible for an attacker to start from that far back, and then mine billions of blocks into the future (since no proof of work is required), and new users would not be able to tell that the blockchain with billions of blocks more is illegitimate. This can generally be solved with timestamping, but special corner cases do tend to appear in overcomplicated designs.  The Slasher algorithm, described  here  and implemented by Zack Hess as a proof-of-concept  here , represents my own attempt at fixing the nothing-at-stake problem. The core idea is that (1) the miners for each block are determined ahead of time, so in the event of a fork a miner will either have an opportunity to mine a given block on all chains or no chains, and (2) if a miner is caught signing two distinct blocks with the same block number they can be deprived of their reward. The algorithm is viable and effective, but it suffers from two flaws of unknown significance. First, if all of the miners for a given block learn each other's identities beforehand, they can meet up and collude to shut down the network. Second, the nothing-at-stake problem remains for attacks going back more than 3000 blocks, although this is a smaller issue because such attacks would be very obvious and can automatically trigger warnings.  For a more in-depth discussion on proof of stake, see  https://blog.ethereum.org/2014/07/05/stake/  \u96be\u9898 : create a proof-of-stake algorithm that solves the nothing-at-stake problem and long-range attack problems, without introducing new collusion risks that require less than 25% of stakeholders to succeed.  \u989d\u5916\u8981\u6c42\u548c\u5047\u8bbe   The expected return from mining should be bounded by  k  times the miner's stake for some  k , and assuming $1 billion total participating stake a stake of $1000 should be able to reach 90% of this maximum efficiency.  The algorithm should be fully incentive-compatible, addressing the double-voting issue defined above and the collusion issue defined above at both short and long range.", 
            "title": "8. \u6743\u76ca\u8bc1\u660e"
        }, 
        {
            "location": "/Misc/Problems/#9", 
            "text": "A third approach to the problem is to use a scarce computational resource other than computational power or currency. In this regard, the two main alternatives that have been proposed are storage and bandwidth. There is no way in principle to provide an after-the-fact cryptographic proof that bandwidth was given or used, so proof of bandwidth should most accurately be considered a subset of social proof, discussed in later problems, but proof of storage is something that certainly can be done computationally. An advantage of proof-of-storage is that it is completely ASIC-resistant; the kind of storage that we have in hard drives is already close to optimal.  The most simple algorithm for proving that you own a file with  N  blocks is to build a Merkle tree out of it, publish the root, and every  k  blocks publish a Merkle tree proof of the  i th block where  i  is the previous block hash mod  N . However, this algorithm is limited because it is only a simple building block, not a complete solution. In order to turn this into a currency, one would need to determine which files are being stored, who stores whose files, to what extent and how the system should enforce redundancy, and if the files come from the users themselves how to prevent compression optimizations and long-range attacks.  Currently, the latest work in this area are two projects called Permacoin and Torcoin, which solve some of the problems in proof of storage with two insights. First, users should not be able to choose which files they store. Instead, files should be randomly selected based on their public key and users should be required to store ALL of the work assigned or else face a zero reward. This idea, provided in the context of proof of bandwidth in the case of Torcoin, prevents attacks involving users only storing their own data. Second, a Lamport-like signature algorithm can be used that requires users to have their private key and store their file locally; as a result; uploading all of one's files to the cloud is no longer a viable strategy. This, to some degree, forces redundancy.  However, the problem with Permacoin is that it leaves unclear what files should be stored; cryptocurrency issuance can theoretically pay for billions of dollars of work per year, but there is no single static archive whose storage is worth billions. Ideally, the system would allow for new files to be added, and perhaps even allow users to upload their own files, but without introducing new vulnerabilities.  \u96be\u9898 : create a currency that uses proof-of-storage as its consensus and distribution algorithm.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   The currency must be future-proof, being able to expand the amount of data stored over time; the system should not eventually fall into some failure state if hard disk space continues to get cheaper and more efficient.  The currency should ideally be maximally useful. At the least, the currency should allow people to upload their own files and have them stored, providing an uploading network with minimal cryptographic overhead, although ideally the currency should select for files that are public goods, providing net total value to society in excess of the number of currency units issued.  The expected return from mining should be at most slightly superlinear, ie. it must be bounded by  ks/(1-s)  for some  k , where  s  is the miner's share of the total network, although perfect linearity is ideal.  The system should be maximally resistant against mining pool centralization as a result of any small degree of superlinearity.  The system should be secure against nothing-at-stake and long-range attacks.  The system should be secure against attacker involving users uploading specially formatted files or storing their own data.", 
            "title": "9. \u5b58\u50a8\u8bc1\u660e"
        }, 
        {
            "location": "/Misc/Problems/#_4", 
            "text": "The second part of cryptoeconomics, and the part where solutions are much less easy to verify and quantify, is of course the economics. Cryptocurrencies are not just cryptographic systems, they are also economic systems, and both kinds of security need to be taken into account. Sometimes, cryptographic security may even be slightly compromised in favor of an economic approach - if a signature algorithm takes more effort to crack than one could gain from cracking it, that is often a reasonable substitute for true security. At the same time, economic problems are also much more difficult to define. One cannot usually definitively know whether or not a problem has been solved without extensive experimentation, and the result will often depend on cultural factors or the other organizational and social structures used by the individuals involved. However, if the economic problems can be solved, the solutions may often have reach far beyond just cryptocurrency.", 
            "title": "\u7ecf\u6d4e\u5b66"
        }, 
        {
            "location": "/Misc/Problems/#10", 
            "text": "One of the main problems with Bitcoin is the issue of price volatility. The value of a bitcoin often experiences very large fluctuations, rising or falling by as much as 25% in a single day and 3x in a month. The main economic reason behind this is that the supply of bitcoins is fixed, so its price is directly proportional to demand (and therefore, by efficient market hypothesis, the expected discounted future demand), and demand is very unpredictable. It is not known if Bitcoin will be simply a niche payment method for transactions requiring a high degree of privacy, a replacement for Western Union, a mainstream consumer payment system or the reserve currency of the world, and the expected value of a bitcoin differs over a thousandfold between these various levels of adoption. Furthermore, the utility of the Bitcoin protocol is heavily dependent on the movements of the Bitcoin price (ie. people are interested in Bitcoin more if the price is going up), creating a positive feedback loop, which has arguably been responsible for both Bitcoin's great meteoric rises and its many-month-long periods of rapid decline.  To solve this problem, there are generally two paths that can be taken. The first is to have the network somehow detect its current level of economic usage, and have a supply function that automatically increases supply when usage increases. This reduces uncertainty; even though the expected future level of adoption of the protocol may have a variance of 10-100x, the circumstance where adoption increases 100x will also have 100x more supply and so the value of the currency will remain the same. There is a problem that if usage decreases there is no way to remove units from circulation, but even still the lack of upward uncertainty should reduce upward volatility, and downward volatility would also naturally reduce because it is no longer bad news for the value of the currency when an opportunity for increased usage is suddenly removed. Furthermore, in the long term the economy can be expected to grow, so the zero-supply-growth floor may not even ever be reached in practice.  The problem is that measuring an economy in a secure way is a difficult problem. The most obvious metric that the system has access to is mining difficulty, but mining difficulty also goes up with Moore's law and in the short term with ASIC development, and there is no known way to estimate the impact of Moore's law alone and so the currency cannot know if its difficulty increased by 10x due to better hardware, a larger user volume or a combination of both. Other metrics, such as transaction count, are potentially gameable by entities that want the supply to change in a particular direction (generally, holders want a lower supply, miners want a higher supply).  Another approach is to attempt to create a currency which tracks a specific asset, using some kind of incentive-compatible scheme likely based on the game-theoretic concept of Schelling points, to feed price information about the asset into the system in a decentralized way. This could then be combined with a supply function mechanism as above, or it can be incorporated into a zero-total-supply currency system which uses debts collateralized with other cryptographic assets to offset its positive supply and thus gain the ability to grow and shrink with changes to usage in either direction. The problem here is constructing the scheme in such a way that there is no incentive for entities to feed in false price information in order to increase or decrease the supply of the asset in their favor.  \u96be\u9898 : construct a cryptographic asset with a stable price.  \u8981\u6c42   The expected root-mean-square daily change in the logarithm of the price of the asset should be less than 25% of that of Bitcoin under similar conditions. Ideally, the asset should be guaranteed to almost always maintain a value within 10% of an arbitrary cryptographic or real-world asset for which price information is easily accessible  The expectation analysis should take into account black swan risks (ie. systems where the variance is 0% 99% of the time but 10x in a day the other 1% of the time are unacceptable)  The solution must come with a model, including parameters such as short-term-consumption purchases, medium-term purchases, speculative purchases, positive and negative media, adoption and regulatory events, irrational actors and actors with political motives, show that their model well fits the history of Bitcoin and potentially major altcoins without overfitting, and show that under the model the other two requirements hold  Zero-total-supply assets, ie. assets where each unit is balanced by a collateralized debt of a unit, are allowed, although such systems must include a robust margin-calling mechanism because it is assumed that most users are anonymous and can therefore trivially run away from debts", 
            "title": "10. \u7a33\u5b9a\u503c\u5bc6\u7801"
        }, 
        {
            "location": "/Misc/Problems/#11", 
            "text": "One of the challenges in economic systems in general is the problem of \"public goods\". For example, suppose that there is a scientific research project which will cost $1 million to complete, and it is known that if it is completed the resulting research will save one million people $5 each. In total, the social benefit is clear: if everyone contributes $1, then each individual person will see a benefit of $5 - $1 = $4 for $4 million total. However, the problem is that from the point of view of each individual person contributing does not make sense - whether or not you contribute has close to zero bearing on whether enough money will be collected, so everyone has the incentive to sit out and let everyone else throw their money in, with the result that no one does.  So far, most problems to public goods have involved centralization; some large organization, whether a big company or a government, agrees to offer some of its private services only to those individuals who participate in paying for the public good. Often this is done implicitly: for example, some of the money from each purchase of an iPad goes toward research and development (some of which is a public good, and some of which is an excludable \"club good\"). At other times, it's more explicit, as in the case of taxation. In order for decentralized economic systems (we'll refer to decentralized economic systems that somehow rely on cryptography and/or cryptocurrency as \"cryptoeconomic systems\") to be effective, ways of incentivizing production of public goods relevant to that system are required. A few possible approaches include:   Assurance contracts  - the idea behind an assurance contract is that  N  people may or may not put their funds into a pool, where that pool pays to produce a public good if and only if at least $X in total is contributed. Otherwise, the pool pays everyone back. If the pool creator acts optimally, the tipping point will be right at the top of the bell curve that is the probability distribution for how much other people might contribute, meaning that the chance that one user with their contribution of  X/N  will be pivotal should, by central limit theorem, approach  ~1/sqrt(N) , creating a  sqrt(N) -sized amplifying effect on their donation.  Dominant assurance contracts  - a special type of assurance contract, called a dominant assurance contract, involves an entrepreneur that pays all contributors back slightly more than 100% of what they put in if the fund fails to reach its target (and takes profits if the fund succeeds); this provides an incentive for someone to create optimally targeted assurance contracts.  Currency issuance  - a cryptoeconomic system can contain its own currency or token system which is somehow necessary or useful in some part of the system. These currency units can then either be generated by the system and then sold or directly assigned to reward contribution. This approach gets around the free-rider problem because no one needs to pay the $1 explicitly; the value arises out of the emergent value of the network which is does not cost people to support.  Status goods issuance  - a status good can be defined as a good that confers only relative benefit to its holder and not absolute benefit to society; for example, you may stand out in the public if you wear an expensive diamond necklace, but if everyone could trivially obtain such a necklace the situation would be very similar to a world with no diamond necklaces at all. A cryptoeconomic system can release its own status goods, and then sell or award them. One example of a status good is a \"badge\"; some online forums, for example, show a special badge beside users that have contributed funds to support the forum's development and maintenance. Another important example of a status good is a namespace; for example, a decentralized messaging protocol may be able to fund itself by selling off all of the 1-4 letter usernames.  Recursive rewarding  - this is in some ways a mirror image of the concept of \"recursive punishment\" that arguably underlies a large number of social protocols. For example, consider the case of tax-funded police forces. In natural circumstances, there often arise opportunities to take actions which are beneficial to the perpetrator, but ultimately harmful to society as a whole (eg. theft). The most common solution to this problem is punishment - an act which is harmful in itself, but which shifts the incentives so that attacking is no longer beneficial to the perpetrator. However, there is a problem: there is no incentive to participate in the punishment process. This is solved by making punishment obligatory, with non-participation (in modern society by paying taxes) itself punishable by the same mechanism. Recursive rewarding is a mirror image of this strategy: here, we reward a desirable action, and people who participate in the rewarding mechanism (eg. by giving reward recipients a discount in shops) are themselves to be rewarded.   Many of these approached can arguably be done in concert, or even simultaneously within one mechanism.  \u96be\u9898 : come up with and implement methods for incentivizing public goods production in a decentralized environment.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   A fully trustworthy oracle exists for determining whether or not a certain public good task has been completed (in reality this is false, but this is the domain of another problem)  The agents involved can be a combination of individual humans, teams of humans, AIs, simple software programs and decentralized cryptographic entities  A certain degree of cultural filtering or conditioning may be required for the mechanism to work, but this should be as small as possible  No reliance on trusted parties or centralized parties should be required. Where some kind of \"supernode\" role does exist, the protocol should provide a way for anyone to participate in that function with a mechanism for rewarding those who do it well  The mechanism should ideally be able to handle both public goods which everyone values and public goods which are only valued by a small portion of the population (eg. the production of a freely available book or video on a specific topic)", 
            "title": "11. \u5206\u6563\u7684\u516c\u5171\u4ea7\u54c1\u6fc0\u52b1"
        }, 
        {
            "location": "/Misc/Problems/#12", 
            "text": "A concept which can arguably be considered to be a mirror image of currency is a reputation system. A reputation system serves three functions. First of all, it provides a mechanism for filtering honest people from dishonest people. Different people have different moral preference profiles, and so individuals who cheat less in one context are less likely to cheat in another context. Second, it provides an incentive not to cheat. If an individual can be said to possess a reputation of value  R , and he enters a business deal where he is receiving payment  V  in exchange for a product with cost-of-production  C , then as long as  R   C  the reputation system removes the incentive to run away with the money because doing so would sacrifice the reputation. Finally, reputation can be thought of as a kind of point system that people value intrinsically, both in a private context and as a status good in comparison with others.  Money serves functions that are very similar. People who are willing to spend more money on something tend to want it more, creating a filtering function ensuring efficient resource consumption on the demand side. It provides an incentive not to cheat by consuming and not producing, because if you do so your remaining currency units and thus ability to consume in the future will go down. And finally, it is also very much an intrinsically valued point system; in fact, some argue that among very wealthy individuals this function of money is dominant.  However, there are also differences. First, money is an absolute score - I have X units of currency C from the point of view of everyone in the world - but reputation is a relative measure, depending on both the owner of the reputation and the observer. I may have a high reputation in North America, a near-zero reputation in Africa, and a negative reputation among certain kinds of antitechnologist and ultranationalist groups. Second, reputation is free to give; it does not cost me anything to praise you, except potentially moral liability that I may incur if you turn out to act immorally in some way. This is in contrast with money, where adding X units to A means subtracting X units from B.  However, up until very recently, reputation has been a very informal concept, having no concept of score and instead relying entirely on individual opinion. Because opinion is relatively easy to manipulate, this means that reputation as a concept has been highly suboptimal in its implementation, and has been quite vulnerable to informational and psychological attacks. Some specific problems are:   How do we know how what the value of someone's reputation with someone else is after a particular number of interactions? A common attack on informal reputation systems is the \"long con\" - act honestly but passively and cheaply for a very long time, accumulate trust, and then suddenly go all out and destructively capitalize on one's reputation as much as possible. The initial dormant phase is cheap for the attacker, but ends up resulting in the attacker accumulating a disproportionately large amount of trust for the community and thereby ultimately causing much more damage than good. Overcompensate for this too much, however, and there ends up being no opportunity to gain trust.  How do we incorporate secondary trust? In general, when  A  is deciding whether or not to trust  B ,  A  has not had any prior dealings with  B , and therefore has no way of knowing whether or not  B  is trustworthy. One approach is to just look at all ratings for  B , but then we run into the issue of Sybil attacks: what if  B  creates 50000 fake users, all of whom rate each other highly, to give good ratings to him? To solve this problem, reputation systems rely on a fallback known as a web of trust: find some chain of people  P[1] ... P[k]  such that  A  trusts  P[1] ,  P[i]  trusts  P[i+1]  for all  i , and  P[k]  trusts  B . Under the \"six degrees of separation hypothesis\", any two people in the world except those completely disconnected from society have such a chain of maximum length  k = 5  (so at most six hops total). However, the question arises, if  A  has a certain rating for  P[1]  and  P[1]  has a certain rating for  B , what should the reputation system recommend to  B ?  If a reputation system becomes more formalized, are there market attacks that reduce its effectiveness to simply being just another form of money? Specifically, how would a reputation system where giving reputation is free handle users multiplying their reputation with millions of \"I praise you if you praise me\" trades? Will such trades need to be explicitly banned, punishable by loss of reputation, or is there a better solution?  How do we deal with double use attacks? Specifically, suppose that  A  has a reputation with value  R = $1000 . Using this reputation,  A  has a business dealing where  P[1]  trusts her for $600. Then, she simultaneously engages in such a dealing with  P[2], P[3] ... P[10] , each of whom individually believe that  A  will not betray them since $600   $1000, and then runs away with $6000 taking the $1000 hit from the value of her reputation. How do we prevent such fractional reserve-like scenarios?   \u96be\u9898 : design a formalized reputation system, including a score  rep(A,B) -  V  where  V  is the reputation of  B  from the point of view of  A , a mechanism for determining the probability that one party can be trusted by another, and a mechanism for updating the reputation given a record of a particular open or finalized interaction.  Note that for the purpose of this use case we are targeting specifically the \"can I trust you\" use case of reputation, and not the social-incentivizing \" whuffie \"-esque currency-like aspect.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   The system has access to a record of all finalized transactions inside the system and all transactions in progress, although entities are of course able to choose to make deals outside the system  It is allowed to introduce mechanisms like charity donations, public goods provision and sacrifices as a way of increasing one's reputation. However, if non-monetary contributions are allowed, there needs to be some mechanism for measuring their value  For simplicity, we can assume that interactions between two people are of the form \"A pays, then B sends the product and A receives\", with no possibility for loss beyond the principal (eg. food poisoning) or ambiguous quality. Ideally, however, the system should account for such possibilities.  The system should continue to be reasonably accurate whether the parties involved are simple programs (eg. micropayment software protocols), more complicated AIs, DAOs, individual humans or human centralized or decentralized organizations  If a mechanism is provided for determining the probability of a successful interaction, a success metric for the system can be defined as the sum over all transactions of  V * (S * log(p) - (1-S) * log(1-p)) , where  S = 1  if the transaction succeeded and  S = 0  if there was a registered complaint,  p  is the assigned probability and  V  is the value of the transaction. The objective is to maximize this metric.", 
            "title": "12. \u58f0\u8a89\u7cfb\u7edf"
        }, 
        {
            "location": "/Misc/Problems/#_5", 
            "text": "In the world of cryptoeconomics, in order for something to be rewarded it must be measured. Some things are easy to measure; for example, just by looking at the string \"dog5356356\" and its SHA256 hash,  0000390f327fefc900... , one can clearly see that around 2 16  SHA256 computations were done to produce it. Other computational results that cannot be verified so quickly can be easily measured competitively using challenge-response protocols, where different parties are incentivized to find errors in each other's proofs. Results to mathematical problems are also usually easy to computationally verify. Other things, however, cannot be verified just by looking them; in that case, in both the real world and the cryptographic world, there is only one solution: social proof.  To some extent, proof of work consensus is itself a form of social proof. Transaction A happened before transaction B because the majority of users say it did, and there is an economic incentive to go with the majority opinion (specifically, if you generate a block on the incorrect chain, that block will get discarded and the miner will receive no reward). Assuming that most participants act truthfully, the incentive is to go along with the projected majority and tell the truth as well. This insight can be extended into  SchellingCoin , a generalized data feed protocol, protocols for proof of bandwidth, and anything else that can be quickly verified. The challenge is, however, what if verification has a cost? What if it takes some effort to determine whether or not a certain thing has happened, or what if the information is in principle only available to a few people? If there is too much gathering cost or secrecy, then centralization becomes necessary; the question is, how high can we go? How much can we measure without any social proof at all, and how much can we measure without a centralized verifier?", 
            "title": "\u5ea6\u91cf"
        }, 
        {
            "location": "/Misc/Problems/#13", 
            "text": "One interesting, and largely unexplored, solution to the problem of distribution specifically (there are reasons why it cannot be so easily used for mining) is using tasks that are socially useful but require original human-driven creative effort and talent. For example, one can come up with a \"proof of proof\" currency that rewards players for coming up with mathematical proofs of certain theorems. There is no generic algorithm, aside from brute force, for proving theorems, and yet proofs of theorems are theoretically computationally easy to verify: one simply needs to write every step of the proof in a formal language, allowing the use of only one inference rule (eg.  a + b = b + a  or  a * (b + c) = a * b + a * c  but not  a * (b + c) = a * c + b * a ) between each step, and having a program verify the correctness of the inferences at each step.  For example, a proof of a common algebraic factorization problem appears as follows:    a^2 - b^2\n= a^2 - a*b + a*b - b^2\n= a*a - a*b + a*b - b^2\n= a*(a - b) + a*b - b^2\n= a*(a - b) + a*b - b*b\n= a*(a - b) + b*a - b*b\n= a*(a - b) + b*(a - b)\n= (a + b)*(a - b)  Each step of the proof can be verified using pattern matching algorithms, but it is much harder for a computer to figure out that the trick is to add and subtract  a*b  into the expression (technically, in this case specialized algorithms can do it, but in more general cases especially involving second-order logic it becomes intractable). Note that for computers the proof must be written down in excruciating detail; blockchain-based algorithms specifically heavily benefit from simplicity. To alleviate this problem, compilers can likely be made that can make small two and three-step inferences and expand shorter proofs into more complete ones.  Alternatives to proof-of-proof include proof-of-optimization, finding optimal inputs to some function to maximize a particular output (eg. the ability of a radio antenna to receive signals), algorithms involving playing strategy games or multiplayer AI challenges (one can even require users to submit programs to the blockchain that play against each other), and solving a specific math problem at greater and greater difficulty (eg. factoring). Note that because success in these problems is very sporadic, and highly inegalitarian, one cannot use most of these algorithms for consensus; rather, it makes sense to focus on distribution.  \u96be\u9898 : create a proof-of-excellence distribution mechanism that rewards solving problems that are both dominated by human effort and whose solutions provide some benefit to humanity.  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   Given a well-justified extrapolation of the global levels of human and computer competence at the underlying problem, over 75% of the rewards from the system should be provided by human labor, although software aids are allowed.  The algorithm must ideally be future-proof; that is to say, it must continue rewarding value production in the long term and should not be an area that will eventually be \"solved\" completely.  The distribution should be maximally egalitarian, though this is a secondary concern.  The system should be secure against front-running attacks, ie. if an individual submits a solution, then it should not be practical for even a moderately powerful attacker to look at the solution and then resubmit his own transaction containing the same solution and thereby steal the reward.", 
            "title": "13. \u5353\u8d8a\u7684\u8bc1\u660e"
        }, 
        {
            "location": "/Misc/Problems/#14-sybil", 
            "text": "A problem that is somewhat related to the issue of a reputation system is the challenge of creating a \"unique identity system\" - a system for generating tokens that prove that an identity is not part of a Sybil attack. The naive form of anti-Sybil token is simple: a sacrifice or proof of deposit. In a sacrifice setup, such identities simply cost $X, and in a PoD system identities require a deposit of $Y in order to be active, where perhaps the deposit can be taken away or destroyed under certain circumstances. However, we would like to have a system that has nicer and more egalitarian features than \"one-dollar-one-vote\"; arguably, one-person-one-vote would be ideal.  To date, we have seen two major strategies for trying to solve this problem. One potential solution is to come up with a proof-of-work algorithm which is dominated by human labor, and not computers. This is not as difficult as it may seem; although computers get more and more powerful every year, there are a number of problems that have remained out of computers' reach for decades, and it may even be possible to identify a class of problems that are the artificial-intelligence-theoretic equivalent of \"NP-complete\" - problems such that, if they can be solved, it with high probability implies that AI can essentially replicate human activity in its entirety, in which case we are essentially in a post-scarcity utopia and money and incentivization may not even be necessary. These problems may be non-interactive challenges like CAPTCHAs, although all existing CAPTCHAs are far from adequate for the task, or they may be interactive strategy games like Go.  The second strategy is to use social proof, turning the muscle of decentralized information gathering toward a simple problem: are these two identities the same person? If they are not, then they receive two anti-Sybil tokens, and if they are they receive one token. In general, we can separately define two concepts of identity: voluntary identity and involuntary identity. A voluntary identity can be seen as a cluster of interactions which are in some fashion correlated with each other; for example, a cryptographic identity consists of the set of interactions signed by a particular public key. An involuntary identity is a cluster of interactions which are correlated with each other, but where the entity producing the interactions does not want the correlations to be visible. A simple unique identity system would rely on voluntary identities embedded in social networks, with the understanding that creating separate identities with reputations is an expensive task and so most people would not want to do it, but a more advanced system may try to detect involuntary slipups like writing style patterns or IP addresses.  The question is, can we use these mechanisms, either separately or together, and perhaps in combination with cryptoeconomic protocols and sacrifices as a fallback in order to create an anti-Sybil system which is highly egalitarian? We will accept that any scheme can be cracked at some cost; however, what we want is for it to be much more efficient for individuals to obtain  one  anti-Sybil token \"the proper way\" rather than purchasing one off the grey/black market. The challenge is to push the grey/black market cost as high as possible, as much as possible without making the first token difficult.  \u96be\u9898  - create a mechanism for distributing anti-Sybil tokens  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42 :   Everyone is part of a social network with similar characteristics to social networks now found in the real world, and social data can be provably provided to cryptoeconomic systems (eg. blockchains, Ethereum contracts)  The cost of obtaining one anti-Sybil token for a human should be as low as possible  The cost of obtaining multiple anti-Sybil tokens for a human should be as high as possible  The cost of obtaining anti-Sybil tokens for an automated system should be as high as possible (this is a more important criterion than high cost for multi-obtainment for humans)  The system should not create dependency on centralized parties (eg. government passport offices) that have the power to cheat the system", 
            "title": "14. \u53cdSybil\u7cfb\u7edf"
        }, 
        {
            "location": "/Misc/Problems/#15", 
            "text": "Incentivizing the production of public goods is, unfortunately, not the only problem that centralization solves. The other problem is determining, first, which public goods are worth producing in the first place and, second, determining to what extent a particular effort actually accomplished the production of the public good. This challenge deals with the latter issue. Although in the case of computational tasks it's easy to come up with a proof of solution, for non-computational tasks the situation is much more difficult. If a cryptoeconomic system wants to incentivize users to build better graphical user interfaces to its own system, how would it rate people's contributions?  Even more problematically , what about potentially quasi-adversarial tasks like incentivizing updates to its own code? What about a DAO that funds healthcare, or tries to incentivize adopting renewable energy?  This is a subclass of the general \"social proof\" problem; here, the particular challenge is that each individual datum in question is something that very few people are interested in, and data gathering costs are often high. Sometimes, there is not even a concept of a single \"correct\" value with respect to the particular metric; in the case of quality measurement for an interface, a solution like A/B testing may be required. In adversarial cases, there may need to be an opportunity for incentivized opponents to look at a solution and attempt to pick it apart.  \u96be\u9898 : come up with and implement a decentralized method for determining whether or not a particular task was performed by a specific person, and for estimating the quality of the work  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   The agents involved can be a combination of individual humans, teams of humans, AIs, simple software programs and other DAOs  There is no cryptographically verifiable information about the completion of any task; the system must rely entirely on some form of social proof", 
            "title": "15. \u5206\u6563\u7684\u8d21\u732e\u6307\u6807"
        }, 
        {
            "location": "/Misc/Problems/#16", 
            "text": "Another, related, problem to the problem of decentralized contribution metrics is the problem of decentralized success metrics. On the macroscopic scale, how do we know if, and to what extent, an organization has succeeded in accomplishing its objectives? In the case of something like Bitcoin, there is a simple, but imperfect, answer: success can be measured by the hashpower of the network. This setup is reasonably effective, but is flawed in two ways: first, hashpower is an imperfect proxy for price, because the development or nondevelopment of ASICs may skew the results, and second, price is an imperfect proxy for success, because the currency may have greater success as something with a lower market capitalization if it is more used in other ways. In the case of a DAO funding healthcare or anti-climate-change efforts, however, no such heuristic exists at all. Once again, some concept of social proof is the only option.  Here, information gathering costs are low, and information is accessible to everyone in the public, so a higher level of accuracy is possible, hopefully even enough for financial contracts based off of the metric to be possible. However, in order to maintain that higher level of accuracy, and in the presence of such financial derivatives, new problems arise. Can one moderately powerful entity manipulate the metric for their own benefit? If information gathering costs do exist, is the system vulnerable to falling into a centralized equilibrium, where everyone is incentivized to simply follow along with the actions of some specific party?  \u96be\u9898 : come up with and implement a decentralized method for measuring numerical real-world variables  \u989d\u5916\u7684\u5047\u8bbe\u548c\u8981\u6c42   The agents involved can be a combination of individual humans, teams of humans, AIs, simple software programs and other DAOs  The system should be able to measure anything that humans can currently reach a rough consensus on (eg. price of an asset, temperature, global CO2 concentration", 
            "title": "16. \u5206\u6563\u7684\u6210\u529f\u6307\u6807"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/", 
            "text": "\u533a\u5757\u94fe\u53ef\u4f38\u7f29\u6027: Chain-Fibers Redux\n\n\nThis article describes a scalability proposal made by Gavin Wood in 2015. Many of the principles described here have been a key inspiration for subsequent \"\nsharding\n\" proposals.\n\n\n\u5386\u53f2\n\n\nI came up with the first seed of this idea while chatting to Janislav Malahov in Berlin in Spring 2014. Unfortunately, the original article I wrote was lost along with my laptop when it was stolen in Vienna. After chatting over the principles with Vitalik more recently, we made a number of alterations and formalisations, mainly to the validation and the sub-state cutting mechanisms. What follows is a fairly complete picture of one particular possible plan for block chain scalability in a later version of Ethereum.\n\n\n\u6982\u8ff0\n\n\nThe basic idea of Chain-Fibers is unchanged from a year ago; split the state-space up into strata and have separate transaction collators specialising in one or a number of state sub-spaces. Transactions requiring interactions from many a subspace would be accordingly more expensive (since collators would have to maintain presence on multiple chains) and take longer to execute (since there is a lesser chance that any given block would contain a superset of the transaction's subspaces). Validity of a transaction is verifiable in isolation through the provision of comprehensive Merkle proofs to its inputs alongside it in the block in which it is included.\n\n\nThe subtleties lie in precisely what governs the division of subspaces (my original proposal included the automated splitting, merging and rotation of subspace-divisions in order to best deliver internal coherency), how security is maintained within comparatively worthless subspaces and how this can play well with Proof-of-Stake (the original was based upon a master PoW chain, feeding off an idea put forward by Max Kaye in early 2014 to disassociate block chain archival from transition semantics).\n\n\nBasic idea is to have a number of chains (e.g. N), each detailing the state-transitions for only a strata of the entire system state (i.e. a state subspace). Following from programming terminology, these might be termed \"fibers\". Accounts thus belong to a subspace and as such a single fiber; the fiber to which they belong can be determined simply from the first log2(N) bits of the address. N can increase or decrease, and is a value maintained within the housekeeping information on the \"Master Chain\".\n\n\nThe Master Chain is maintained by a set of bonded Validators V, with the number of validators proportional to N. A random selection of validators validate each block produced, and validators ultimately vote to form consensus over the Master Chain. Each block of the Master Chain maintains a reference to the header of each fiber.\n\n\nTransaction collators produce blocks (accepting fees from transactors), and pay Validators some of the fees collected to include the hash of their block in the main chain. Blocks are produced across a particular \"home set\" of fibers; this is basically just the set of fibers of which they maintain the State Trie. Their blocks may involve transactions over one or many of these fibers, though none outside their \"home set\".\n\n\n\"Fishermen\" is a term given to freelance checkers. Since block validation and availability are both important, and since it is possible that sets of validators may be contractually bribed, it is important to have a mechanism to involve additional rational individuals in acting as \"whistle-blowers\" to avoid bogging the other validators needlessly checking all blocks. The fishermen basically pay to attempt to convince a quorum of validators that a previously validated block is invalid (or unavailable, which we assume is equivalent). If a fisherman demonstrates a validator (or, more likely, set of validators) acted in a dishonourable fashion, then they get to claim all of their bonds. To avoid DoSing the validators with spurious challenges, a fee is payable.\n\n\n\u539f\u7406\u56fe\n\n\nSorry for the not-quite ASCII-art. I'm not quite as 1337 at Inkscape as Vitalik.\n\n\nTransactors        ==TX+FEE==\n  Collators                     ==BLOCK+FEE==\n  Validators\nmake transaction                 validate transaction,                         random selection chosen to audit\n                                produce Comprehensive Merkle                    TX/PSR/CMP contents \n availability,\n                                  Proof and Post State Root,                  all placed in PoS-consensus master block\n                                collate into X-fiber Block\n\n                                Fishermen                 ==CHALLENGE+FEE==\n  Validators\n                                search for invalid or                         a selection adjudicate challenge\n                                  unavailable X-fiber blocks\n\n\n\n\n\u4ea4\u6613\u4eba\n\n\nTransactors are pretty much exactly the same as in Ethereum 1.0 - they are the users of the system.\n\n\n\u4ea4\u6613\u4eba: \u505a\u4ea4\u6613\n\n\nTransactors make a transaction much like they do in the existing Ethereum system. One or two minor differences - addresses can be used as a distance metric; those sharing the same number of initial bits are considered \"closer\", which means a greater certainty into the future that they will continue to be contained in the same state subspace. Contracts are naturally created in the same state subspace as the creator.\n\n\nTransactions, like Collators, operate over a number of fibers; perhaps one perhaps all, probably somewhere in between. Submission to collators may be directed through fiber sub-network overlays.\n\n\nSubmission and payment to the collators happens much as existing transaction submission to miners happens in Ethereum 1.0.\n\n\n\u6392\u5e8f\u5668\n\n\nCollators maintain presence on at least two peer sub-network overlays; the Validators overlay, and one or more fiber overlays. The fiber overlays may provide directed transaction propogation. Collators \"collate\" on a set of fibers. They maintain a full fiber-chain for each fiber they collate over, and can accept all transactions that involve any combination of their fiber set. The greater this combination, then the greater their \"transaction net\", but the greater their overall disk/memory footprint.\n\n\n\u6392\u5e8f\u5668: validate transaction\n\n\nOn receipt of a transaction, they go through the usual Ethereum 1.0 rites of checking payment is enough, initial balances \nc. Once basic validation is done, they attempt to execute it, throwing it out if it touches any fiber that is not part of collator's fiber set.\n\n\n\u6392\u5e8f\u5668: produce Comprehensive Merkle Proof and Post State Root\n\n\nCollators provide each post-state-root (as is found in the transaction receipt of Ethereum 1.0) and append to the block Merkle proofs and associated hints (e.g. contract code) for all inputs (balance, nonce, state, code) from all subspaces that are required for the evaluation of each transaction from a previously known post-state-root.\n\n\nThis allows an auditor to, without anything other than the previous post-state-root for each fiber, determine the validity of the block.\n\n\n\u6392\u5e8f\u5668: collate into X-fiber Block\n\n\nA Cross Fiber Block is created from the total information collated. This includes transactions, transaction receipts (post-state-roots), Comprehensive Merkle-Proofs and associated hash-hints. This block does not include any consensus-specific information such as timestamping, uncles \nc.\n\n\n\u9a8c\u8bc1\u5668\n\n\nValidators (who might be better named auditors) are bonded particpants, chosen regularly from the highest bidders, who take a small fee for the ultimate maintenence of the network. Their job, as a whole, is to form a judiciary and ultimate authority over the validity and transaction contents of the chain. We generally assume that they are mostly benevolent and cannot all be bribed. Being bonded, validators may also be called to audit and stake their bond on an opinion over validity or information-availability.\n\n\n\u9a8c\u8bc1\u5668: all placed in PoS-consensus master block\n\n\nThey maintain signing control over the Master Chain. The Master Chain (MC) encodes all PoS/consensus stuff like timestamping and includes its own little state root for recording validator's bond balances, ongoing challenges, fiber block header-hashes and any other housekeeping information.\n\n\nEach master block (MB), a set of collated X-Fiber Blocks (XBs) are taken; these must be non-overlapping, so that each fiber belongs to only a single XB.\n\n\n\u9a8c\u8bc1\u5668: random selection chosen to audit TX/PSR/CMP contents \n availability\n\n\nFor each MB we have a number of XSBs referenced from the MB's Trie. Each fiber is assigned a randomly selected set of validators, and the validators must review whatever XB contains their assigned fiber. Validation includes attaining the XB, finding the previous PSRs for each of the fibers (placed in the MB) and checking that the proofs in its CMP, cover all required inputs to the transactions collated within and that the PSR is indeed the final state root when all are executed.\n\n\nThe block is considered valid iff all assigned validators sign it. Signing it is considered an assertion that the block contents are both valid and available for a probabilistically long \"challenge period\" in which a Fisherman may challenge. Any challenge to the block's validity which is ultimately upheld by a full consensus of a randomly selected set of validators (ultimately ending with a majority vote, should it be doggedly contested) will mean the instant loss of the bond.\n\n\n\u6e14\u592b\n\n\nFishermen (who might be called bounty hunters) are the freelance error-checkers of the system. They watch the validators in the hope that they can find wrong-doing. To help guarantee presence, payouts are designed to be huge. The costs of challenging are small but not insignificant.\n\n\n\u6e14\u592b: \u641c\u7d22\u65e0\u6548\u6216\u4e0d\u53ef\u7528\u7684X\u5149\u7ea4\u6a21\u5757\n\n\nThey check the X-fiber blocks looking for validity errors and/or inavailability of data. When they find an invalid block or unavailable data, they launch a challenge (for a small fee, paid to validators) in the hope that a sufficiently large portion of validators will concur. If they succeed and validators ultimately uphold the challenge, then they receive the bonds of all validators who had previously asserted validity/availability of the information.\n\n\n\u6e14\u592b\u6311\u6218:\n\n\n\n\nFisherman finds an invalid/unavailable block not yet outside its \"challenge period\" (10-30 blocks); pays a fee, submits a challenge transaction into the master chain;\n\n\nA randomly selected set of validators (e.g. of order e.g. sqrt(N)) ++ any validators that self-select (through doubling their bond), check the block that was challenged; each votes Y or N to the block's validity;\n\n\nIf N, the validator receives a small payment Pn.\n\n\nIf Y, the validator stakes their bond, though receives a larger payment Py (perhaps Py = 2Pn).\n\n\nThe outcome of the challenge (probably accumulated into the following block) is:\n\n\nIf more than 66% of validators vote Y (valid), then the challenge ends. The Fisherman loses their fee, but may reinitiate a challenge.\n\n\nIf at least one validator votes Y (valid), then the challenge continues with a second, larger set of randomly selected validators. All bonds are staked.\n\n\nIf all validators vote N (invalid), then the block is recorded as invalid and the Fishermen receives the bond of all validators that have asserted the blocks validity. This is a very large payoff.\n\n\nNOTE: If the set includes all validators, then it's a simple majority-carries rule.\n\n\n\n\n\u5176\u5b83\u5dee\u5f02\n\n\n\n\nAll addresses are contained in a lookup table unique to each state subspace; this means they can be referenced through a small number of bits and avoid large amounts of wasted entropy in the RLP for proofs \nc.\n\n\n\n\n\u6ce8\u91ca\n\n\n\n\nOnce a block is out of the challenge period, it is considered unassailable. If it does turn out to be bad, then it must be fixed in the same way as a protocol upgrade. As such it is likely that validators and other large stakeholder would act as Fishermen to protect their investment.", 
            "title": "\u94fe\u6761\u7ea4\u7ef4"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#chain-fibers-redux", 
            "text": "This article describes a scalability proposal made by Gavin Wood in 2015. Many of the principles described here have been a key inspiration for subsequent \" sharding \" proposals.", 
            "title": "\u533a\u5757\u94fe\u53ef\u4f38\u7f29\u6027: Chain-Fibers Redux"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_1", 
            "text": "I came up with the first seed of this idea while chatting to Janislav Malahov in Berlin in Spring 2014. Unfortunately, the original article I wrote was lost along with my laptop when it was stolen in Vienna. After chatting over the principles with Vitalik more recently, we made a number of alterations and formalisations, mainly to the validation and the sub-state cutting mechanisms. What follows is a fairly complete picture of one particular possible plan for block chain scalability in a later version of Ethereum.", 
            "title": "\u5386\u53f2"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_2", 
            "text": "The basic idea of Chain-Fibers is unchanged from a year ago; split the state-space up into strata and have separate transaction collators specialising in one or a number of state sub-spaces. Transactions requiring interactions from many a subspace would be accordingly more expensive (since collators would have to maintain presence on multiple chains) and take longer to execute (since there is a lesser chance that any given block would contain a superset of the transaction's subspaces). Validity of a transaction is verifiable in isolation through the provision of comprehensive Merkle proofs to its inputs alongside it in the block in which it is included.  The subtleties lie in precisely what governs the division of subspaces (my original proposal included the automated splitting, merging and rotation of subspace-divisions in order to best deliver internal coherency), how security is maintained within comparatively worthless subspaces and how this can play well with Proof-of-Stake (the original was based upon a master PoW chain, feeding off an idea put forward by Max Kaye in early 2014 to disassociate block chain archival from transition semantics).  Basic idea is to have a number of chains (e.g. N), each detailing the state-transitions for only a strata of the entire system state (i.e. a state subspace). Following from programming terminology, these might be termed \"fibers\". Accounts thus belong to a subspace and as such a single fiber; the fiber to which they belong can be determined simply from the first log2(N) bits of the address. N can increase or decrease, and is a value maintained within the housekeeping information on the \"Master Chain\".  The Master Chain is maintained by a set of bonded Validators V, with the number of validators proportional to N. A random selection of validators validate each block produced, and validators ultimately vote to form consensus over the Master Chain. Each block of the Master Chain maintains a reference to the header of each fiber.  Transaction collators produce blocks (accepting fees from transactors), and pay Validators some of the fees collected to include the hash of their block in the main chain. Blocks are produced across a particular \"home set\" of fibers; this is basically just the set of fibers of which they maintain the State Trie. Their blocks may involve transactions over one or many of these fibers, though none outside their \"home set\".  \"Fishermen\" is a term given to freelance checkers. Since block validation and availability are both important, and since it is possible that sets of validators may be contractually bribed, it is important to have a mechanism to involve additional rational individuals in acting as \"whistle-blowers\" to avoid bogging the other validators needlessly checking all blocks. The fishermen basically pay to attempt to convince a quorum of validators that a previously validated block is invalid (or unavailable, which we assume is equivalent). If a fisherman demonstrates a validator (or, more likely, set of validators) acted in a dishonourable fashion, then they get to claim all of their bonds. To avoid DoSing the validators with spurious challenges, a fee is payable.", 
            "title": "\u6982\u8ff0"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_3", 
            "text": "Sorry for the not-quite ASCII-art. I'm not quite as 1337 at Inkscape as Vitalik.  Transactors        ==TX+FEE==   Collators                     ==BLOCK+FEE==   Validators\nmake transaction                 validate transaction,                         random selection chosen to audit\n                                produce Comprehensive Merkle                    TX/PSR/CMP contents   availability,\n                                  Proof and Post State Root,                  all placed in PoS-consensus master block\n                                collate into X-fiber Block\n\n                                Fishermen                 ==CHALLENGE+FEE==   Validators\n                                search for invalid or                         a selection adjudicate challenge\n                                  unavailable X-fiber blocks", 
            "title": "\u539f\u7406\u56fe"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_4", 
            "text": "Transactors are pretty much exactly the same as in Ethereum 1.0 - they are the users of the system.", 
            "title": "\u4ea4\u6613\u4eba"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_5", 
            "text": "Transactors make a transaction much like they do in the existing Ethereum system. One or two minor differences - addresses can be used as a distance metric; those sharing the same number of initial bits are considered \"closer\", which means a greater certainty into the future that they will continue to be contained in the same state subspace. Contracts are naturally created in the same state subspace as the creator.  Transactions, like Collators, operate over a number of fibers; perhaps one perhaps all, probably somewhere in between. Submission to collators may be directed through fiber sub-network overlays.  Submission and payment to the collators happens much as existing transaction submission to miners happens in Ethereum 1.0.", 
            "title": "\u4ea4\u6613\u4eba: \u505a\u4ea4\u6613"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_6", 
            "text": "Collators maintain presence on at least two peer sub-network overlays; the Validators overlay, and one or more fiber overlays. The fiber overlays may provide directed transaction propogation. Collators \"collate\" on a set of fibers. They maintain a full fiber-chain for each fiber they collate over, and can accept all transactions that involve any combination of their fiber set. The greater this combination, then the greater their \"transaction net\", but the greater their overall disk/memory footprint.", 
            "title": "\u6392\u5e8f\u5668"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#validate-transaction", 
            "text": "On receipt of a transaction, they go through the usual Ethereum 1.0 rites of checking payment is enough, initial balances  c. Once basic validation is done, they attempt to execute it, throwing it out if it touches any fiber that is not part of collator's fiber set.", 
            "title": "\u6392\u5e8f\u5668: validate transaction"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#produce-comprehensive-merkle-proof-and-post-state-root", 
            "text": "Collators provide each post-state-root (as is found in the transaction receipt of Ethereum 1.0) and append to the block Merkle proofs and associated hints (e.g. contract code) for all inputs (balance, nonce, state, code) from all subspaces that are required for the evaluation of each transaction from a previously known post-state-root.  This allows an auditor to, without anything other than the previous post-state-root for each fiber, determine the validity of the block.", 
            "title": "\u6392\u5e8f\u5668: produce Comprehensive Merkle Proof and Post State Root"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#collate-into-x-fiber-block", 
            "text": "A Cross Fiber Block is created from the total information collated. This includes transactions, transaction receipts (post-state-roots), Comprehensive Merkle-Proofs and associated hash-hints. This block does not include any consensus-specific information such as timestamping, uncles  c.", 
            "title": "\u6392\u5e8f\u5668: collate into X-fiber Block"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_7", 
            "text": "Validators (who might be better named auditors) are bonded particpants, chosen regularly from the highest bidders, who take a small fee for the ultimate maintenence of the network. Their job, as a whole, is to form a judiciary and ultimate authority over the validity and transaction contents of the chain. We generally assume that they are mostly benevolent and cannot all be bribed. Being bonded, validators may also be called to audit and stake their bond on an opinion over validity or information-availability.", 
            "title": "\u9a8c\u8bc1\u5668"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#all-placed-in-pos-consensus-master-block", 
            "text": "They maintain signing control over the Master Chain. The Master Chain (MC) encodes all PoS/consensus stuff like timestamping and includes its own little state root for recording validator's bond balances, ongoing challenges, fiber block header-hashes and any other housekeeping information.  Each master block (MB), a set of collated X-Fiber Blocks (XBs) are taken; these must be non-overlapping, so that each fiber belongs to only a single XB.", 
            "title": "\u9a8c\u8bc1\u5668: all placed in PoS-consensus master block"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#random-selection-chosen-to-audit-txpsrcmp-contents-availability", 
            "text": "For each MB we have a number of XSBs referenced from the MB's Trie. Each fiber is assigned a randomly selected set of validators, and the validators must review whatever XB contains their assigned fiber. Validation includes attaining the XB, finding the previous PSRs for each of the fibers (placed in the MB) and checking that the proofs in its CMP, cover all required inputs to the transactions collated within and that the PSR is indeed the final state root when all are executed.  The block is considered valid iff all assigned validators sign it. Signing it is considered an assertion that the block contents are both valid and available for a probabilistically long \"challenge period\" in which a Fisherman may challenge. Any challenge to the block's validity which is ultimately upheld by a full consensus of a randomly selected set of validators (ultimately ending with a majority vote, should it be doggedly contested) will mean the instant loss of the bond.", 
            "title": "\u9a8c\u8bc1\u5668: random selection chosen to audit TX/PSR/CMP contents &amp; availability"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_8", 
            "text": "Fishermen (who might be called bounty hunters) are the freelance error-checkers of the system. They watch the validators in the hope that they can find wrong-doing. To help guarantee presence, payouts are designed to be huge. The costs of challenging are small but not insignificant.", 
            "title": "\u6e14\u592b"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#x", 
            "text": "They check the X-fiber blocks looking for validity errors and/or inavailability of data. When they find an invalid block or unavailable data, they launch a challenge (for a small fee, paid to validators) in the hope that a sufficiently large portion of validators will concur. If they succeed and validators ultimately uphold the challenge, then they receive the bonds of all validators who had previously asserted validity/availability of the information.", 
            "title": "\u6e14\u592b: \u641c\u7d22\u65e0\u6548\u6216\u4e0d\u53ef\u7528\u7684X\u5149\u7ea4\u6a21\u5757"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_9", 
            "text": "Fisherman finds an invalid/unavailable block not yet outside its \"challenge period\" (10-30 blocks); pays a fee, submits a challenge transaction into the master chain;  A randomly selected set of validators (e.g. of order e.g. sqrt(N)) ++ any validators that self-select (through doubling their bond), check the block that was challenged; each votes Y or N to the block's validity;  If N, the validator receives a small payment Pn.  If Y, the validator stakes their bond, though receives a larger payment Py (perhaps Py = 2Pn).  The outcome of the challenge (probably accumulated into the following block) is:  If more than 66% of validators vote Y (valid), then the challenge ends. The Fisherman loses their fee, but may reinitiate a challenge.  If at least one validator votes Y (valid), then the challenge continues with a second, larger set of randomly selected validators. All bonds are staked.  If all validators vote N (invalid), then the block is recorded as invalid and the Fishermen receives the bond of all validators that have asserted the blocks validity. This is a very large payoff.  NOTE: If the set includes all validators, then it's a simple majority-carries rule.", 
            "title": "\u6e14\u592b\u6311\u6218:"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_10", 
            "text": "All addresses are contained in a lookup table unique to each state subspace; this means they can be referenced through a small number of bits and avoid large amounts of wasted entropy in the RLP for proofs  c.", 
            "title": "\u5176\u5b83\u5dee\u5f02"
        }, 
        {
            "location": "/Misc/Chain-Fibers-Redux/#_11", 
            "text": "Once a block is out of the challenge period, it is considered unassailable. If it does turn out to be bad, then it must be fixed in the same way as a protocol upgrade. As such it is likely that validators and other large stakeholder would act as Fishermen to protect their investment.", 
            "title": "\u6ce8\u91ca"
        }, 
        {
            "location": "/Misc/Glossary/", 
            "text": "\u672f\u8bed\n\n\n\u5bc6\u7801\u5b66\n\n\n\u516c\u94a5\u5bc6\u7801\u5b66\n\n\n\n\nComputational infeasibility\n: a process is computationally infeasible if it would take an impracticably long time (eg. billions of years) to do it for anyone who might conceivably have an interest in carrying it out. Generally, 2\n80\n computational steps is considered the lower bound for computational infeasibility.\n\n\nHash\n: a hash function (or hash algorithm) is a process by which a piece of data of arbitrary size (could be anything; a piece of text, a picture, or even a list of other hashes) is processed into a small piece of data (usually 32 bytes) which looks completely random, and from which no meaningful data can be recovered about the document, but which has the important property that the result of hashing one particular document is always the same. Additionally, it is crucially important that it is computationally infeasible to find two documents that have the same hash. Generally, changing even one letter in a document will completely randomize the hash; for example, the SHA3 hash of \"Saturday\" is \nc38bbc8e93c09f6ed3fe39b5135da91ad1a99d397ef16948606cdcbd14929f9d\n, whereas the SHA3 hash of Caturday is \nb4013c0eed56d5a0b448b02ec1d10dd18c1b3832068fbbdc65b98fa9b14b6dbf\n. Hashes are usually used as a way of creating a globally agreed-upon identifier for a particular document that cannot be forged.\n\n\nEncryption\n: encryption is a process by which a document (\nplaintext\n) is combined with a shorter string of data, called a \nkey\n (eg. \nc85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4\n), to produce an output (\nciphertext\n) which can be \"decrypted\" back into the original plaintext by someone else who has the key, but which is incomprehensible and computationally infeasible to decrypt for anyone who does not have the key.\n\n\nPublic key encryption\n: a special kind of encryption where there is a process for generating two keys at the same time (typically called a \nprivate key\n and a \npublic key\n), such that documents encrypted using one key can be decrypted with the other. Generally, as suggested by the name, individuals publish their public keys and keep their private keys to themselves.\n\n\nDigital signature\n: a digital signing algorithm is a process by which a user can produce a short string of data called a \"signature\" of a document using a private key such that anyone with the corresponding public key, the signature and the document can verify that (1) the document was \"signed\" by the owner of that particular private key, and (2) the document was not changed after it was signed. Note that this differs from traditional signatures where you can scribble extra text onto a document after you sign it and there's no way to tell the difference; in a digital signature any change to the document will render the signature invalid.\n\n\n\n\n\u533a\u5757\u94fe\n\n\n\u8bcd\u6c47\n\n\n\n\nAddress\n: an address is essentially the representation of a public key belonging to a particular user; for example, the address associated with the private key given above is \n0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\n. Note that in practice, the address is technically the hash of a public key, but for simplicity it's better to ignore this distinction.\n\n\nTransaction\n: a transaction is a digitally signed message authorizing some particular action associated with the blockchain. In a currency, the dominant transaction type is sending currency units or tokens to someone else; in other systems actions like registering domain names, making and fulfilling trade offers and entering into contracts are also valid transaction types.\n\n\nBlock\n: a block is a package of data that contains zero or more transactions, the hash of the previous block (\"parent\"), and optionally other data. Because each block (except for the initial \"genesis block\") points to the previous block, the data structure that they form is called a \"blockchain\".\n\n\nState\n: the set of data that a blockchain network strictly needs to keep track of, and that represents data currently relevant to applications on the chain. In a currency, this is simply balances; in more complex applications this could refer to other data structures that the application in question needs to keep track of (eg. who has what domain name, what is the status of a given contract, etc). The \npost-state\n of a block is the state after executing all transactions in the ancestors of the block starting from the genesis going up to and including the transactions in that block itself.\n\n\nHistory\n: the past transactions and blocks. Note that the state is a deterministic function of the history.\n\n\nAccount\n: an account is an object in the state; in a currency system, this is a record of how much money some particular user has; in more complex systems accounts can have different functions.\n\n\nProof of work\n: one important property of a block in Bitcoin, Ethereum and many other crypto-ledgers is that the hash of the block must be smaller than some target value. The reason this is necessary is that in a decentralized system anyone can produce blocks, so in order to prevent the network from being flooded with blocks, and to provide a way of measuring how much consensus there is behind a particular version of the blockchain, it must in some way be hard to produce a block. Because hashes are pseudorandom, finding a block whose hash is less than \n0000000100000000000000000000000000000000000000000000000000000000\n takes an average of 4.3 billion attempts. In all such systems, the target value self-adjusts so that on average one node in the network finds a block every N minutes (eg. N = 10 for Bitcoin and 1 for Ethereum).\n\n\nProof of work nonce\n: a meaningless value in a block which can be adjusted in order to try to satisfy the proof of work condition\n\n\nMining\n: mining is the process of repeatedly aggregating transactions, constructing a block and trying different nonces until a nonce is found that satisfies the proof of work condition. If a miner gets lucky and produces a valid block, they are granted a certain number of coins as a reward as well as all of the transaction fees in the block, and all miners start trying to create a new block containing the hash of the newly generated block as their parent.\n\n\nStale\n: a stale is a block that is created when there is already another block with the same parent out there; stales typically get discarded and are wasted effort.\n\n\nFork\n: a situation where two blocks are generated pointing to the same block as their parent, and some portion of miners see one block first and some see the other. This may lead to two blockchains growing at the same time. Generally, it is mathematically near-certain that a fork will resolve itself within four blocks as miners on one chain will eventually get lucky and that chain will grow longer and all miners switch to it; however, forks may last longer if miners disagree on whether or not a particular block is valid.\n\n\nDouble spend\n: a deliberate fork, where a user with a large amount of mining power sends a transaction to purchase some product, then after receiving the product creates another transaction sending the same coins to themselves. The attacker then creates a block, at the same level as the block containing the original transaction but containing the second transaction instead, and starts mining on the fork. If the attacker has more than 50% of all mining power, the double spend is guaranteed to succeed eventually at any block depth. Below 50%, there is some probability of success, but it is usually only substantial at a depth up to about 2-5; for this reason, most cryptocurrency exchanges, gambling sites and financial services wait until six blocks have been produced (\"six confirmations\") before accepting a payment.\n\n\nLight client\n - a client that downloads only a small part of the blockchain, allowing users of low-power or low-storage hardware like smartphones and laptops to maintain almost the same guarantee of security by sometimes selectively downloading small parts of the state without needing to spend megabytes of bandwidth and gigabytes of storage on full blockchain validation and maintenance.\n\n\n\n\n\u4ee5\u592a\u574a\u533a\u5757\u94fe\n\n\n\u590d\u4ec7\n\n\n\n\nSerialization\n: the process of converting a data structure into a sequence of bytes. Ethereum internally uses an encoding format called recursive-length prefix encoding (RLP), described \nhere\n\n\nPatricia tree\n (or \ntrie\n): a data structure which stores the state of every account. The trie is built by starting from each individual node, then splitting the nodes into groups of up to 16 and hashing each group, then making hashes of hashes and so forth until there is one final \"root hash\" for the entire trie. The trie has the important properties that (1) there is exactly one possible trie and therefore one possible root hash for each set of data, (2) it is very easy to update, add or remove nodes in the trie and generate the new root hash, (3) there is no way to modify any part of the tree without changing the root hash, so if the root hash is included in a signed document or a valid block the signature or proof of work secures the entire tree, and (4) one can provide just the \"branch\" of a tree going down to a particular node as cryptographic proof that that node is indeed in the tree with that exact content. Patricia trees are also used to store the internal storage of accounts as well as transactions and ommers. See \nhere\n for a more detailed description.\n\n\nUncle\n: See \nOmmer\n, the gender-neutral alternative to aunt/uncle.\n\n\nOmmer\n: a child of a parent of a parent of a block that is not the parent, or more generally a child of an ancestor that is not itself an ancestor. If A is an ommer of B, B is a \nnibling\n (niece/nephew) of A.\n\n\nUncle inclusion mechanism\n: Ethereum has a mechanism where a block may include its uncles; this ensures that miners that create blocks that do not quite get included into the main chain can still get rewarded.\n\n\nAccount nonce\n: a transaction counter in each account. This prevents replay attacks where a transaction sending eg. 20 coins from A to B can be replayed by B over and over to continually drain A's balance.\n\n\nEVM code\n: Ethereum virtual machine code, the programming language in which accounts on the Ethereum blockchain can contain code. The EVM code associated with an account is executed every time a message is sent to that account, and has the ability to read/write storage and itself send messages.\n\n\nMessage\n: a sort of \"virtual transaction\" sent by EVM code from one account to another. Note that \"transactions\" and \"messages\" in Ethereum are different. A \"transaction\" in Ethereum parlance specifically refers to a digitally signed piece of data, originating from a source other than executing EVM code, to be recorded in the blockchain. Every transaction triggers an associated message, but messages can also be sent by EVM code, in which case they are never represented in data anywhere.\n\n\nStorage\n: a key/value database contained in each account, where keys and values are both 32-byte strings but can otherwise contain anything.\n\n\nExternally owned account\n: an account controlled by a private key. Externally owned accounts cannot contain EVM code.\n\n\nContract\n: an account which contains, and is controlled by, EVM code. Contracts cannot be controlled by private keys directly; unless built into the EVM code, a contract has no owner once released.\n\n\nEther\n: the primary internal cryptographic token of the Ethereum network. Ether is used to pay transaction and computation fees for Ethereum transactions.\n\n\nGas\n: a measurement roughly equivalent to computational steps. Every transaction is required to include a gas limit and a fee that it is willing to pay per gas; miners have the choice of including the transaction and collecting the fee or not. If the total number of gas used by the computation spawned by the transaction, including the original message and any sub-messages that may be triggered, is less than or equal to the gas limit, then the transaction processes. If the total gas exceeds the gas limit, then all changes are reverted, except that the transaction is still valid and the fee can still be collected by the miner. Every operation has a gas expenditure; for most operations it is ~3-10, although some expensive operations have expenditures up to 700 and a transaction itself has an expenditure of 21000.\n\n\n\n\n\u5361\u65af\u5e15\u548c\u7f29\u653e\u7814\u7a76\n\n\nProof-of-Stake-FAQ\n \u548c \nSharding-FAQ\n\n\n\n\nSecurity deposit\n: a quantity of ether that a user deposits into a mechanism (often a proof of stake consensus mechanism, though this can also be used for other applications) that a user normally expects to be able to eventually withdraw and recover, but which can be taken away in the event of malfeasance from the user's side.\n\n\nValidator\n: a participant in proof of stake consensus. Validators need to submit a security deposit in order to get included in the validator set.\n\n\nEconomic finality\n: a block or state can be considered \nfinalized\n if it can be shown that if any incompatible block or state is also finalized (eg. two different blocks at the same height) then there exists evidence that can be used to penalize (the security deposits of) the parties at fault by some amount $X. This value X is called the \ncryptoeconomic security margin\n of the finality mechanism.\n\n\nSlashing condition\n: a condition which, if triggered by a validator, causes the validator's deposit to be destroyed.\n\n\nPrepare\n and \ncommit\n: two types of messages that validators can send in many types of consensus protocols; see https://medium.com/@VitalikButerin/minimal-slashing-conditions-20f0b500fc6c\n\n\nFault\n: an action taken by a validator (or more generally, a participant in a mechanism) that they would not have taken had they correctly followed the protocol\n\n\nLiveness fault\n: a validator failing to submit a message that according to the protocol they should have submitted (or submitting a message later than they should have)\n\n\nCensorship fault\n: a validator failing to accept valid messages from other validators\n\n\nEquivocation\n: a validator sending two messages that contradict each other, or more precisely a validator sending two messages that a validator running the correct algorithm could only send if it sends one message, \"rewinds\" its internal state to some point before sending that message, then at some future point in time sends the other message. One simple example is a transaction sender sending two transactions with the same nonce.\n\n\nInvalidity fault\n: a validator sending a message that a computer running the correct algorithm could not possibly send, unless its internal state is manipulated with in some way other than rewinding.\n\n\nUniquely attributable fault\n: a fault such that there exists clear evidence which can be used to determine exactly which validator committed the fault. For example, liveness faults are not uniquely attributable because if a message from A fails to reach B, it could be because A failed to send that message, or because B failed to listen to it, whereas equivocation faults are uniquely attributable.\n\n\nFraud proof\n: a set of data, usually a part of a block plus some extra \"witness data\" (eg. Merkle branches), that can be used to prove that a given block is invalid.\n\n\nData availability problem\n and \nFisherman's dilemma\n: see https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding\n\n\nValidity\n: the property of a state that it is indeed the result of executing a valid history of transactions\n\n\nData availability\n: the property of a state that any node connected to the network could download any specific part of the state that they wish to.\n\n\nTight coupling\n: chains A and B are tightly coupled if (i) any state of A points to some state of B (and vice versa), and (ii) a state of A should not be considered admissible unless both that state itself and the state of B that it points to are valid and data-available.\n\n\nLoose coupling\n: chains A and B are loosely coupled if (i) any state of A points to some state of B (and vice versa), and (ii) they are \nnot\n tightly coupled.\n\n\nShard\n: a subset of the state which is managed by different nodes from the nodes that manage other shards. Usually, shards must be tightly coupled, and \nsidechains\n must be loosely coupled.\n\n\n\n\n\u975e\u533a\u5757\u94fe\n\n\n\n\nWhisper\n: an upcoming P2P messaging protocol\n\n\nSwarm\n: an upcoming P2P data storage protocol optimized for static web hosting\n\n\nSolidity\n, \nLLL\n, \nSerpent\n and \nViper\n: programming languages for writing contract code which can be compiled into EVM code. Serpent can also be compiled into LLL.  Solidity is a C++-like language (and is the most widely used), Serpent and Viper are Python-like languages (the developer of the two currently recommends Viper more), and LLL is an acronym for Lisp-like language.\n\n\nPoC\n: proof-of-concept, another name for a pre-launch release", 
            "title": "\u8bcd\u6c47\u8868"
        }, 
        {
            "location": "/Misc/Glossary/#_1", 
            "text": "", 
            "title": "\u672f\u8bed"
        }, 
        {
            "location": "/Misc/Glossary/#_2", 
            "text": "\u516c\u94a5\u5bc6\u7801\u5b66   Computational infeasibility : a process is computationally infeasible if it would take an impracticably long time (eg. billions of years) to do it for anyone who might conceivably have an interest in carrying it out. Generally, 2 80  computational steps is considered the lower bound for computational infeasibility.  Hash : a hash function (or hash algorithm) is a process by which a piece of data of arbitrary size (could be anything; a piece of text, a picture, or even a list of other hashes) is processed into a small piece of data (usually 32 bytes) which looks completely random, and from which no meaningful data can be recovered about the document, but which has the important property that the result of hashing one particular document is always the same. Additionally, it is crucially important that it is computationally infeasible to find two documents that have the same hash. Generally, changing even one letter in a document will completely randomize the hash; for example, the SHA3 hash of \"Saturday\" is  c38bbc8e93c09f6ed3fe39b5135da91ad1a99d397ef16948606cdcbd14929f9d , whereas the SHA3 hash of Caturday is  b4013c0eed56d5a0b448b02ec1d10dd18c1b3832068fbbdc65b98fa9b14b6dbf . Hashes are usually used as a way of creating a globally agreed-upon identifier for a particular document that cannot be forged.  Encryption : encryption is a process by which a document ( plaintext ) is combined with a shorter string of data, called a  key  (eg.  c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4 ), to produce an output ( ciphertext ) which can be \"decrypted\" back into the original plaintext by someone else who has the key, but which is incomprehensible and computationally infeasible to decrypt for anyone who does not have the key.  Public key encryption : a special kind of encryption where there is a process for generating two keys at the same time (typically called a  private key  and a  public key ), such that documents encrypted using one key can be decrypted with the other. Generally, as suggested by the name, individuals publish their public keys and keep their private keys to themselves.  Digital signature : a digital signing algorithm is a process by which a user can produce a short string of data called a \"signature\" of a document using a private key such that anyone with the corresponding public key, the signature and the document can verify that (1) the document was \"signed\" by the owner of that particular private key, and (2) the document was not changed after it was signed. Note that this differs from traditional signatures where you can scribble extra text onto a document after you sign it and there's no way to tell the difference; in a digital signature any change to the document will render the signature invalid.", 
            "title": "\u5bc6\u7801\u5b66"
        }, 
        {
            "location": "/Misc/Glossary/#_3", 
            "text": "\u8bcd\u6c47   Address : an address is essentially the representation of a public key belonging to a particular user; for example, the address associated with the private key given above is  0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826 . Note that in practice, the address is technically the hash of a public key, but for simplicity it's better to ignore this distinction.  Transaction : a transaction is a digitally signed message authorizing some particular action associated with the blockchain. In a currency, the dominant transaction type is sending currency units or tokens to someone else; in other systems actions like registering domain names, making and fulfilling trade offers and entering into contracts are also valid transaction types.  Block : a block is a package of data that contains zero or more transactions, the hash of the previous block (\"parent\"), and optionally other data. Because each block (except for the initial \"genesis block\") points to the previous block, the data structure that they form is called a \"blockchain\".  State : the set of data that a blockchain network strictly needs to keep track of, and that represents data currently relevant to applications on the chain. In a currency, this is simply balances; in more complex applications this could refer to other data structures that the application in question needs to keep track of (eg. who has what domain name, what is the status of a given contract, etc). The  post-state  of a block is the state after executing all transactions in the ancestors of the block starting from the genesis going up to and including the transactions in that block itself.  History : the past transactions and blocks. Note that the state is a deterministic function of the history.  Account : an account is an object in the state; in a currency system, this is a record of how much money some particular user has; in more complex systems accounts can have different functions.  Proof of work : one important property of a block in Bitcoin, Ethereum and many other crypto-ledgers is that the hash of the block must be smaller than some target value. The reason this is necessary is that in a decentralized system anyone can produce blocks, so in order to prevent the network from being flooded with blocks, and to provide a way of measuring how much consensus there is behind a particular version of the blockchain, it must in some way be hard to produce a block. Because hashes are pseudorandom, finding a block whose hash is less than  0000000100000000000000000000000000000000000000000000000000000000  takes an average of 4.3 billion attempts. In all such systems, the target value self-adjusts so that on average one node in the network finds a block every N minutes (eg. N = 10 for Bitcoin and 1 for Ethereum).  Proof of work nonce : a meaningless value in a block which can be adjusted in order to try to satisfy the proof of work condition  Mining : mining is the process of repeatedly aggregating transactions, constructing a block and trying different nonces until a nonce is found that satisfies the proof of work condition. If a miner gets lucky and produces a valid block, they are granted a certain number of coins as a reward as well as all of the transaction fees in the block, and all miners start trying to create a new block containing the hash of the newly generated block as their parent.  Stale : a stale is a block that is created when there is already another block with the same parent out there; stales typically get discarded and are wasted effort.  Fork : a situation where two blocks are generated pointing to the same block as their parent, and some portion of miners see one block first and some see the other. This may lead to two blockchains growing at the same time. Generally, it is mathematically near-certain that a fork will resolve itself within four blocks as miners on one chain will eventually get lucky and that chain will grow longer and all miners switch to it; however, forks may last longer if miners disagree on whether or not a particular block is valid.  Double spend : a deliberate fork, where a user with a large amount of mining power sends a transaction to purchase some product, then after receiving the product creates another transaction sending the same coins to themselves. The attacker then creates a block, at the same level as the block containing the original transaction but containing the second transaction instead, and starts mining on the fork. If the attacker has more than 50% of all mining power, the double spend is guaranteed to succeed eventually at any block depth. Below 50%, there is some probability of success, but it is usually only substantial at a depth up to about 2-5; for this reason, most cryptocurrency exchanges, gambling sites and financial services wait until six blocks have been produced (\"six confirmations\") before accepting a payment.  Light client  - a client that downloads only a small part of the blockchain, allowing users of low-power or low-storage hardware like smartphones and laptops to maintain almost the same guarantee of security by sometimes selectively downloading small parts of the state without needing to spend megabytes of bandwidth and gigabytes of storage on full blockchain validation and maintenance.", 
            "title": "\u533a\u5757\u94fe"
        }, 
        {
            "location": "/Misc/Glossary/#_4", 
            "text": "\u590d\u4ec7   Serialization : the process of converting a data structure into a sequence of bytes. Ethereum internally uses an encoding format called recursive-length prefix encoding (RLP), described  here  Patricia tree  (or  trie ): a data structure which stores the state of every account. The trie is built by starting from each individual node, then splitting the nodes into groups of up to 16 and hashing each group, then making hashes of hashes and so forth until there is one final \"root hash\" for the entire trie. The trie has the important properties that (1) there is exactly one possible trie and therefore one possible root hash for each set of data, (2) it is very easy to update, add or remove nodes in the trie and generate the new root hash, (3) there is no way to modify any part of the tree without changing the root hash, so if the root hash is included in a signed document or a valid block the signature or proof of work secures the entire tree, and (4) one can provide just the \"branch\" of a tree going down to a particular node as cryptographic proof that that node is indeed in the tree with that exact content. Patricia trees are also used to store the internal storage of accounts as well as transactions and ommers. See  here  for a more detailed description.  Uncle : See  Ommer , the gender-neutral alternative to aunt/uncle.  Ommer : a child of a parent of a parent of a block that is not the parent, or more generally a child of an ancestor that is not itself an ancestor. If A is an ommer of B, B is a  nibling  (niece/nephew) of A.  Uncle inclusion mechanism : Ethereum has a mechanism where a block may include its uncles; this ensures that miners that create blocks that do not quite get included into the main chain can still get rewarded.  Account nonce : a transaction counter in each account. This prevents replay attacks where a transaction sending eg. 20 coins from A to B can be replayed by B over and over to continually drain A's balance.  EVM code : Ethereum virtual machine code, the programming language in which accounts on the Ethereum blockchain can contain code. The EVM code associated with an account is executed every time a message is sent to that account, and has the ability to read/write storage and itself send messages.  Message : a sort of \"virtual transaction\" sent by EVM code from one account to another. Note that \"transactions\" and \"messages\" in Ethereum are different. A \"transaction\" in Ethereum parlance specifically refers to a digitally signed piece of data, originating from a source other than executing EVM code, to be recorded in the blockchain. Every transaction triggers an associated message, but messages can also be sent by EVM code, in which case they are never represented in data anywhere.  Storage : a key/value database contained in each account, where keys and values are both 32-byte strings but can otherwise contain anything.  Externally owned account : an account controlled by a private key. Externally owned accounts cannot contain EVM code.  Contract : an account which contains, and is controlled by, EVM code. Contracts cannot be controlled by private keys directly; unless built into the EVM code, a contract has no owner once released.  Ether : the primary internal cryptographic token of the Ethereum network. Ether is used to pay transaction and computation fees for Ethereum transactions.  Gas : a measurement roughly equivalent to computational steps. Every transaction is required to include a gas limit and a fee that it is willing to pay per gas; miners have the choice of including the transaction and collecting the fee or not. If the total number of gas used by the computation spawned by the transaction, including the original message and any sub-messages that may be triggered, is less than or equal to the gas limit, then the transaction processes. If the total gas exceeds the gas limit, then all changes are reverted, except that the transaction is still valid and the fee can still be collected by the miner. Every operation has a gas expenditure; for most operations it is ~3-10, although some expensive operations have expenditures up to 700 and a transaction itself has an expenditure of 21000.", 
            "title": "\u4ee5\u592a\u574a\u533a\u5757\u94fe"
        }, 
        {
            "location": "/Misc/Glossary/#_5", 
            "text": "Proof-of-Stake-FAQ  \u548c  Sharding-FAQ   Security deposit : a quantity of ether that a user deposits into a mechanism (often a proof of stake consensus mechanism, though this can also be used for other applications) that a user normally expects to be able to eventually withdraw and recover, but which can be taken away in the event of malfeasance from the user's side.  Validator : a participant in proof of stake consensus. Validators need to submit a security deposit in order to get included in the validator set.  Economic finality : a block or state can be considered  finalized  if it can be shown that if any incompatible block or state is also finalized (eg. two different blocks at the same height) then there exists evidence that can be used to penalize (the security deposits of) the parties at fault by some amount $X. This value X is called the  cryptoeconomic security margin  of the finality mechanism.  Slashing condition : a condition which, if triggered by a validator, causes the validator's deposit to be destroyed.  Prepare  and  commit : two types of messages that validators can send in many types of consensus protocols; see https://medium.com/@VitalikButerin/minimal-slashing-conditions-20f0b500fc6c  Fault : an action taken by a validator (or more generally, a participant in a mechanism) that they would not have taken had they correctly followed the protocol  Liveness fault : a validator failing to submit a message that according to the protocol they should have submitted (or submitting a message later than they should have)  Censorship fault : a validator failing to accept valid messages from other validators  Equivocation : a validator sending two messages that contradict each other, or more precisely a validator sending two messages that a validator running the correct algorithm could only send if it sends one message, \"rewinds\" its internal state to some point before sending that message, then at some future point in time sends the other message. One simple example is a transaction sender sending two transactions with the same nonce.  Invalidity fault : a validator sending a message that a computer running the correct algorithm could not possibly send, unless its internal state is manipulated with in some way other than rewinding.  Uniquely attributable fault : a fault such that there exists clear evidence which can be used to determine exactly which validator committed the fault. For example, liveness faults are not uniquely attributable because if a message from A fails to reach B, it could be because A failed to send that message, or because B failed to listen to it, whereas equivocation faults are uniquely attributable.  Fraud proof : a set of data, usually a part of a block plus some extra \"witness data\" (eg. Merkle branches), that can be used to prove that a given block is invalid.  Data availability problem  and  Fisherman's dilemma : see https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding  Validity : the property of a state that it is indeed the result of executing a valid history of transactions  Data availability : the property of a state that any node connected to the network could download any specific part of the state that they wish to.  Tight coupling : chains A and B are tightly coupled if (i) any state of A points to some state of B (and vice versa), and (ii) a state of A should not be considered admissible unless both that state itself and the state of B that it points to are valid and data-available.  Loose coupling : chains A and B are loosely coupled if (i) any state of A points to some state of B (and vice versa), and (ii) they are  not  tightly coupled.  Shard : a subset of the state which is managed by different nodes from the nodes that manage other shards. Usually, shards must be tightly coupled, and  sidechains  must be loosely coupled.", 
            "title": "\u5361\u65af\u5e15\u548c\u7f29\u653e\u7814\u7a76"
        }, 
        {
            "location": "/Misc/Glossary/#_6", 
            "text": "Whisper : an upcoming P2P messaging protocol  Swarm : an upcoming P2P data storage protocol optimized for static web hosting  Solidity ,  LLL ,  Serpent  and  Viper : programming languages for writing contract code which can be compiled into EVM code. Serpent can also be compiled into LLL.  Solidity is a C++-like language (and is the most widely used), Serpent and Viper are Python-like languages (the developer of the two currently recommends Viper more), and LLL is an acronym for Lisp-like language.  PoC : proof-of-concept, another name for a pre-launch release", 
            "title": "\u975e\u533a\u5757\u94fe"
        }
    ]
}