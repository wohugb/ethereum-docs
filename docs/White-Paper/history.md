# 历史

分散式数字货币的概念以及财产登记等其他应用程序的概念已经出现了

80年代-90年代,匿名电子现金协议, 主要依赖于被称为Chaumian致盲的密码学原语, 提供了高度隐私的货币,但由于依赖中央调解机构，协议很大程度上未能获得牵引力。

1998年, 戴伟的[b-money][7]成为第一个提出通过解决计算困惑和分散共识来创造货币的想法的提案，但是关于如何实现分权化共识的细节却很少。

2005年, 哈尔·芬尼介绍了一个概念"[可重复使用的工作证明][8]", 一个使用b-money的想法与Adam Back的计算困难的Hashcash拼图一起为一个加密货币创造一个概念的系统, 但是依靠可信计算作为后端再一次没有达到理想.

2009年, 分散化的货币是中本聪实践中首次实施的, 通过公共密钥密码学把所有权管理的基本原则与一个一致的算法结合起来，以便跟踪谁拥有货币, 被称为“工作证明”.

工作证明背后的机制是空间的突破，因为它同时解决了两个问题。

首先, 它提供了一个简单而适度的共识算法, 允许网络中的节点集体同意对比特币分类帐状态的一组规范更新.

其次, 它提供了一个允许自由进入共识进程的机制， 解决决定谁影响共识的政治问题， 同时防止sybil攻击。

这是通过取代正式的参与壁垒来实现的， 例如要求在特定名单上注册为独特实体, 带有经济障碍 - 共识投票过程中单个节点的权重与节点带来的计算能力成正比.

从那以后，提出了一种替代方法，称为_权益证明_, 计算一个节点的权重与其货币持有量成正比，而不是计算资源; 对这两种方法的相对优点的讨论超出了本文的范围，但应该指出，这两种方法都可以用作加密货币的支柱.

## 状态传递系统的比特币

![statetransition.png](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png)

从技术角度来看, 像比特币这样的加密货币的分类账可以被认为是一种状态转换系统, 在那里存在一个由所有现有比特币的所有权状态组成的“状态”和一个采取状态和交易的“状态转换功能”，并输出一个新的状态，这个状态是结果.

例如，在标准的银行体系中，国家是资产负债表， 交易是将`$X`从A移动到B的请求， 而状态转换函数将A账户中的价值减少`$X`，并将B账户中的价值增加`$X`。
如果A的帐户首先少于`$X`，则状态转换函数返回一个错误。
因此，可以正式定义:

    APPLY(S,TX) -> S' or ERROR

在上面定义的银行系统中:

    APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }

但:

    APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR

比特币中的“国家”是所有已经铸造和尚未用完的货币(从技术上说，“未使用的交易产出”或UTXO)的集合，每个UTXO拥有一个面额和一个所有者 (由一个20字节的地址定义，该地址本质上是一个加密公钥<sup>[1]</sup>).
交易包含一个或多个输入， 每个输入包含对现有UTXO的引用和由与所有者地址关联的私钥生成的加密签名， 和一个或多个输出，每个输出包含一个新的UTXO添加到状态。

状态转换函数`APPLY(S,TX) -> S'`可以大致定义如下：

1. 对于每个输入 `TX`:
    * 如果引用的UTXO不在`S`中，则返回一个错误.
    * 如果提供的签名与UTXO的所有者不匹配，则返回错误.
2. 如果所有输入的UTXO的面值之和小于所有输出的UTXO的面值的总和, 返回一个错误.
3. 返回所有输入UTXO的`S`，并添加所有输出的UTXO.

第一步的前半部分阻止交易发件人花钱不存在的货币, 第一步的后半部分阻止交易发件人花钱购买他人的货币，第二步强制保值。
为了使用这个付款，协议如下。
假设Alice想把11.7 BTC发送给Bob。
首先，Alice会寻找一个她拥有的UTXO集合，总计至少为11.7 BTC。
实际上，Alice将无法获得11.7 BTC;,说她能得到的最小的是6 + 4 + 2 = 12。,然后她用这三个输入和两个输出创建一个交易。
第一个输出将是Bob的地址为11.7 BTC的所有者, 而第二个输出将是剩下的0.3比特币“变”, 主人是爱丽丝本人.

## 挖矿

![block_picture.jpg](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png)

如果我们能够获得值得信赖的集中服务，那么这个系统实施起来是微不足道的; 它可以完全按照描述进行编码，使用中央服务器的硬盘来跟踪状态。
但是，对于比特币，我们正在试图建立一个分散的货币体系，所以我们需要将国家交易体系与共识体系结合起来，以确保每个人都能够就交易顺序达成一致。
比特币的分散式共识流程要求网络中的节点不断尝试生成称为“块”的交易包。
网络每十分钟产生一个块，每个块包含一个时间戳，一个随机数，一个前一个块的引用（即散列），以及自上一次以来发生的所有事务的列表块。
随着时间的推移，这将创造一个持续不断增长的“区块链”，不断更新以代表比特币分类账的最新状态。

用于检查块是否有效的算法在此范例中表示如下:

1. 检查块引用的前一个块是否存在且有效。
2. 检查块的时间戳是否大于前一个块<sup>[2]</ sup>的时间戳，并在未来不到2个小时
3. 检查块上的工作证明是否有效。
4. 让`S[0]`是前一个块末尾的状态。
5. 假设`TX`是带有`n`个事务的块的事务列表。对于`0 ... n-1`中的所有`i`，设置`S[i + 1] = APPLY（S [i]，TX [i]）`如果任何应用程序返回错误，退出并返回false。
6. 返回true，并在这个块的末尾注册`S [n]`作为状态。

本质上，块中的每个事务都必须提供一个有效的状态转换，从事务执行之前的规范状态转换到新的状态
请注意，状态不是以任何方式编码在块中;,它仅仅是一个被验证节点记住的抽象概念，并且只能通过从起始状态开始并且在每个块中顺序地应用每个事务而被（安全）地计算用于任何块。
此外，请注意，矿工包括事务处理在内的顺序。,如果在块中有两个事务A和B，使得B花费由A创建的UTXO，则如果A在B之前，则该块将是有效的，否则不是。

上述列表中有一个在其他系统中没有的有效性条件是对“工作证明”的要求。
精确的条件是，每个块的双SHA256散列，被视为一个256位的数字，必须小于一个动态调整的目标，截至本书写时约为2<sup>187</sup>.
这样做的目的是在计算上使块创建“硬”，从而防止sybil攻击者重新构建对他们有利的整个区块链。
因为SHA256被设计成一个完全不可预知的伪随机函数，所以创建一个有效的块的唯一方法就是反复试验，反复递增nonce并查看新的hash是否匹配。

在目前的〜2<sup>187</sup>, 在找到有效的块之前，网络必须进行平均2<sup>69</sup>次尝试; 一般而言，网络每隔2016年一次重新校准目标，因此平均每10分钟网络中的某个节点产生一个新的数据块.
为了补偿这个计算工作的矿工, 每个矿区的矿工有权包括一个交易给自己25 BTC无处不在.
此外，如果任何交易的投入总额高于其投入产出，则差异也作为“交易费用”交给矿工。
顺便说一下，这也是BTC发行的唯一机制。,发生的状态根本不包含任何货币。

每个矿区的矿工有权包括一个交易给自己25 BTC无处不在
由于比特币的基础密码学已知是安全的，因此攻击者将直接针对比特币系统中不受密码学保护的部分：交易顺序。
攻击者的策略很简单：

1. 发送100 BTC到商家以换取一些产品（最好是快速交货的数字商品）
2. 等待产品交付
3. 产生另一个交易发送相同的100 BTC给自己
4. 试图说服网络，他的交易是他自己的第一个。

一旦步骤（1）发生，几分钟之后，某个矿工将把交易包括在内, 说块号码270000.大约一个小时后, 在该块之后，另外五个块将被添加到链中, 每个块都间接指向交易，从而“确认”.
此时，商家将接受付款并交付产品;,因为我们假设这是一个数字商品，交货是即时的。
现在，攻击者创建另一个发送100比特币给他自己的交易。
如果攻击者只是简单地将其释放到野外，交易将不会被处理。 矿工将尝试运行“APPLY（S，TX）”，并注意到“TX”消耗了一个不再处于该状态的UTXO。
因此，攻击者创建区块链的“分支”，首先挖掘另一个版本的区块270000，指向与父区块相同的区块269999，但新交易代替旧区块。
由于块数据不同，这需要重做工作证明。
此外，攻击者的新版块270000具有不同的散列，因此原始块270001到270005不会“指向”它;,因此，原始链条和攻击者的新链条是完全分离的。
规则是，在一个分支中，最长的区块链被认为是事实，所以合法的矿工将在270005链上工作，而攻击者只能在270000链上工作。
为了让攻击者能够使自己的区块链最长，他需要比网络其他部分更强大的计算能力来追赶（因此，“51％攻击”）。

--待检测--

## 默克尔树

![SPV in bitcoin](https://raw.githubusercontent.com/ethereum/www/master-postsale/src/extras/gh_wiki/spv_bitcoin.png)

_左树: 在Merkle树中只显示少量的节点就足以证明分支的有效性。_

_右树: 任何改变Merkle树的任何部分的尝试最终都会导致链上的不一致。_

比特币的一个重要的可扩展性特点是块存储在一个多层次的数据结构中。
块的“散列”实际上只是块头的散列，一个大致200字节的数据块，包含时间戳，随机数，先前的块散列和称为Merkle树的数据结构的根散列，存储所有事务,在块。
Merkle树是一种二叉树，由包含底层数据的树的底部有大量叶节点的一组节点组成，一组中间节点，其中每个节点是其两个子节点的散列，,最后是一个单一的根节点，也是由它的两个孩子的散列形成的，代表树的“顶”。
Merkle树的目的是允许一个块中的数据被零碎地传递：一个节点只能从一个源下载一个块的头部，树的小部分与另一个源相关，并且仍然可以被保证,所有的数据是正确的。
之所以这样做，是因为哈希会向上传播：如果恶意用户试图将虚假事务交换到Merkle树的底部，这种更改将导致上面的节点发生更改，然后在上面的节点发生更改,，最后改变树的根，因此改变块的哈希，导致协议把它注册为一个完全不同的块（几乎可以肯定是有一个无效的工作证明）。

Merkle树议定书可以说是长期可持续性的必要条件。
比特币网络中的一个“完整节点”，一个用于存储和处理每个区块的完整节点，截至2014年4月，在比特币网络中占用大约15 GB的磁盘空间，并且每个月增长超过千兆字节。
目前，对于一些台式电脑而不是手机来说，这是可行的，以后只有企业和爱好者才能参与。
称为“简化支付验证”（SPV）的协议允许存在另一类节点，称为“灯节点”，其下载块标题，验证块标题上的工作证明，然后仅下载“分支,“与与其相关的交易相关联。
这使得轻型节点可以确定安全的强有力的保证，比特币交易的状态和当前的余额是下载整个区块链的一小部分。

## 替代区块链应用程序

将底层区块链理念应用于其他概念的想法也有着悠久的历史。
2005年，Nick Szabo提出了“拥有所有权的安全财产权”概念[9]“，这是一份描述”复制数据库技术的新进展“将如何允许基于区块链的系统存储,谁拥有什么土地，创造一个精心设计的框架，包括家园，逆权管理和格鲁吉亚土地税等概念。
然而，不幸的是，当时没有有效的复制数据库系统，因此该协议在实践中从未得到实施。
然而，2009年之后，一旦比特币的分散化共识得以形成，一些替代应用迅速开始出现。

* **名字货币** - 在2010年创建，[名字货币][10]最好形容为分散的名称注册数据库。在像Tor，比特币和比特消息这样的分散协议中，需要有一些识别帐户的方法，以便其他人可以与之交互，但是在所有现有的解决方案中，唯一可用的标识符是像“1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy”这样的伪随机哈希。理想情况下，人们希望能够有一个像“乔治”这样的名字的帐户。但问题是，如果一个人可以创建一个名为“乔治”的账户，那么其他人可以使用相同的过程。唯一的解决方案是首先注册的范例，第一个注册者成功，第二个注册失败 - 这是一个完全适合比特币共识协议的问题。名字货币是最古老，也是最成功的使用这种想法的名称注册系统的实现。
* **彩色货币** -  [彩色货币][2]的目的是作为一个协议，允许人们创建自己的数字货币 - 或者，在一个单位的货币重要微不足道的情况下，数字令牌,，在比特币区块链上。在彩色货币协议中，通过公开地为特定的比特币UTXO分配一种颜色来“发行”新币种，并且该协议递归地将其他UTXO的颜色定义为与创建它们的交易花费的输入的颜色相同,（一些特殊的规则适用于混合颜色输入的情况）。这允许用户维护仅包含特定颜色的UTXO的钱包，并像常规比特币一样将其发送，通过区块链回溯以确定他们接收的任何UTXO的颜色。
* **元货币** -  元货币背后的想法是有一个生活在比特币之上的协议，使用比特币交易来存储元货币交易，但有一个不同的状态转换功能，“APPLY”。因为元货币协议不能阻止无效的元货币交易出现在比特币区块链中，所以规则是。这为创建一个任意的加密货币协议提供了一个简单的机制，可能具有在比特币本身无法实现的高级功能，但是开发成本非常低，因为挖掘和。元货币s已被用来实施一些类型的金融

因此，总的来说，建立共识协议有两种方法：建立一个独立的网络，并在比特币之上建立一个协议。
前一种方法虽然在像名字货币这样的应用程序中合理成功，但难以实施;,每个单独的实现需要引导一个独立的区块链，以及构建和测试所有必要的状态转换和网络代码。
此外，我们预测，分散式共识技术的应用程序集将遵循幂律分布，绝大多数应用程序太小而不能保证自己的区块链，并且我们注意到存在大量的分散式应用程序，特别是分散式自治,组织，需要互相交流。

另一方面，基于比特币的方法存在缺陷，即它不能继承简化的支付验证
SPV适用于比特币，因为它可以使用区块链深度作为有效性的代理;,在某个时候，曾经是一个祖先
另一方面，基于区块链的元协议不能强制区块链不包含无效的交易
因此，一个完全安全的SPV元协议实现将需要反向扫描到比特币的开始
目前，基于比特币的元协议的所有“轻量级”实现依赖于可信的服务器来提供数据，可以说是非常不理想的结果，特别是当加密货币的主要目的之一是消除对信任的需要时。

## 脚本

目前，基于比特币的元协议的所有“轻量级”实现依赖于可信的服务器来提供数据，可以说是非常不理想的结果，特别是当加密货币的主要目的之一是消除对信任的需要时。
比特币中的UTXO不仅可以由公钥来拥有，还可以通过以简单的基于堆栈的编程语言表达的更复杂的脚本来拥有。
在这种模式下，UTXO必须提供满足脚本的数据。
事实上，即使是基本的公钥所有权机制也是通过脚本实现的：脚本以椭圆曲线签名为输入，根据交易和拥有UTXO的地址进行验证，如果验证为
其他更复杂的脚本存在于各种其他用例中。
例如，可以构建一个脚本，要求从给定的三个私钥中的两个签名进行验证
脚本也可以用来支付计算问题的解决方案，甚至可以构建一个脚本说

但是，在比特币中实现的脚本语言有几个重要的限制：

* **缺乏图灵完备性** - 也就是说，虽然比特币脚本编制有大量的计算子集。
缺少的主要类别是循环。
这样做是为了避免交易验证期间的无限循环;,理论上来说这是脚本的一个可以克服的障碍
例如，实施一个替代椭圆曲线签名算法可能需要256次重复乘法
* **价值失明** -  UTXO脚本无法提供对可撤回金额的细粒度控制。
例如，甲骨文合同的一个强大的用例就是一个套期保值合约，A和B投入1000美元的BTC
这要求甲骨文公司确定1美元的BTC价值，但即使如此，这也是一个巨大的进步
但是，由于UTXO是全有或全无，实现这一目标的唯一方法是通过非常低效的方式进行许多UTXO的不同命名（例如，每个k的UTXO为2 k） ,30），并选择哪个UTXO发送给A，哪个发送给B.
* **缺乏状态** -  UTXO可以使用或未使用;,除了这个以外，没有任何其他内部状态的多阶段合同或者脚本的机会。
这使得很难做出多阶段的期权合约，分散交易提议或两阶段密码承诺协议（安全计算奖励所必需的）。
这也意味着UTXO只能用来构建简单的一次性合同，而不是像分散组织那样更复杂的“有状态”合同，并且使得元协议难以实施。
二值化状态与价值失明相结合也意味着另一个重要的应用 - 撤回限制是不可能的。
* **区块链失明** -  UTXO对区块链数据（例如随机数，时间戳和前一个区块哈希）是盲目的。
这严重限制了赌博和其他几个类别的应用，剥夺了脚本语言潜在的有价值的随机性。

因此，我们看到在cryptocurrency之上构建高级应用程序的三种方法：构建一个新的区块链
构建一个新的区块链允许构建一个功能集的无限自由度，但是以开发时间为代价，
使用脚本很容易实现和标准化，但功能非常有限，元协议虽然简单，
通过以太坊，我们打算构建一个替代框架，在易于开发的同时提供更大的收益，以及更强大的轻客户端特性，同时允许应用程序共享经济环境和

[2]: https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit
[7]: http://www.weidai.com/bmoney.txt
[8]: http://nakamotoinstitute.org/finney/rpow/
[9]: http://szabo.best.vwh.net/securetitle.html
[10]: https://名字货币.org/