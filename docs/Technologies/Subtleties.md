# 玄机

## 内存

* 存储是一个键/值存储区，其中键和值都是32个字节
* 堆栈中的值是32个字节
* 内存是一个字节数组，内存以零大小开始，但可以通过访问或存储大于当前大小的索引来存储内存，从而以32字节块的形式进行扩展。
* 扩展内存的费用是通过减法积分法来确定的，具体来说，`TOTALFEE(SZ)= SZ * 3 + floor(SZ ** 2/512)`是将内存扩展为`SZ` 32字节块的总费用(注意：部分填充的块被计数，= 2块)，如果一个特定的操作将存储器的大小从`x`扩展到`y`，则额外的天然气成本为TOTALFEE(y) - TOTALFEE(x)
* 如果一个操作将零片宽的数据写入内存，即使片的起始索引超过当前内存大小，内存也不会扩展。

## 随机数

* 如果一个外部拥有的账户发送一个事务，它的随机数在执行之前会增加
* 如果外部拥有账户创建合同，则其执行时间会在执行前增加。,合同的随机数从1开始，而不是0
* 如果合同发送消息，则不会发生随机数增量
* 如果合同创建合同，则按以下顺序执行以下步骤：
    * 新的(`内部`)合同的地址计算为`sha3(rlp.encode([outer_contract_address，outer_contract_nonce]))`
    * `外部`合约的随机数增加1
    * 内部合约的随机数设置为1
    * 内部合同的代码和存储清空
    * 调用代码是初始化代码(这是由CREATE操作码提供的内存片)
    * 如果调用返回一个异常，除了外部合约的随机数增量外，全部都会被还原
    * 如果调用返回24000或更多字节，这被认为是一个例外
    * 如果呼叫返回x <24000字节，外部呼叫充电x * 200瓦斯。 如果没有足够的气体，那么这也被视为例外; 如果存在，则创建成功，并将内部合同的代码设置为该呼叫的返回数据.

## 异常情况

* 以下计数作为例外:
    * 执行耗尽气体
    * 尝试从堆栈中获取更多插槽的操作，或将超过1024个项目放入堆栈
    * 跳转到一个糟糕的跳转目的地
    * 一个无效的操作码(注意：假定一个帐户的代码后面跟着一个无限的STOP指令尾，所以程序计数器`走开`代码的末尾并不是一个无效的操作码异常，但是跳到代码之外,是一个例外，因为STOP不是有效的跳转目标)
    * 位于0xfd的REVERT操作码(从Metropolis开始; Metropolis 0xfd之前只是一个无效的操作码)
* 如果事务触发异常，则：
    * 从发件人到收件人的价值转移有时会发生
    * 从发件人到矿工的费用转移仍在进行
    * 整个`STARTGAS`被添加到`gas_used`，除非这个异常是`REVERT`操作码的结果
    * 导致异常的消息调用(或创建合同)期间的所有其他执行都会被还原
    * 当一个事务包含多个消息调用和合同创建时，只有其中一些可能会被还原。
* 如果合同生成事务触发异常，则：
    * 从发件人到矿工的费用转移仍在进行
    * 从发件人的帐户中扣除捐赠
    * 本来创建的账户无论如何都会被创建，保留其原来的天赋，但是以空字符串作为其代码
    * 整个`STARTGAS`被添加到`gas_used`，除非这个异常是`REVERT`操作码的结果
    * 所有其他执行被恢复
* 如果`CALL`操作的子执行触发异常，则：
    * 以太值仍然发送
    * 除非例外是由`REVERT`操作码造成的，否则所有气体都将被消耗
    * `0`被添加到堆栈中
    * 所有其他执行被恢复
* 如果CREATE操作的子执行触发异常，则：
    * 以太值是洛杉矶
    * 除非例外是由`REVERT`操作码造成的，否则所有气体都将被消耗
    * 所有其他执行被恢复
    * 当前的实现将`0`添加到堆栈上，但是没有关系，因为剩余的0个气体会执行父节点执行任务
* 如果合同试图`调用`或`创建`一个余额不足的合同，那么子执行和转移根本不会发生，没有天然气被消耗，并且0被添加到堆栈中。
* `CALL`或`CREATE`最多可以消耗`CALL`制造时剩余的63/64的气体;,如果一个`CALL`要求超过这个规定的最大值，那么无论需要多少气体，内部呼叫将只有规定的最大气体。

## 算法

* 所有算术都是模2×256 </sup>。,对于除法，模数和比较，存在有符号和无符号运算符(例如，如果使用`SDIV`，`(0-27)/3`返回-9，但如果使用了`DIV`则返回`38597363079105398474523661669562635951089994888546854679819194669304376546636`。
* 在`SDIV`/`SMOD`情况下带负运算符的截断和模运算就像在Python中一样处理(例如，
* 分数(第二个参数)等于0的`DIV`，`SDIV`，`MOD`和`SMOD`将0推入堆栈。

### 其他操作

* CREATE操作码有三个值：值(即ether的初始值)，内存启动和内存长度，并将新合同的地址压入堆栈。 ,CREATE给出初始化子执行过程中的所有气体(如果气体仍然存在，它将被退回到父执行)
* `CALL`操作码有七个值：气体，接收器，以太值，输入数据开始的存储位置，输入数据的长度，输出数据开始的存储位置，输出数据的长度。,它为了成功(即没有用完气体)或者因为失败而放入堆栈。
* 当一个合约调用SELFDESTRUCT时，它的ether立即被发送到所需的地址，但合约继续存在直到交易执行结束。,请注意，这会产生一个有趣的效果，与比特币不同，比特币可以永久锁定资金，但永远不会销毁，如果某个契约将SELFDESTRUCTs放入其自身中，或者在具有SELFDESTRUCTED的同一事务执行的上下文中接收到ether，则该ether实际上会被销毁,。
* 如果合同A调用合同B调用合同A，那么A的内部执行将拥有自己的新鲜内存堆栈和PC，但它将修改和读取相同的余额和存储。
* 如果合约初始化返回一个空数组，则不会创建合约。,这使您可以将合同初始化`滥用`为原子多操作，这在某些需要执行多项操作的协议中可能很有用，但您不希望某些协议能够在没有其他操作的情况下进行处理。
* `JUMP`和`JUMPI`指令只允许跳到(1)被`JUMPDEST`操作码占用的目的地，(2)不在`PUSH`数据内。,请注意，正确处理这些条件需要预处理代码;,一个特别的病理用例是`PUSH2 JUMPDEST PUSH1 PUSH2 JUMPDEST PUSH1 PUSH2 JUMPDEST PUSH1 ...`，因为这段代码中所有的`JUMPDEST`都是无效的，但是替代的一段代码等同于此，但只有用`PUSH2`,另一个操作(例如`BALANCE`)将具有所有的`JUMPDESTS`有效。
* `CALL`有一个多部分的天然气成本：
    * 700丝袜
    * 如果值不为零，则为9000
    * 如果目标帐户尚不存在，则额外增加25000(注意：零余额与不存在的差额！)
* `CALLCODE`的运作方式与通话类似，但没有25000天然气附加费的可能性。
* 非零值`CALL`操作的子消息(不是由交易引起的顶级消息！)在呼叫账户提供的天然气上获得额外的2300天然气;,这笔津贴可以被认为是从9000强制增加中支付的